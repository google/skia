#Topic IRect
#Alias IRects
#Alias IRect_Reference

#Subtopic Overview
    #Subtopic Subtopic
    #Populate
    ##
##

#Struct SkIRect

SkIRect holds four 32 bit integer coordinates describing the upper and
lower bounds of a rectangle. SkIRect may be created from outer bounds or 
from position, width, and height. SkIRect describes an area; if its right
is less than or equal to its left, or if its bottom is less than or equal to
its top, it is considered empty. 

#Subtopic Related_Function
#Populate
#Subtopic ##

#Subtopic Member_Function
#Populate
#Subtopic ##

#Subtopic Member
#Populate

#Member int32_t  fLeft
#Line # smaller x-axis bounds ##
May contain any value. The smaller of the horizontal values when sorted.
When equal to or greater than fRight, IRect is empty.
##

#Member int32_t  fTop
#Line # smaller y-axis bounds ##
May contain any value. The smaller of the horizontal values when sorted.
When equal to or greater than fBottom, IRect is empty.
##

#Member int32_t  fRight
#Line # larger x-axis bounds ##
May contain any value. The larger of the vertical values when sorted.
When equal to or less than fLeft, IRect is empty.
##

#Member int32_t  fBottom
#Line # larger y-axis bounds ##
May contain any value. The larger of the vertical values when sorted.
When equal to or less than fTop, IRect is empty.
##

#Subtopic Member ##

#Subtopic Constructor
#Populate

# ------------------------------------------------------------------------------

#Method static constexpr SkIRect SK_WARN_UNUSED_RESULT MakeEmpty()

#In Constructor
#Line # returns bounds of (0, 0, 0, 0) ##
Returns constructed IRect set to (0, 0, 0, 0).
Many other rectangles are empty; if left is equal to or greater than right,
or if top is equal to or greater than bottom. Setting all members to zero
is a convenience, but does not designate a special empty rectangle.

#Return bounds (0, 0, 0, 0) ##

#Example
    SkIRect rect = SkIRect::MakeEmpty();
    SkDebugf("MakeEmpty isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
    rect.offset(10, 10);
    SkDebugf("offset rect isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
    rect.inset(10, 10);
    SkDebugf("inset rect isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
    rect.outset(20, 20);
    SkDebugf("outset rect isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
#StdOut
MakeEmpty isEmpty: true
offset rect isEmpty: true
inset rect isEmpty: true
outset rect isEmpty: false
##
##

#SeeAlso EmptyIRect isEmpty setEmpty SkRect::MakeEmpty

##

# ------------------------------------------------------------------------------

#Method static constexpr SkIRect SK_WARN_UNUSED_RESULT MakeWH(int32_t w, int32_t h)

#In Constructor
#Line # constructs from int input returning (0, 0, width, height) ##
Returns constructed IRect set to (0, 0, w, h). Does not validate input; w or h
may be negative.

#Param w  width of constructed IRect  ##
#Param h  height of constructed IRect ##

#Return bounds (0, 0, w, h) ##

#Example
    SkIRect rect1 = SkIRect::MakeWH(25, 35);
    SkIRect rect2 = SkIRect::MakeSize({25, 35});
    SkIRect rect3 = SkIRect::MakeXYWH(0, 0, 25, 35);
    SkIRect rect4 = SkIRect::MakeLTRB(0, 0, 25, 35);
    SkDebugf("all %s" "equal\n", rect1 == rect2 && rect2 == rect3 && rect3 == rect4 ?
             "" : "not ");
#StdOut
all equal
##
##

#SeeAlso MakeSize MakeXYWH SkRect::MakeWH SkRect::MakeIWH

##

# ------------------------------------------------------------------------------

#Method static constexpr SkIRect SK_WARN_UNUSED_RESULT MakeSize(const SkISize& size)

#In Constructor
#Line # constructs from ISize returning (0, 0, width, height) ##
Returns constructed IRect set to (0, 0, size.width(), size.height()). 
Does not validate input; size.width() or size.height() may be negative.

#Param size  values for IRect width and height ##

#Return bounds (0, 0, size.width(), size.height()) ##

#Example
    SkSize size = {25.5f, 35.5f};
    SkIRect rect = SkIRect::MakeSize(size.toRound());
    SkDebugf("round width: %d  height: %d\n", rect.width(), rect.height());
    rect = SkIRect::MakeSize(size.toFloor());
    SkDebugf("floor width: %d  height: %d\n", rect.width(), rect.height());
#StdOut
round width: 26  height: 36
floor width: 25  height: 35
##
##

#SeeAlso MakeWH MakeXYWH SkRect::Make SkRect::MakeIWH 

##

# ------------------------------------------------------------------------------

#Method static constexpr SkIRect SK_WARN_UNUSED_RESULT MakeLTRB(int32_t l, int32_t t, int32_t r, int32_t b)

#In Constructor
#Line # constructs from int left, top, right, bottom ##
Returns constructed IRect set to (l, t, r, b). Does not sort input; IRect may
result in fLeft greater than fRight, or fTop greater than fBottom.

#Param l  integer stored in fLeft ##
#Param t  integer stored in fTop ##
#Param r  integer stored in fRight ##
#Param b  integer stored in fBottom ##

#Return bounds (l, t, r, b) ##

#Example
    SkIRect rect = SkIRect::MakeLTRB(5, 35, 15, 25);
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect.sort();
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 5, 35, 15, 25  isEmpty: true
rect: 5, 25, 15, 35  isEmpty: false
##
##

#SeeAlso MakeXYWH SkRect::MakeLTRB

##

# ------------------------------------------------------------------------------

#Method static constexpr SkIRect SK_WARN_UNUSED_RESULT MakeXYWH(int32_t x, int32_t y, int32_t w, int32_t h)

#In Constructor
#Line # constructs from int input returning (x, y, width, height) ##
Returns constructed IRect set to:
#Formula
(x, y, x + w, y + h)
##
. Does not validate input;
w or h may be negative.

#Param x  stored in fLeft ##
#Param y  stored in fTop ##
#Param w  added to x and stored in fRight ##
#Param h  added to y and stored in fBottom ##

#Return bounds at (x, y) with width w and height h ##

#Example
    SkIRect rect = SkIRect::MakeXYWH(5, 35, -15, 25);
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect.sort();
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 5, 35, -10, 60  isEmpty: true
rect: -10, 35, 5, 60  isEmpty: false
##
##

#SeeAlso MakeLTRB SkRect::MakeXYWH

##

#Subtopic Constructor ##

#Subtopic Property
#Line # member values, center, validity ##
#Populate
##

# ------------------------------------------------------------------------------

#Method int32_t left() const

#In Property
#Line # returns smaller bounds in x, if sorted ##
Returns left edge of IRect, if sorted.
Call sort() to reverse fLeft and fRight if needed.

#Return fLeft ##

#Example
    SkIRect unsorted = { 15, 5, 10, 25 };
    SkDebugf("unsorted.fLeft: %d unsorted.left(): %d\n", unsorted.fLeft, unsorted.left());
    SkIRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fLeft: %d sorted.left(): %d\n", sorted.fLeft, sorted.left());
#StdOut
unsorted.fLeft: 15 unsorted.left(): 15
sorted.fLeft: 10 sorted.left(): 10
##
##

#SeeAlso fLeft x() SkRect::left()

##

# ------------------------------------------------------------------------------

#Method int32_t top() const

#In Property
#Line # returns smaller bounds in y, if sorted ##
Returns top edge of IRect, if sorted. Call isEmpty to see if IRect may be invalid,
and sort() to reverse fTop and fBottom if needed.

#Return fTop ##

#Example
    SkIRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fTop: %d unsorted.top(): %d\n", unsorted.fTop, unsorted.top());
    SkIRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fTop: %d sorted.top(): %d\n", sorted.fTop, sorted.top());
#StdOut
unsorted.fTop: 25 unsorted.top(): 25
sorted.fTop: 5 sorted.top(): 5
##
##

#SeeAlso fTop y() SkRect::top()

##

# ------------------------------------------------------------------------------

#Method int32_t right() const

#In Property
#Line # returns larger bounds in x, if sorted ##
Returns right edge of IRect, if sorted.
Call sort() to reverse fLeft and fRight if needed.

#Return fRight ##

#Example
    SkIRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fRight: %d unsorted.right(): %d\n", unsorted.fRight, unsorted.right());
    SkIRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fRight: %d sorted.right(): %d\n", sorted.fRight, sorted.right());
#StdOut
unsorted.fRight: 10 unsorted.right(): 10
sorted.fRight: 15 sorted.right(): 15
##
##

#SeeAlso fRight SkRect::right()

##

# ------------------------------------------------------------------------------

#Method int32_t bottom() const

#In Property
#Line # returns larger bounds in y, if sorted ##
Returns bottom edge of IRect, if sorted. Call isEmpty to see if IRect may be invalid,
and sort() to reverse fTop and fBottom if needed.

#Return fBottom ##

#Example
    SkIRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fBottom: %d unsorted.bottom(): %d\n", unsorted.fBottom, unsorted.bottom());
    SkIRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fBottom: %d sorted.bottom(): %d\n", sorted.fBottom, sorted.bottom());
#StdOut
unsorted.fBottom: 5 unsorted.bottom(): 5
sorted.fBottom: 25 sorted.bottom(): 25
##
##

#SeeAlso fBottom SkRect::bottom()

##

# ------------------------------------------------------------------------------

#Method int32_t x() const

#In Property
#Line # returns bounds left ##
Returns left edge of IRect, if sorted. Call isEmpty to see if IRect may be invalid,
and sort() to reverse fLeft and fRight if needed.

#Return fLeft ##

#Example
    SkIRect unsorted = { 15, 5, 10, 25 };
    SkDebugf("unsorted.fLeft: %d unsorted.x(): %d\n", unsorted.fLeft, unsorted.x());
    SkIRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fLeft: %d sorted.x(): %d\n", sorted.fLeft, sorted.x());
#StdOut
unsorted.fLeft: 15 unsorted.x(): 15
sorted.fLeft: 10 sorted.x(): 10
##
##

#SeeAlso fLeft left() y() SkRect::x()

##

# ------------------------------------------------------------------------------

#Method int32_t y() const

#In Property
#Line # returns bounds top ##
Returns top edge of IRect, if sorted. Call isEmpty to see if IRect may be invalid,
and sort() to reverse fTop and fBottom if needed.

#Return fTop ##

#Example
    SkIRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fTop: %d unsorted.y(): %d\n", unsorted.fTop, unsorted.y());
    SkIRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fTop: %d sorted.y(): %d\n", sorted.fTop, sorted.y());
#StdOut
unsorted.fTop: 25 unsorted.y(): 25
sorted.fTop: 5 sorted.y(): 5
##
##

#SeeAlso fTop top() x() SkRect::y()

##

# ------------------------------------------------------------------------------

#Method int32_t width() const

#In Property
#Line # returns span in x ##
Returns span on the x-axis. This does not check if IRect is sorted, or if
result fits in 32-bit signed integer; result may be negative.

#Return fRight minus fLeft ##

#Example
    SkIRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted width: %d\n", unsorted.width());
    SkIRect large = { -2147483647, 1, 2147483644, 2 };
    SkDebugf("large width: %d\n", large.width());
#StdOut
unsorted width: -5
large width: -5
##
##

#SeeAlso height() width64() height64() SkRect::width()

##

# ------------------------------------------------------------------------------

#Method int64_t width64() const

#In Property
#Line # returns span in y as int64_t ##
Returns span on the x-axis. This does not check if IRect is sorted, so the
result may be negative. This is safer than calling width() since width() might
overflow in its calculation.

#Return fRight minus fLeft cast to int64_t ##

#Bug 7489
# width64 is not yet visible to fiddle
#NoExample
SkIRect large = { -2147483647, 1, 2147483644, 2 };
SkDebugf("width: %d wdith64: %lld\n", large.width(), large.width64());
#StdOut
width: -5 width64: 4294967291
##
##

#SeeAlso width() height() height64() SkRect::width()

##

# ------------------------------------------------------------------------------

#Method int32_t height() const

#In Property
#Line # returns span in y ##
Returns span on the y-axis. This does not check if IRect is sorted, or if
result fits in 32-bit signed integer; result may be negative.

#Return fBottom minus fTop ##

#Example
    SkIRect unsorted = { 15, 25, 10, 20 };
    SkDebugf("unsorted height: %d\n", unsorted.height());
    SkIRect large = { 1, -2147483647, 2, 2147483644 };
    SkDebugf("large height: %d\n", large.height());
#StdOut
unsorted height: -5
large height: -5
##
##

#SeeAlso width() SkRect::height()

##

# ------------------------------------------------------------------------------

#Method int64_t height64() const

#In Property
#Line # returns span in y as int64_t ##
Returns span on the y-axis. This does not check if IRect is sorted, so the
result may be negative. This is safer than calling height() since height() might
overflow in its calculation.

#Return fBottom minus fTop cast to int64_t ##

#Bug 7489
# height64 not yet visible to fiddle
#NoExample
SkIRect large = { 1, -2147483647, 2, 2147483644 };
SkDebugf("height: %d height64: %lld\n", large.height(), large.height64());
#StdOut
height: -5 height64: 4294967291
##
##

#SeeAlso width() height() width64() SkRect::height()

##

# ------------------------------------------------------------------------------

#Method SkISize size() const

#In Property
#Line # returns ISize (width, height) ##
Returns spans on the x-axis and y-axis. This does not check if IRect is sorted,
or if result fits in 32-bit signed integer; result may be negative.

#Return  ISize (width, height) ##

#Example
    auto debugster = [](const char* prefix, const SkIRect& rect) -> void {
        SkISize size = rect.size();
        SkDebugf("%s ", prefix);
        SkDebugf("rect: %d, %d, %d, %d  ", rect.left(), rect.top(), rect.right(), rect.bottom());
        SkDebugf("size: %d, %d\n", size.width(), size.height());
    };
    SkIRect rect = {20, 30, 40, 50};
    debugster("original", rect);
    rect.offset(20, 20);
    debugster("  offset", rect);
    rect.outset(20, 20);
    debugster("  outset", rect);
#StdOut
original rect: 20, 30, 40, 50  size: 20, 20
  offset rect: 40, 50, 60, 70  size: 20, 20
  outset rect: 20, 30, 80, 90  size: 60, 60
##
##

#SeeAlso height() width() MakeSize

##

# ------------------------------------------------------------------------------

#Method int32_t centerX() const

#In Property
#Line # returns midpoint in x ##
Returns average of left edge and right edge. Result does not change if IRect
is sorted. Result may be incorrect if IRect is far from the origin.

Result is rounded down.

#Return midpoint in x ##

#Example
#Description
Dividing by two rounds towards zero. centerX uses a bit shift and rounds down.
##
    SkIRect tests[] = {{20, 30, 41, 51}, {-20, -30, -41, -51}, {-10, -10, 11, 11}};
    for (auto rect : tests) {
        SkDebugf("left: %3d right: %3d centerX: %3d ", rect.left(), rect.right(), rect.centerX());
        SkDebugf("div2: %3d\n", (rect.left() + rect.right()) / 2);
    }
#StdOut
left:  20 right:  41 centerX:  30 div2:  30
left: -20 right: -41 centerX: -31 div2: -30
left: -10 right:  11 centerX:   0 div2:   0
##
##

#SeeAlso centerY SkRect::centerX

##

# ------------------------------------------------------------------------------

#Method int32_t centerY() const

#In Property
#Line # returns midpoint in y ##
Returns average of top edge and bottom edge. Result does not change if IRect
is sorted. Result may be incorrect if IRect is far from the origin. 

Result is rounded down.

#Return midpoint in y ##

#Example
   SkIRect rect = { 0, 0, 2, 2 };
   rect.offset(0x40000000, 0x40000000);
   SkDebugf("left: %d right: %d centerX: %d ", rect.left(), rect.right(), rect.centerX());
   SkDebugf("safe mid x: %d\n", rect.left() / 2 + rect.right() / 2);
#StdOut
left: 1073741824 right: 1073741826 centerX: -1073741823 safe mid x: 1073741825
##
##

#SeeAlso centerX SkRect::centerY

##

# ------------------------------------------------------------------------------

#Method bool isEmpty() const

#In Property
#Line # returns true if width or height are zero or negative or they exceed int32_t ##
Returns true if width() or height() .

#Return true if width() or height() are zero or negative ##

#Example
    SkIRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};
    for (auto rect : tests) {
        SkDebugf("rect: {%d, %d, %d, %d} is" "%s empty\n", rect.left(), rect.top(), rect.right(),
                 rect.bottom(), rect.isEmpty() ? "" : " not");
        rect.sort();
        SkDebugf("sorted: {%d, %d, %d, %d} is" "%s empty\n", rect.left(), rect.top(), rect.right(),
                 rect.bottom(), rect.isEmpty() ? "" : " not");
    }
#StdOut
rect: {20, 40, 10, 50} is empty
sorted: {10, 40, 20, 50} is not empty
rect: {20, 40, 20, 50} is empty
sorted: {20, 40, 20, 50} is empty
##
##

#SeeAlso EmptyIRect MakeEmpty sort SkRect::isEmpty

##

# ------------------------------------------------------------------------------

#Method bool isEmpty64() const

#In Property
#Line # returns true if width or height are zero or negative ##
Returns true if fLeft is equal to or greater than fRight, or if fTop is equal
to or greater than fBottom. Call sort() to reverse rectangles with negative
width64() or height64().

#Return true if width64() or height64() are zero or negative ##

#Bug 7489
# isEmpty64 not yet visible to fiddle
#NoExample
SkIRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};
for (auto rect : tests) {
SkDebugf("rect: {%d, %d, %d, %d} is" "%s empty\n", rect.left(), rect.top(), rect.right(),
rect.bottom(), isEmpty64() ? "" : " not");
rect.sort();
SkDebugf("sorted: {%d, %d, %d, %d} is" "%s empty\n", rect.left(), rect.top(), rect.right(),
rect.bottom(), isEmpty64() ? "" : " not");
}
#StdOut
rect: {20, 40, 10, 50} is empty
sorted: {10, 40, 20, 50} is not empty
rect: {20, 40, 20, 50} is empty
sorted: {20, 40, 20, 50} is empty
##
##

#SeeAlso EmptyIRect MakeEmpty sort SkRect::isEmpty

##

#Subtopic Operator
#Populate

# ------------------------------------------------------------------------------

#Method bool operator==(const SkIRect& a, const SkIRect& b)

#In Operator
#Line # returns true if members are equal ##
Returns true if all members in a: fLeft, fTop, fRight, and fBottom; are 
identical to corresponding members in b.

#Param a  IRect to compare ##
#Param b  IRect to compare ##

#Return true if members are equal ##

#Example
    SkIRect test = {0, 0, 2, 2};
    SkIRect sorted = test.makeSorted();
    SkDebugf("test %c= sorted\n", test == sorted ? '=' : '!');
#StdOut
test == sorted
##
##

#SeeAlso operator!=(const SkIRect& a, const SkIRect& b)

##

# ------------------------------------------------------------------------------

#Method bool operator!=(const SkIRect& a, const SkIRect& b)

#In Operator
#Line # returns true if members are unequal ##
Returns true if any member in a: fLeft, fTop, fRight, and fBottom; is not 
identical to the corresponding member in b.

#Param a  IRect to compare ##
#Param b  IRect to compare ##

#Return true if members are not equal ##

#Example
    SkIRect test = {2, 2, 0, 0};
    SkIRect sorted = test.makeSorted();
    SkDebugf("test %c= sorted\n", test != sorted ? '!' : '=');
#StdOut
test != sorted
##
##

#SeeAlso operator==(const SkIRect& a, const SkIRect& b)

##

#Subtopic Operator ##

# ------------------------------------------------------------------------------

#Method bool is16Bit() const

#In Property
#Line # returns true if members fit in 16-bit word ##
Returns true if all members: fLeft, fTop, fRight, and fBottom; values are
equal to or larger than -32768 and equal to or smaller than 32767. 

#Return true if members fit in 16-bit word ##

#Example
    SkIRect tests[] = {{-32768, -32768, 32767, 32767}, {-32768, -32768, 32768, 32768}};
    for (auto rect : tests) {
        SkDebugf("{%d, %d, %d, %d} %s in 16 bits\n", rect.fLeft, rect.fTop, rect.fRight,
                 rect.fBottom, rect.is16Bit() ? "fits" : "does not fit");
}
#StdOut
{-32768, -32768, 32767, 32767} fits in 16 bits
{-32768, -32768, 32768, 32768} does not fit in 16 bits
##
##

#SeeAlso SkTFitsIn

##

# ------------------------------------------------------------------------------
#Subtopic Set
#Line # replaces all values ##
#Populate
##

#Method void setEmpty()

#In Set
#Line # sets to (0, 0, 0, 0) ##
Sets IRect to (0, 0, 0, 0).

Many other rectangles are empty; if left is equal to or greater than right,
or if top is equal to or greater than bottom. Setting all members to zero
is a convenience, but does not designate a special empty rectangle.

#Example
    SkIRect rect = {3, 4, 1, 2};
    for (int i = 0; i < 2; ++i) {
    SkDebugf("rect: {%d, %d, %d, %d} is %s" "empty\n", rect.fLeft, rect.fTop,
             rect.fRight, rect.fBottom, rect.isEmpty() ? "" : "not ");
    rect.setEmpty();
    }
#StdOut
rect: {3, 4, 1, 2} is empty
rect: {0, 0, 0, 0} is empty
##
##

#SeeAlso MakeEmpty SkRect::setEmpty

##

# ------------------------------------------------------------------------------

#Method void set(int32_t left, int32_t top, int32_t right, int32_t bottom)

#In Set
#Line # sets to (left, top, right, bottom) ##
Sets IRect to (left, top, right, bottom).
left and right are not sorted; left is not necessarily less than right.
top and bottom are not sorted; top is not necessarily less than bottom.

#Param left  assigned to fLeft ##
#Param top  assigned to fTop ##
#Param right  assigned to fRight ##
#Param bottom  assigned to fBottom ##

#Example
    SkIRect rect1 = {3, 4, 1, 2};
    SkDebugf("rect1: {%d, %d, %d, %d}\n", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);
    SkIRect rect2;
    rect2.set(3, 4, 1, 2);
    SkDebugf("rect2: {%d, %d, %d, %d}\n", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);
#StdOut
rect1: {3, 4, 1, 2}
rect2: {3, 4, 1, 2}
##
##

#SeeAlso setLTRB setXYWH SkRect::set

##

# ------------------------------------------------------------------------------

#Method void setLTRB(int32_t left, int32_t top, int32_t right, int32_t bottom)

#In Set
#Line # sets to SkScalar input (left, top, right, bottom) ##
Sets IRect to (left, top, right, bottom).
left and right are not sorted; left is not necessarily less than right.
top and bottom are not sorted; top is not necessarily less than bottom.

#Param left  stored in fLeft ##
#Param top  stored in fTop ##
#Param right  stored in fRight ##
#Param bottom  stored in fBottom ##

#Example
    SkIRect rect1 = {3, 4, 1, 2};
    SkDebugf("rect1: {%d, %d, %d, %d}\n", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);
    SkIRect rect2;
    rect2.setLTRB(3, 4, 1, 2);
    SkDebugf("rect2: {%d, %d, %d, %d}\n", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);
#StdOut
rect1: {3, 4, 1, 2}
rect2: {3, 4, 1, 2}
##
##

#SeeAlso set setXYWH SkRect::setLTRB

##

# ------------------------------------------------------------------------------

#Method void setXYWH(int32_t x, int32_t y, int32_t width, int32_t height)

#In Set
#Line # sets to (x, y, width, height) ##
Sets IRect to:
#Formula
(x, y, x + width, y + height)
##
. Does not validate input;
width or height may be negative.

#Param x  stored in fLeft ##
#Param y  stored in fTop ##
#Param width  added to x and stored in fRight ##
#Param height  added to y and stored in fBottom ##

#Example
    SkIRect rect;
    rect.setXYWH(5, 35, -15, 25);
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect.sort();
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 5, 35, -10, 60  isEmpty: true
rect: -10, 35, 5, 60  isEmpty: false
##
##

#SeeAlso MakeXYWH setLTRB set SkRect::setXYWH

##

#Subtopic Inset_Outset_Offset
#Line # moves sides ##
#Populate

# ------------------------------------------------------------------------------

#Method SkIRect makeOffset(int32_t dx, int32_t dy) const

#In Inset_Outset_Offset
#Line # constructs from translated sides ##
Returns IRect offset by (dx, dy).

If dx is negative, IRect returned is moved to the left.
If dx is positive, IRect returned is moved to the right.
If dy is negative, IRect returned is moved upward.
If dy is positive, IRect returned is moved downward. 

#Param dx  offset added to fLeft and fRight ##
#Param dy  offset added to fTop and fBottom ##

#Return IRect offset in x or y, with original width and height ##

#Example
    SkIRect rect = { 10, 50, 20, 60 };
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect = rect.makeOffset(15, 32);
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 10, 50, 20, 60  isEmpty: false
rect: 25, 82, 35, 92  isEmpty: false
##
##

#SeeAlso offset() makeInset makeOutset SkRect::makeOffset

##

# ------------------------------------------------------------------------------

#Method SkIRect makeInset(int32_t dx, int32_t dy) const

#In Inset_Outset_Offset
#Line # constructs from sides moved symmetrically about the center ##
Returns IRect, inset by (dx, dy).

If dx is negative, IRect returned is wider.
If dx is positive, IRect returned is narrower.
If dy is negative, IRect returned is taller.
If dy is positive, IRect returned is shorter. 

#Param dx  offset added to fLeft and subtracted from fRight ##
#Param dy  offset added to fTop and subtracted from fBottom ##

#Return IRect inset symmetrically left and right, top and bottom ##

#Example
    SkIRect rect = { 10, 50, 20, 60 };
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect = rect.makeInset(15, 32);
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 10, 50, 20, 60  isEmpty: false
rect: 25, 82, 5, 28  isEmpty: true
##
##

#SeeAlso inset() makeOffset makeOutset SkRect::makeInset

##

# ------------------------------------------------------------------------------

#Method SkIRect makeOutset(int32_t dx, int32_t dy) const

#In Inset_Outset_Offset
#Line # constructs from sides moved symmetrically about the center ##
Returns IRect, outset by (dx, dy).

If dx is negative, IRect returned is narrower.
If dx is positive, IRect returned is wider.
If dy is negative, IRect returned is shorter.
If dy is positive, IRect returned is taller. 

#Param dx  offset subtracted to fLeft and added from fRight ##
#Param dy  offset subtracted to fTop and added from fBottom ##

#Return IRect outset symmetrically left and right, top and bottom ##

#Example
    SkIRect rect = { 10, 50, 20, 60 };
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect = rect.makeOutset(15, 32);
    SkDebugf("rect: %d, %d, %d, %d  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 10, 50, 20, 60  isEmpty: false
rect: -5, 18, 35, 92  isEmpty: false
##
##

#SeeAlso outset() makeOffset makeInset SkRect::makeOutset

##

# ------------------------------------------------------------------------------

#Method void offset(int32_t dx, int32_t dy)

#In Inset_Outset_Offset
#Line # translates sides without changing width and height ##
Offsets IRect by adding dx to fLeft, fRight; and by adding dy to fTop, fBottom.

If dx is negative, moves IRect returned to the left.
If dx is positive, moves IRect returned to the right.
If dy is negative, moves IRect returned upward.
If dy is positive, moves IRect returned downward. 

#Param dx  offset added to fLeft and fRight ##
#Param dy  offset added to fTop and fBottom ##

#Example
    SkIRect rect = { 10, 14, 50, 73 };
    rect.offset(5, 13);
    SkDebugf("rect: %d, %d, %d, %d\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 55, 86
##
##

#SeeAlso offsetTo makeOffset SkRect::offset

##

# ------------------------------------------------------------------------------

#Method void offset(const SkIPoint& delta)

#In Inset_Outset_Offset
Offsets IRect by adding delta.fX to fLeft, fRight; and by adding delta.fY to
fTop, fBottom.

If delta.fX is negative, moves IRect returned to the left.
If delta.fX is positive, moves IRect returned to the right.
If delta.fY is negative, moves IRect returned upward.
If delta.fY is positive, moves IRect returned downward. 

#Param delta  offset added to IRect ##

#Example
    SkIRect rect = { 10, 14, 50, 73 };
    rect.offset({5, 13});
    SkDebugf("rect: %d, %d, %d, %d\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 55, 86
##
##

#SeeAlso offsetTo makeOffset SkRect::offset

##

# ------------------------------------------------------------------------------

#Method void offsetTo(int32_t newX, int32_t newY)

#In Inset_Outset_Offset
#Line # translates to (x, y) without changing width and height ##
Offsets IRect so that fLeft equals newX, and fTop equals newY. width and height
are unchanged.

#Param newX  stored in fLeft, preserving width() ##
#Param newY  stored in fTop, preserving height() ##

#Example
    SkIRect rect = { 10, 14, 50, 73 };
    rect.offsetTo(15, 27);
    SkDebugf("rect: %d, %d, %d, %d\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 55, 86
##
##

#SeeAlso offset makeOffset setXYWH SkRect::offsetTo

##

# ------------------------------------------------------------------------------

#Method void inset(int32_t dx, int32_t dy)

#In Inset_Outset_Offset
#Line # moves the sides symmetrically about the center ##
Insets IRect by (dx,dy).

If dx is positive, makes IRect narrower.
If dx is negative, makes IRect wider.
If dy is positive, makes IRect shorter.
If dy is negative, makes IRect taller.

#Param dx  offset added to fLeft and subtracted from fRight ##
#Param dy  offset added to fTop and subtracted from fBottom ##

#Example
    SkIRect rect = { 10, 14, 50, 73 };
    rect.inset(5, 13);
    SkDebugf("rect: %d, %d, %d, %d\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 45, 60
##
##

#SeeAlso outset makeInset SkRect::inset

##

# ------------------------------------------------------------------------------

#Method void outset(int32_t dx, int32_t dy)

#In Inset_Outset_Offset
#Line # moves the sides symmetrically about the center ##
Outsets IRect by (dx, dy).

If dx is positive, makes IRect wider.
If dx is negative, makes IRect narrower.
If dy is positive, makes IRect taller.
If dy is negative, makes IRect shorter.

#Param dx  subtracted to fLeft and added from fRight ##
#Param dy  subtracted to fTop and added from fBottom ##

#Example
    SkIRect rect = { 10, 14, 50, 73 };
    rect.outset(5, 13);
    SkDebugf("rect: %d, %d, %d, %d\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 5, 1, 55, 86
##
##

#SeeAlso inset makeOutset SkRect::outset

##

#Subtopic Inset_Outset_Offset ##

#Subtopic Intersection
#Line # set to shared bounds ##

IRects intersect when they enclose a common area. To intersect, each of the pair 
must describe area; fLeft is less than fRight, and fTop is less than fBottom;
empty() returns false. The intersection of IRect pair can be described by:

#Formula
(max(a.fLeft, b.fLeft), max(a.fTop, b.fTop),
 min(a.fRight, b.fRight), min(a.fBottom, b.fBottom))
##
.

The intersection is only meaningful if the resulting IRect is not empty and
describes an area: fLeft is less than fRight, and fTop is less than fBottom.

#Populate

# ------------------------------------------------------------------------------

#Method bool quickReject(int l, int t, int r, int b) const

#In Intersection
#Line # returns true if rectangles do not intersect ##
Constructs IRect (l, t, r, b) and returns true if constructed IRect does not
intersect IRect. Does not check to see if construction or IRect is empty.

Is implemented with short circuit logic so that true can be returned after
a single compare.

#Param l  x minimum of constructed IRect ##
#Param t  y minimum of constructed IRect ##
#Param r  x maximum of constructed IRect ##
#Param b  y maximum of constructed IRect ##

#Return true if construction and IRect have no area in common ##

#Example
#Description
quickReject is the complement of Intersects.
##
   const SkIRect rect = {7, 11, 13, 17};
   const int32_t* r = &rect.fLeft;
   const SkIRect tests[] = { {13, 11, 15, 17}, { 7, 7, 13, 11 }, { 12, 16, 14, 18 } };
   for (auto& test : tests) {
     const int32_t* t = &test.fLeft;
     SkDebugf("rect (%d, %d, %d, %d) test(%d, %d, %d, %d) quickReject %s; intersects %s\n",
              r[0], r[1], r[2], r[3], t[0], t[1], t[2], t[3],
              rect.quickReject(t[0], t[1], t[2], t[3]) ? "true" : "false", 
              SkIRect::Intersects(rect, test) ? "true" : "false");
   }
#StdOut
rect (7, 11, 13, 17) test(13, 11, 15, 17) quickReject true; intersects false
rect (7, 11, 13, 17) test(7, 7, 13, 11) quickReject true; intersects false
rect (7, 11, 13, 17) test(12, 16, 14, 18) quickReject false; intersects true
##
##

#SeeAlso Intersects

##

# ------------------------------------------------------------------------------

#Method bool contains(int32_t x, int32_t y) const

#In Intersection
#Line # returns true if IPoint (x, y) is equal or inside ##
Returns true if:
#Formula
fLeft <= x < fRight && fTop <= y < fBottom
##
.
Returns false if IRect is empty.

Considers input to describe constructed IRect:
#Formula
(x, y, x + 1, y + 1)
##
and
returns true if constructed area is completely enclosed by IRect area.

#Param x  test IPoint x-coordinate ##
#Param y  test IPoint y-coordinate ##

#Return true if (x, y) is inside IRect ##

#Example
    SkIRect rect = { 30, 50, 40, 60 };
    SkIPoint pts[] = { { 30, 50}, { 40, 50}, { 30, 60} };
    for (auto pt : pts) {
        SkDebugf("rect: (%d, %d, %d, %d) %s (%d, %d)\n",
                 rect.left(), rect.top(), rect.right(), rect.bottom(),
                 rect.contains(pt.x(), pt.y()) ? "contains" : "does not contain", pt.x(), pt.y());
    }
#StdOut
rect: (30, 50, 40, 60) contains (30, 50)
rect: (30, 50, 40, 60) does not contain (40, 50)
rect: (30, 50, 40, 60) does not contain (30, 60)
##
##

#SeeAlso containsNoEmptyCheck SkRect::contains

##

# ------------------------------------------------------------------------------

#Method bool contains(int32_t left, int32_t top, int32_t right, int32_t bottom) const

#In Intersection
Constructs IRect to intersect from (left, top, right, bottom). Does not sort
construction.

Returns true if IRect contains construction.
Returns false if IRect is empty or construction is empty.

#Param left  x minimum of constructed IRect ##
#Param top  y minimum of constructed IRect ##
#Param right  x maximum of constructed IRect ##
#Param bottom  y maximum of constructed IRect ##

#Return true if all sides of IRect are outside construction ##

#Example
    SkIRect rect = { 30, 50, 40, 60 };
    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };
    for (auto contained : tests) {
        bool success = rect.contains(
                       contained.left(), contained.top(), contained.right(), contained.bottom());
        SkDebugf("rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\n",
                 rect.left(), rect.top(), rect.right(), rect.bottom(),
                 success ? "contains" : "does not contain",
                 contained.left(), contained.top(), contained.right(), contained.bottom());
    }
#StdOut
rect: (30, 50, 40, 60) contains (30, 50, 31, 51)
rect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)
rect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)
##
##

#SeeAlso containsNoEmptyCheck SkRect::contains

##

# ------------------------------------------------------------------------------

#Method bool contains(const SkIRect& r) const

#In Intersection
Returns true if IRect contains r.
Returns false if IRect is empty or r is empty.

IRect contains r when IRect area completely includes r area.

#Param r  IRect contained ##

#Return true if all sides of IRect are outside r ##

#Example
    SkIRect rect = { 30, 50, 40, 60 };
    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };
    for (auto contained : tests) {
        SkDebugf("rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\n",
                 rect.left(), rect.top(), rect.right(), rect.bottom(),
                 rect.contains(contained) ? "contains" : "does not contain",
                 contained.left(), contained.top(), contained.right(), contained.bottom());
    }
#StdOut
rect: (30, 50, 40, 60) contains (30, 50, 31, 51)
rect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)
rect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)
##
##

#SeeAlso containsNoEmptyCheck SkRect::contains

##

# ------------------------------------------------------------------------------

#Method bool contains(const SkRect& r) const

#In Intersection
Returns true if IRect contains r.
Returns false if IRect is empty or r is empty.

IRect contains r when IRect area completely includes r area.

#Param r  Rect contained ##

#Return true if all sides of IRect are outside r ##

#Example
    SkIRect rect = { 30, 50, 40, 60 };
    SkRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };
    for (auto contained : tests) {
        SkDebugf("rect: (%d, %d, %d, %d) %s (%g, %g, %g, %g)\n",
                 rect.left(), rect.top(), rect.right(), rect.bottom(),
                 rect.contains(contained) ? "contains" : "does not contain",
                 contained.left(), contained.top(), contained.right(), contained.bottom());
    }
#StdOut
rect: (30, 50, 40, 60) contains (30, 50, 31, 51)
rect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)
rect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)
##
##

#SeeAlso containsNoEmptyCheck SkRect::contains

##

# ------------------------------------------------------------------------------

#Method bool containsNoEmptyCheck(int32_t left, int32_t top,
                              int32_t right, int32_t bottom) const
#In Intersection
#Line # returns true if contains unsorted IRect ##

Constructs IRect from (left, top, right, bottom). Does not sort
construction.

Returns true if IRect contains construction.
Asserts if IRect is empty or construction is empty, and if SK_DEBUG is defined.

Return is undefined if IRect is empty or construction is empty.

#Param left  x minimum of constructed IRect ##
#Param top  y minimum of constructed IRect ##
#Param right  x maximum of constructed IRect ##
#Param bottom  y maximum of constructed IRect ##

#Return true if all sides of IRect are outside construction ##

#Example
    SkIRect rect = { 30, 50, 40, 60 };
    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };
    for (auto contained : tests) {
        bool success = rect.containsNoEmptyCheck(
                 contained.left(), contained.top(), contained.right(), contained.bottom());
        SkDebugf("rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\n",
                 rect.left(), rect.top(), rect.right(), rect.bottom(),
                 success ? "contains" : "does not contain",
                 contained.left(), contained.top(), contained.right(), contained.bottom());
    }
#StdOut
rect: (30, 50, 40, 60) contains (30, 50, 31, 51)
rect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)
rect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)
##
##

#SeeAlso contains SkRect::contains

##

# ------------------------------------------------------------------------------

#Method bool containsNoEmptyCheck(const SkIRect& r) const

#In Intersection
Returns true if IRect contains construction.
Asserts if IRect is empty or construction is empty, and if SK_DEBUG is defined.

Return is undefined if IRect is empty or construction is empty.

#Param r  IRect contained ##

#Return true if all sides of IRect are outside r ##

#Example
    SkIRect rect = { 30, 50, 40, 60 };
    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };
    for (auto contained : tests) {
        SkDebugf("rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\n",
                 rect.left(), rect.top(), rect.right(), rect.bottom(),
                 rect.containsNoEmptyCheck(contained) ? "contains" : "does not contain",
                 contained.left(), contained.top(), contained.right(), contained.bottom());
    }
#StdOut
rect: (30, 50, 40, 60) contains (30, 50, 31, 51)
rect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)
rect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)
##
##

#SeeAlso contains SkRect::contains

##

# ------------------------------------------------------------------------------

#Method bool intersect(const SkIRect& r)

#In Intersection
#Line # sets to shared area; returns true if not empty ##
Returns true if IRect intersects r, and sets IRect to intersection.
Returns false if IRect does not intersect r, and leaves IRect unchanged.

Returns false if either r or IRect is empty, leaving IRect unchanged.

#Param r  limit of result ##

#Return true if r and IRect have area in common ##

#Example
#Description
Two SkDebugf calls are required. If the calls are combined, their arguments
may not be evaluated in left to right order: the printed intersection may
be before or after the call to intersect.
##
    SkIRect leftRect =  { 10, 40, 50, 80 };
    SkIRect rightRect = { 30, 60, 70, 90 };
    SkDebugf("%s intersection: ", leftRect.intersect(rightRect) ? "" : "no ");
    SkDebugf("%d, %d, %d, %d\n", leftRect.left(), leftRect.top(), 
                                 leftRect.right(), leftRect.bottom());
#StdOut
 intersection: 30, 60, 50, 80
##                                 
##

#SeeAlso Intersects intersectNoEmptyCheck join SkRect::intersect

##

# ------------------------------------------------------------------------------

#Method bool SK_WARN_UNUSED_RESULT intersect(const SkIRect& a, const SkIRect& b)

#In Intersection
Returns true if a intersects b, and sets IRect to intersection.
Returns false if a does not intersect b, and leaves IRect unchanged.

Returns false if either a or b is empty, leaving IRect unchanged.

#Param a  IRect to intersect ##
#Param b  IRect to intersect ##

#Return true if a and b have area in common ##

#Example
    SkIRect result;
    bool intersected = result.intersect({ 10, 40, 50, 80 }, { 30, 60, 70, 90 });
    SkDebugf("%s intersection: %d, %d, %d, %d\n", intersected ? "" : "no ",
             result.left(), result.top(), result.right(), result.bottom());
#StdOut
 intersection: 30, 60, 50, 80
##                                 
##

#SeeAlso Intersects intersectNoEmptyCheck join SkRect::intersect

##

# ------------------------------------------------------------------------------

#Method bool SK_WARN_UNUSED_RESULT intersectNoEmptyCheck(const SkIRect& a, const SkIRect& b)

#In Intersection
#Line # sets to shared area; returns true if not empty skips empty check ##
Returns true if a intersects b, and sets IRect to intersection.
Returns false if a does not intersect b, and leaves IRect unchanged.

Asserts if either a or b is empty, and if SK_DEBUG is defined.

#Param a  IRect to intersect ##
#Param b  IRect to intersect ##

#Return true if a and b have area in common ##

#Example
    SkIRect result;
    bool intersected = result.intersectNoEmptyCheck({ 10, 40, 50, 80 }, { 30, 60, 70, 90 });
    SkDebugf("intersection: %d, %d, %d, %d\n",
             result.left(), result.top(), result.right(), result.bottom());
#StdOut
 intersection: 30, 60, 50, 80
##                                 
##

#SeeAlso Intersects intersect join SkRect::intersect

##

# ------------------------------------------------------------------------------

#Method bool intersect(int32_t left, int32_t top, int32_t right, int32_t bottom)

#In Intersection
Constructs IRect to intersect from (left, top, right, bottom). Does not sort
construction.

Returns true if IRect intersects construction, and sets IRect to intersection.
Returns false if IRect does not intersect construction, and leaves IRect unchanged.

Returns false if either construction or IRect is empty, leaving IRect unchanged.

#Param left  x minimum of constructed IRect ##
#Param top  y minimum of constructed IRect ##
#Param right  x maximum of constructed IRect ##
#Param bottom  y maximum of constructed IRect ##

#Return true if construction and IRect have area in common ##

#Example
#Description
Two SkDebugf calls are required. If the calls are combined, their arguments
may not be evaluated in left to right order: the printed intersection may
be before or after the call to intersect.
##
    SkIRect leftRect =  { 10, 40, 50, 80 };
    SkDebugf("%s intersection: ", leftRect.intersect(30, 60, 70, 90) ? "" : "no ");
    SkDebugf("%d, %d, %d, %d\n", leftRect.left(), leftRect.top(), 
                                 leftRect.right(), leftRect.bottom());
#StdOut
 intersection: 30, 60, 50, 80
##                                 
##

#SeeAlso intersectNoEmptyCheck Intersects join SkRect::intersect

##

# ------------------------------------------------------------------------------

#Method static bool Intersects(const SkIRect& a, const SkIRect& b)

#In Intersection
#Line # returns true if areas overlap ##
Returns true if a intersects b.
Returns false if either a or b is empty, or do not intersect.

#Param a  IRect to intersect ##
#Param b  IRect to intersect ##

#Return true if a and b have area in common ##

#Example
    SkDebugf("%s intersection", SkIRect::Intersects({10, 40, 50, 80}, {30, 60, 70, 90}) ? "" : "no ");
#StdOut
 intersection
##                                 
##

#SeeAlso IntersectsNoEmptyCheck intersect SkRect::intersect

##

# ------------------------------------------------------------------------------

#Method static bool IntersectsNoEmptyCheck(const SkIRect& a, const SkIRect& b)

#In Intersection
#Line # returns true if areas overlap skips empty check ##
Returns true if a intersects b.
Asserts if either a or b is empty, and if SK_DEBUG is defined.

#Param a  IRect to intersect ##
#Param b  IRect to intersect ##

#Return true if a and b have area in common ##

#Example
    SkDebugf("%s intersection", SkIRect::IntersectsNoEmptyCheck(
            {10, 40, 50, 80}, {30, 60, 70, 90}) ? "" : "no ");
#StdOut
 intersection
##                                 
##

#SeeAlso Intersects intersect SkRect::intersect

##

#Subtopic Intersection ##

# ------------------------------------------------------------------------------

#Subtopic Join
#Line # set to union of bounds ##
#Populate
##

#Method void join(int32_t left, int32_t top, int32_t right, int32_t bottom)

#In Join
#Line # sets to union of bounds ##
Constructs IRect to intersect from (left, top, right, bottom). Does not sort
construction.

Sets IRect to the union of itself and the construction.

Has no effect if construction is empty. Otherwise, if IRect is empty, sets
IRect to construction.

#Param left  x minimum of constructed IRect ##
#Param top  y minimum of constructed IRect ##
#Param right  x maximum of constructed IRect ##
#Param bottom  y maximum of constructed IRect ##

#Example
    SkIRect rect = { 10, 20, 15, 25};
    rect.join(50, 60, 55, 65);
    SkDebugf("join: %d, %d, %d, %d\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
 join: 10, 20, 55, 65
##                                 
##

#SeeAlso set SkRect::join

##

# ------------------------------------------------------------------------------

#Method void join(const SkIRect& r)

#In Join
Sets IRect to the union of itself and r.

Has no effect if r is empty. Otherwise, if IRect is empty, sets IRect to r.

#Param r  expansion IRect ##

#Example
    SkIRect rect = { 10, 20, 15, 25};
    rect.join({50, 60, 55, 65});
    SkDebugf("join: %d, %d, %d, %d\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
 join: 10, 20, 55, 65
##                                 
##

#SeeAlso set SkRect::join

##

# ------------------------------------------------------------------------------

#Subtopic Sorting
#Line # orders sides ##
#Populate
##

#Method void sort()

#In Sorting
#Line # orders sides from smaller to larger ##
Swaps fLeft and fRight if fLeft is greater than fRight; and swaps
fTop and fBottom if fTop is greater than fBottom. Result may be empty,
and width() and height() will be zero or positive.

#Example
    SkIRect rect = { 30, 50, 20, 10 };
    SkDebugf("rect: %d, %d, %d, %d\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    rect.sort();
    SkDebugf("sorted: %d, %d, %d, %d\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 30, 50, 20, 10
sorted: 20, 10, 30, 50
##
##

#SeeAlso makeSorted SkRect::sort

##

# ------------------------------------------------------------------------------

#Method SkIRect makeSorted() const

#In Sorting
#In Constructor
#Line # constructs, ordering sides from smaller to larger ##
Returns IRect with fLeft and fRight swapped if fLeft is greater than fRight; and
with fTop and fBottom swapped if fTop is greater than fBottom. Result may be empty;
and width() and height() will be zero or positive.

#Return  sorted IRect ##

#Example
    SkIRect rect = { 30, 50, 20, 10 };
    SkDebugf("rect: %d, %d, %d, %d\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    SkIRect sort = rect.makeSorted();
    SkDebugf("sorted: %d, %d, %d, %d\n", sort.fLeft, sort.fTop, sort.fRight, sort.fBottom);
#StdOut
rect: 30, 50, 20, 10
sorted: 20, 10, 30, 50
##
##

#SeeAlso sort SkRect::makeSorted

##

# ------------------------------------------------------------------------------

#Method static const SkIRect& SK_WARN_UNUSED_RESULT EmptyIRect()

#In Constructor
#Line # returns immutable bounds of (0, 0, 0, 0) ##
Returns a reference to immutable empty IRect, set to (0, 0, 0, 0).

#Return  global IRect set to all zeroes ##

#Example
    const SkIRect& rect = SkIRect::EmptyIRect();
    SkDebugf("rect: %d, %d, %d, %d\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 0, 0, 0, 0
##
##

#SeeAlso MakeEmpty

##

#Method static SkIRect SK_WARN_UNUSED_RESULT MakeLargest()
#Deprecated
##

#Struct SkIRect ##

#Topic IRect ##
