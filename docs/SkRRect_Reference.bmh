#Topic RRect
#Alias Round_Rect ##
#Alias RRect_Reference ##

#Class SkRRect

SkRRect describes a rounded rectangle with a bounds and a pair of radii for each corner.
The bounds and radii can be set so that SkRRect describes: a rectangle with sharp corners;
a Circle; an Oval; or a rectangle with one or more rounded corners.

SkRRect allows implementing CSS properties that describe rounded corners.
SkRRect may have up to eight different radii, one for each axis on each of its four
corners.

SkRRect may modify the provided parameters when initializing bounds and radii.
If either axis radii is zero or less: radii are stored as zero; corner is square.
If corner curves overlap, radii are proportionally reduced to fit within bounds.

#Subtopic Overview
#Populate
##

#Subtopic Constructor
#Populate
##

#Subtopic Operator
#Populate
##

#Subtopic Member_Function
#Populate
##

# ------------------------------------------------------------------------------

#Method SkRRect()
#In Constructor
#Line # creates with zeroed bounds and corner radii ##

Initializes bounds at (0, 0), the origin, with zero width and height.
Initializes corner radii to (0, 0), and sets type of kEmpty_Type.

#Return empty Round_Rect ##

#Example
#Height 60
    SkRRect rrect;
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    canvas->drawRRect(rrect, p);
    rrect.setRect({10, 10, 100, 50});
    canvas->drawRRect(rrect, p);
##

#SeeAlso setEmpty isEmpty

#Method ##

# ------------------------------------------------------------------------------

#Method SkRRect(const SkRRect& rrect)
#In Constructor
#Line # copies bounds and corner radii ##

Initializes to copy of rrect bounds and corner radii.

#Param rrect  bounds and corner to copy ##

#Return copy of rrect ##

#Bug 8115
#Example
#Height 60
    SkRRect rrect = SkRRect::MakeRect({10, 10, 100, 50});
    SkRRect rrect2(rrect);
    rrect2.inset(20, 20);
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    canvas->drawRRect(rrect, p);
    canvas->drawRRect(rrect2, p);
##

#SeeAlso operator=(const SkRRect& rrect) MakeRect

#Method ##

# ------------------------------------------------------------------------------

#Method SkRRect& operator=(const SkRRect& rrect)
#In Operator
#Line # copies bounds and corner radii ##

Copies rrect bounds and corner radii.

#Param rrect  bounds and corner to copy ##

#Return copy of rrect ##

#Example
#Height 110
    SkRRect rrect = SkRRect::MakeRect({40, 40, 100, 70});
    SkRRect rrect2 = rrect;
    rrect2.inset(-20, -20);
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    canvas->drawRRect(rrect, p);
    canvas->drawRRect(rrect2, p);
##

#SeeAlso SkRRect(const SkRRect& rrect) MakeRect

#Method ##

# ------------------------------------------------------------------------------
#Subtopic Type
#Line # specialization of Round_Rect geometry ##

#PhraseDef list_of_rrect_types
kEmpty_Type, kRect_Type, kOval_Type, kSimple_Type, kNinePatch_Type,
kComplex_Type
##

#Enum Type
#Line # specialization of Round_Rect geometry ##

#Code
    enum Type {
        kEmpty_Type,
        kRect_Type,
        kOval_Type,
        kSimple_Type,
        kNinePatch_Type,
        kComplex_Type,
        kLastType = kComplex_Type,
    };
##

Type describes possible specializations of Round_Rect. Each Type is
exclusive; a Round_Rect may only have one type. 

Type members become progressively less restrictive; larger values of
Type have more degrees of freedom than smaller values.

#Const kEmpty_Type 0
#Line # zero width or height ##
Round_Rect has zero width or height. All radii are zero.
##
#Const kRect_Type 1
#Line # non-zero width and height, and zeroed radii ##
Round_Rect has width and height. All radii are zero.
##
#Const kOval_Type 2
#Line # non-zero width and height filled with radii ##
Round_Rect has width and height. All four x-radii are equal,
and at least half the width. All four y-radii are equal,
and at least half the height.
##
#Const kSimple_Type 3
#Line # non-zero width and height with equal radii ##
Round_Rect has width and height. All four x-radii are equal and
greater than zero, and all four y-radii are equal and greater than
zero. Either x-radii are less than half the width, or y-radii is
less than half the height, or both.
##
#Const kNinePatch_Type 4
#Line # non-zero width and height with axis-aligned radii ##
Round_Rect has width and height. Left x-radii are equal, top
y-radii are equal, right x-radii are equal, and bottom y-radii
are equal. The radii do not describe Rect, Oval, or simple type.

The centers of the corner ellipses form an axis-aligned rectangle
that divides the Round_Rect into nine rectangular patches; an
interior rectangle, four edges, and four corners.
##
#Const kComplex_Type 5
#Line # non-zero width and height with arbitrary radii ##
both radii are non-zero.
##
#Const kLastType 5
#Line # largest Type value ##
##

#Example
#Height 128
    struct Radii { SkVector data[4]; };
    auto drawRRectType = [=](const SkRect& rect, const Radii& radii) {
        SkRRect rrect;
        rrect.setRectRadii(rect, radii.data);
        SkPaint paint;
        paint.setAntiAlias(true);
        const char* typeStr[] = { "empty", "rect", "oval", "simple", "nine patch", "complex" };
        paint.setTextAlign(SkPaint::kCenter_Align);
        canvas->drawString(typeStr[(int) rrect.type()], rect.centerX(), rect.bottom() + 20, paint);
        paint.setStyle(SkPaint::kStroke_Style);       
        canvas->drawRRect(rrect, paint);
    };
    drawRRectType({ 45,  30,  45,  30}, {{{ 5,  5}, { 5,  5}, { 5,  5}, { 5,  5}}});
    drawRRectType({ 90,  10, 140,  30}, {{{ 0,  0}, { 0,  0}, { 0,  0}, { 0,  0}}});
    drawRRectType({160,  10, 210,  30}, {{{25, 10}, {25, 10}, {25, 10}, {25, 10}}});
    drawRRectType({ 20,  80,  70, 100}, {{{ 5,  5}, { 5,  5}, { 5,  5}, { 5,  5}}});
    drawRRectType({ 90,  80, 140, 100}, {{{ 5,  5}, {10,  5}, {10,  5}, { 5,  5}}});
    drawRRectType({160,  80, 210, 100}, {{{ 5,  5}, {10,  5}, { 5,  5}, { 5,  5}}});
##

#SeeAlso Rect Path

#Enum ##

# ------------------------------------------------------------------------------

#Method Type getType() const
#In Property
#Line # returns Type ##

Returns Type, one of: #list_of_rrect_types#.

#Return Type ##

#Example
#Height 100
#Description 
rrect2 is not a Rect; inset() has made it empty.
##
    SkRRect rrect = SkRRect::MakeRect({10, 10, 100, 50});
    SkRRect rrect2(rrect);
    rrect2.inset(20, 20);
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    std::string str("Type ");
    str += SkRRect::kRect_Type == rrect2.getType() ? "=" : "!"; 
    str += "= SkRRect::kRect_Type";
    canvas->drawString(str.c_str(), 20, 80, SkPaint());
    canvas->drawRRect(rrect2, p);
##

#SeeAlso Type type

#Method ##

# ------------------------------------------------------------------------------

#Method Type type() const
#In Property
#Line # returns Type ##

Returns Type, one of: #list_of_rrect_types#.

#Return Type ##

#Example
#Height 100
#Description 
inset() has made rrect2 empty.
##
    SkRRect rrect = SkRRect::MakeRect({10, 10, 100, 50});
    SkRRect rrect2(rrect);
    rrect2.inset(20, 20);
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    std::string str("Type ");
    str += SkRRect::kEmpty_Type == rrect2.type() ? "=" : "!"; 
    str += "= SkRRect::kEmpty_Type";
    canvas->drawString(str.c_str(), 20, 80, SkPaint());
    canvas->drawRRect(rrect2, p);
##

#SeeAlso Type getType

#Method ##

#Subtopic Type ##

# ------------------------------------------------------------------------------

#Method inline bool isEmpty() const
#In Property
#Line # returns true if width or height are zero ##
Returns true if rect().fLeft is equal to rect().fRight, or if rect().fTop is equal
to rect().fBottom.

#Return true if width() or height() are zero ##

#Example
#Height 100
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 10, 5);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isEmpty() ? "empty" : "not empty", 64, 90, paint);
    rrect.inset(40, 0);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isEmpty() ? "empty" : "not empty", 64, 90, paint);
##

#SeeAlso SkRect::isEmpty height width

#Method ##

# ------------------------------------------------------------------------------

#Method inline bool isRect() const
#In Property
#Line # returns true if not empty, and one radius at each corner is zero ##
Returns true if not empty, and if either x-axis or y-axis radius at each corner
is zero.

#Return true if not empty, and one radius at each corner is zero ##

#Example
#Height 100
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isRect() ? "rect" : "not rect", 64, 90, paint);
    SkVector radii[] = {{10, 10}, {0, 0}, {0, 0}, {0, 0}};
    rrect.setRectRadii(rrect.getBounds(), radii);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isRect() ? "rect" : "not rect", 64, 90, paint);
##

#SeeAlso isEmpty radii

#Method ##

# ------------------------------------------------------------------------------

#Method inline bool isOval() const
#In Property
#Line # returns true if not empty, axes radii are equal, radii fill bounds ##
Returns true if not empty, if all x-axis radii are equal, if all y-axis radii
are equal, x-axis radii are at least half the width, and y-axis radii are at
least half the height.

#Return true if has identical geometry to Oval ##

#Example
#Height 100
#Description
The first radii are scaled down proportionately until both x-axis and y-axis fit
within the bounds. After scaling, x-axis radius is smaller than half the width;
left Round_Rect is not an oval. The second radii are equal to half the
dimensions; right Round_Rect is an oval.
##
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 40, 30);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isOval() ? "oval" : "not oval", 64, 90, paint);
    rrect.setRectXY(rrect.getBounds(), 35, 25);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isOval() ? "oval" : "not oval", 64, 90, paint);
##

#SeeAlso isEmpty isSimple SkCanvas::drawOval

#Method ##

# ------------------------------------------------------------------------------

#Method inline bool isSimple() const
#In Property
#Line # returns true if not empty, Rect or Oval; and axes radii are equal ##
Returns true if not empty, if all x-axis radii are equal but not zero,
if all y-axis radii are equal but not zero; and x-axis radius is less than half
width(), or y-axis radius is less than half height().

#Return true if not empty, Rect or Oval; and axes radii are equal ##

#Bug 8107
#Example
#Height 100
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkVector radii[] = {{40, 30}, {40, 30}, {40, 30}, {40, 30}};
    SkRRect rrect;
    rrect.setRectRadii({30, 10, 100, 60}, radii);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isSimple() ? "simple" : "not simple", 64, 90, paint);
    radii[0].fX = 35;
    rrect.setRectRadii(rrect.getBounds(), radii);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isSimple() ? "simple" : "not simple", 64, 90, paint);
##

#SeeAlso isEmpty isRect isOval isNinePatch

#Method ##

# ------------------------------------------------------------------------------

#Method inline bool isNinePatch() const
#In Property
#Line # returns true if not empty, Rect, Oval or simple; and radii are axis-aligned ##
Returns true if isEmpty, isRect, isOval, and isSimple return false; and if
left x-axis radii are equal, right x-axis radii are equal, top y-axis radii are
equal, and bottom y-axis radii are equal.

#Return true if not empty, Rect, Oval or simple; and radii are axis-aligned ##

#Bug 8107
#Example
#Height 100
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkVector radii[] = {{20, 30}, {40, 30}, {40, 30}, {20, 30}};
    SkRRect rrect;
    rrect.setRectRadii({30, 10, 100, 60}, radii);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isNinePatch() ? "9 patch" : "not 9 patch", 64, 90, paint);
    radii[0].fX = 35;
    rrect.setRectRadii(rrect.getBounds(), radii);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isNinePatch() ? "9 patch" : "not 9 patch", 64, 90, paint);
##

#SeeAlso isEmpty isRect isOval isSimple isComplex

#Method ##

# ------------------------------------------------------------------------------

#Method inline bool isComplex() const
#In Property
#Line # returns true if not empty, Rect, Oval, simple, or nine-patch ##

Returns true if isEmpty, isRect, isOval, isSimple, and isNinePatch return false.
If true: width and height are greater than zero, at least one corner radii are
both greater than zero; left x-axis radii are not equal, or right x-axis radii
are not equal, or top y-axis radii are not equal, or bottom y-axis radii are not
equal.

#Return true if not empty, Rect, Oval, simple, or nine-patch ##

#Example
#Height 100
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkVector radii[] = {{25, 30}, {40, 30}, {40, 30}, {20, 30}};
    SkRRect rrect;
    rrect.setRectRadii({30, 10, 100, 60}, radii);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isComplex() ? "complex" : "not complex", 64, 90, paint);
    radii[0].fX = 20;
    rrect.setRectRadii(rrect.getBounds(), radii);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isComplex() ? "complex" : "not complex", 64, 90, paint);
##

#SeeAlso isEmpty isRect isOval isSimple isNinePatch

#Method ##

# ------------------------------------------------------------------------------

#Method SkScalar width() const
#In Property
#Line # returns span in x-axis ##
Returns span on the x-axis. This does not check if result fits in 32-bit float;
result may be infinity.

#Return bounds().fRight minus bounds().fLeft ##

#Example
#Description
SkRRect::MakeRect sorts its input, so width() is always zero or larger.
##
    SkRRect unsorted = SkRRect::MakeRect({ 15, 25, 10, 5 });
    SkDebugf("unsorted width: %g\n", unsorted.width());
    SkRRect large = SkRRect::MakeRect({ -FLT_MAX, 1, FLT_MAX, 2 });
    SkDebugf("large width: %.0f\n", large.width());
#StdOut
unsorted width: 5
large width: inf
##
##

#SeeAlso SkRect::width height getBounds

#Method ##

# ------------------------------------------------------------------------------

#Method SkScalar height() const
#In Property
#Line # returns span in y-axis ##
Returns span on the y-axis. This does not check if result fits in 32-bit float;
result may be infinity.

#Return bounds().fBottom minus bounds().fTop ##

#Example
#Description
SkRRect::MakeRect sorts its input, so height() is always zero or larger.
##
    SkRRect unsorted = SkRRect::MakeRect({ 15, 25, 10, 20 });
    SkDebugf("unsorted height: %g\n", unsorted.height());
    SkRRect large = SkRRect::MakeRect({ 1, -FLT_MAX, 2, FLT_MAX });
    SkDebugf("large height: %.0f\n", large.height());
#StdOut
unsorted height: 5
large height: inf
##
##

#SeeAlso SkRect.height width getBounds

#Method ##

# ------------------------------------------------------------------------------

#Method SkVector getSimpleRadii() const
#In Property
#Line # returns corner radii for simple types ##

Returns top-left corner x-radii. If type() returns kEmpty_Type, kRect_Type, 
kOval_Type, or kSimple_Type, returns a value representative of all corner radii.
If type() returns kNinePatch_Type or kComplex_Type, at least one of the
remaining three corners has a different value.

#Return corner radii for simple types ##

#Example
#Height 100
    auto drawDetails = [=](const SkRRect& rrect) {
        SkPaint paint;
        paint.setAntiAlias(true);
        paint.setTextAlign(SkPaint::kCenter_Align);
        paint.setTextSize(12);
        canvas->drawRRect(rrect, paint);
        SkVector corner = rrect.getSimpleRadii();
        std::string label = "corner: " + std::to_string(corner.fX).substr(0, 3) + ", " +
                        std::to_string(corner.fY).substr(0, 3);
        canvas->drawString(label.c_str(), 64, 90, paint);
        canvas->translate(128, 0);
    };
    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});
    drawDetails(rrect);
    rrect.setRectXY(rrect.getBounds(), 5, 8);
    drawDetails(rrect);
##

#SeeAlso radii getBounds getType isSimple

#Method ##

# ------------------------------------------------------------------------------

#Method void setEmpty()
#In Set
#Line # zeroes width, height, and corner radii ##

Sets bounds to zero width and height at (0, 0), the origin. Sets
corner radii to zero and sets type to kEmpty_Type.

#Example
#Height 80
#Description
Nothing blue is drawn because Round_Rect is set to empty.
##
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});
    canvas->drawRRect(rrect, paint);
    rrect.setEmpty();
    paint.setColor(SK_ColorBLUE);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso MakeEmpty setRect

#Method ##

# ------------------------------------------------------------------------------

#Method void setRect(const SkRect& rect)
#In Set
#Line # sets Round_Rect bounds with zeroed corners ##

Sets bounds to sorted rect, and sets corner radii to zero.
If set bounds has width and height, and sets type to kRect_Type;
otherwise, sets type to kEmpty_Type.

#Param rect  bounds to set ##

#Example
#Height 90
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});
    canvas->drawRRect(rrect, paint);
    rrect.setRect({60, 30, 120, 80});
    paint.setColor(SK_ColorBLUE);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso MakeRect setRectXY

#Method ##

# ------------------------------------------------------------------------------

#Method static SkRRect MakeEmpty()
#In Constructor
#Line # creates with zeroed bounds and corner radii ##

Initializes bounds at (0, 0), the origin, with zero width and height.
Initializes corner radii to (0, 0), and sets type of kEmpty_Type.

#Return empty Round_Rect ##

#Example
#Height 90
    SkRRect rrect = SkRRect::MakeEmpty();
    SkRRect rrect2(rrect);
    rrect2.inset(-20, -20);
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    std::string str("Type ");
    str += SkRRect::kEmpty_Type == rrect2.type() ? "=" : "!"; 
    str += "= SkRRect::kEmpty_Type";
    canvas->drawString(str.c_str(), 20, 80, SkPaint());
    canvas->drawRRect(rrect2, p);
##

#SeeAlso SkRRect() SkRect::MakeEmpty

#Method ##

# ------------------------------------------------------------------------------

#Method static SkRRect MakeRect(const SkRect& r)
#In Constructor
#Line # copies bounds and zeroes corner radii ##

Initializes to copy of r bounds and zeroes corner radii.

#Param r  bounds to copy ##

#Return copy of r ##

#Example
#Height 70
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});
    canvas->drawRRect(rrect, paint);
    rrect.setOval(rrect.getBounds());
    paint.setColor(SK_ColorBLUE);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso setRect MakeOval MakeRectXY

#Method ##

# ------------------------------------------------------------------------------

#Method static SkRRect MakeOval(const SkRect& oval)
#In Constructor
#Line # creates Oval to fit bounds ##

Sets bounds to oval, x-axis radii to half oval.width(), and all y-axis radii
to half oval.height(). If oval bounds is empty, sets to kEmpty_Type.
Otherwise, sets to kOval_Type.

#Param oval  bounds of Oval ##

#Return Oval ##

#Example
#Height 70
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeOval({30, 10, 100, 60});
    canvas->drawRRect(rrect, paint);
    rrect.setRect(rrect.getBounds());
    paint.setColor(SK_ColorBLUE);
    paint.setBlendMode(SkBlendMode::kDifference);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso setOval MakeRect MakeRectXY

#Method ##

# ------------------------------------------------------------------------------

#Method static SkRRect MakeRectXY(const SkRect& rect, SkScalar xRad, SkScalar yRad)
#In Constructor
#Line # creates rounded rectangle ##

Sets to rounded rectangle with the same radii for all four corners.
If rect is empty, sets to kEmpty_Type.
Otherwise, if xRad and yRad are zero, sets to kRect_Type.
Otherwise, if xRad is at least half rect.width() and yRad is at least half
rect.height(), sets to kOval_Type.
Otherwise, sets to kSimple_Type.

#Param rect  bounds of rounded rectangle ##
#Param xRad  x-axis radius of corners ##
#Param yRad  y-axis radius of corners ##

#Return rounded rectangle ##

#Example
#Height 70
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 20, 20);
    canvas->drawRRect(rrect, paint);
    rrect.setRect(rrect.getBounds());
    paint.setColor(SK_ColorBLUE);
    paint.setBlendMode(SkBlendMode::kModulate);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso setRectXY

#Method ##

# ------------------------------------------------------------------------------

#Method void setOval(const SkRect& oval)
#In Set
#Line # replaces with Oval to fit bounds ##

Sets bounds to oval, x-axis radii to half oval.width(), and all y-axis radii
to half oval.height(). If oval bounds is empty, sets to kEmpty_Type.
Otherwise, sets to kOval_Type.

#Param oval  bounds of Oval ##

#Example
#Height 70
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 20, 20);
    canvas->drawRRect(rrect, paint);
    rrect.setOval(rrect.getBounds());
    paint.setColor(SK_ColorWHITE);
    paint.setBlendMode(SkBlendMode::kExclusion);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso MakeOval

#Method ##

# ------------------------------------------------------------------------------

#Method void setRectXY(const SkRect& rect, SkScalar xRad, SkScalar yRad)
#In Set
#Line # replaces with rounded rectangle ##

Sets to rounded rectangle with the same radii for all four corners.
If rect is empty, sets to kEmpty_Type.
Otherwise, if xRad or yRad is zero, sets to kRect_Type.
Otherwise, if xRad is at least half rect.width() and yRad is at least half
rect.height(), sets to kOval_Type.
Otherwise, sets to kSimple_Type.

#Param rect  bounds of rounded rectangle ##
#Param xRad  x-axis radius of corners ##
#Param yRad  y-axis radius of corners ##

#Example
#Height 70
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 20, 20);
    canvas->drawRRect(rrect, paint);
    rrect.setRectXY(rrect.getBounds(), 5, 5);
    paint.setColor(SK_ColorWHITE);
    paint.setBlendMode(SkBlendMode::kExclusion);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso MakeRectXY SkPath::addRoundRect

#Method ##

# ------------------------------------------------------------------------------

#Method void setNinePatch(const SkRect& rect, SkScalar leftRad, SkScalar topRad,
                      SkScalar rightRad, SkScalar bottomRad)
#In Set
#Line # replaces with rounded rectangle ##

Sets bounds to rect. Sets radii to (leftRad, topRad), (rightRad, topRad),
(rightRad, bottomRad), (leftRad, bottomRad).

If rect is empty, sets to kEmpty_Type.
Otherwise, if leftRad and rightRad are zero, sets to kRect_Type.
Otherwise, if topRad and bottomRad are zero, sets to kRect_Type.
Otherwise, if leftRad and rightRad are equal and at least half rect.width(), and
topRad and bottomRad are equal at least half rect.height(), sets to kOval_Type.
Otherwise, if leftRad and rightRad are equal, and topRad and bottomRad are equal,
sets to kSimple_Type. Otherwise, sets to kNinePatch_Type.

Nine patch refers to the nine parts defined by the radii: one center rectangle,
four edge patches, and four corner patches.

#Param rect  bounds of rounded rectangle ##
#Param leftRad  left-top and left-bottom x-axis radius ##
#Param topRad  left-top and right-top y-axis radius ##
#Param rightRad  right-top and right-bottom x-axis radius ##
#Param bottomRad  left-bottom and right-bottom y-axis radius ##

#Example
#Height 70
    SkPaint paint;
    paint.setAntiAlias(true);
    SkRRect rrect;
    rrect.setNinePatch({30, 10, 100, 60}, 10, 20, 20, 10);
    canvas->drawRRect(rrect, paint);
    paint.setColor(SK_ColorWHITE);
    const SkRect r = rrect.getBounds();
    canvas->drawLine(r.fLeft, r.fTop + rrect.radii(SkRRect::kUpperLeft_Corner).fY,
                     r.fRight, r.fTop + rrect.radii(SkRRect::kUpperRight_Corner).fY, paint);
    canvas->drawLine(r.fLeft, r.fBottom - rrect.radii(SkRRect::kLowerLeft_Corner).fY,
                     r.fRight, r.fBottom - rrect.radii(SkRRect::kLowerRight_Corner).fY, paint);
    canvas->drawLine(r.fLeft + rrect.radii(SkRRect::kUpperLeft_Corner).fX, r.fTop,
                     r.fLeft + rrect.radii(SkRRect::kLowerLeft_Corner).fX, r.fBottom, paint);
    canvas->drawLine(r.fRight - rrect.radii(SkRRect::kUpperRight_Corner).fX, r.fTop,
                     r.fRight - rrect.radii(SkRRect::kLowerRight_Corner).fX, r.fBottom, paint);
##

#SeeAlso setRectRadii

#Method ##

# ------------------------------------------------------------------------------

#Method void setRectRadii(const SkRect& rect, const SkVector radii[4])
#In Set
#Line # replaces with rounded rectangle ##

Sets bounds to rect. Sets radii array for individual control of all for corners.

If rect is empty, sets to kEmpty_Type.
Otherwise, if one of each corner radii are zero, sets to kRect_Type.
Otherwise, if all x-axis radii are equal and at least half rect.width(), and
all y-axis radii are equal at least half rect.height(), sets to kOval_Type.
Otherwise, if all x-axis radii are equal, and all y-axis radii are equal,
sets to kSimple_Type. Otherwise, sets to kNinePatch_Type.

#Param rect  bounds of rounded rectangle ##
#Param radii  corner x-axis and y-axis radii ##

#Example
#Height 128
    SkPaint paint;
    paint.setStrokeWidth(15);
    paint.setStrokeCap(SkPaint::kSquare_Cap);
    paint.setAntiAlias(true);
    float intervals[] = { 5, 21.75f };
    paint.setStyle(SkPaint::kStroke_Style);
    paint.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 0));
    SkPath path;
    SkRRect rrect;
    SkVector corners[] = {{15, 17}, {17, 19}, {19, 15}, {15, 15}};
    rrect.setRectRadii({20, 20, 100, 100}, corners);
    path.addRRect(rrect, SkPath::kCW_Direction);
    canvas->drawPath(path, paint);
    path.rewind();
    path.addRRect(rrect, SkPath::kCCW_Direction, 1);
    canvas->translate(120, 0);
    canvas->drawPath(path, paint);
##

#SeeAlso setNinePatch SkPath::addRoundRect

#Method ##

# ------------------------------------------------------------------------------

#Enum Corner
#Line # corner radii order ##

#Code
    enum Corner {
        kUpperLeft_Corner,
        kUpperRight_Corner,
        kLowerRight_Corner,
        kLowerLeft_Corner,
    };
##

The radii are stored: top-left, top-right, bottom-right, bottom-left.

#Const kUpperLeft_Corner 0
#Line # index of top-left corner radii ##
##
#Const kUpperRight_Corner 1
#Line # index of top-right corner radii ##
##
#Const kLowerRight_Corner 2
#Line # index of bottom-right corner radii ##
##
#Const kLowerLeft_Corner 3
#Line # index of bottom-left corner radii ##
##

#Example
#Height 70
    SkPaint paint;
    paint.setAntiAlias(true);
    SkRRect rrect;
    SkVector corners[] = {{25, 17}, {17, 19}, {19, 15}, {15, 15}};
    rrect.setRectRadii({30, 10, 100, 60}, corners);
    canvas->drawRRect(rrect, paint);
    paint.setColor(SK_ColorWHITE);
    const SkRect r = rrect.getBounds();
    canvas->drawLine(r.fLeft, r.fTop + rrect.radii(SkRRect::kUpperLeft_Corner).fY,
                     r.fRight, r.fTop + rrect.radii(SkRRect::kUpperRight_Corner).fY, paint);
    canvas->drawLine(r.fLeft, r.fBottom - rrect.radii(SkRRect::kLowerLeft_Corner).fY,
                     r.fRight, r.fBottom - rrect.radii(SkRRect::kLowerRight_Corner).fY, paint);
    canvas->drawLine(r.fLeft + rrect.radii(SkRRect::kUpperLeft_Corner).fX, r.fTop,
                     r.fLeft + rrect.radii(SkRRect::kLowerLeft_Corner).fX, r.fBottom, paint);
    canvas->drawLine(r.fRight - rrect.radii(SkRRect::kUpperRight_Corner).fX, r.fTop,
                     r.fRight - rrect.radii(SkRRect::kLowerRight_Corner).fX, r.fBottom, paint);
##

#SeeAlso radii

#Enum ##

# ------------------------------------------------------------------------------

#Method const SkRect& rect() const
#In Property
#Line # returns bounds ##
Returns bounds. Bounds may have zero width or zero height. Bounds right is
greater than or equal to left; bounds bottom is greater than or equal to top.
Result is identical to getBounds.

#Return bounding box ##

#Example
    for (SkScalar left : { SK_ScalarNaN, SK_ScalarInfinity, 100.f, 50.f, 25.f} ) {
        SkRRect rrect1 = SkRRect::MakeRectXY({left, 20, 60, 220}, 50, 200);
        SkDebugf("left bounds: (%g) %g\n", left, rrect1.rect().fLeft);
    }
#StdOut
left bounds: (nan) 0
left bounds: (inf) 0
left bounds: (100) 60
left bounds: (50) 50
left bounds: (25) 25
##
##

#SeeAlso getBounds

#Method ##

# ------------------------------------------------------------------------------

#Method SkVector radii(Corner corner) const
#In Property
#Line # returns x-axis and y-axis radii for one corner ##
Returns Scalar pair for radius of curve on x-axis and y-axis for one corner.
Both radii may be zero. If not zero, both are positive and finite.


#Param corner  one of: kUpperLeft_Corner, kUpperRight_Corner,
                       kLowerRight_Corner, kLowerLeft_Corner 
##

#Return x-axis and y-axis radii for one corner ##

#Example
#Description
Finite values are scaled proportionately to fit; other values are set to zero.
Scaled values cannot be larger than 25, half the bounding Round_Rect width.
Small scaled values are halved to scale in proportion to the y-axis corner
radius, which is twice the bounds height.
##
    for (SkScalar radiusX : { SK_ScalarNaN, SK_ScalarInfinity, 100.f, 50.f, 25.f} ) {
        SkRRect rrect1 = SkRRect::MakeRectXY({10, 20, 60, 220}, radiusX, 200);
        SkDebugf("left corner: (%g) %g\n", radiusX, rrect1.radii(SkRRect::kUpperLeft_Corner).fX);
    }
#StdOut
left corner: (nan) 0
left corner: (inf) 0
left corner: (100) 25
left corner: (50) 25
left corner: (25) 12.5
##
##

#SeeAlso Corner

#Method ##

# ------------------------------------------------------------------------------

#Method const SkRect& getBounds() const
#In Property
#Line # returns bounds ##
Returns bounds. Bounds may have zero width or zero height. Bounds right is
greater than or equal to left; bounds bottom is greater than or equal to top.
Result is identical to rect().

#Return bounding box ##

#Example
#Height 120
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRectXY({20, 20, 220, 100}, 15, 15);
    canvas->drawRRect(rrect, paint);
    paint.setColor(SK_ColorWHITE);
    rrect = SkRRect::MakeOval(rrect.getBounds());
    canvas->drawRRect(rrect, paint);
##

#SeeAlso rect

#Method ##

# ------------------------------------------------------------------------------

#Method bool operator==(const SkRRect& a, const SkRRect& b)
#In Operator
#Line # returns true if members are equal ##
Returns true if bounds and radii in a are equal to bounds and radii in b.

a and b are not equal if either contain NaN. a and b are equal if members
contain zeroes width different signs.

#Param a  Rect bounds and radii to compare ##
#Param b  Rect bounds and radii to compare ##

#Return true if members are equal ##

#Example
    SkRRect rrect1 = SkRRect::MakeRectXY({10, 20, 60, 220}, 50, 200);
    SkRRect rrect2 = SkRRect::MakeRectXY(rrect1.rect(), 25, 100);
    SkRRect rrect3 = SkRRect::MakeOval(rrect1.rect());
    canvas->drawRRect(rrect1, SkPaint());
    std::string str = "rrect1 " + std::string(rrect1 == rrect2 ? "=" : "!") + "= rrect2";
    canvas->drawString(str.c_str(), 10, 240, SkPaint());
    canvas->translate(70, 0);
    canvas->drawRRect(rrect2, SkPaint());
    canvas->translate(70, 0);
    canvas->drawRRect(rrect3, SkPaint());
    str = "rrect2 " + std::string(rrect2 == rrect3 ? "=" : "!") + "= rrect3";
    canvas->drawString(str.c_str(), -20, 240, SkPaint());
##

#SeeAlso operator!=(const SkRRect& a, const SkRRect& b)

#Method ##

# ------------------------------------------------------------------------------

#Method bool operator!=(const SkRRect& a, const SkRRect& b)
#In Operator
#Line # returns true if members are unequal ##
Returns true if bounds and radii in a are not equal to bounds and radii in b.

a and b are not equal if either contain NaN. a and b are equal if members
contain zeroes width different signs.

#Param a  Rect bounds and radii to compare ##
#Param b  Rect bounds and radii to compare ##

#Return true if members are not equal ##

#Example
    SkRRect rrect1 = SkRRect::MakeRectXY({10, 20, 60, 220}, 50, 100);
    SkRRect rrect2 = SkRRect::MakeRectXY(rrect1.rect(), 50, 50);
    SkRRect rrect3 = SkRRect::MakeOval(rrect1.rect());
    canvas->drawRRect(rrect1, SkPaint());
    std::string str = "rrect1 " + std::string(rrect1 == rrect2 ? "=" : "!") + "= rrect2";
    canvas->drawString(str.c_str(), 10, 240, SkPaint());
    canvas->translate(70, 0);
    canvas->drawRRect(rrect2, SkPaint());
    canvas->translate(70, 0);
    canvas->drawRRect(rrect3, SkPaint());
    str = "rrect2 " + std::string(rrect2 == rrect3 ? "=" : "!") + "= rrect3";
    canvas->drawString(str.c_str(), -20, 240, SkPaint());
##

#SeeAlso operator==(const SkRRect& a, const SkRRect& b)

#Method ##

# ------------------------------------------------------------------------------

#Method void inset(SkScalar dx, SkScalar dy, SkRRect* dst) const
#In Inset_Outset_Offset
#Line # insets bounds and radii ##

Copies Round_Rect to dst, then insets dst bounds by dx and dy, and adjusts dst
radii by dx and dy. dx and dy may be positive, negative, or zero. dst may be
Round_Rect.

If either corner radius is zero, the corner has no curvature and is unchanged.
Otherwise, if adjusted radius becomes negative, pins radius to zero.
If dx exceeds half dst bounds width, dst bounds left and right are set to 
bounds x-axis center. If dy exceeds half dst bounds height, dst bounds top and
bottom are set to bounds y-axis center.

If dx or dy cause the bounds to become infinite, dst bounds is zeroed.

#Param dx  added to rect().fLeft, and subtracted from rect().fRight ##
#Param dy  added to rect().fTop, and subtracted from rect().fBottom ##
#Param dst  insets bounds and radii ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect.inset(-3, 3, &rrect);
    }
##

#SeeAlso outset offset makeOffset

#Method ##

# ------------------------------------------------------------------------------

#Method void inset(SkScalar dx, SkScalar dy)
#In Inset_Outset_Offset
#Line # insets bounds and radii ##
Insets bounds by dx and dy, and adjusts radii by dx and dy. dx and dy may be
positive, negative, or zero.

If either corner radius is zero, the corner has no curvature and is unchanged.
Otherwise, if adjusted radius becomes negative, pins radius to zero.
If dx exceeds half bounds width, bounds left and right are set to 
bounds x-axis center. If dy exceeds half bounds height, bounds top and
bottom are set to bounds y-axis center.

If dx or dy cause the bounds to become infinite, bounds is zeroed.

#Param dx  added to rect().fLeft, and subtracted from rect().fRight ##
#Param dy  added to rect().fTop, and subtracted from rect().fBottom ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({10, 20, 180, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect.inset(3, 3);
    }
##

#SeeAlso outset offset makeOffset


#Method ##

# ------------------------------------------------------------------------------

#Method void outset(SkScalar dx, SkScalar dy, SkRRect* dst) const
#In Inset_Outset_Offset
#Line # outsets bounds and radii ##

Outsets dst bounds by dx and dy, and adjusts radii by dx and dy. dx and dy may be
positive, negative, or zero.

If either corner radius is zero, the corner has no curvature and is unchanged.
Otherwise, if adjusted radius becomes negative, pins radius to zero.
If dx exceeds half dst bounds width, dst bounds left and right are set to 
bounds x-axis center. If dy exceeds half dst bounds height, dst bounds top and
bottom are set to bounds y-axis center.

If dx or dy cause the bounds to become infinite, dst bounds is zeroed.

#Param dx  subtracted from rect().fLeft, and added to rect().fRight ##
#Param dy  subtracted from rect().fTop, and added to rect().fBottom ##
#Param dst  outset bounds and radii ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect.outset(-3, 3, &rrect);
    }
##

#SeeAlso inset offset makeOffset


#Method ##

# ------------------------------------------------------------------------------

#Method void outset(SkScalar dx, SkScalar dy)
#In Inset_Outset_Offset
#Line # outsets bounds and radii ##

Outsets bounds by dx and dy, and adjusts radii by dx and dy. dx and dy may be
positive, negative, or zero.

If either corner radius is zero, the corner has no curvature and is unchanged.
Otherwise, if adjusted radius becomes negative, pins radius to zero.
If dx exceeds half bounds width, bounds left and right are set to 
bounds x-axis center. If dy exceeds half bounds height, bounds top and
bottom are set to bounds y-axis center.

If dx or dy cause the bounds to become infinite, bounds is zeroed.

#Param dx  subtracted from rect().fLeft, and added to rect().fRight ##
#Param dy  subtracted from rect().fTop, and added to rect().fBottom ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect.outset(3, 3);
    }
##

#SeeAlso inset offset makeOffset

#Method ##

# ------------------------------------------------------------------------------

#Method void offset(SkScalar dx, SkScalar dy)
#In Inset_Outset_Offset
#Line # offsets bounds and radii ##

Translates Round_Rect by (dx, dy).

#Param dx  offset added to rect().fLeft and rect().fRight ##
#Param dy  offset added to rect().fTop and rect().fBottom ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect.offset(3, 3);
    }
##

#SeeAlso makeOffset inset outset

#Method ##

# ------------------------------------------------------------------------------

#Method SkRRect SK_WARN_UNUSED_RESULT makeOffset(SkScalar dx, SkScalar dy) const
#In Inset_Outset_Offset
#Line # offsets bounds and radii ##

Returns Round_Rect translated by (dx, dy).

#Param dx  offset added to rect().fLeft and rect().fRight ##
#Param dy  offset added to rect().fTop and rect().fBottom ##

#Return Round_Rect bounds offset by (dx, dy), with unchanged corner radii ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect = rrect.makeOffset(-3, 3);
    }
##

#SeeAlso offset inset outset

#Method ##

# ------------------------------------------------------------------------------

#Method bool contains(const SkRect& rect) const
#In Intersection
#Line # returns true if Rect is inside ##

Returns true if rect is inside the bounds and corner radii, and if
Round_Rect and rect are not empty.

#Param rect  area tested for containment ##

#Return true if Round_Rect contains rect ##

#Example
#Height 110
    SkRect test = {10, 10, 110, 80};
    SkRRect rrect = SkRRect::MakeRect(test);
    SkRRect oval = SkRRect::MakeOval(test);
    test.inset(10, 10);
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    canvas->drawString(rrect.contains(test) ? "contains" : "does not contain", 55, 100, paint);
    canvas->drawString(oval.contains(test) ? "contains" : "does not contain", 185, 100, paint);    
    paint.setStyle(SkPaint::kStroke_Style);
    canvas->drawRRect(rrect, paint);
    canvas->drawRect(test, paint);
    canvas->translate(120, 0);
    canvas->drawRRect(oval, paint);
    canvas->drawRect(test, paint);
##

#SeeAlso SkRect::contains

#Method ##

# ------------------------------------------------------------------------------

#Method bool isValid() const
#In Utility
#Line # returns if type() matches bounds and radii  ##
Returns true if bounds and radii values are finite and describe a Round_Rect
Type that matches getType. All Round_Rect methods construct valid types,
even if the input values are not valid. Invalid Round_Rect data can only
be generated by corrupting memory.

#Return true if bounds and radii match type() ##

#Example
#Height 110
    SkRRect rrect = SkRRect::MakeRect({10, 10, 110, 80});
    SkRRect corrupt = rrect;
    *((float*) &corrupt) = 120;
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    canvas->drawString(rrect.isValid() ? "is valid" : "is corrupted", 55, 100, paint);
    canvas->drawString(corrupt.isValid() ? "is valid" : "is corrupted", 185, 100, paint);    
    paint.setStyle(SkPaint::kStroke_Style);
    canvas->drawRRect(rrect, paint);
    canvas->translate(120, 0);
    canvas->drawRRect(corrupt, paint);
##

#SeeAlso Type getType

#Method ##

# ------------------------------------------------------------------------------

#Const kSizeInMemory 48
#Line # storage space for Round_Rect ##

Space required to serialize SkRRect into a buffer. Always a multiple of four.

#Const ##

# ------------------------------------------------------------------------------

#Method size_t writeToMemory(void* buffer) const
#In Utility
#Line # writes Round_Rect to buffer ##

Writes Round_Rect to buffer. Writes kSizeInMemory bytes, and returns
kSizeInMemory, the number of bytes written.

#Param buffer  storage for Round_Rect ##

#Return bytes written, kSizeInMemory ##

#Example
#Height 110
    SkRRect rrect = SkRRect::MakeRect({10, 10, 110, 80});
    char storage[SkRRect::kSizeInMemory];
    rrect.writeToMemory(storage);
    SkRRect copy;
    copy.readFromMemory(storage, sizeof(storage));
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    canvas->drawString("rrect", 55, 100, paint);
    canvas->drawString("copy", 185, 100, paint);    
    paint.setStyle(SkPaint::kStroke_Style);
    canvas->drawRRect(rrect, paint);
    canvas->translate(120, 0);
    canvas->drawRRect(copy, paint);
##

#SeeAlso readFromMemory

#Method ##

# ------------------------------------------------------------------------------

#Method size_t readFromMemory(const void* buffer, size_t length)
#In Utility
#Line # reads Round_Rect from buffer ##

Reads Round_Rect from buffer, reading kSizeInMemory bytes.
Returns kSizeInMemory, bytes read if length is at least kSizeInMemory.
Otherwise, returns zero.

#Param buffer  memory to read from ##
#Param length  size of buffer ##

#Return  bytes read, or 0 if length is less than kSizeInMemory
##

#Example
#Height 110
    SkVector radii[] = {{5, 5},  {10, 10}, {15, 15}, {5, 5}};
    SkRRect rrect;
    rrect.setRectRadii({10, 10, 110, 80}, radii);
    char storage[SkRRect::kSizeInMemory];
    rrect.writeToMemory(storage);
    SkRRect copy;
    copy.readFromMemory(storage, sizeof(storage));
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    canvas->drawString("rrect", 55, 100, paint);
    canvas->drawString("copy", 185, 100, paint);    
    paint.setStyle(SkPaint::kStroke_Style);
    canvas->drawRRect(rrect, paint);
    canvas->translate(120, 0);
    canvas->drawRRect(copy, paint);
##

#SeeAlso writeToMemory

#Method ##

# ------------------------------------------------------------------------------

#Method bool transform(const SkMatrix& matrix, SkRRect* dst) const
#In Inset_Outset_Offset
#Line # scales and offsets into copy ##

Transforms by Round_Rect by matrix, storing result in dst.
Returns true if Round_Rect transformed can be represented by another Round_Rect.
Returns false if matrix contains transformations other than scale and translate.

Asserts in debug builds if Round_Rect equals dst.

#Param matrix  SkMatrix specifying the transform ##
#Param dst  SkRRect to store the result ##

#Return  true if transformation succeeded.
##

#Example
#Height 110
    SkVector radii[] = {{5, 5},  {10, 10}, {15, 15}, {5, 5}};
    SkRRect rrect;
    rrect.setRectRadii({10, 10, 110, 80}, radii);
    SkRRect transformed;
    SkMatrix matrix = SkMatrix::MakeRectToRect(rrect.rect(), {140, 30, 220, 80},
                                               SkMatrix::kCenter_ScaleToFit);
    bool success = rrect.transform(matrix, &transformed);
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    canvas->drawString("rrect", 55, 100, paint);
    canvas->drawString(success ? "transformed" : "transform failed", 185, 100, paint);    
    paint.setStyle(SkPaint::kStroke_Style);
    canvas->drawRRect(rrect, paint);
    canvas->drawRRect(transformed, paint);
##

#SeeAlso SkPath::transform

#Method ##

# ------------------------------------------------------------------------------

#Method void dump(bool asHex) const
#In Utility
#Line # sends text representation to standard output ##
Writes text representation of Round_Rect to standard output.
Set asHex true to generate exact binary representations
of floating point numbers.

#Param asHex  true if SkScalar values are written as hexadecimal ##

#Example
SkRRect rrect = SkRRect::MakeRect({6.f / 7, 2.f / 3, 6.f / 7, 2.f / 3});
for (bool dumpAsHex : { false, true } ) {
    rrect.dump(dumpAsHex);
}
#StdOut
SkRect::MakeLTRB(0.857143f, 0.666667f, 0.857143f, 0.666667f);
const SkPoint corners[] = {
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
};
SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab), /* 0.666667 */
                 SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab)  /* 0.666667 */);
const SkPoint corners[] = {
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
};
##
##

#SeeAlso dumpHex SkRect::dump SkPath::dump SkPathMeasure::dump

#Method ##

# ------------------------------------------------------------------------------

#Method void dump() const
#In Utility
#Line # sends text representation using floats to standard output ##
Writes text representation of Round_Rect to standard output. The representation
may be directly compiled as C++ code. Floating point values are written
with limited precision; it may not be possible to reconstruct original
Round_Rect from output.

#Example
SkRRect rrect = SkRRect::MakeRect({6.f / 7, 2.f / 3, 6.f / 7, 2.f / 3});
rrect.dump();
SkRect bounds = SkRect::MakeLTRB(0.857143f, 0.666667f, 0.857143f, 0.666667f);
const SkPoint corners[] = {
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
};
SkRRect copy;
copy.setRectRadii(bounds, corners);
SkDebugf("rrect is " "%s" "equal to copy\n", rrect == copy ? "" : "not ");
#StdOut
SkRect::MakeLTRB(0.857143f, 0.666667f, 0.857143f, 0.666667f);
const SkPoint corners[] = {
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
};
rrect is not equal to copy
##
##

#SeeAlso dumpHex SkRect::dump SkPath::dump SkPathMeasure::dump

#Method ##

# ------------------------------------------------------------------------------

#Method void dumpHex() const
#In Utility
#Line # sends text representation using hexadecimal to standard output ##
Writes text representation of Round_Rect to standard output. The representation
may be directly compiled as C++ code. Floating point values are written
in hexadecimal to preserve their exact bit pattern. The output reconstructs the
original Round_Rect.

#Example
SkRRect rrect = SkRRect::MakeRect({6.f / 7, 2.f / 3, 6.f / 7, 2.f / 3});
rrect.dumpHex();
SkRect bounds = SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab), /* 0.666667 */
                 SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab)  /* 0.666667 */);
const SkPoint corners[] = {
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
};
SkRRect copy;
copy.setRectRadii(bounds, corners);
SkDebugf("rrect is " "%s" "equal to copy\n", rrect == copy ? "" : "not ");
#StdOut
SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab), /* 0.666667 */
                 SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab)  /* 0.666667 */);
const SkPoint corners[] = {
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
};
rrect is equal to copy
##
##

#SeeAlso dump SkRect::dumpHex SkPath::dumpHex

#Method ##

#Class SkRRect ##

#Topic RRect ##
