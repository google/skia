#Topic Rect
#Alias Rects
#Alias Rect_Reference

#Struct SkRect

SkRect holds four SkScalar coordinates describing the upper and
lower bounds of a rectangle. SkRect may be created from outer bounds or 
from position, width, and height. SkRect describes an area; if its right
is less than or equal to its left, or if its bottom is less than or equal to
its top, it is considered empty.

# move to topic about MakeIWH and friends
SkRect can be constructed from int values to avoid compiler warnings that
integer input cannot convert to SkScalar without loss of precision.

#Topic Overview

#Subtopic Subtopics
#ToDo manually add subtopics ##
#Table
#Legend
# topics # description ##
#Legend ##
#Table ##
##

#Subtopic Operators
#Table
#Legend
# description                                       # function ##
#Legend ##
# bool operator!=(const SkRect& a, const SkRect& b) # Returns true if members are unequal. ##
# bool operator==(const SkRect& a, const SkRect& b) # Returns true if members are equal. ##
#Table ##
#Subtopic ##

#Subtopic Member_Functions
#Table
#Legend
# description           # function ##
#Legend ##
# Intersects            # Returns true if areas overlap. ##
# Make                  # Constructs from ISize returning (0, 0, width, height). ##
# MakeEmpty             # Constructs from bounds of (0, 0, 0, 0). ##
# MakeFromIRect         # Deprecated. ##
# MakeIWH               # Constructs from int input returning (0, 0, width, height). ##
# MakeLTRB              # Constructs from SkScalar left, top, right, bottom. ##
# MakeSize              # Constructs from Size returning (0, 0, width, height). ##
# MakeWH                # Constructs from SkScalar input returning (0, 0, width, height). ##
# MakeXYWH              # Constructs from SkScalar input returning (x, y, width, height). ##
# asScalars             # Returns pointer to members as array. ##
# bottom()              # Returns larger bounds in y, if sorted. ##
# centerX               # Returns midpoint in x. ##
# centerY               # Returns midpoint in y. ##
# contains()            # Returns true if points are equal or inside. ##
# dump()                # Sends text representation using floats to standard output. ##
# dumpHex               # Sends text representation using hexadecimal to standard output. ##
# height                # Returns span in y. ##
# inset()               # Moves the sides symmetrically about the center. ##
# intersect()           # Sets to shared area; returns true if not empty. ##
# intersects()          # Returns true if areas overlap. ##
# isEmpty               # Returns true if width or height are zero or negative. ##
# isFinite              # Returns true if no member is infinite or NaN. ##
# isSorted              # Returns true if width or height are zero or positive. ##
# iset()                # Sets to int input (left, top, right, bottom). ##
# isetWH                # Sets to int input (0, 0, width, height). ##
# join()                # Sets to union of bounds. ##
# joinNonEmptyArg       # Sets to union of bounds, asserting that argument is not empty. ##
# joinPossiblyEmptyRect # Sets to union of bounds. Skips empty check for both. ##
# left()                # Returns smaller bounds in x, if sorted. ##
# makeInset             # Constructs from sides moved symmetrically about the center. ##
# makeOffset            # Constructs from translated sides. ##
# makeOutset            # Constructs from sides moved symmetrically about the center. ##
# makeSorted            # Constructs, ordering sides from smaller to larger. ##
# offset()              # Translates sides without changing width and height. ##
# offsetTo              # Translates to (x, y) without changing width and height. ##
# outset()              # Moves the sides symmetrically about the center. ##
# right()               # Returns larger bounds in x, if sorted. ##
# round()               # Sets members to nearest integer value. ##
# roundIn               # Sets members to nearest integer value towards opposite. ##
# roundOut              # Sets members to nearest integer value away from opposite. ##
# set()                 # Sets to SkScalar input (left, top, right, bottom) and others. ##
# setBounds             # Sets to upper and lower limits of Point array. ##
# setBoundsCheck        # Sets to upper and lower limits of Point array. ##
# setEmpty              # Sets to (0, 0, 0, 0). ##
# setLTRB               # Sets to SkScalar input (left, top, right, bottom). ##
# setWH                 # Sets to SkScalar input (0, 0, width, height). ##
# setXYWH               # Sets to SkScalar input (x, y, width, height). ##
# sort()                # Orders sides from smaller to larger. ##
# toQuad                # Returns four corners as Point. ##
# top()                 # Returns smaller bounds in y, if sorted. ##
# width()               # Returns span in x. ##
# x()                   # Returns bounds left. ##
# y()                   # Returns bounds top. ##
#Table ##
#Subtopic ##

#Topic ##

#Member SkScalar  fLeft
May contain any value, including infinities and NaN. The smaller of the
horizontal values when sorted. When equal to or greater than fRight, Rect is empty.
##

#Member SkScalar  fTop
May contain any value, including infinities and NaN. The smaller of the
vertical values when sorted. When equal to or greater than fBottom, Rect is empty.
##

#Member SkScalar  fRight
May contain any value, including infinities and NaN. The larger of the
horizontal values when sorted. When equal to or less than fLeft, Rect is empty.
##

#Member SkScalar  fBottom
May contain any value, including infinities and NaN. The larger of the
vertical values when sorted. When equal to or less than fTop, Rect is empty.
##

# ------------------------------------------------------------------------------

#Method static constexpr SkRect SK_WARN_UNUSED_RESULT MakeEmpty()

Returns constructed Rect set to (0, 0, 0, 0).
Many other rectangles are empty; if left is equal to or greater than right,
or if top is equal to or greater than bottom. Setting all members to zero
is a convenience, but does not designate a special empty rectangle.
 
#Return bounds (0, 0, 0, 0) ##

#Example
    SkRect rect = SkRect::MakeEmpty();
    SkDebugf("MakeEmpty isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
    rect.offset(10, 10);
    SkDebugf("offset rect isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
    rect.inset(10, 10);
    SkDebugf("inset rect isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
    rect.outset(20, 20);
    SkDebugf("outset rect isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
#StdOut
MakeEmpty isEmpty: true
offset rect isEmpty: true
inset rect isEmpty: true
outset rect isEmpty: false
##
##

#SeeAlso isEmpty setEmpty SkIRect::MakeEmpty

##

# ------------------------------------------------------------------------------

#Method static constexpr SkRect SK_WARN_UNUSED_RESULT MakeWH(SkScalar w, SkScalar h)

Returns constructed Rect set to SkScalar values (0, 0, w, h). Does not
validate input; w or h may be negative.

Passing integer values may generate a compiler warning since Rect cannot
represent 32-bit integers exactly. Use SkIRect for an exact integer rectangle.

#Param w  SkScalar width of constructed Rect  ##
#Param h  SkScalar height of constructed Rect ##

#Return bounds (0, 0, w, h) ##

#Example
    SkRect rect1 = SkRect::MakeWH(25, 35);
    SkRect rect2 = SkRect::MakeIWH(25, 35);
    SkRect rect3 = SkRect::MakeXYWH(0, 0, 25, 35);
    SkRect rect4 = SkRect::MakeLTRB(0, 0, 25, 35);
    SkDebugf("all %s" "equal\n", rect1 == rect2 && rect2 == rect3 && rect3 == rect4 ?
             "" : "not ");
#StdOut
all equal
##
##

#SeeAlso MakeSize MakeXYWH MakeIWH setWH SkIRect::MakeWH

##

# ------------------------------------------------------------------------------

#Method static SkRect SK_WARN_UNUSED_RESULT MakeIWH(int w, int h)

Returns constructed Rect set to integer values (0, 0, w, h). Does not validate
input; w or h may be negative.

Use to avoid a compiler warning that input may lose precision when stored.
Use SkIRect for an exact integer rectangle.

#Param w  integer width of constructed Rect  ##
#Param h  integer height of constructed Rect ##

#Return bounds (0, 0, w, h) ##

#Example
    SkIRect i_rect = SkIRect::MakeWH(25, 35);
    SkRect  f_rect = SkRect::MakeIWH(25, 35);
    SkDebugf("i_rect width: %d f_rect width:%g\n", i_rect.width(), f_rect.width());
    i_rect = SkIRect::MakeWH(125000111, 0);
    f_rect = SkRect::MakeIWH(125000111, 0);
    SkDebugf("i_rect width: %d f_rect width:%.0f\n", i_rect.width(), f_rect.width());
#StdOut
i_rect width: 25 f_rect width:25
i_rect width: 125000111 f_rect width:125000112
##
##

#SeeAlso MakeXYWH MakeWH isetWH SkIRect::MakeWH

##

# ------------------------------------------------------------------------------

#Method static constexpr SkRect SK_WARN_UNUSED_RESULT MakeSize(const SkSize& size)

Returns constructed Rect set to (0, 0, size.width(), size.height()). Does not
validate input; size.width() or size.height() may be negative.

#Param size  SkScalar values for Rect width and height ##

#Return bounds (0, 0, size.width(), size.height()) ##

#Example
    SkSize size = {25.5f, 35.5f};
    SkRect rect = SkRect::MakeSize(size);
    SkDebugf("rect width: %g  height: %g\n", rect.width(), rect.height());
    SkISize floor = size.toFloor();
    rect = SkRect::MakeSize(SkSize::Make(floor));
    SkDebugf("floor width: %g  height: %g\n", rect.width(), rect.height());
#StdOut
rect width: 25.5  height: 35.5
floor width: 25  height: 35
##
##

#SeeAlso MakeWH MakeXYWH MakeIWH setWH SkIRect::MakeWH

##

# ------------------------------------------------------------------------------

#Method static constexpr SkRect SK_WARN_UNUSED_RESULT MakeLTRB(SkScalar l, SkScalar t, SkScalar r,
                                                           SkScalar b)

Returns constructed Rect set to (l, t, r, b). Does not sort input; Rect may
result in fLeft greater than fRight, or fTop greater than fBottom.

#Param l  SkScalar stored in fLeft ##
#Param t  SkScalar stored in fTop ##
#Param r  SkScalar stored in fRight ##
#Param b  SkScalar stored in fBottom ##

#Return bounds (l, t, r, b) ##

#Example
    SkRect rect = SkRect::MakeLTRB(5, 35, 15, 25);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect.sort();
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 5, 35, 15, 25  isEmpty: true
rect: 5, 25, 15, 35  isEmpty: false
##
##

#SeeAlso MakeXYWH SkIRect::MakeLTRB

##

# ------------------------------------------------------------------------------

#Method static constexpr SkRect SK_WARN_UNUSED_RESULT MakeXYWH(SkScalar x, SkScalar y, SkScalar w, SkScalar h)

Returns constructed Rect set to
#Formula
(x, y, x + w, y + h)
##
. Does not validate input;
w or h may be negative.

#Param x  stored in fLeft ##
#Param y  stored in fTop ##
#Param w  added to x and stored in fRight ##
#Param h  added to y and stored in fBottom ##

#Return bounds at (x, y) with width w and height h ##

#Example
    SkRect rect = SkRect::MakeXYWH(5, 35, -15, 25);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect.sort();
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 5, 35, -10, 60  isEmpty: true
rect: -10, 35, 5, 60  isEmpty: false
##
##

#SeeAlso MakeLTRB SkIRect::MakeXYWH

##

# ------------------------------------------------------------------------------

#Method static SkRect SK_WARN_UNUSED_RESULT MakeFromIRect(const SkIRect& irect)

Deprecated.

#Deprecated
##

#Param irect  integer rect ##

#Return irect as SkRect ##

#NoExample
##

#SeeAlso Make

##

# ------------------------------------------------------------------------------

#Method static SkRect Make(const SkISize& size)

Returns constructed IRect set to (0, 0, size.width(), size.height()). 
Does not validate input; size.width() or size.height() may be negative.

#Param size  integer values for Rect width and height ##

#Return bounds (0, 0, size.width(), size.height()) ##

#Example
    SkRect rect1 = SkRect::MakeSize({2, 35});
    SkRect rect2 = SkRect::MakeIWH(2, 35);
    SkDebugf("rect1 %c= rect2\n", rect1 == rect2 ? '=' : '!');
#StdOut
rect1 == rect2
##
##

#SeeAlso MakeWH MakeXYWH SkRect::MakeIWH SkIRect::MakeSize

##

# ------------------------------------------------------------------------------

#Method static SkRect SK_WARN_UNUSED_RESULT Make(const SkIRect& irect)

Returns constructed IRect set to irect, promoting integers to Scalar.
Does not validate input; fLeft may be greater than fRight, fTop may be greater
than fBottom.

#Param irect  integer unsorted bounds ##

#Return irect members converted to SkScalar ##

#Example
    SkIRect i_rect1 = {2, 35, 22, 53};
    SkRect f_rect = SkRect::Make(i_rect1);
    f_rect.offset(0.49f, 0.49f);
    SkIRect i_rect2;
    f_rect.round(&i_rect2);
    SkDebugf("i_rect1 %c= i_rect2\n", i_rect1 == i_rect2? '=' : '!');
##

#SeeAlso MakeLTRB

##

# ------------------------------------------------------------------------------

#Method bool isEmpty() const

Returns true if fLeft is equal to or greater than fRight, or if fTop is equal
to or greater than fBottom. Call sort() to reverse rectangles with negative
width() or height().

#Return true if width() or height() are zero or negative ##

#Example
    SkRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};
    for (auto rect : tests) {
        SkDebugf("rect: {%g, %g, %g, %g} is" "%s empty\n", rect.left(), rect.top(), rect.right(),
                 rect.bottom(), rect.isEmpty() ? "" : " not");
        rect.sort();
        SkDebugf("sorted: {%g, %g, %g, %g} is" "%s empty\n", rect.left(), rect.top(), rect.right(),
                 rect.bottom(), rect.isEmpty() ? "" : " not");
    }
#StdOut
rect: {20, 40, 10, 50} is empty
sorted: {10, 40, 20, 50} is not empty
rect: {20, 40, 20, 50} is empty
sorted: {20, 40, 20, 50} is empty
##
##

#SeeAlso MakeEmpty sort SkIRect::isEmpty

##

# ------------------------------------------------------------------------------

#Method bool isSorted() const

Returns true if fLeft is equal to or less than fRight, or if fTop is equal
to or less than fBottom. Call sort() to reverse rectangles with negative
width() or height().

#Return true if width() or height() are zero or positive ##

#Example
    SkRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};
    for (auto rect : tests) {
        SkDebugf("rect: {%g, %g, %g, %g} is" "%s sorted\n", rect.left(), rect.top(), rect.right(),
                 rect.bottom(), rect.isSorted() ? "" : " not");
        rect.sort();
        SkDebugf("sorted: {%g, %g, %g, %g} is" "%s sorted\n", rect.left(), rect.top(), rect.right(),
                 rect.bottom(), rect.isSorted() ? "" : " not");
    }
#StdOut
rect: {20, 40, 10, 50} is not sorted
sorted: {10, 40, 20, 50} is sorted
rect: {20, 40, 20, 50} is sorted
sorted: {20, 40, 20, 50} is sorted
##
##

#SeeAlso sort makeSorted isEmpty

##

# ------------------------------------------------------------------------------

#Method bool isFinite() const

Returns true if all values in the rectangle are finite: SK_ScalarMin or larger,
and SK_ScalarMax or smaller. 

#Return true if no member is infinite or NaN ##

#Example
SkRect largest = { SK_ScalarMin, SK_ScalarMin, SK_ScalarMax, SK_ScalarMax };
    SkDebugf("largest is finite: %s\n", largest.isFinite() ? "true" : "false");
    SkDebugf("large width %g\n", largest.width());
    SkRect widest = SkRect::MakeWH(largest.width(), largest.height());
    SkDebugf("widest is finite: %s\n", widest.isFinite() ? "true" : "false");
#StdOut
largest is finite: true
large width inf
widest is finite: false
##
##

#SeeAlso SkScalarIsFinite SkScalarIsNaN

##

# ------------------------------------------------------------------------------

#Method SkScalar    x() const

Returns left edge of Rect, if sorted. Call isSorted to see if Rect is valid.
Call sort() to reverse fLeft and fRight if needed.

#Return fLeft ##

#Example
    SkRect unsorted = { 15, 5, 10, 25 };
    SkDebugf("unsorted.fLeft: %g unsorted.x(): %g\n", unsorted.fLeft, unsorted.x());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fLeft: %g sorted.x(): %g\n", sorted.fLeft, sorted.x());
#StdOut
unsorted.fLeft: 15 unsorted.x(): 15
sorted.fLeft: 10 sorted.x(): 10
##
##

#SeeAlso fLeft left() y() SkIRect::x()

##

# ------------------------------------------------------------------------------

#Method SkScalar    y() const

Returns top edge of Rect, if sorted. Call isEmpty to see if Rect may be invalid,
and sort() to reverse fTop and fBottom if needed.

#Return fTop ##

#Example
    SkRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fTop: %g unsorted.y(): %g\n", unsorted.fTop, unsorted.y());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fTop: %g sorted.y(): %g\n", sorted.fTop, sorted.y());
#StdOut
unsorted.fTop: 25 unsorted.y(): 25
sorted.fTop: 5 sorted.y(): 5
##
##

#SeeAlso fTop top() x() SkIRect::y()

##

# ------------------------------------------------------------------------------

#Method SkScalar    left() const

Returns left edge of Rect, if sorted. Call isSorted to see if Rect is valid.
Call sort() to reverse fLeft and fRight if needed.

#Return fLeft ##

#Example
    SkRect unsorted = { 15, 5, 10, 25 };
    SkDebugf("unsorted.fLeft: %g unsorted.left(): %g\n", unsorted.fLeft, unsorted.left());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fLeft: %g sorted.left(): %g\n", sorted.fLeft, sorted.left());
#StdOut
unsorted.fLeft: 15 unsorted.left(): 15
sorted.fLeft: 10 sorted.left(): 10
##
##

#SeeAlso fLeft x() SkIRect::left()

##

# ------------------------------------------------------------------------------

#Method SkScalar    top() const

Returns top edge of Rect, if sorted. Call isEmpty to see if Rect may be invalid,
and sort() to reverse fTop and fBottom if needed.

#Return fTop ##

#Example
    SkRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fTop: %g unsorted.top(): %g\n", unsorted.fTop, unsorted.top());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fTop: %g sorted.top(): %g\n", sorted.fTop, sorted.top());
#StdOut
unsorted.fTop: 25 unsorted.top(): 25
sorted.fTop: 5 sorted.top(): 5
##
##

#SeeAlso fTop y() SkIRect::top()

##

# ------------------------------------------------------------------------------

#Method SkScalar    right() const

Returns right edge of Rect, if sorted. Call isSorted to see if Rect is valid.
Call sort() to reverse fLeft and fRight if needed.

#Return fRight ##

#Example
    SkRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fRight: %g unsorted.right(): %g\n", unsorted.fRight, unsorted.right());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fRight: %g sorted.right(): %g\n", sorted.fRight, sorted.right());
#StdOut
unsorted.fRight: 10 unsorted.right(): 10
sorted.fRight: 15 sorted.right(): 15
##
##

#SeeAlso fRight SkIRect::right()

##

# ------------------------------------------------------------------------------

#Method SkScalar    bottom() const

Returns bottom edge of Rect, if sorted. Call isEmpty to see if Rect may be invalid,
and sort() to reverse fTop and fBottom if needed.

#Return fBottom ##

#Example
    SkRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fBottom: %g unsorted.bottom(): %g\n", unsorted.fBottom, unsorted.bottom());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fBottom: %g sorted.bottom(): %g\n", sorted.fBottom, sorted.bottom());
#StdOut
unsorted.fBottom: 5 unsorted.bottom(): 5
sorted.fBottom: 25 sorted.bottom(): 25
##
##

#SeeAlso fBottom SkIRect::bottom()

##

# ------------------------------------------------------------------------------

#Method SkScalar    width() const

Returns span on the x-axis. This does not check if Rect is sorted, or if
result fits in 32-bit float; result may be negative or infinity.

#Return fRight minus fLeft ##

#Example
#Description
Compare with SkIRect::width() example.
##
    SkRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted width: %g\n", unsorted.width());
    SkRect large = { -2147483647.f, 1, 2147483644.f, 2 };
    SkDebugf("large width: %.0f\n", large.width());
#StdOut
unsorted width: -5
large width: 4294967296
##
##

#SeeAlso height() SkIRect::width()

##

# ------------------------------------------------------------------------------

#Method SkScalar    height() const

Returns span on the y-axis. This does not check if IRect is sorted, or if
result fits in 32-bit float; result may be negative or infinity.

#Return fBottom minus fTop ##

#Example
#Description
Compare with SkIRect::height() example.
##
    SkRect unsorted = { 15, 25, 10, 20 };
    SkDebugf("unsorted height: %g\n", unsorted.height());
    SkRect large = { 1, -2147483647.f, 2, 2147483644.f };
    SkDebugf("large height: %.0f\n", large.height());
#StdOut
unsorted height: -5
large height: 4294967296
##
##

#SeeAlso width() SkIRect::height()

##

# ------------------------------------------------------------------------------

#Method SkScalar    centerX() const

Returns average of left edge and right edge. Result does not change if Rect
is sorted. Result may overflow to infinity if Rect is far from the origin.

#Return midpoint in x ##

#Example
    SkRect tests[] = {{20, 30, 41, 51}, {-20, -30, -41, -51}};
    for (auto rect : tests) {
        SkDebugf("left: %3g right: %3g centerX: %3g\n", rect.left(), rect.right(), rect.centerX());
        rect.sort();
        SkDebugf("left: %3g right: %3g centerX: %3g\n", rect.left(), rect.right(), rect.centerX());
    }
#StdOut
left:  20 right:  41 centerX: 30.5
left:  20 right:  41 centerX: 30.5
left: -20 right: -41 centerX: -30.5
left: -41 right: -20 centerX: -30.5
##
##

#SeeAlso centerY SkIRect::centerX

##

# ------------------------------------------------------------------------------

#Method SkScalar    centerY() const

Returns average of top edge and bottom edge. Result does not change if Rect
is sorted. Result may overflow to infinity if Rect is far from the origin.

#Return midpoint in y ##

#Example
   SkRect rect = { 2e+38, 2e+38, 3e+38, 3e+38 };
   SkDebugf("left: %g right: %g centerX: %g ", rect.left(), rect.right(), rect.centerX());
   SkDebugf("safe mid x: %g\n", rect.left() / 2 + rect.right() / 2);
#StdOut
left: 2e+38 right: 3e+38 centerX: inf safe mid x: 2.5e+38
##
##

#SeeAlso centerX SkIRect::centerY

##

# ------------------------------------------------------------------------------

#Method bool operator==(const SkRect& a, const SkRect& b)

Returns true if all members in a: fLeft, fTop, fRight, and fBottom; are  
equal to the corresponding members in b.

a and b are not equal if either contain NaN. a and b are equal if members
contain zeroes width different signs.

#Param a  Rect to compare ##
#Param b  Rect to compare ##

#Return true if members are equal ##

#Example
    auto debugster = [](const SkRect& test) -> void {
        SkRect negZero = {-0.0f, -0.0f, 2, 2};
        SkDebugf("{%g, %g, %g, %g} %c= {%g, %g, %g, %g} %s numerically equal\n",
                 test.fLeft, test.fTop, test.fRight, test.fBottom,
                 negZero.fLeft, negZero.fTop, negZero.fRight, negZero.fBottom,
                 test == negZero ? '=' : '!',
                 test.fLeft == negZero.fLeft && test.fTop == negZero.fTop &&
                 test.fRight == negZero.fRight && test.fBottom == negZero.fBottom ?
                 "and are" : "yet are not");
    };
    SkRect tests[] = {{0, 0, 2, 2}, {-0, -0, 2, 2}, {0.0f, 0.0f, 2, 2}};
    SkDebugf("tests are %s" "equal\n", tests[0] == tests[1] && tests[1] == tests[2] ? "" : "not ");
    for (auto rect : tests) {
        debugster(rect);
    }
#StdOut
tests are equal
{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal
{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal
{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal    
##
##

#SeeAlso operator!=(const SkRect& a, const SkRect& b)

##

# ------------------------------------------------------------------------------

#Method bool operator!=(const SkRect& a, const SkRect& b)

Returns true if any in a: fLeft, fTop, fRight, and fBottom; does not   
equal the corresponding members in b.

a and b are not equal if either contain NaN. a and b are equal if members
contain zeroes width different signs.

#Param a  Rect to compare ##
#Param b  Rect to compare ##

#Return true if members are not equal ##

#Example
    SkRect test = {0, 0, 2, SK_ScalarNaN};
    SkDebugf("test with NaN is %s" "equal to itself\n", test == test ? "" : "not ");
#StdOut
test with NaN is not equal to itself    
##
##

#SeeAlso operator==(const SkRect& a, const SkRect& b)

##

# ------------------------------------------------------------------------------

#Method void toQuad(SkPoint quad[4]) const

Returns four points in quad that enclose Rect ordered as: top-left, top-right,
bottom-right, bottom-left. 

#Private
Consider adding param to control whether quad is CW or CCW.
##

#Param quad  storage for corners of Rect ##

#Example
    SkRect rect = {1, 2, 3, 4};
    SkPoint corners[4];
    rect.toQuad(corners);
    SkDebugf("rect: {%g, %g, %g, %g}\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    SkDebugf("corners:");
    for (auto corner : corners) {
        SkDebugf(" {%g, %g}", corner.fX, corner.fY);
    }
    SkDebugf("\n");
#StdOut
rect: {1, 2, 3, 4}
corners: {1, 2} {3, 2} {3, 4} {1, 4}    
##
##

#SeeAlso SkPath::addRect

##

# ------------------------------------------------------------------------------

#Method void setEmpty()

Sets Rect to (0, 0, 0, 0).

Many other rectangles are empty; if left is equal to or greater than right,
or if top is equal to or greater than bottom. Setting all members to zero
is a convenience, but does not designate a special empty rectangle.

#Example
    SkRect rect = {3, 4, 1, 2};
    for (int i = 0; i < 2; ++i) {
    SkDebugf("rect: {%g, %g, %g, %g} is %s" "empty\n", rect.fLeft, rect.fTop,
             rect.fRight, rect.fBottom, rect.isEmpty() ? "" : "not ");
    rect.setEmpty();
    }
#StdOut
rect: {3, 4, 1, 2} is empty
rect: {0, 0, 0, 0} is empty
##
##

#SeeAlso MakeEmpty SkIRect::setEmpty

##

# ------------------------------------------------------------------------------

#Method void set(const SkIRect& src)

Sets Rect to src, promoting src members from integer to Scalar.
Very large values in src may lose precision. 

#Param src  integer Rect ##

#Example
    SkIRect i_rect = {3, 4, 1, 2};
    SkDebugf("i_rect: {%d, %d, %d, %d}\n", i_rect.fLeft, i_rect.fTop, i_rect.fRight, i_rect.fBottom);
    SkRect f_rect;
    f_rect.set(i_rect);
    SkDebugf("f_rect: {%g, %g, %g, %g}\n", f_rect.fLeft, f_rect.fTop, f_rect.fRight, f_rect.fBottom);
#StdOut
i_rect: {3, 4, 1, 2}
f_rect: {3, 4, 1, 2}
##
##

#SeeAlso  setLTRB SkIntToScalar

##

# ------------------------------------------------------------------------------

#Method void set(SkScalar left, SkScalar top, SkScalar right, SkScalar bottom)

Sets Rect to (left, top, right, bottom).
left and right are not sorted; left is not necessarily less than right.
top and bottom are not sorted; top is not necessarily less than bottom.

#Param left  stored in fLeft ##
#Param top  stored in fTop ##
#Param right  stored in fRight ##
#Param bottom  stored in fBottom ##

#Example
    SkRect rect1 = {3, 4, 1, 2};
    SkDebugf("rect1: {%g, %g, %g, %g}\n", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);
    SkRect rect2;
    rect2.set(3, 4, 1, 2);
    SkDebugf("rect2: {%g, %g, %g, %g}\n", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);
#StdOut
rect1: {3, 4, 1, 2}
rect2: {3, 4, 1, 2}
##
##

#SeeAlso setLTRB setXYWH SkIRect::set

##

# ------------------------------------------------------------------------------

#Method void setLTRB(SkScalar left, SkScalar top, SkScalar right, SkScalar bottom)

Sets Rect to (left, top, right, bottom).
left and right are not sorted; left is not necessarily less than right.
top and bottom are not sorted; top is not necessarily less than bottom.

#Param left  stored in fLeft ##
#Param top  stored in fTop ##
#Param right  stored in fRight ##
#Param bottom  stored in fBottom ##

#Example
    SkRect rect1 = {3, 4, 1, 2};
    SkDebugf("rect1: {%g, %g, %g, %g}\n", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);
    SkRect rect2;
    rect2.setLTRB(3, 4, 1, 2);
    SkDebugf("rect2: {%g, %g, %g, %g}\n", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);
#StdOut
rect1: {3, 4, 1, 2}
rect2: {3, 4, 1, 2}
##
##

#SeeAlso set setXYWH SkIRect::set

##

# ------------------------------------------------------------------------------

#Method void iset(int left, int top, int right, int bottom)

Sets Rect to (left, top, right, bottom).
All parameters are promoted from integer to Scalar.
left and right are not sorted; left is not necessarily less than right.
top and bottom are not sorted; top is not necessarily less than bottom.

#Param left  promoted to SkScalar and stored in fLeft ##
#Param top  promoted to SkScalar and stored in fTop ##
#Param right  promoted to SkScalar and stored in fRight ##
#Param bottom  promoted to SkScalar and stored in fBottom ##

#Example
    SkRect rect1 = {3, 4, 1, 2};
    SkDebugf("rect1: {%g, %g, %g, %g}\n", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);
    SkRect rect2;
    rect2.iset(3, 4, 1, 2);
    SkDebugf("rect2: {%g, %g, %g, %g}\n", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);
#StdOut
rect1: {3, 4, 1, 2}
rect2: {3, 4, 1, 2}
##
##

#SeeAlso set setLTRB SkIRect::set SkIntToScalar

##

# ------------------------------------------------------------------------------

#Method void isetWH(int width, int height)

Sets Rect to (0, 0, width, height).
width and height may be zero or negative. width and height are promoted from
integer to SkScalar, large values may lose precision.

#Param width  promoted to SkScalar and stored in fRight ##
#Param height  promoted to SkScalar and stored in fBottom ##

#Example
    SkRect rect1 = {0, 0, 1, 2};
    SkDebugf("rect1: {%g, %g, %g, %g}\n", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);
    SkRect rect2;
    rect2.isetWH(1, 2);
    SkDebugf("rect2: {%g, %g, %g, %g}\n", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);
#StdOut
rect1: {0, 0, 1, 2}
rect2: {0, 0, 1, 2}
##
##

#SeeAlso MakeWH MakeXYWH iset() SkIRect:MakeWH

##

# ------------------------------------------------------------------------------

#Method void set(const SkPoint pts[], int count)

Sets to bounds of Point array with count entries. If count is zero or smaller,
or if Point array contains an infinity or NaN, sets Rect to (0, 0, 0, 0).

Result is either empty or sorted: fLeft is less than or equal to fRight, and
fTop is less than or equal to fBottom.

#Param pts  Point array ##
#Param count  entries in array ##

#Example
   SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};
   for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {
       SkRect rect;
       rect.set(points, count);
       if (count > 0) {
           SkDebugf("added: %3g, %g ", points[count - 1].fX,  points[count - 1].fY);
       } else {
           SkDebugf("%14s", " ");
       }
       SkDebugf("count: %d rect: %g, %g, %g, %g\n", count,
               rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
   }
#StdOut
              count: 0 rect: 0, 0, 0, 0
added:   3, 4 count: 1 rect: 3, 4, 3, 4
added:   1, 2 count: 2 rect: 1, 2, 3, 4
added:   5, 6 count: 3 rect: 1, 2, 5, 6
added: nan, 8 count: 4 rect: 0, 0, 0, 0
##
##

#SeeAlso setBounds setBoundsCheck SkPath::addPoly

##

# ------------------------------------------------------------------------------

#Method void setBounds(const SkPoint pts[], int count)

Sets to bounds of Point array with count entries. If count is zero or smaller,
or if Point array contains an infinity or NaN, sets to (0, 0, 0, 0).

Result is either empty or sorted: fLeft is less than or equal to fRight, and
fTop is less than or equal to fBottom.

#Param pts  Point array ##
#Param count  entries in array ##

#Example
   SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};
   for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {
       SkRect rect;
       rect.setBounds(points, count);
       if (count > 0) {
           SkDebugf("added: %3g, %g ", points[count - 1].fX,  points[count - 1].fY);
       } else {
           SkDebugf("%14s", " ");
       }
       SkDebugf("count: %d rect: %g, %g, %g, %g\n", count,
               rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
   }
#StdOut
              count: 0 rect: 0, 0, 0, 0
added:   3, 4 count: 1 rect: 3, 4, 3, 4
added:   1, 2 count: 2 rect: 1, 2, 3, 4
added:   5, 6 count: 3 rect: 1, 2, 5, 6
added: nan, 8 count: 4 rect: 0, 0, 0, 0
##
##

#SeeAlso set setBoundsCheck SkPath::addPoly

##

# ------------------------------------------------------------------------------

#Method bool setBoundsCheck(const SkPoint pts[], int count)

Sets to bounds of Point array with count entries. Returns false if count is
zero or smaller, or if Point array contains an infinity or NaN; in these cases
sets Rect to (0, 0, 0, 0).

Result is either empty or sorted: fLeft is less than or equal to fRight, and
fTop is less than or equal to fBottom.

#Param pts  Point array ##
#Param count  entries in array ##

#Return true if all Point values are finite ##

#Example
   SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};
   for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {
       SkRect rect;
       bool success = rect.setBoundsCheck(points, count);
       if (count > 0) {
           SkDebugf("added: %3g, %g ", points[count - 1].fX,  points[count - 1].fY);
       } else {
           SkDebugf("%14s", " ");
       }
       SkDebugf("count: %d rect: %g, %g, %g, %g success: %s\n", count,
               rect.fLeft, rect.fTop, rect.fRight, rect.fBottom, success ? "true" : "false");
   }
#StdOut
              count: 0 rect: 0, 0, 0, 0 success: true
added:   3, 4 count: 1 rect: 3, 4, 3, 4 success: true
added:   1, 2 count: 2 rect: 1, 2, 3, 4 success: true
added:   5, 6 count: 3 rect: 1, 2, 5, 6 success: true
added: nan, 8 count: 4 rect: 0, 0, 0, 0 success: false
##
##

#SeeAlso set setBounds SkPath::addPoly

##

# ------------------------------------------------------------------------------

#Method void set(const SkPoint& p0, const SkPoint& p1)

Sets bounds to the smallest Rect enclosing Points p0 and p1. The result is
sorted and may be empty. Does not check to see if values are finite.

#Param p0  corner to include ##
#Param p1  corner to include ##

#Example
#Description
p0 and p1 may be swapped and have the same effect unless one contains NaN. 
##
   SkPoint point1 = {SK_ScalarNaN, 8};
   SkPoint point2 = {3, 4};
   SkRect rect;
   rect.set(point1, point2);
   SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
   rect.set(point2, point1);
   SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
##

#SeeAlso setBounds setBoundsCheck

##

# ------------------------------------------------------------------------------

#Method void setXYWH(SkScalar x, SkScalar y, SkScalar width, SkScalar height)

Sets Rect to 
#Formula
(x, y, x + width, y + height)
##
. Does not validate input;
width or height may be negative.

#Param x  stored in fLeft ##
#Param y  stored in fTop ##
#Param width  added to x and stored in fRight ##
#Param height  added to y and stored in fBottom ##

#Example
    SkRect rect;
    rect.setXYWH(5, 35, -15, 25);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect.sort();
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 5, 35, -10, 60  isEmpty: true
rect: -10, 35, 5, 60  isEmpty: false
##
##

#SeeAlso MakeXYWH setLTRB set SkIRect::setXYWH

##

# ------------------------------------------------------------------------------

#Method void setWH(SkScalar width, SkScalar height)

Sets Rect to (0, 0, width, height). Does not validate input;
width or height may be negative.

#Param width  stored in fRight ##
#Param height  stored in fBottom ##

#Example
    SkRect rect;
    rect.setWH(-15, 25);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect.sort();
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 0, 0, -15, 25  isEmpty: true
rect: -15, 0, 0, 25  isEmpty: false
##
##

#SeeAlso MakeWH setXYWH isetWH

##

# ------------------------------------------------------------------------------

#Method SkRect makeOffset(SkScalar dx, SkScalar dy) const

Returns Rect offset by (dx, dy).

If dx is negative, Rect returned is moved to the left.
If dx is positive, Rect returned is moved to the right.
If dy is negative, Rect returned is moved upward.
If dy is positive, Rect returned is moved downward. 

#Param dx  added to fLeft and fRight ##
#Param dy  added to fTop and fBottom ##

#Return Rect offset in x or y, with original width and height ##

#Example
    SkRect rect = { 10, 50, 20, 60 };
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect = rect.makeOffset(15, 32);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 10, 50, 20, 60  isEmpty: false
rect: 25, 82, 35, 92  isEmpty: false
##
##

#SeeAlso offset() makeInset makeOutset SkIRect::makeOffset

##

# ------------------------------------------------------------------------------

#Method SkRect makeInset(SkScalar dx, SkScalar dy) const

Returns Rect, inset by (dx, dy).

If dx is negative, Rect returned is wider.
If dx is positive, Rect returned is narrower.
If dy is negative, Rect returned is taller.
If dy is positive, Rect returned is shorter. 

#Param dx  added to fLeft and subtracted from fRight ##
#Param dy  added to fTop and subtracted from fBottom ##

#Return Rect inset symmetrically left and right, top and bottom ##

#Example
    SkRect rect = { 10, 50, 20, 60 };
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect = rect.makeInset(15, 32);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 10, 50, 20, 60  isEmpty: false
rect: 25, 82, 5, 28  isEmpty: true
##
##

#SeeAlso inset() makeOffset makeOutset SkIRect::makeInset

##

# ------------------------------------------------------------------------------

#Method SkRect makeOutset(SkScalar dx, SkScalar dy) const

Returns Rect, outset by (dx, dy).

If dx is negative, Rect returned is narrower.
If dx is positive, Rect returned is wider.
If dy is negative, Rect returned is shorter.
If dy is positive, Rect returned is taller. 

#Param dx  subtracted to fLeft and added from fRight ##
#Param dy  subtracted to fTop and added from fBottom ##

#Return Rect outset symmetrically left and right, top and bottom ##

#Example
    SkRect rect = { 10, 50, 20, 60 };
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect = rect.makeOutset(15, 32);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 10, 50, 20, 60  isEmpty: false
rect: -5, 18, 35, 92  isEmpty: false
##
##

#SeeAlso outset() makeOffset makeInset SkIRect::makeOutset

##

# ------------------------------------------------------------------------------

#Method void offset(SkScalar dx, SkScalar dy)

Offsets Rect by adding dx to fLeft, fRight; and by adding dy to fTop, fBottom.

If dx is negative, moves Rect to the left.
If dx is positive, moves Rect to the right.
If dy is negative, moves Rect upward.
If dy is positive, moves Rect downward. 

#Param dx  offset added to fLeft and fRight ##
#Param dy  offset added to fTop and fBottom ##

#Example
    SkRect rect = { 10, 14, 50, 73 };
    rect.offset(5, 13);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 55, 86
##
##

#SeeAlso offsetTo makeOffset SkIRect::offset

##

# ------------------------------------------------------------------------------

#Method void offset(const SkPoint& delta)

Offsets Rect by adding delta.fX to fLeft, fRight; and by adding delta.fY to
fTop, fBottom.

If delta.fX is negative, moves Rect to the left.
If delta.fX is positive, moves Rect to the right.
If delta.fY is negative, moves Rect upward.
If delta.fY is positive, moves Rect downward. 

#Param delta  added to Rect ##

#Example
    SkRect rect = { 10, 14, 50, 73 };
    rect.offset({5, 13});
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 55, 86
##
##

#SeeAlso offsetTo makeOffset SkIRect::offset

##

# ------------------------------------------------------------------------------

#Method void offsetTo(SkScalar newX, SkScalar newY)

Offsets Rect so that fLeft equals newX, and fTop equals newY. width and height
are unchanged.

#Param newX  stored in fLeft, preserving width() ##
#Param newY  stored in fTop, preserving height() ##

#Example
    SkRect rect = { 10, 14, 50, 73 };
    rect.offsetTo(15, 27);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 55, 86
##
##

#SeeAlso offset makeOffset setXYWH SkIRect::offsetTo

##

# ------------------------------------------------------------------------------

#Method void inset(SkScalar dx, SkScalar dy)

Insets Rect by (dx, dy).

If dx is positive, makes Rect narrower.
If dx is negative, makes Rect wider.
If dy is positive, makes Rect shorter.
If dy is negative, makes Rect taller.

#Param dx  added to fLeft and subtracted from fRight ##
#Param dy  added to fTop and subtracted from fBottom ##

#Example
    SkRect rect = { 10, 14, 50, 73 };
    rect.inset(5, 13);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 45, 60
##
##

#SeeAlso outset makeInset SkIRect::inset

##

# ------------------------------------------------------------------------------

#Method void outset(SkScalar dx, SkScalar dy)

Outsets Rect by (dx, dy).

If dx is positive, makes Rect wider.
If dx is negative, makes Rect narrower.
If dy is positive, makes Rect taller.
If dy is negative, makes Rect shorter.

#Param dx  subtracted to fLeft and added from fRight ##
#Param dy  subtracted to fTop and added from fBottom ##

#Example
    SkRect rect = { 10, 14, 50, 73 };
    rect.outset(5, 13);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 5, 1, 55, 86
##
##

#SeeAlso inset makeOutset SkIRect::outset

##

#Topic Intersection

Rects intersect when they enclose a common area. To intersect, each of the pair 
must describe area; fLeft is less than fRight, and fTop is less than fBottom;
empty() returns false. The intersection of Rect pair can be described by:

#Formula
(max(a.fLeft, b.fLeft), max(a.fTop, b.fTop),
 min(a.fRight, b.fRight), min(a.fBottom, b.fBottom))
##
.

The intersection is only meaningful if the resulting Rect is not empty and
describes an area: fLeft is less than fRight, and fTop is less than fBottom.

# ------------------------------------------------------------------------------

#Method bool intersect(const SkRect& r)

Returns true if Rect intersects r, and sets Rect to intersection.
Returns false if Rect does not intersect r, and leaves Rect unchanged.

Returns false if either r or Rect is empty, leaving Rect unchanged.

#Param r  limit of result ##

#Return true if r and Rect have area in common ##

#Example
#Description
Two SkDebugf calls are required. If the calls are combined, their arguments
may not be evaluated in left to right order: the printed intersection may
be before or after the call to intersect.
##
    SkRect leftRect =  { 10, 40, 50, 80 };
    SkRect rightRect = { 30, 60, 70, 90 };
    SkDebugf("%s intersection: ", leftRect.intersect(rightRect) ? "" : "no ");
    SkDebugf("%g, %g, %g, %g\n", leftRect.left(), leftRect.top(), 
                                 leftRect.right(), leftRect.bottom());
#StdOut
 intersection: 30, 60, 50, 80
##                                 
##

#SeeAlso intersects Intersects join SkIRect::intersect

##

# ------------------------------------------------------------------------------

#Method bool intersect(SkScalar left, SkScalar top, SkScalar right, SkScalar bottom)

Constructs Rect to intersect from (left, top, right, bottom). Does not sort
construction.

Returns true if Rect intersects construction, and sets Rect to intersection.
Returns false if Rect does not intersect construction, and leaves Rect unchanged.

Returns false if either construction or Rect is empty, leaving Rect unchanged.

#Param left  x minimum of constructed Rect ##
#Param top  y minimum of constructed Rect ##
#Param right  x maximum of constructed Rect ##
#Param bottom  y maximum of constructed Rect ##

#Return true if construction and Rect have area in common ##

#Example
#Description
Two SkDebugf calls are required. If the calls are combined, their arguments
may not be evaluated in left to right order: the printed intersection may
be before or after the call to intersect.
##
    SkRect leftRect =  { 10, 40, 50, 80 };
    SkDebugf("%s intersection: ", leftRect.intersect(30, 60, 70, 90) ? "" : "no ");
    SkDebugf("%g, %g, %g, %g\n", leftRect.left(), leftRect.top(), 
                                 leftRect.right(), leftRect.bottom());
#StdOut
 intersection: 30, 60, 50, 80
##                                 
##

#SeeAlso intersects Intersects join SkIRect::intersect

##

# ------------------------------------------------------------------------------

#Method bool SK_WARN_UNUSED_RESULT intersect(const SkRect& a, const SkRect& b)

Returns true if a intersects b, and sets Rect to intersection.
Returns false if a does not intersect b, and leaves Rect unchanged.

Returns false if either a or b is empty, leaving Rect unchanged.

#Param a  Rect to intersect ##
#Param b  Rect to intersect ##

#Return true if a and b have area in common ##

#Example
    SkRect result;
    bool intersected = result.intersect({ 10, 40, 50, 80 }, { 30, 60, 70, 90 });
    SkDebugf("%s intersection: %g, %g, %g, %g\n", intersected ? "" : "no ",
             result.left(), result.top(), result.right(), result.bottom());
#StdOut
 intersection: 30, 60, 50, 80
##                                 
##

#SeeAlso intersects Intersects join SkIRect::intersect

##

# ------------------------------------------------------------------------------

#Method    bool intersects(SkScalar left, SkScalar top, SkScalar right, SkScalar bottom) const

Constructs Rect to intersect from (left, top, right, bottom). Does not sort
construction.

Returns true if Rect intersects construction.
Returns false if either construction or Rect is empty, or do not intersect.

#Param left  x minimum of constructed Rect ##
#Param top  y minimum of constructed Rect ##
#Param right  x maximum of constructed Rect ##
#Param bottom  y maximum of constructed Rect ##

#Return true if construction and Rect have area in common ##

#Example
    SkRect rect = { 10, 40, 50, 80 };
    SkDebugf("%s intersection", rect.intersects(30, 60, 70, 90) ? "" : "no ");
#StdOut
 intersection
##                                 
##

#SeeAlso intersect Intersects SkIRect::Intersects

##

# ------------------------------------------------------------------------------

#Method    bool intersects(const SkRect& r) const

Returns true if Rect intersects r.
Returns false if either r or Rect is empty, or do not intersect.

#Param r  Rect to intersect ##

#Return true if r and Rect have area in common ##

#Example
    SkRect rect = { 10, 40, 50, 80 };
    SkDebugf("%s intersection", rect.intersects({30, 60, 70, 90}) ? "" : "no ");
#StdOut
 intersection
##                                 
##

#SeeAlso intersect Intersects SkIRect::Intersects

##

# ------------------------------------------------------------------------------

#Method    static bool Intersects(const SkRect& a, const SkRect& b)

Returns true if a intersects b.
Returns false if either a or b is empty, or do not intersect.

#Param a  Rect to intersect ##
#Param b  Rect to intersect ##

#Return true if a and b have area in common ##

#Example
    SkDebugf("%s intersection", SkRect::Intersects({10, 40, 50, 80}, {30, 60, 70, 90}) ? "" : "no ");
#StdOut
 intersection
##                                 
##

#SeeAlso intersect intersects SkIRect::Intersects

##

#Topic Intersection ##


# ------------------------------------------------------------------------------

#Method    void join(SkScalar left, SkScalar top, SkScalar right, SkScalar bottom)

Constructs Rect to intersect from (left, top, right, bottom). Does not sort
construction.

Sets Rect to the union of itself and the construction.

Has no effect if construction is empty. Otherwise, if Rect is empty, sets
Rect to construction.

#Param left  x minimum of constructed Rect ##
#Param top  y minimum of constructed Rect ##
#Param right  x maximum of constructed Rect ##
#Param bottom  y maximum of constructed Rect ##

#Example
    SkRect rect = { 10, 20, 15, 25};
    rect.join(50, 60, 55, 65);
    SkDebugf("join: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
 join: 10, 20, 55, 65
##                                 
##

#SeeAlso joinNonEmptyArg joinPossiblyEmptyRect SkIRect::join

##

# ------------------------------------------------------------------------------

#Method    void join(const SkRect& r)

Sets Rect to the union of itself and r.

Has no effect if r is empty. Otherwise, if Rect is empty, sets
Rect to r.

#Param r  expansion Rect ##

#Example
    SkRect rect = { 10, 20, 15, 25};
    rect.join({50, 60, 55, 65});
    SkDebugf("join: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
 join: 10, 20, 55, 65
##                                 
##

#SeeAlso joinNonEmptyArg joinPossiblyEmptyRect SkIRect::join

##

# ------------------------------------------------------------------------------

#Method    void joinNonEmptyArg(const SkRect& r)

Sets Rect to the union of itself and r.

Asserts if r is empty and SK_DEBUG is defined.
If Rect is empty, sets Rect to r.

May produce incorrect results if r is empty.

#Param r  expansion Rect ##

#Example
#Description
Since Rect is not sorted, first result is copy of toJoin.
##
    SkRect rect = { 10, 100, 15, 0};
    SkRect sorted = rect.makeSorted();
    SkRect toJoin = { 50, 60, 55, 65 };
    rect.joinNonEmptyArg(toJoin);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    sorted.joinNonEmptyArg(toJoin);
    SkDebugf("sorted: %g, %g, %g, %g\n", sorted.fLeft, sorted.fTop, sorted.fRight, sorted.fBottom);
#StdOut
rect: 50, 60, 55, 65
sorted: 10, 0, 55, 100
##                                 
##

#SeeAlso join joinPossiblyEmptyRect SkIRect::join

##

# ------------------------------------------------------------------------------

#Method    void joinPossiblyEmptyRect(const SkRect& r)

Sets Rect to the union of itself and the construction.

May produce incorrect results if Rect or r is empty.

#Param r  expansion Rect ##

#Example
#Description
Since Rect is not sorted, first result is not useful.
##
    SkRect rect = { 10, 100, 15, 0};
    SkRect sorted = rect.makeSorted();
    SkRect toJoin = { 50, 60, 55, 65 };
    rect.joinPossiblyEmptyRect(toJoin);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    sorted.joinPossiblyEmptyRect(toJoin);
    SkDebugf("sorted: %g, %g, %g, %g\n", sorted.fLeft, sorted.fTop, sorted.fRight, sorted.fBottom);
#StdOut
rect: 10, 60, 55, 65
sorted: 10, 0, 55, 100
##                                 
##

#SeeAlso joinNonEmptyArg join SkIRect::join

##

# ------------------------------------------------------------------------------

#Method    bool contains(const SkRect& r) const

Returns true if Rect contains r.
Returns false if Rect is empty or r is empty.

Rect contains r when Rect area completely includes r area.

#Param r  Rect contained ##

#Return true if all sides of Rect are outside r ##

#Example
    SkRect rect = { 30, 50, 40, 60 };
    SkRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };
    for (auto contained : tests) {
        SkDebugf("rect: (%g, %g, %g, %g) %s (%g, %g, %g, %g)\n",
                 rect.left(), rect.top(), rect.right(), rect.bottom(),
                 rect.contains(contained) ? "contains" : "does not contain",
                 contained.left(), contained.top(), contained.right(), contained.bottom());
    }
#StdOut
rect: (30, 50, 40, 60) contains (30, 50, 31, 51)
rect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)
rect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)
##
##

#SeeAlso SkIRect::contains

##

# ------------------------------------------------------------------------------

#Method    bool contains(const SkIRect& r) const

Returns true if Rect contains r.
Returns false if Rect is empty or r is empty.

Rect contains r when Rect area completely includes r area.

#Param r  IRect contained ##

#Return true if all sides of Rect are outside r ##

#Example
    SkRect rect = { 30, 50, 40, 60 };
    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };
    for (auto contained : tests) {
        SkDebugf("rect: (%g, %g, %g, %g) %s (%d, %d, %d, %d)\n",
                 rect.left(), rect.top(), rect.right(), rect.bottom(),
                 rect.contains(contained) ? "contains" : "does not contain",
                 contained.left(), contained.top(), contained.right(), contained.bottom());
    }
#StdOut
rect: (30, 50, 40, 60) contains (30, 50, 31, 51)
rect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)
rect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)
##
##

#SeeAlso SkIRect::contains

##

#Topic Round

# ------------------------------------------------------------------------------

#Method    void round(SkIRect* dst) const

Sets IRect by adding 0.5 and discarding the fractional portion of Rect
members, using
#Formula
(SkScalarRoundToInt(fLeft), SkScalarRoundToInt(fTop),
 SkScalarRoundToInt(fRight), SkScalarRoundToInt(fBottom))
##
.

#Param dst  storage for IRect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkIRect round;
    rect.round(&round);
    SkDebugf("round: %d, %d, %d, %d\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 31, 51, 41, 61
##
##

#SeeAlso roundIn roundOut SkScalarRoundToInt

##

# ------------------------------------------------------------------------------

#Method    void roundOut(SkIRect* dst) const

Sets IRect by discarding the fractional portion of fLeft and fTop; and
rounding up fRight and FBottom, using
#Formula
(SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop),
 SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom))
##
.

#Param dst  storage for IRect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkIRect round;
    rect.roundOut(&round);
    SkDebugf("round: %d, %d, %d, %d\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 30, 50, 41, 61
##
##

#SeeAlso roundIn round SkScalarRoundToInt

##

# ------------------------------------------------------------------------------

#Method    void roundOut(SkRect* dst) const 

Sets Rect by discarding the fractional portion of fLeft and fTop; and
rounding up fRight and FBottom, using
#Formula
(SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop),
 SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom))
##
.

#Param dst  storage for Rect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkRect round;
    rect.roundOut(&round);
    SkDebugf("round: %g, %g, %g, %g\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 30, 50, 41, 61
##
##

#SeeAlso roundIn round SkScalarRoundToInt

##

# ------------------------------------------------------------------------------

#Method    void roundIn(SkIRect* dst) const

Sets Rect by rounding up fLeft and fTop; and
discarding the fractional portion of fRight and FBottom, using

#Formula
(SkScalarCeilToInt(fLeft), SkScalarCeilToInt(fTop),
 SkScalarFloorToInt(fRight), SkScalarFloorToInt(fBottom))
##
.

#Param dst  storage for IRect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkIRect round;
    rect.roundIn(&round);
    SkDebugf("round: %d, %d, %d, %d\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 31, 51, 40, 60
##
##

#SeeAlso roundOut round SkScalarRoundToInt

##

# ------------------------------------------------------------------------------

#Method    SkIRect round() const

Returns IRect by adding 0.5 and discarding the fractional portion of Rect
members, using
#Formula
(SkScalarRoundToInt(fLeft), SkScalarRoundToInt(fTop),
 SkScalarRoundToInt(fRight), SkScalarRoundToInt(fBottom))
##
.

#Return  rounded IRect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkIRect round = rect.round();
    SkDebugf("round: %d, %d, %d, %d\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 31, 51, 41, 61
##
##

#SeeAlso roundOut roundIn SkScalarRoundToInt

##

# ------------------------------------------------------------------------------

#Method    SkIRect roundOut() const

Sets IRect by discarding the fractional portion of fLeft and fTop; and
rounding up fRight and FBottom, using
#Formula
(SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop),
 SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom))
##
.

#Return  rounded IRect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkIRect round = rect.roundOut();
    SkDebugf("round: %d, %d, %d, %d\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 30, 50, 41, 61
##
##

#SeeAlso round roundIn SkScalarRoundToInt

##

#Topic Round ##

# ------------------------------------------------------------------------------

#Method    void sort()

Swaps fLeft and fRight if fLeft is greater than fRight; and swaps
fTop and fBottom if fTop is greater than fBottom. Result may be empty;
and width() and height() will be zero or positive.

#Example
    SkRect rect = { 30.5f, 50.5f, 20.5f, 10.5f };
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    rect.sort();
    SkDebugf("sorted: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 30.5, 50.5, 20.5, 10.5
sorted: 20.5, 10.5, 30.5, 50.5
##
##

#SeeAlso makeSorted SkIRect::sort

##

# ------------------------------------------------------------------------------

#Method    SkRect makeSorted() const

Returns Rect with fLeft and fRight swapped if fLeft is greater than fRight; and
with fTop and fBottom swapped if fTop is greater than fBottom. Result may be empty;
and width() and height() will be zero or positive.

#Return  sorted Rect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 20.5f, 10.5f };
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    SkRect sort = rect.makeSorted();
    SkDebugf("sorted: %g, %g, %g, %g\n", sort.fLeft, sort.fTop, sort.fRight, sort.fBottom);
#StdOut
rect: 30.5, 50.5, 20.5, 10.5
sorted: 20.5, 10.5, 30.5, 50.5
##
##

#SeeAlso sort SkIRect::makeSorted

##

# ------------------------------------------------------------------------------

#Method    const SkScalar* asScalars() const

Returns pointer to first Scalar in Rect, to treat it as an array with four
entries.

#Return  pointer to fLeft ##

#Example
   SkRect rect = {7, 11, 13, 17};
SkDebugf("rect.asScalars() %c= &rect.fLeft\n", rect.asScalars() == &rect.fLeft? '=' : '!');
#StdOut
rect.asScalars() == &rect.fLeft
##
##

#SeeAlso toQuad

##

# ------------------------------------------------------------------------------

#Method    void dump(bool asHex) const

Writes text representation of Rect to standard output. Set asHex to true to 
generate exact binary representations of floating point numbers.

#Param asHex  true if SkScalar values are written as hexadecimal ##

#Example
   SkRect rect = {20, 30, 40, 50};
    for (bool dumpAsHex : { false, true } ) {
        rect.dump(dumpAsHex);
        SkDebugf("\n");
    }
#StdOut
SkRect::MakeLTRB(20, 30, 40, 50);

SkRect::MakeLTRB(SkBits2Float(0x41a00000), /* 20.000000 */
                 SkBits2Float(0x41f00000), /* 30.000000 */
                 SkBits2Float(0x42200000), /* 40.000000 */
                 SkBits2Float(0x42480000)  /* 50.000000 */);
##
##

#SeeAlso dumpHex

##

# ------------------------------------------------------------------------------

#Method    void dump() const

Writes text representation of Rect to standard output. The representation may be
directly compiled as C++ code. Floating point values are written
with limited precision; it may not be possible to reconstruct original Rect
from output.

#Example
SkRect rect = {6.f / 7, 2.f / 3, 26.f / 10, 42.f / 6};
rect.dump();
SkRect copy = SkRect::MakeLTRB(0.857143f, 0.666667f, 2.6f, 7);
SkDebugf("rect is " "%s" "equal to copy\n", rect == copy ? "" : "not ");
#StdOut
SkRect::MakeLTRB(0.857143f, 0.666667f, 2.6f, 7);
rect is not equal to copy
##
##

#SeeAlso dumpHex

##

# ------------------------------------------------------------------------------

#Method    void dumpHex() const

Writes text representation of Rect to standard output. The representation may be
directly compiled as C++ code. Floating point values are written
in hexadecimal to preserve their exact bit pattern. The output reconstructs the
original Rect.

Use instead of dump() when submitting 
#A bug reports against Skia # http://bug.skia.org ##
.

#Example
   SkRect rect = {6.f / 7, 2.f / 3, 26.f / 10, 42.f / 6};
rect.dumpHex();
SkRect copy = SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab), /* 0.666667 */
                 SkBits2Float(0x40266666), /* 2.600000 */
                 SkBits2Float(0x40e00000)  /* 7.000000 */);
SkDebugf("rect is " "%s" "equal to copy\n", rect == copy ? "" : "not ");
#StdOut
SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab), /* 0.666667 */
                 SkBits2Float(0x40266666), /* 2.600000 */
                 SkBits2Float(0x40e00000)  /* 7.000000 */);
rect is equal to copy
##
##

#SeeAlso dump

##

#Method static SkRect SK_WARN_UNUSED_RESULT MakeLargest()

#Deprecated
##

Returns constructed SkRect setting left and top to most negative finite value, and
setting right and bottom to most positive finite value.

#Return  bounds (SK_ScalarMin, SK_ScalarMin, SK_ScalarMax, SK_ScalarMax) ##

##

#Struct SkRect ##

#Topic Rect ##
