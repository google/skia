#Topic Pixmap
#Alias Pixmap_Reference ##

#Class SkPixmap

Pixmap provides a utility to pair SkImageInfo with pixels and row bytes.
Pixmap is a low level class which provides convenience functions to access
raster destinations. Canvas can not draw Pixmap, nor does Pixmap provide
a direct drawing destination.

Use Bitmap to draw pixels referenced by Pixmap; use Surface to draw into
pixels referenced by Pixmap.

Pixmap does not try to manage the lifetime of the pixel memory. Use Pixel_Ref
to manage pixel memory; Pixel_Ref is safe across threads.

#Subtopic Overview
#Populate
##

#Subtopic Related_Function
#Populate
##

#Subtopic Constructor
#Populate
##

#Subtopic Member_Function
#Populate
##

#Subtopic Initialization
#Line # sets fields for use ##

# ------------------------------------------------------------------------------

#Method SkPixmap()

#In Initialization
#Line # constructs with default values ##
Creates an empty Pixmap without pixels, with kUnknown_SkColorType, with
kUnknown_SkAlphaType, and with a width and height of zero. Use
reset() to associate pixels, SkColorType, SkAlphaType, width, and height
after Pixmap has been created.

#Return empty Pixmap ##

#Example
void draw(SkCanvas* canvas) {
    const char* alphas[] = {"Unknown", "Opaque", "Premul", "Unpremul"};
    const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                            "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
    SkPixmap pixmap;
    for (int i = 0; i < 2; ++i) {
       SkDebugf("width: %2d  height: %2d", pixmap.width(), pixmap.height());
       SkDebugf("  color: k%s_SkColorType", colors[pixmap.colorType()]);
       SkDebugf("  alpha: k%s_SkAlphaType\n", alphas[pixmap.alphaType()]);
       pixmap.reset(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType),
                    nullptr, 0);
    }
}
#StdOut
width:  0  height:  0  color: kUnknown_SkColorType  alpha: kUnknown_SkAlphaType
width: 25  height: 35  color: kRGBA_8888_SkColorType  alpha: kOpaque_SkAlphaType
##
##

#SeeAlso SkPixmap(const SkImageInfo& info, const void* addr, size_t rowBytes) reset() SkAlphaType SkColorType

##

# ------------------------------------------------------------------------------

#Method SkPixmap(const SkImageInfo& info, const void* addr, size_t rowBytes)

#In Initialization
#Line # constructs from Image_Info, pixels ##
Creates Pixmap from info width, height, SkAlphaType, and SkColorType.
addr points to pixels, or nullptr. rowBytes should be info.width() times
info.bytesPerPixel(), or larger.

No parameter checking is performed; it is up to the caller to ensure that
addr and rowBytes agree with info.

The memory lifetime of pixels is managed by the caller. When Pixmap goes
out of scope, addr is unaffected.

Pixmap may be later modified by reset() to change its size, pixel type, or
storage.

#Param info  width, height, SkAlphaType, SkColorType of Image_Info ##
#Param addr  pointer to pixels allocated by caller; may be nullptr ##
#Param rowBytes  size of one row of addr; width times pixel size, or larger ##

#Return initialized Pixmap ##

#Example
#Image 3
#Description
SkImage::MakeRasterCopy takes const SkPixmap& as an argument. The example
constructs a SkPixmap from the brace-delimited parameters.
##
    SkDebugf("image alpha only = %s\n", image->isAlphaOnly() ? "true" : "false");
    SkPMColor pmColors = 0;
    sk_sp<SkImage> copy = SkImage::MakeRasterCopy({SkImageInfo::MakeA8(1, 1),
                                                  (uint8_t*)&pmColors,
                                                  1});
    SkDebugf("copy alpha only = %s\n", copy->isAlphaOnly() ? "true" : "false");
#StdOut
image alpha only = false
copy alpha only = true
##
##

#SeeAlso SkPixmap() reset() SkAlphaType SkColorType

##

# ------------------------------------------------------------------------------

#Method void reset()

#In Initialization
#Line # reuses existing Pixmap with replacement values ##
Sets width, height, row bytes to zero; pixel address to nullptr; SkColorType to
kUnknown_SkColorType; and SkAlphaType to kUnknown_SkAlphaType.

The prior pixels are unaffected; it is up to the caller to release pixels
memory if desired.

#Example
void draw(SkCanvas* canvas) {
    const char* alphas[] = {"Unknown", "Opaque", "Premul", "Unpremul"};
    const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                            "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
    SkPixmap pixmap(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType),
                    nullptr, 0);
    for (int i = 0; i < 2; ++i) {
       SkDebugf("width: %2d  height: %2d", pixmap.width(), pixmap.height());
       SkDebugf("  color: k%s_SkColorType", colors[pixmap.colorType()]);
       SkDebugf("  alpha: k%s_SkAlphaType\n", alphas[pixmap.alphaType()]);
       pixmap.reset();
    }
}
#StdOut
width: 25  height: 35  color: kRGBA_8888_SkColorType  alpha: kOpaque_SkAlphaType
width:  0  height:  0  color: kUnknown_SkColorType  alpha: kUnknown_SkAlphaType
##
##

#SeeAlso SkPixmap() SkAlphaType SkColorType

##

# ------------------------------------------------------------------------------

#Method void reset(const SkImageInfo& info, const void* addr, size_t rowBytes)

#In Initialization
Sets width, height, SkAlphaType, and SkColorType from info.
Sets pixel address from addr, which may be nullptr.
Sets row bytes from rowBytes, which should be info.width() times
info.bytesPerPixel(), or larger.

Does not check addr. Asserts if built with SK_DEBUG defined and if rowBytes is
too small to hold one row of pixels.

The memory lifetime pixels are managed by the caller. When Pixmap goes
out of scope, addr is unaffected.

#Param info  width, height, SkAlphaType, SkColorType of Image_Info ##
#Param addr  pointer to pixels allocated by caller; may be nullptr ##
#Param rowBytes  size of one row of addr; width times pixel size, or larger ##

#Example
#Image 4
#Height 64
void draw(SkCanvas* canvas) {
    std::vector<int32_t> pixels;
    pixels.resize(image->height() * image->width() * 4);
    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,
            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
    image->readPixels(pixmap, 0, 0);
    int x = 0;
    for (auto colorType : { kRGBA_8888_SkColorType, kBGRA_8888_SkColorType } ) {
        pixmap.reset(SkImageInfo::Make(image->width(), image->height(), colorType,
                image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
        SkBitmap bitmap;
        bitmap.installPixels(pixmap);
        canvas->drawBitmap(bitmap, x, 0);
        x += 128;
    }
}
##

#SeeAlso SkPixmap(const SkImageInfo& info, const void* addr, size_t rowBytes) reset() SkAlphaType SkColorType

##

# ------------------------------------------------------------------------------

#Method void setColorSpace(sk_sp<SkColorSpace> colorSpace)

#In Initialization
#Line # sets Image_Info Color_Space ##

Changes Color_Space in Image_Info; preserves width, height, SkAlphaType, and
SkColorType in Image, and leaves pixel address and row bytes unchanged.
Color_Space reference count is incremented.

#Param colorSpace  Color_Space moved to Image_Info ##

#Example
void draw(SkCanvas* canvas) {
    SkPixmap pixmap;
    sk_sp<SkColorSpace> colorSpace1 = SkColorSpace::MakeRGB(SkColorSpace::kLinear_RenderTargetGamma,
                                                            SkColorSpace::kRec2020_Gamut);
    SkDebugf("is %sunique\n", colorSpace1->unique() ? "" : "not ");
    pixmap.setColorSpace(colorSpace1);
    SkDebugf("is %sunique\n", colorSpace1->unique() ? "" : "not ");
}
#StdOut
is unique
is not unique
##
##

#SeeAlso Color_Space SkImageInfo::makeColorSpace

##

# ------------------------------------------------------------------------------

#Method bool SK_WARN_UNUSED_RESULT reset(const SkMask& mask)
#Deprecated soon
##

# ------------------------------------------------------------------------------

#Method bool SK_WARN_UNUSED_RESULT extractSubset(SkPixmap* subset, const SkIRect& area) const

#In Initialization
#Line # sets pointer to portion of original ##
Sets subset width, height, pixel address to intersection of Pixmap with area,
if intersection is not empty; and return true. Otherwise, leave subset unchanged
and return false.

Failing to read the return value generates a compile time warning.

#Param subset  storage for width, height, pixel address of intersection ##
#Param area    bounds to intersect with Pixmap ##

#Return true if intersection of Pixmap and area is not empty ##

#Example
#Image 3
#Height 128
void draw(SkCanvas* canvas) {
    std::vector<int32_t> pixels;
    pixels.resize(image->height() * image->width() * 4);
    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,
            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
    image->readPixels(pixmap, 0, 0);
    SkPixmap inset;
    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {
        SkBitmap bitmap;
        bitmap.installPixels(inset);
        canvas->drawBitmap(bitmap, 0, 0);
    }
}
##

#SeeAlso reset() SkIRect::intersect

##

#Subtopic Initialization ##

#Subtopic Image_Info_Access
#Line # returns all or part of Image_Info ##

# ------------------------------------------------------------------------------

#Method const SkImageInfo& info() const

#In Image_Info_Access
#Line # returns Image_Info ##
Returns width, height, Alpha_Type, Color_Type, and Color_Space.

#Return reference to ImageInfo  ##

#Example
#Image 3
    std::vector<int32_t> pixels;
    pixels.resize(image->height() * image->width() * 4);
    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,
            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
    image->readPixels(pixmap, 0, 0);
    SkPixmap inset;
    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {
        const SkImageInfo& info = inset.info();
        const char* alphas[] = {"Unknown", "Opaque", "Premul", "Unpremul"};
        const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888",
                "RGB_888x", "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
        SkDebugf("width: %d height: %d color: %s alpha: %s\n", info.width(), info.height(),
                 colors[info.colorType()], alphas[info.alphaType()]);
    }
#StdOut
width: 384 height: 384 color: BGRA_8888 alpha: Opaque
##
##

#SeeAlso Image_Info

##

# ------------------------------------------------------------------------------

#Method size_t rowBytes() const

#In Image_Info_Access
#Line # returns interval between rows in bytes ##
Returns row bytes, the interval from one pixel row to the next. Row bytes
is at least as large as:
#Formula
width() * info().bytesPerPixel()
##
.

Returns zero if colorType is kUnknown_SkColorType.
It is up to the Bitmap creator to ensure that row bytes is a useful value.

#Return  byte length of pixel row ##

#Example
SkPixmap badPixmap = {SkImageInfo::MakeA8(4, 4), nullptr, 2};
SkPixmap okPixmap = {SkImageInfo::MakeA8(4, 4), nullptr, 8};
for (auto& pixmap : { badPixmap, okPixmap } ) {
    SkDebugf("rowBytes: %d minRowBytes: %d\n", pixmap.rowBytes(),
       pixmap.info().minRowBytes());
}
#StdOut
rowBytes: 2 minRowBytes: 4
rowBytes: 8 minRowBytes: 4
##
##

#SeeAlso addr() info() SkImageInfo::minRowBytes

##

# ------------------------------------------------------------------------------

#Method const void* addr() const

#In Image_Info_Access
#Line # returns readable pixel address as void pointer ##
Returns pixel address, the base address corresponding to the pixel origin.

It is up to the Pixmap creator to ensure that pixel address is a useful value.

#Return  pixel address ##

#Example
#Image 3
    std::vector<int32_t> pixels;
    pixels.resize(image->height() * image->width() * 4);
    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,
            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
    image->readPixels(pixmap, 0, 0);
    SkDebugf("pixels address: 0x%llx\n", pixmap.addr());
    SkPixmap inset;
    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {
         SkDebugf("inset address:  0x%llx\n", inset.addr());
    }
#StdOut
#Volatile
pixels address: 0x7f2a440bb010
inset address:  0x7f2a440fb210
##
##

#SeeAlso addr(int x, int y) addr8 addr16 addr32 addr64 info() rowBytes()

##

# ------------------------------------------------------------------------------

#Method int width() const

#In Image_Info_Access
#Line # returns pixel column count ##
Returns pixel count in each pixel row. Should be equal or less than:

#Formula
rowBytes() / info().bytesPerPixel()
##
.

#Return  pixel width in Image_Info ##

#Example
    SkImageInfo info = SkImageInfo::MakeA8(16, 32);
    SkPixmap pixmap(info, nullptr, 64);
    SkDebugf("pixmap width: %d  info width: %d\n", pixmap.width(), info.width());
#StdOut
pixmap width: 16  info width: 16
##
##

#SeeAlso height() SkImageInfo::width()

##

# ------------------------------------------------------------------------------

#Method int height() const

#In Image_Info_Access
#Line # returns pixel row count ##
Returns pixel row count.

#Return  pixel height in Image_Info ##

#Example
    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);
    SkDebugf("pixmap height: %d  info height: %d\n", pixmap.height(), pixmap.info().height());
#StdOut
pixmap height: 32  info height: 32
##
##

#SeeAlso width() ImageInfo::height()

##

# ------------------------------------------------------------------------------

#Method SkColorType colorType() const

#In Image_Info_Access
#Line # returns Image_Info Color_Type ##
Returns Color_Type, one of: #list_of_color_types#.

#Return  Color_Type in Image_Info ##

#Example
    const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                            "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);
    SkDebugf("color type: k" "%s" "_SkColorType\n", colors[pixmap.colorType()]);
#StdOut
color type: kAlpha_8_SkColorType
##
##

#SeeAlso alphaType() SkImageInfo::colorType

##

# ------------------------------------------------------------------------------

#Method SkAlphaType alphaType() const

#In Image_Info_Access
#Line # returns Image_Info Alpha_Type ##
Returns Alpha_Type, one of: #list_of_alpha_types#.

#Return  Alpha_Type in Image_Info ##

#Example
    const char* alphas[] = {"Unknown", "Opaque", "Premul", "Unpremul"};
    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);
    SkDebugf("alpha type: k" "%s" "_SkAlphaType\n", alphas[pixmap.alphaType()]);
#StdOut
alpha type: kPremul_SkAlphaType
##
##

#SeeAlso colorType() SkImageInfo::alphaType

##

# ------------------------------------------------------------------------------

#Method SkColorSpace* colorSpace() const

#In Image_Info_Access
#Line # returns Image_Info Color_Space ##
Returns Color_Space, the range of colors, associated with Image_Info. The
reference count of Color_Space is unchanged. The returned Color_Space is
immutable.

#Return Color_Space in Image_Info, or nullptr ##

#Example
#Description
SkColorSpace::MakeSRGBLinear creates Color_Space with linear gamma
and an sRGB gamut. This Color_Space gamma is not close to sRGB gamma.
##
    SkPixmap pixmap(SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,
            SkColorSpace::MakeSRGBLinear()), nullptr, 64);
    SkColorSpace* colorSpace = pixmap.colorSpace();
    SkDebugf("gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\n",
            colorSpace->gammaCloseToSRGB() ? "true" : "false",
            colorSpace->gammaIsLinear() ? "true" : "false",
            colorSpace->isSRGB() ? "true" : "false");
#StdOut
gammaCloseToSRGB: false  gammaIsLinear: true  isSRGB: false
##
##

#SeeAlso Color_Space SkImageInfo::colorSpace

##

# ------------------------------------------------------------------------------

#Method bool isOpaque() const

#In Image_Info_Access
#Line # returns true if Image_Info describes opaque pixels ##
Returns true if Alpha_Type is kOpaque_SkAlphaType.
Does not check if Color_Type allows Alpha, or if any pixel value has
transparency.

#Return true if Image_Info has opaque Alpha_Type ##

#Example
#Description
    isOpaque ignores whether all pixels are opaque or not.
##
    std::vector<uint32_t> pixels;
    const int height = 2;
    const int width = 2;
    pixels.resize(height * width * 4);
    SkPixmap pixmap(SkImageInfo::Make(width, height, kN32_SkColorType,
            kPremul_SkAlphaType), (const void*) &pixels.front(), width * 4);
    for (int index = 0; index < 2; ++index) {
        pixmap.erase(0x00000000);
        SkDebugf("isOpaque: %s\n", pixmap.isOpaque() ? "true" : "false");
        pixmap.erase(0xFFFFFFFF);
        SkDebugf("isOpaque: %s\n", pixmap.isOpaque() ? "true" : "false");
        pixmap.reset(pixmap.info().makeAlphaType(kOpaque_SkAlphaType),
                     (const void*) &pixels.front(), width * 4);
    }
#StdOut
isOpaque: false
isOpaque: false
isOpaque: true
isOpaque: true
##
##

#SeeAlso computeIsOpaque SkImageInfo::isOpaque

##

# ------------------------------------------------------------------------------

#Method SkIRect bounds() const

#In Image_Info_Access
#Line # returns width and height as Rectangle ##
Returns IRect { 0, 0, width(), height() }.

#Return  integral rectangle from origin to width() and height() ##

#Example
    for (int width : { 0, 2 } ) {
        for (int height : { 0, 2 } ) {
             SkPixmap pixmap(SkImageInfo::MakeA8(width, height), nullptr, width);
             SkDebugf("width: %d height: %d empty: %s\n", width, height,
                      pixmap.bounds().isEmpty() ? "true" : "false");
        }
    }
#StdOut
width: 0 height: 0 empty: true
width: 0 height: 2 empty: true
width: 2 height: 0 empty: true
width: 2 height: 2 empty: false
##
##

#SeeAlso height() width() IRect

##

# ------------------------------------------------------------------------------

#Method int rowBytesAsPixels() const

#In Image_Info_Access
#Line # returns interval between rows in pixels ##

Returns number of pixels that fit on row. Should be greater than or equal to
width().

#Return  maximum pixels per row ##

#Example
    for (int rowBytes : { 4, 5, 6, 7, 8} ) {
        SkPixmap pixmap(SkImageInfo::MakeN32(1, 1, kPremul_SkAlphaType), nullptr, rowBytes);
        SkDebugf("rowBytes: %d rowBytesAsPixels: %d\n", rowBytes, pixmap.rowBytesAsPixels());
    }
#StdOut
rowBytes: 4 rowBytesAsPixels: 1
rowBytes: 5 rowBytesAsPixels: 1
rowBytes: 6 rowBytesAsPixels: 1
rowBytes: 7 rowBytesAsPixels: 1
rowBytes: 8 rowBytesAsPixels: 2
##
##

#SeeAlso rowBytes shiftPerPixel width SkImageInfo::bytesPerPixel

##

# ------------------------------------------------------------------------------

#Method int shiftPerPixel() const

#In Image_Info_Access
#Line # returns bit shift from pixels to bytes ##
Returns bit shift converting row bytes to row pixels.
Returns zero for kUnknown_SkColorType.

#Return one of: 0, 1, 2, 3; left shift to convert pixels to bytes ##

#Example
    const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                            "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
    SkImageInfo info = SkImageInfo::MakeA8(1, 1);
    for (SkColorType colorType : { kUnknown_SkColorType,   kAlpha_8_SkColorType,
                                   kRGB_565_SkColorType,   kARGB_4444_SkColorType,
                                   kRGBA_8888_SkColorType, kBGRA_8888_SkColorType,
                                   kGray_8_SkColorType,    kRGBA_F16_SkColorType } ) {
        SkPixmap pixmap(info.makeColorType(colorType), nullptr, 4);
        SkDebugf("color: k" "%s" "_SkColorType" "%*s" "bytesPerPixel: %d shiftPerPixel: %d\n",
                colors[colorType], 10 - strlen(colors[colorType]), " ",
                pixmap.info().bytesPerPixel(), pixmap.shiftPerPixel());
    }
#StdOut
color: kUnknown_SkColorType   bytesPerPixel: 0 shiftPerPixel: 0
color: kAlpha_8_SkColorType   bytesPerPixel: 1 shiftPerPixel: 0
color: kRGB_565_SkColorType   bytesPerPixel: 2 shiftPerPixel: 1
color: kARGB_4444_SkColorType bytesPerPixel: 2 shiftPerPixel: 1
color: kRGBA_8888_SkColorType bytesPerPixel: 4 shiftPerPixel: 2
color: kBGRA_8888_SkColorType bytesPerPixel: 4 shiftPerPixel: 2
color: kGray_8_SkColorType    bytesPerPixel: 1 shiftPerPixel: 0
color: kRGBA_F16_SkColorType  bytesPerPixel: 8 shiftPerPixel: 3
##
##

#SeeAlso rowBytes rowBytesAsPixels width SkImageInfo::bytesPerPixel

##

# ------------------------------------------------------------------------------

#Method size_t computeByteSize() const

#In Image_Info_Access
#Line # returns size required for pixels ##
Returns minimum memory required for pixel storage.
Does not include unused memory on last row when rowBytesAsPixels exceeds width().
Returns zero if result does not fit in size_t.
Returns zero if height() or width() is 0.
Returns height() times rowBytes if colorType is kUnknown_SkColorType.

#Return size in bytes of image buffer ##

#Example
    SkPixmap pixmap;
    for (int width : { 1, 1000, 1000000 } ) {
        for (int height: { 1, 1000, 1000000 } ) {
            SkImageInfo imageInfo = SkImageInfo::MakeN32(width, height, kPremul_SkAlphaType);
            pixmap.reset(imageInfo, nullptr, width * 5);
            SkDebugf("width: %7d height: %7d computeByteSize: %13lld\n", width, height,
                     pixmap.computeByteSize());
        }
    }
#StdOut
width:       1 height:       1 computeByteSize:             4
width:       1 height:    1000 computeByteSize:          4999
width:       1 height: 1000000 computeByteSize:       4999999
width:    1000 height:       1 computeByteSize:          4000
width:    1000 height:    1000 computeByteSize:       4999000
width:    1000 height: 1000000 computeByteSize:    4999999000
width: 1000000 height:       1 computeByteSize:       4000000
width: 1000000 height:    1000 computeByteSize:    4999000000
width: 1000000 height: 1000000 computeByteSize: 4999999000000
##
##

#SeeAlso SkImageInfo::computeByteSize

##

#Subtopic Image_Info_Access ##

#Subtopic Reader
#Line # examine pixel value ##

# ------------------------------------------------------------------------------

#Method bool computeIsOpaque() const

#In Reader
#Line # returns true if all pixels are opaque ##
Returns true if all pixels are opaque. Color_Type determines how pixels
are encoded, and whether pixel describes Alpha. Returns true for Color_Types
without alpha in each pixel; for other Color_Types, returns true if all
pixels have alpha values equivalent to 1.0 or greater.

For Color_Types kRGB_565_SkColorType or kGray_8_SkColorType: always
returns true. For Color_Types kAlpha_8_SkColorType, kBGRA_8888_SkColorType,
kRGBA_8888_SkColorType: returns true if all pixel Alpha values are 255.
For Color_Type kARGB_4444_SkColorType: returns true if all pixel Alpha values are 15.
For kRGBA_F16_SkColorType: returns true if all pixel Alpha values are 1.0 or
greater.

Returns false for kUnknown_SkColorType.

#Return true if all pixels have opaque values or Color_Type is opaque  ##

#Example
    std::vector<uint32_t> pixels;
    const int height = 2;
    const int width = 2;
    pixels.resize(height * width * 4);
    SkPixmap pixmap(SkImageInfo::Make(width, height, kN32_SkColorType,
            kPremul_SkAlphaType), (const void*) &pixels.front(), width * 4);
    for (int index = 0; index < 2; ++index) {
        pixmap.erase(0x00000000);
        SkDebugf("computeIsOpaque: %s\n", pixmap.computeIsOpaque() ? "true" : "false");
        pixmap.erase(0xFFFFFFFF);
        SkDebugf("computeIsOpaque: %s\n", pixmap.computeIsOpaque() ? "true" : "false");
        pixmap.reset(pixmap.info().makeAlphaType(kOpaque_SkAlphaType),
                     (const void*) &pixels.front(), width * 4);
    }
#StdOut
computeIsOpaque: false
computeIsOpaque: true
computeIsOpaque: false
computeIsOpaque: true
##
##

#SeeAlso isOpaque Color_Type Alpha

##

# ------------------------------------------------------------------------------

#Method SkColor getColor(int x, int y) const

#In Reader
#Line # returns one pixel as Unpremultiplied Color ##
Returns pixel at (x, y) as Unpremultiplied Color.
Returns black with Alpha if Color_Type is kAlpha_8_SkColorType.

Input is not validated: out of bounds values of x or y trigger an assert() if
built with SK_DEBUG defined; and returns undefined values or may crash if
SK_RELEASE is defined. Fails if Color_Type is kUnknown_SkColorType or
pixel address is nullptr.

Color_Space in Image_Info is ignored. Some Color precision may be lost in the
conversion to Unpremultiplied Color; original pixel data may have additional
precision.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  pixel converted to Unpremultiplied Color ##

#Example
    const int w = 4;
    const int h = 4;
    std::vector<SkPMColor> storage;
    storage.resize(w * h);
    SkDebugf("Premultiplied:\n");
    for (int y = 0; y < h; ++y) {
        SkDebugf("(0, %d) ", y);
        for (int x = 0; x < w; ++x) {
            int a = 0xFF * (x + y) / (w - 1 + h - 1);
            storage[x + y * w] = SkPackARGB32(a, a * x / (w - 1), a * y / (h - 1), a);
            SkDebugf("0x%08x%c", storage[x + y * w], x == w - 1 ? '\n' : ' ');
        }
    }
    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), &storage.front(), w * 4);
    SkDebugf("Unpremultiplied:\n");
    for (int y = 0; y < h; ++y) {
        SkDebugf("(0, %d) ", y);
        for (int x = 0; x < w; ++x) {
            SkDebugf("0x%08x%c", pixmap.getColor(x, y), x == w - 1 ? '\n' : ' ');
        }
    }
#StdOut
Premultiplied:
(0, 0) 0x00000000 0x2a0e002a 0x55380055 0x7f7f007f
(0, 1) 0x2a000e2a 0x551c1c55 0x7f542a7f 0xaaaa38aa
(0, 2) 0x55003855 0x7f2a547f 0xaa7171aa 0xd4d48dd4
(0, 3) 0x7f007f7f 0xaa38aaaa 0xd48dd4d4 0xffffffff
Unpremultiplied:
(0, 0) 0x00000000 0x2a5500ff 0x55a800ff 0x7fff00ff
(0, 1) 0x2a0055ff 0x555454ff 0x7fa954ff 0xaaff54ff
(0, 2) 0x5500a8ff 0x7f54a9ff 0xaaaaaaff 0xd4ffaaff
(0, 3) 0x7f00ffff 0xaa54ffff 0xd4aaffff 0xffffffff
##
##

#SeeAlso addr() readPixels

##

#Subtopic Reader ##

#Subtopic Readable_Address
#Line # returns read only pixels ##

# ------------------------------------------------------------------------------

#Method const void* addr(int x, int y) const

#In Readable_Address
Returns readable pixel address at (x, y). Returns nullptr if Pixel_Ref is nullptr.

Input is not validated: out of bounds values of x or y trigger an assert() if
built with SK_DEBUG defined. Returns nullptr if Color_Type is kUnknown_SkColorType.

Performs a lookup of pixel size; for better performance, call
one of: addr8, addr16, addr32, addr64, or addrF16.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  readable generic pointer to pixel ##

#Example
    const int w = 4;
    const int h = 4;
    std::vector<SkPMColor> storage;
    storage.resize(w * h);
    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), &storage.front(), w * 4);
    SkDebugf("pixmap.addr(1, 2) %c= &storage[1 + 2 * w]\n",
              pixmap.addr(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');
#StdOut
pixmap.addr(1, 2) == &storage[1 + 2 * w]
##
##

#SeeAlso addr8 addr16 addr32 addr64 addrF16 getColor writable_addr SkBitmap::getAddr

##

# ------------------------------------------------------------------------------

#Method const uint8_t* addr8() const

#In Readable_Address
#Line # returns readable pixel address as 8-bit pointer ##
Returns readable base pixel address. Result is addressable as unsigned 8-bit bytes.
Will trigger an assert() if Color_Type is not kAlpha_8_SkColorType or
kGray_8_SkColorType, and is built with SK_DEBUG defined.

One byte corresponds to one pixel.

#Return  readable unsigned 8-bit pointer to pixels ##

#Example
    const int w = 4;
    const int h = 4;
    uint8_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kGray_8_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr8() %c= storage\n",
              pixmap.addr8()  == storage ? '=' : '!');
#StdOut
pixmap.addr8() == storage
##
##

#SeeAlso addr() addr16 addr32 addr64 addrF16 getColor writable_addr writable_addr8

##

# ------------------------------------------------------------------------------

#Method const uint16_t* addr16() const

#In Readable_Address
#Line # returns readable pixel address as 16-bit pointer ##
Returns readable base pixel address. Result is addressable as unsigned 16-bit words.
Will trigger an assert() if Color_Type is not kRGB_565_SkColorType or
kARGB_4444_SkColorType, and is built with SK_DEBUG defined.

One word corresponds to one pixel.

#Return  readable unsigned 16-bit pointer to pixels ##

#Example
    const int w = 4;
    const int h = 4;
    uint16_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kARGB_4444_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr16() %c= storage\n",
              pixmap.addr16()  == storage ? '=' : '!');
#StdOut
pixmap.addr16() == storage
##
##

#SeeAlso addr() addr8 addr32 addr64 addrF16 getColor writable_addr writable_addr16

##

# ------------------------------------------------------------------------------

#Method const uint32_t* addr32() const

#In Readable_Address
#Line # returns readable pixel address as 32-bit pointer ##
Returns readable base pixel address. Result is addressable as unsigned 32-bit words.
Will trigger an assert() if Color_Type is not kRGBA_8888_SkColorType or
kBGRA_8888_SkColorType, and is built with SK_DEBUG defined.

One word corresponds to one pixel.

#Return  readable unsigned 32-bit pointer to pixels ##

#Example
    const int w = 4;
    const int h = 4;
    uint32_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr32() %c= storage\n",
              pixmap.addr32()  == storage ? '=' : '!');
#StdOut
pixmap.addr32() == storage
##
##

#SeeAlso addr() addr8 addr16 addr64 addrF16 getColor writable_addr writable_addr32

##

# ------------------------------------------------------------------------------

#Method const uint64_t* addr64() const

#In Readable_Address
#Line # returns readable pixel address as 64-bit pointer ##
Returns readable base pixel address. Result is addressable as unsigned 64-bit words.
Will trigger an assert() if Color_Type is not kRGBA_F16_SkColorType and is built
with SK_DEBUG defined.

One word corresponds to one pixel.

#Return  readable unsigned 64-bit pointer to pixels ##

#Example
    const int w = 4;
    const int h = 4;
    uint64_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr64() %c= storage\n",
              pixmap.addr64()  == storage ? '=' : '!');
#StdOut
pixmap.addr64() == storage
##
##

#SeeAlso addr() addr8 addr16 addr32 addrF16 getColor writable_addr writable_addr64

##

# ------------------------------------------------------------------------------

#Method const uint16_t* addrF16() const

#In Readable_Address
#Line # returns readable pixel component address as 16-bit pointer ##
Returns readable base pixel address. Result is addressable as unsigned 16-bit words.
Will trigger an assert() if Color_Type is not kRGBA_F16_SkColorType and is built
with SK_DEBUG defined.

Each word represents one color component encoded as a half float.
Four words correspond to one pixel.

#Return  readable unsigned 16-bit pointer to first component of pixels ##

#Example
    const int w = 4;
    const int h = 4;
    uint16_t storage[w * h * 4];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),
                    storage, w * 4 * sizeof(storage[0]));
    SkDebugf("pixmap.addrF16() %c= storage\n",
              pixmap.addrF16()  == storage ? '=' : '!');
#StdOut
pixmap.addrF16() == storage
##
##

#SeeAlso addr() addr8 addr16 addr32 addr64 getColor writable_addr writable_addrF16

##

# ------------------------------------------------------------------------------

#Method const uint8_t* addr8(int x, int y) const

#In Readable_Address
Returns readable pixel address at (x, y).

Input is not validated: out of bounds values of x or y trigger an assert() if
built with SK_DEBUG defined.

Will trigger an assert() if Color_Type is not kAlpha_8_SkColorType or
kGray_8_SkColorType, and is built with SK_DEBUG defined.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  readable unsigned 8-bit pointer to pixel at (x, y) ##

#Example
    const int w = 4;
    const int h = 4;
    uint8_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kGray_8_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr8(1, 2) %c= &storage[1 + 2 * w]\n",
              pixmap.addr8(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');
#StdOut
pixmap.addr8(1, 2) == &storage[1 + 2 * w]
##
##

#SeeAlso addr() addr16 addr32 addr64 addrF16 getColor writable_addr writable_addr8

##

# ------------------------------------------------------------------------------

#Method const uint16_t* addr16(int x, int y) const

#In Readable_Address
Returns readable pixel address at (x, y).

Input is not validated: out of bounds values of x or y trigger an assert() if
built with SK_DEBUG defined.

Will trigger an assert() if Color_Type is not kRGB_565_SkColorType or
kARGB_4444_SkColorType, and is built with SK_DEBUG defined.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  readable unsigned 16-bit pointer to pixel at (x, y) ##

#Example
    const int w = 4;
    const int h = 4;
    uint16_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kARGB_4444_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr16(1, 2) %c= &storage[1 + 2 * w]\n",
              pixmap.addr16(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');
#StdOut
pixmap.addr16(1, 2) == &storage[1 + 2 * w]
##
##

#SeeAlso addr() addr8 addr32 addr64 addrF16 getColor writable_addr writable_addr16

##

# ------------------------------------------------------------------------------

#Method const uint32_t* addr32(int x, int y) const

#In Readable_Address
Returns readable pixel address at (x, y).

Input is not validated: out of bounds values of x or y trigger an assert() if
built with SK_DEBUG defined.

Will trigger an assert() if Color_Type is not kRGBA_8888_SkColorType or
kBGRA_8888_SkColorType, and is built with SK_DEBUG defined.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  readable unsigned 32-bit pointer to pixel at (x, y) ##

#Example
    const int w = 4;
    const int h = 4;
    uint32_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_8888_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr32(1, 2) %c= &storage[1 + 2 * w]\n",
              pixmap.addr32(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');
#StdOut
pixmap.addr32(1, 2) == &storage[1 + 2 * w]
##
##

#SeeAlso addr() addr8 addr16 addr64 addrF16 getColor writable_addr writable_addr64

##

# ------------------------------------------------------------------------------

#Method const uint64_t* addr64(int x, int y) const

#In Readable_Address
Returns readable pixel address at (x, y).

Input is not validated: out of bounds values of x or y trigger an assert() if
built with SK_DEBUG defined.

Will trigger an assert() if Color_Type is not kRGBA_F16_SkColorType and is built
with SK_DEBUG defined.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  readable unsigned 64-bit pointer to pixel at (x, y) ##

#Example
    const int w = 4;
    const int h = 4;
    uint64_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr64(1, 2) %c= &storage[1 + 2 * w]\n",
              pixmap.addr64(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');
#StdOut
pixmap.addr64(1, 2) == &storage[1 + 2 * w]
##
##

#SeeAlso addr() addr8 addr16 addr32 addrF16 getColor writable_addr writable_addr64

##

# ------------------------------------------------------------------------------

#Method const uint16_t* addrF16(int x, int y) const

#In Readable_Address
Returns readable pixel address at (x, y).

Input is not validated: out of bounds values of x or y trigger an assert() if
built with SK_DEBUG defined.

Will trigger an assert() if Color_Type is not kRGBA_F16_SkColorType and is built
with SK_DEBUG defined.

Each unsigned 16-bit word represents one color component encoded as a half float.
Four words correspond to one pixel.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  readable unsigned 16-bit pointer to pixel component at (x, y) ##

#Example
    const int w = 4;
    const int h = 4;
    const int wordsPerPixel = 4;
    const int rowWords = w * wordsPerPixel;
    uint16_t storage[rowWords * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),
                    storage, rowWords * sizeof(storage[0]));
    SkDebugf("pixmap.addrF16(1, 2) %c= &storage[1 * wordsPerPixel + 2 * rowWords]\n",
              pixmap.addrF16(1, 2)  == &storage[1 * wordsPerPixel + 2 * rowWords] ? '=' : '!');
#StdOut
pixmap.addrF16(1, 2) == &storage[1 * wordsPerPixel + 2 * rowWords]
##
##

#SeeAlso addr() addr8 addr16 addr32 addr64 getColor writable_addr writable_addrF16

##

#Subtopic Readable_Address ##

#Subtopic Writable_Address
#Line # returns writable pixels ##

# ------------------------------------------------------------------------------

#Method void* writable_addr() const

#In Writable_Address
#Line # returns writable pixel address as void pointer ##
Returns writable base pixel address.

#Return  writable generic base pointer to pixels ##

#Example
    const int w = 4;
    const int h = 4;
    SkPMColor storage[w * h * 4];
    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), storage, w * 4);
    SkDebugf("pixmap.writable_addr() %c= (void *)storage\n",
              pixmap.writable_addr()  == (void *)storage ? '=' : '!');
    pixmap.erase(0x00000000);
    *(SkPMColor*)pixmap.writable_addr() = 0xFFFFFFFF;
    SkDebugf("pixmap.getColor(0, 1) %c= 0x00000000\n",
              pixmap.getColor(0, 1)  == 0x00000000 ? '=' : '!');
    SkDebugf("pixmap.getColor(0, 0) %c= 0xFFFFFFFF\n",
              pixmap.getColor(0, 0)  == 0xFFFFFFFF ? '=' : '!');
#StdOut
pixmap.writable_addr() == (void *)storage
pixmap.getColor(0, 1) == 0x00000000
pixmap.getColor(0, 0) == 0xFFFFFFFF
##
##

#SeeAlso writable_addr8 writable_addr16 writable_addr32 writable_addr64 writable_addrF16 addr()

##

# ------------------------------------------------------------------------------

#Method void* writable_addr(int x, int y) const

#In Writable_Address
Returns writable pixel address at (x, y).

Input is not validated: out of bounds values of x or y trigger an assert() if
built with SK_DEBUG defined. Returns zero if Color_Type is kUnknown_SkColorType.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  writable generic pointer to pixel ##

#Example
    const int w = 4;
    const int h = 4;
    SkPMColor storage[w * h * 4];
    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), storage, w * 4);
    SkDebugf("pixmap.writable_addr() %c= (void *)storage\n",
              pixmap.writable_addr()  == (void *)storage ? '=' : '!');
    pixmap.erase(0x00000000);
    *(SkPMColor*)pixmap.writable_addr(1, 2) = 0xFFFFFFFF;
    SkDebugf("pixmap.getColor(0, 0) %c= 0x00000000\n",
              pixmap.getColor(0, 0)  == 0x00000000 ? '=' : '!');
    SkDebugf("pixmap.getColor(1, 2) %c= 0xFFFFFFFF\n",
              pixmap.getColor(1, 2)  == 0xFFFFFFFF ? '=' : '!');
#StdOut
pixmap.writable_addr() == (void *)storage
pixmap.getColor(0, 0) == 0x00000000
pixmap.getColor(1, 2) == 0xFFFFFFFF
##
##

#SeeAlso writable_addr8 writable_addr16 writable_addr32 writable_addr64 writable_addrF16 addr()

##

# ------------------------------------------------------------------------------

#Method uint8_t* writable_addr8(int x, int y) const

#In Writable_Address
#Line # returns writable pixel address as 8-bit pointer ##
Returns writable pixel address at (x, y). Result is addressable as unsigned
8-bit bytes. Will trigger an assert() if Color_Type is not kAlpha_8_SkColorType
or kGray_8_SkColorType, and is built with SK_DEBUG defined.

One byte corresponds to one pixel.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  writable unsigned 8-bit pointer to pixels ##

#Example
#Height 64
#Description
Altering pixels after drawing Bitmap is not guaranteed to affect subsequent
drawing on all platforms. Adding a second SkBitmap::installPixels after editing
pixel memory is safer.
##
void draw(SkCanvas* canvas) {
    uint8_t storage[][5] = {{ 0,   0,  64,   0,  0},
                            { 0, 128, 255, 128,  0},
                            {64, 255, 255, 255, 64},
                            { 0, 128, 255, 128,  0},
                            { 0,   0,  64,   0,  0}};
    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kPremul_SkAlphaType);
    SkPixmap pixmap(imageInfo, storage[0], 5);
    SkBitmap bitmap;
    bitmap.installPixels(pixmap);
    canvas->scale(10, 10);
    canvas->drawBitmap(bitmap, 0, 0);
    *pixmap.writable_addr8(2, 2) = 0;
//  bitmap.installPixels(pixmap);      // uncomment to fix on GPU
    canvas->drawBitmap(bitmap, 10, 0);
}
##

#SeeAlso writable_addr writable_addr16 writable_addr32 writable_addr64 writable_addrF16 addr() addr8

##

# ------------------------------------------------------------------------------

#Method uint16_t* writable_addr16(int x, int y) const

#In Writable_Address
#Line # returns writable pixel address as 16-bit pointer ##
Returns writable_addr pixel address at (x, y). Result is addressable as unsigned
16-bit words. Will trigger an assert() if Color_Type is not kRGB_565_SkColorType
or kARGB_4444_SkColorType, and is built with SK_DEBUG defined.

One word corresponds to one pixel.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  writable unsigned 16-bit pointer to pixel ##

#Example
#Description
Draw a five by five bitmap, and draw it again with a center black pixel.
The low nibble of the 16-bit word is Alpha.
##
#Height 64
    uint16_t storage[][5] = {{ 0xCABF, 0xDABE, 0xCA9D, 0xC96C, 0xA39B },
                             { 0xACEE, 0xA87C, 0x893A, 0x4779, 0x8708 },
                             { 0x4B7C, 0x255B, 0x2559, 0x2557, 0x4656 },
                             { 0x9099, 0x8128, 0x2557, 0x4124, 0x3323 },
                             { 0x7547, 0x5505, 0x4434, 0x2012, 0x0000 }};
    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kARGB_4444_SkColorType, kPremul_SkAlphaType);
    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);
    SkBitmap bitmap;
    bitmap.installPixels(pixmap);
    canvas->scale(10, 10);
    canvas->drawBitmap(bitmap, 0, 0);
    *pixmap.writable_addr16(2, 2) = 0x000F;
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 10, 0);
##

#SeeAlso writable_addr writable_addr8 writable_addr32 writable_addr64 writable_addrF16 addr() addr16

##

# ------------------------------------------------------------------------------

#Method uint32_t* writable_addr32(int x, int y) const

#In Writable_Address
#Line # returns writable pixel address as 32-bit pointer ##
Returns writable pixel address at (x, y). Result is addressable as unsigned
32-bit words. Will trigger an assert() if Color_Type is not
kRGBA_8888_SkColorType or kBGRA_8888_SkColorType, and is built with SK_DEBUG
defined.

One word corresponds to one pixel.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  writable unsigned 32-bit pointer to pixel ##

#Example
#Image 4
#Height 72
    std::vector<int32_t> pixels;
    pixels.resize(image->height() * image->width() * 4);
    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,
            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
    image->readPixels(pixmap, 0, 0);
    for (int y = 0; y < pixmap.height() / 2; ++y) {
        for (int x = 0; x < pixmap.width(); ++x) {
            if ((x & 4) == (y & 4)) {
                *pixmap.writable_addr32(x, y) =
                        *pixmap.writable_addr32(pixmap.width() - x, pixmap.height() - y);
            }
        }
    }
    SkBitmap bitmap;
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso writable_addr writable_addr8 writable_addr16 writable_addr64 writable_addrF16 addr() addr32

##

# ------------------------------------------------------------------------------

#Method uint64_t* writable_addr64(int x, int y) const

#In Writable_Address
#Line # returns writable pixel address as 64-bit pointer ##
Returns writable pixel address at (x, y). Result is addressable as unsigned
64-bit words. Will trigger an assert() if Color_Type is not
kRGBA_F16_SkColorType and is built with SK_DEBUG defined.

One word corresponds to one pixel.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  writable unsigned 64-bit pointer to pixel ##

#Example
#Height 40
    SkImageInfo info = SkImageInfo::Make(3, 3, kRGBA_F16_SkColorType, kPremul_SkAlphaType);
    uint64_t storage[9];
    SkPixmap pixmap(info, storage, 3 * sizeof(uint64_t));
    SkColor4f c4 { 1, 0.45f, 0.25f, 0.65f };
    pixmap.erase(c4);
    SkBitmap bitmap;
    canvas->scale(10, 10);
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
    *pixmap.writable_addr64(1, 1) |= 0x00ff000000000000LL;
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 10, 0);
##

#SeeAlso writable_addr writable_addr8 writable_addr16 writable_addr32 writable_addrF16 addr() addr64

##

# ------------------------------------------------------------------------------

#Method uint16_t* writable_addrF16(int x, int y) const

#In Writable_Address
#Line # returns writable pixel component address as 16-bit pointer ##
Returns writable pixel address at (x, y). Result is addressable as unsigned
16-bit words. Will trigger an assert() if Color_Type is not
kRGBA_F16_SkColorType and is built with SK_DEBUG defined.

Each word represents one color component encoded as a half float.
Four words correspond to one pixel.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return  writable unsigned 16-bit pointer to first component of pixel ##

#Example
#Height 64
#Description
Left bitmap is drawn with two pixels defined in half float format. Right bitmap
is drawn after overwriting bottom half float color with top half float color.
##
    SkImageInfo info = SkImageInfo::Make(1, 2, kRGBA_F16_SkColorType, kPremul_SkAlphaType);
    uint16_t storage[2][4];
    SkPixmap pixmap(info, storage[0], sizeof(uint64_t));
    SkIRect topPixelBounds = {0, 0, 1, 1};
    pixmap.erase({ 0.65f, 0.45f, 0.25f, 1 }, &topPixelBounds);
    SkIRect bottomPixelBounds = {0, 1, 1, 2};
    pixmap.erase({ 0.25f, 0.65f, 0.45f, 1 }, &bottomPixelBounds);
    SkBitmap bitmap;
    canvas->scale(20, 20);
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
    uint16_t* pixel2 = pixmap.writable_addrF16(0, 1);
    for (int i = 0; i < 4; ++i) {
        pixel2[i] = storage[0][i];
    }
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 4, 0);
##

#SeeAlso writable_addr writable_addr8 writable_addr16 writable_addr32 writable_addr64 addr() addrF16

##

#Subtopic Writable_Address ##

#Subtopic Pixels
#Populate
#Line # read and write pixel values ##
##

# ------------------------------------------------------------------------------

#Method bool readPixels(const SkImageInfo& dstInfo, void* dstPixels, size_t dstRowBytes) const
#In Pixels
#Line # copies and converts pixels ##

Copies a Rect of pixels to dstPixels. Copy starts at (0, 0), and does not
exceed Pixmap (width(), height()).

dstInfo specifies width, height, Color_Type, Alpha_Type, and
Color_Space of destination. dstRowBytes specifics the gap from one destination
row to the next. Returns true if pixels are copied. Returns false if
dstInfo.addr() equals nullptr, or dstRowBytes is less than dstInfo.minRowBytes.

Pixels are copied only if pixel conversion is possible. If Pixmap colorType is
kGray_8_SkColorType, or kAlpha_8_SkColorType; dstInfo.colorType must match.
If Pixmap colorType is kGray_8_SkColorType, dstInfo.colorSpace must match.
If Pixmap alphaType is kOpaque_SkAlphaType, dstInfo.alphaType must
match. If Pixmap colorSpace is nullptr, dstInfo.colorSpace must match. Returns
false if pixel conversion is not possible.

Returns false if Pixmap width() or height() is zero or negative.

#Param dstInfo  destination width, height, Color_Type, Alpha_Type, Color_Space ##
#Param dstPixels  destination pixel storage ##
#Param dstRowBytes  destination row length ##

#Return  true if pixels are copied to dstPixels ##

#Example
#Height 128
#Description
Transferring the gradient from 8 bits per component to 4 bits per component
creates visible banding.
##
    std::vector<int32_t> pixels;
    const int width = 256;
    const int height = 64;
    pixels.resize(height * width * 4);
    SkImageInfo srcInfo = SkImageInfo::MakeN32Premul(width, height);
    SkPixmap srcPixmap(srcInfo, (const void*) &pixels.front(), width * 4);
    SkColor  gradColors[] = { 0xFFAA3300, 0x7F881122 };
    SkPoint  gradPoints[] = { { 0, 0 }, { 256, 0 } };
    SkPaint paint;
    paint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,
                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));
    SkBitmap bitmap;
    bitmap.installPixels(srcPixmap);
    SkCanvas srcCanvas(bitmap);
    srcCanvas.drawRect(SkRect::MakeWH(width, height), paint);
    canvas->drawBitmap(bitmap, 0, 0);
    std::vector<int32_t> dstPixels;
    dstPixels.resize(height * width * 2);
    SkImageInfo dstInfo = srcInfo.makeColorType(kARGB_4444_SkColorType);
    srcPixmap.readPixels(dstInfo, &dstPixels.front(), width * 2);
    SkPixmap dstPixmap(dstInfo, &dstPixels.front(), width * 2);
    bitmap.installPixels(dstPixmap);
    canvas->drawBitmap(bitmap, 0, 128);
##

#SeeAlso erase SkBitmap::readPixels SkCanvas::drawBitmap SkCanvas::readPixels SkImage::readPixels SkSurface::readPixels

##

# ------------------------------------------------------------------------------

#Method bool readPixels(const SkImageInfo& dstInfo, void* dstPixels, size_t dstRowBytes, int srcX,
                    int srcY) const

Copies a Rect of pixels to dstPixels. Copy starts at (srcX, srcY), and does not
exceed Pixmap (width(), height()).

dstInfo specifies width, height, Color_Type, Alpha_Type, and
Color_Space of destination. dstRowBytes specifics the gap from one destination
row to the next. Returns true if pixels are copied. Returns false if
dstInfo.addr() equals nullptr, or dstRowBytes is less than dstInfo.minRowBytes.

Pixels are copied only if pixel conversion is possible. If Pixmap colorType is
kGray_8_SkColorType, or kAlpha_8_SkColorType; dstInfo.colorType must match.
If Pixmap colorType is kGray_8_SkColorType, dstInfo.colorSpace must match.
If Pixmap alphaType is kOpaque_SkAlphaType, dstInfo.alphaType must
match. If Pixmap colorSpace is nullptr, dstInfo.colorSpace must match. Returns
false if pixel conversion is not possible.

srcX and srcY may be negative to copy only top or left of source. Returns
false if Pixmap width() or height() is zero or negative. Returns false if:

#Formula
abs(srcX) >= Pixmap width()
##
, or if
#Formula
abs(srcY) >= Pixmap height()
##
.

#Param dstInfo  destination width, height, Color_Type, Alpha_Type, Color_Space ##
#Param dstPixels  destination pixel storage ##
#Param dstRowBytes  destination row length ##
#Param srcX  column index whose absolute value is less than width() ##
#Param srcY  row index whose absolute value is less than height() ##

#Return  true if pixels are copied to dstPixels ##

#Example
#Image 3
void draw(SkCanvas* canvas) {
    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());
    std::vector<int32_t> srcPixels;
    const int rowBytes = image->width() * 4;
    srcPixels.resize(image->height() * rowBytes);
    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);
    image->readPixels(pixmap, 0, 0);
    for (int offset : { 32, 64, 96 } ) {
        std::vector<int32_t> dstPixels;
        dstPixels.resize(image->height() * rowBytes);
        pixmap.readPixels(info, &dstPixels.front(), rowBytes, offset, 0);
        SkBitmap bitmap;
        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);
        bitmap.installPixels(dstmap);
        canvas->translate(32, 32);
        canvas->drawBitmap(bitmap, 0, 0);
    }
}
##

#SeeAlso erase SkBitmap::readPixels SkCanvas::drawBitmap SkCanvas::readPixels SkImage::readPixels SkSurface::readPixels

##

# ------------------------------------------------------------------------------

#Method bool readPixels(const SkPixmap& dst, int srcX, int srcY) const

Copies a Rect of pixels to dst. Copy starts at (srcX, srcY), and does not
exceed Pixmap (width(), height()). dst specifies width, height, Color_Type,
Alpha_Type, and Color_Space of destination.  Returns true if pixels are copied.
Returns false if dst.addr() equals nullptr, or dst.rowBytes is less than
dst SkImageInfo::minRowBytes.

Pixels are copied only if pixel conversion is possible. If Pixmap colorType is
kGray_8_SkColorType, or kAlpha_8_SkColorType; dst.info().colorType must match.
If Pixmap colorType is kGray_8_SkColorType, dst.info().colorSpace must match.
If Pixmap alphaType is kOpaque_SkAlphaType, dst.info().alphaType must
match. If Pixmap colorSpace is nullptr, dst.info().colorSpace must match. Returns
false if pixel conversion is not possible.

srcX and srcY may be negative to copy only top or left of source. Returns
false Pixmap width() or height() is zero or negative. Returns false if:

#Formula
abs(srcX) >= Pixmap width()
##
, or if
#Formula
abs(srcY) >= Pixmap height()
##
.

#Param dst  Image_Info and pixel address to write to ##
#Param srcX  column index whose absolute value is less than width() ##
#Param srcY  row index whose absolute value is less than height() ##

#Return  true if pixels are copied to dst ##

#Example
#Image 3
void draw(SkCanvas* canvas) {
    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());
    std::vector<int32_t> srcPixels;
    const int rowBytes = image->width() * 4;
    srcPixels.resize(image->height() * rowBytes);
    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);
    image->readPixels(pixmap, 0, 0);
    for (int offset : { 32, 64, 96 } ) {
        std::vector<int32_t> dstPixels;
        dstPixels.resize(image->height() * rowBytes);
        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);
        pixmap.readPixels(dstmap, offset, 0);
        SkBitmap bitmap;
        bitmap.installPixels(dstmap);
        canvas->translate(32, 32);
        canvas->drawBitmap(bitmap, 0, 0);
    }
}
##

#SeeAlso erase SkBitmap::readPixels SkCanvas::drawBitmap SkCanvas::readPixels SkImage::readPixels SkSurface::readPixels

##

# ------------------------------------------------------------------------------

#Method bool readPixels(const SkPixmap& dst) const

Copies pixels inside bounds() to dst. dst specifies width, height, Color_Type,
Alpha_Type, and Color_Space of destination.  Returns true if pixels are copied.
Returns false if dst.addr() equals nullptr, or dst.rowBytes is less than
dst SkImageInfo::minRowBytes.

Pixels are copied only if pixel conversion is possible. If Pixmap colorType is
kGray_8_SkColorType, or kAlpha_8_SkColorType; dst Color_Type must match.
If Pixmap colorType is kGray_8_SkColorType, dst Color_Space must match.
If Pixmap alphaType is kOpaque_SkAlphaType, dst Alpha_Type must
match. If Pixmap colorSpace is nullptr, dst Color_Space must match. Returns
false if pixel conversion is not possible.

Returns false if Pixmap width() or height() is zero or negative.

#Param dst  Image_Info and pixel address to write to ##

#Return  true if pixels are copied to dst ##

#Example
#Image 3
void draw(SkCanvas* canvas) {
    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());
    std::vector<int32_t> srcPixels;
    const int rowBytes = image->width() * 4;
    srcPixels.resize(image->height() * rowBytes);
    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);
    image->readPixels(pixmap, 0, 0);
    for (int index = 0; index < 3; ++index ) {
        std::vector<int32_t> dstPixels;
        dstPixels.resize(image->height() * rowBytes);
        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);
        pixmap.readPixels(dstmap);
        SkBitmap bitmap;
        bitmap.installPixels(dstmap);
        canvas->translate(32, 32);
        canvas->drawBitmap(bitmap, 0, 0);
    }
}
##

#SeeAlso erase SkBitmap::readPixels SkCanvas::drawBitmap SkCanvas::readPixels SkImage::readPixels SkSurface::readPixels

##

# ------------------------------------------------------------------------------

#Method bool scalePixels(const SkPixmap& dst, SkFilterQuality filterQuality) const

#In Pixels
#Line # scales and converts pixels ##
Copies Bitmap to dst, scaling pixels to fit dst.width() and dst.height(), and
converting pixels to match dst.colorType and dst.alphaType. Returns true if
pixels are copied. Returns false if dst.addr() is nullptr, or dst.rowBytes is
less than dst SkImageInfo::minRowBytes.

Pixels are copied only if pixel conversion is possible. If Pixmap colorType is
kGray_8_SkColorType, or kAlpha_8_SkColorType; dst Color_Type must match.
If Pixmap colorType is kGray_8_SkColorType, dst Color_Space must match.
If Pixmap alphaType is kOpaque_SkAlphaType, dst Alpha_Type must
match. If Pixmap colorSpace is nullptr, dst Color_Space must match. Returns
false if pixel conversion is not possible.

Returns false if Bitmap width() or height() is zero or negative.

Scales the image, with filterQuality, to match dst.width() and dst.height().
filterQuality kNone_SkFilterQuality is fastest, typically implemented with
Filter_Quality_Nearest_Neighbor. kLow_SkFilterQuality is typically implemented with
Filter_Quality_Bilerp. kMedium_SkFilterQuality is typically implemented with
Filter_Quality_Bilerp, and Filter_Quality_MipMap when size is reduced.
kHigh_SkFilterQuality is slowest, typically implemented with Filter_Quality_BiCubic.

#Param dst  Image_Info and pixel address to write to ##
#Param filterQuality  one of: kNone_SkFilterQuality, kLow_SkFilterQuality,
                      kMedium_SkFilterQuality, kHigh_SkFilterQuality
##

#Return  true if pixels are scaled to fit dst ##

#Example
#Image 3
void draw(SkCanvas* canvas) {
    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());
    std::vector<int32_t> srcPixels;
    int rowBytes = image->width() * 4;
    srcPixels.resize(image->height() * rowBytes);
    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);
    image->readPixels(pixmap, 0, 0);
    for (int offset : { 32, 64, 96 } ) {
        info = SkImageInfo::MakeN32Premul(image->width() + offset, image->height());
        rowBytes = info.width() * 4;
        std::vector<int32_t> dstPixels;
        dstPixels.resize(image->height() * rowBytes);
        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);
        pixmap.scalePixels(dstmap, kMedium_SkFilterQuality);
        SkBitmap bitmap;
        bitmap.installPixels(dstmap);
        canvas->translate(32, 32);
        canvas->drawBitmap(bitmap, 0, 0);
    }
}
##

#SeeAlso SkCanvas::drawBitmap SkImage::scalePixels

##

# ------------------------------------------------------------------------------

#Method bool erase(SkColor color, const SkIRect& subset) const

#In Pixels
#Line # writes Color to pixels ##
Writes color to pixels bounded by subset; returns true on success.
Returns false if colorType is kUnknown_SkColorType, or if subset does
not intersect bounds().

#Param color  Unpremultiplied Color to write ##
#Param subset bounding integer Rect of written pixels ##

#Return  true if pixels are changed ##

#Example
#Height 50
    uint32_t storage[2];
    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);
    SkPixmap pixmap(info, storage, info.minRowBytes());
    pixmap.erase(SK_ColorBLUE, {0, 0, 1, 1});
    pixmap.erase(SK_ColorRED, {0, 1, 1, 2});
    SkBitmap bitmap;
    canvas->scale(20, 20);
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso SkBitmap::erase SkCanvas::clear SkCanvas::drawColor

##

# ------------------------------------------------------------------------------

#Method bool erase(SkColor color) const

Writes color to pixels inside bounds(); returns true on success.
Returns false if colorType is kUnknown_SkColorType, or if bounds()
is empty.

#Param color  Unpremultiplied Color to write ##

#Return  true if pixels are changed ##

#Example
#Height 50
    uint32_t storage[2];
    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);
    SkPixmap pixmap(info, storage, info.minRowBytes());
    pixmap.erase(SK_ColorBLUE);
    SkBitmap bitmap;
    canvas->scale(20, 20);
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso SkBitmap::erase SkCanvas::clear SkCanvas::drawColor

##

# ------------------------------------------------------------------------------

#Method bool erase(const SkColor4f& color, const SkIRect* subset = nullptr) const

Writes color to pixels bounded by subset; returns true on success.
if subset is nullptr, writes colors pixels inside bounds(). Returns false if
colorType is kUnknown_SkColorType, if subset is not nullptr and does
not intersect bounds(), or if subset is nullptr and bounds() is empty.

#Param color  Unpremultiplied Color to write ##
#Param subset  bounding integer Rect of pixels to write; may be nullptr ##

#Return  true if pixels are changed ##

#Example
#Height 50
    uint32_t storage[2];
    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);
    SkPixmap pixmap(info, storage, info.minRowBytes());
    SkIRect topPixelBounds = {0, 0, 1, 1};
    pixmap.erase({ 0.65f, 0.45f, 0.25f, 1 }, &topPixelBounds);
    SkIRect bottomPixelBounds = {0, 1, 1, 2};
    pixmap.erase({ 0.25f, 0.65f, 0.45f, 1 }, &bottomPixelBounds);
    SkBitmap bitmap;
    canvas->scale(20, 20);
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso SkBitmap::erase SkCanvas::clear SkCanvas::drawColor

##

#Class SkPixmap ##

#Topic Pixmap ##
