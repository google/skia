<!DOCTYPE html>

<html lang="en" xmlns="https://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title></title>

<script type="text/javascript">
    var text = {
        "Path_Conic_Weight": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* verbNames[] = { \"move\", \"line\", \"quad\", \"conic\", \"cubic\", \"close\", \"done\" };\n    const int pointCount[]  = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n    SkPath path;\n    path.conicTo(20, 30, 50, 60, 1);\n    SkPath::Iter iter(path, false);\n    SkPath::Verb verb;\n    do {\n       SkPoint points[4];\n       verb = iter.next(points);\n       SkDebugf(\"%s \", verbNames[(int) verb]);\n       for (int i = 0; i < pointCount[(int) verb]; ++i) {\n            SkDebugf(\"{%g, %g}, \", points[i].fX, points[i].fY);\n       }\n       if (SkPath::kConic_Verb == verb) {\n           SkDebugf(\"weight = %g\", iter.conicWeight());\n       }\n       SkDebugf(\"\\n\");\n    } while (SkPath::kDone_Verb != verb);\n}\n",
    "hash": "2aadded3d20dfef34d1c8abe28c7bc8d",
    "file": "SkPath_Reference",
    "name": "Conic_Weight",
        "stdout": "move {0, 0}, \\nquad {0, 0}, {20, 30}, {50, 60}, \\ndone \\n"
    },
        "Path_Conic_Weight_a": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* verbNames[] = { \"move\", \"line\", \"quad\", \"conic\", \"cubic\", \"close\", \"done\" };\n    const int pointCount[]  = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n    SkPath path;\n    path.arcTo(20, 0, 20, 20, 20);\n    SkPath::Iter iter(path, false);\n    SkPath::Verb verb;\n    do {\n       SkPoint points[4];\n       verb = iter.next(points);\n       SkDebugf(\"%s \", verbNames[(int) verb]);\n       for (int i = 0; i < pointCount[(int) verb]; ++i) {\n            SkDebugf(\"{%g, %g}, \", points[i].fX, points[i].fY);\n       }\n       if (SkPath::kConic_Verb == verb) {\n           SkDebugf(\"weight = %g\", iter.conicWeight());\n       }\n       SkDebugf(\"\\n\");\n    } while (SkPath::kDone_Verb != verb);\n}\n",
    "hash": "e88f554efacfa9f75f270fb1c0add5b4",
    "file": "SkPath_Reference",
    "name": "Conic_Weight_2",
        "stdout": "move {0, 0}, \\nconic {0, 0}, {20, 0}, {20, 20}, weight = 0.707107\\ndone \\n"
    },
        "Path_Conic_Weight_b": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* verbNames[] = { \"move\", \"line\", \"quad\", \"conic\", \"cubic\", \"close\", \"done\" };\n    const int pointCount[]  = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n    SkPath path;\n    path.conicTo(20, 0, 20, 20, SK_ScalarInfinity);\n    SkPath::Iter iter(path, false);\n    SkPath::Verb verb;\n    do {\n       SkPoint points[4];\n       verb = iter.next(points);\n       SkDebugf(\"%s \", verbNames[(int) verb]);\n       for (int i = 0; i < pointCount[(int) verb]; ++i) {\n            SkDebugf(\"{%g, %g}, \", points[i].fX, points[i].fY);\n       }\n       if (SkPath::kConic_Verb == verb) {\n           SkDebugf(\"weight = %g\", iter.conicWeight());\n       }\n       SkDebugf(\"\\n\");\n    } while (SkPath::kDone_Verb != verb);\n}\n",
    "hash": "6fb11419e99297fe2fe666c296117fb9",
    "file": "SkPath_Reference",
    "name": "Conic_Weight_3",
        "stdout": "move {0, 0}, \\nline {0, 0}, {20, 0}, \\nline {20, 0}, {20, 20}, \\ndone \\n"
    },
        "SkAutoCanvasRestore_restore": {
    "code": "void draw(SkCanvas* canvas) {\n    for (bool callRestore : { false, true } ) {\n        for (bool saveCanvas : {false, true} ) {\n            SkAutoCanvasRestore autoRestore(canvas, saveCanvas);\n            if (!saveCanvas) {\n                canvas->save();\n            }\n            SkDebugf(\"saveCanvas: %s  before restore: %d\\n\",\n                   saveCanvas ? \"true\" : \"false\", canvas->getSaveCount());\n            if (callRestore) autoRestore.restore();\n            SkDebugf(\"saveCanvas: %s  after restore: %d\\n\",\n                   saveCanvas ? \"true\" : \"false\", canvas->getSaveCount());\n        }\n    }\n    SkDebugf(\"final count: %d\\n\", canvas->getSaveCount());\n}",
    "hash": "9f459b218ec079c1ada23f4412968f9a",
    "file": "SkAutoCanvasRestore_Reference",
    "name": "SkAutoCanvasRestore::restore()",
        "stdout": "saveCanvas: false  before restore: 2\\nsaveCanvas: false  after restore: 2\\nsaveCanvas: true  before restore: 2\\nsaveCanvas: true  after restore: 2\\nsaveCanvas: false  before restore: 2\\nsaveCanvas: false  after restore: 1\\nsaveCanvas: true  before restore: 2\\nsaveCanvas: true  after restore: 1\\nfinal count: 1\\n"
    },
        "SkBitmap_ComputeIsOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::Make(2, 2, kN32_SkColorType, kPremul_SkAlphaType));\n    for (int index = 0; index < 2; ++index) {\n        bitmap.allocPixels();\n        bitmap.eraseColor(0x00000000);\n        SkDebugf(\"computeIsOpaque: %s\\n\", SkBitmap::ComputeIsOpaque(bitmap) ? \"true\" : \"false\");\n        bitmap.eraseColor(0xFFFFFFFF);\n        SkDebugf(\"computeIsOpaque: %s\\n\", SkBitmap::ComputeIsOpaque(bitmap) ? \"true\" : \"false\");\n        bitmap.setInfo(bitmap.info().makeAlphaType(kOpaque_SkAlphaType));\n    }\n}",
    "hash": "9df1baa17658fbd0c419780f26fd854f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::ComputeIsOpaque",
        "stdout": "computeIsOpaque: false\\ncomputeIsOpaque: true\\ncomputeIsOpaque: false\\ncomputeIsOpaque: true\\n"
    },
        "SkBitmap_HeapAllocator_allocPixelRef": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(16, 16, kPremul_SkAlphaType));\n    SkDebugf(\"pixel address = %p\\n\", bitmap.getPixels());\n    SkBitmap::HeapAllocator stdalloc;\n    if (!stdalloc.allocPixelRef(&bitmap)) {\n        SkDebugf(\"pixel allocation failed\\n\");\n    } else {\n        SkDebugf(\"pixel address = %p\\n\", bitmap.getPixels());\n    }\n}",
    "hash": "fe79a9c1ec350264eb9c7b2509dd3638",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::HeapAllocator::allocPixelRef",
        "stdout": "pixel address = (nil)\\npixel address = 0x560ddd0ac670\\n\\n"
    },
        "SkBitmap_alphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);\n    SkDebugf(\"alpha type: k\" \"%s\" \"_SkAlphaType\\n\", alphas[pixmap.alphaType()]);\n}",
    "hash": "070b1a60232be499eb10c6ea62371804",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::alphaType",
        "stdout": "alpha type: kPremul_SkAlphaType\\n"
    },
        "SkBitmap_bytesPerPixel": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkImageInfo info = SkImageInfo::MakeA8(1, 1);\n    SkBitmap bitmap;\n    for (SkColorType colorType : {\n    kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType,\n    kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType,\n    kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType,\n    kGray_8_SkColorType, kRGBA_F16_SkColorType\n                                 } ) {\n        bitmap.setInfo(info.makeColorType(colorType));\n        SkDebugf(\"color: k\" \"%s\" \"_SkColorType\" \"%*s\" \"bytesPerPixel: %d\\n\",\n                colors[colorType], 13 - strlen(colors[colorType]), \" \",\n                bitmap.bytesPerPixel());\n    }\n}",
    "hash": "2a688e6f0a516c0d44a826381e9d637f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::bytesPerPixel",
        "stdout": "color: kUnknown_SkColorType      bytesPerPixel: 0\\ncolor: kAlpha_8_SkColorType      bytesPerPixel: 1\\ncolor: kRGB_565_SkColorType      bytesPerPixel: 2\\ncolor: kARGB_4444_SkColorType    bytesPerPixel: 2\\ncolor: kRGBA_8888_SkColorType    bytesPerPixel: 4\\ncolor: kRGB_888x_SkColorType     bytesPerPixel: 4\\ncolor: kBGRA_8888_SkColorType    bytesPerPixel: 4\\ncolor: kRGBA_1010102_SkColorType bytesPerPixel: 4\\ncolor: kRGB_101010x_SkColorType  bytesPerPixel: 4\\ncolor: kGray_8_SkColorType       bytesPerPixel: 1\\ncolor: kRGBA_F16_SkColorType     bytesPerPixel: 8\\n"
    },
        "SkBitmap_colorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,\n            SkColorSpace::MakeSRGBLinear()));\n    SkColorSpace* colorSpace = bitmap.colorSpace();\n    SkDebugf(\"gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\\n\",\n            colorSpace->gammaCloseToSRGB() ? \"true\" : \"false\",\n            colorSpace->gammaIsLinear() ? \"true\" : \"false\",\n            colorSpace->isSRGB() ? \"true\" : \"false\");\n}",
    "hash": "817f95879fadba44baf87ea60e9b595a",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::colorSpace",
        "stdout": "gammaCloseToSRGB: false  gammaIsLinear: true  isSRGB: false\\n"
    },
        "SkBitmap_colorType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeA8(16, 32));\n    SkDebugf(\"color type: k\" \"%s\" \"_SkColorType\\n\", colors[bitmap.colorType()]);\n}",
    "hash": "ceb77fab7326b57822a147b04aa0960e",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::colorType",
        "stdout": "color type: kAlpha_8_SkColorType\\n"
    },
        "SkBitmap_computeByteSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    for (int width : { 1, 1000, 1000000 } ) {\n        for (int height: { 1, 1000, 1000000 } ) {\n            SkImageInfo imageInfo = SkImageInfo::MakeN32(width, height, kPremul_SkAlphaType);\n            bitmap.setInfo(imageInfo, width * 5);\n            SkDebugf(\"width: %7d height: %7d computeByteSize: %13lld\\n\", width, height,\n                     bitmap.computeByteSize());\n        }\n    }\n}",
    "hash": "165c8f208829fc0908e8a50da60c0076",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::computeByteSize",
        "stdout": "width:       1 height:       1 computeByteSize:             4\\nwidth:       1 height:    1000 computeByteSize:          4999\\nwidth:       1 height: 1000000 computeByteSize:       4999999\\nwidth:    1000 height:       1 computeByteSize:          4000\\nwidth:    1000 height:    1000 computeByteSize:       4999000\\nwidth:    1000 height: 1000000 computeByteSize:    4999999000\\nwidth: 1000000 height:       1 computeByteSize:       4000000\\nwidth: 1000000 height:    1000 computeByteSize:    4999000000\\nwidth: 1000000 height: 1000000 computeByteSize: 4999999000000\\n"
    },
        "SkBitmap_copy_const_SkBitmap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original;\n    if (original.tryAllocPixels(\n            SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType))) {\n        SkDebugf(\"original has pixels before copy: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n        SkBitmap copy(original);\n        SkDebugf(\"original has pixels after copy: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n        SkDebugf(\"copy has pixels: %s\\n\", copy.getPixels() ? \"true\" : \"false\");\n    }\n}\n",
    "hash": "bbbae7a181bfd128a4484e8e9f454db1",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::SkBitmap(const SkBitmap& src)",
        "stdout": "original has pixels before copy: true\\noriginal has pixels after copy: true\\ncopy has pixels: true\\n"
    },
        "SkBitmap_copy_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original;\n    if (original.tryAllocPixels(\n            SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType))) {\n        SkDebugf(\"original has pixels before copy: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n        SkBitmap copy = original;\n        SkDebugf(\"original has pixels after copy: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n        SkDebugf(\"copy has pixels: %s\\n\", copy.getPixels() ? \"true\" : \"false\");\n    }\n}\n",
    "hash": "45279c519ae808f78bd30e9d84bdfdde",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::operator=(const SkBitmap& src)",
        "stdout": "original has pixels before copy: true\\noriginal has pixels after copy: true\\ncopy has pixels: true\\n"
    },
        "SkBitmap_dimensions": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(33, 55, kOpaque_SkAlphaType));\n    SkISize dimensions = bitmap.dimensions();\n    SkRect bounds;\n    bitmap.getBounds(&bounds);\n    SkRect dimensionsAsBounds = SkRect::Make(dimensions);\n    SkDebugf(\"dimensionsAsBounds %c= bounds\\n\", dimensionsAsBounds == bounds ? '=' : '!');\n}",
    "hash": "647056bcc12c27fb4413f212f33a2898",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::dimensions()",
        "stdout": "dimensionsAsBounds == bounds\\n"
    },
        "SkBitmap_drawsNothing": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    for (int w : { 0, 8 } ) {\n        for (bool allocate : { false, true} ) {\n            bitmap.setInfo(SkImageInfo::MakeA8(w, 8));\n            allocate ? bitmap.allocPixels() : (void) 0 ;\n            SkDebugf(\"empty:%s isNull:%s drawsNothing:%s\\n\", bitmap.empty() ? \"true \" : \"false\",\n                     bitmap.isNull() ? \"true \" : \"false\", bitmap.drawsNothing() ? \"true\" : \"false\");\n        }\n    }\n}",
    "hash": "daacf43394ce4045a362a48b5774deed",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::drawsNothing",
        "stdout": "empty:true  isNull:true  drawsNothing:true\\nempty:true  isNull:false drawsNothing:true\\nempty:false isNull:true  drawsNothing:true\\nempty:false isNull:false drawsNothing:false\\n"
    },
        "SkBitmap_empty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    for (int width : { 0, 2 } ) {\n        for (int height : { 0, 2 } ) {\n             bitmap.setInfo(SkImageInfo::MakeA8(width, height));\n             SkDebugf(\"width: %d height: %d empty: %s\\n\", width, height,\n                      bitmap.empty() ? \"true\" : \"false\");\n        }\n    }\n}",
    "hash": "a3762c2722b56ba55e42689c527f146c",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::empty()",
        "stdout": "width: 0 height: 0 empty: true\\nwidth: 0 height: 2 empty: true\\nwidth: 2 height: 0 empty: true\\nwidth: 2 height: 2 empty: false\\n"
    },
        "SkBitmap_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkBitmap bitmap;\n    for (int i = 0; i < 2; ++i) {\n       SkDebugf(\"width: %2d  height: %2d\", bitmap.width(), bitmap.height());\n       SkDebugf(\"  color: k%s_SkColorType\", colors[bitmap.colorType()]);\n       SkDebugf(\"  alpha: k%s_SkAlphaType\\n\", alphas[bitmap.alphaType()]);\n       bitmap.setInfo(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType),\n                      0);\n    }\n}\n",
    "hash": "6739d14ec0d6a373f2fcadc6b3077fd4",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::SkBitmap()",
        "stdout": "width:  0  height:  0  color: kUnknown_SkColorType  alpha: kUnknown_SkAlphaType\\nwidth: 25  height: 35  color: kRGBA_8888_SkColorType  alpha: kOpaque_SkAlphaType\\n"
    },
        "SkBitmap_extractSubset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect bounds, s;\n    source.getBounds(&bounds);\n    SkDebugf(\"bounds: %d, %d, %d, %d\\n\", bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    SkBitmap subset;\n    for (int left: { -100, 0, 100, 1000 } ) {\n         for (int right: { 0, 100, 1000 } ) {\n             SkIRect b = SkIRect::MakeLTRB(left, 100, right, 200);\n             bool success = source.extractSubset(&subset, b);\n             SkDebugf(\"subset: %4d, %4d, %4d, %4d  \", b.fLeft, b.fTop, b.fRight, b.fBottom);\n             SkDebugf(\"success; %s\", success ? \"true\" : \"false\");\n             if (success) {\n                 subset.getBounds(&s);\n                 SkDebugf(\"  subset: %d, %d, %d, %d\", s.fLeft, s.fTop, s.fRight, s.fBottom);\n             }\n             SkDebugf(\"\\n\");\n         }\n    }\n}",
    "hash": "304148c50c91490bfd58e9222342419c",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::extractSubset",
        "stdout": "bounds: 0, 0, 512, 512\\nsubset: -100,  100,    0,  200  success; false\\nsubset: -100,  100,  100,  200  success; true  subset: 0, 0, 100, 100\\nsubset: -100,  100, 1000,  200  success; true  subset: 0, 0, 512, 100\\nsubset:    0,  100,    0,  200  success; false\\nsubset:    0,  100,  100,  200  success; true  subset: 0, 0, 100, 100\\nsubset:    0,  100, 1000,  200  success; true  subset: 0, 0, 512, 100\\nsubset:  100,  100,    0,  200  success; false\\nsubset:  100,  100,  100,  200  success; false\\nsubset:  100,  100, 1000,  200  success; true  subset: 0, 0, 412, 100\\nsubset: 1000,  100,    0,  200  success; false\\nsubset: 1000,  100,  100,  200  success; false\\nsubset: 1000,  100, 1000,  200  success; false\\n"
    },
        "SkBitmap_getAddr": {
    "code": "void draw(SkCanvas* canvas) {\n    char* row0 = (char* ) source.getAddr(0, 0);\n    char* row1 = (char* ) source.getAddr(0, 1);\n    SkDebugf(\"addr interval %c= rowBytes\\n\",\n             (size_t) (row1 - row0) == source.rowBytes() ? '=' : '!');\n}",
    "hash": "ffcefb2344cd38c3b99f69cfe6d64a17",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getAddr",
        "stdout": "addr interval == rowBytes\\n"
    },
        "SkBitmap_getAddr16": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap16;\n    SkImageInfo dstInfo = SkImageInfo::Make(source.width(), source.height(), kARGB_4444_SkColorType,\n                     kPremul_SkAlphaType);\n    bitmap16.allocPixels(dstInfo);\n    if (source.readPixels(dstInfo, bitmap16.getPixels(), bitmap16.rowBytes(), 0, 0)) {\n        uint16_t* row0 = bitmap16.getAddr16(0, 0);\n        uint16_t* row1 = bitmap16.getAddr16(0, 1);\n        size_t interval = (row1 - row0) * bitmap16.bytesPerPixel();\n        SkDebugf(\"addr interval %c= rowBytes\\n\", interval == bitmap16.rowBytes() ? '=' : '!');\n    }\n}",
    "hash": "53e00899ef2e00e2096daf7a07d9b059",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getAddr16",
        "stdout": "addr interval == rowBytes\\n"
    },
        "SkBitmap_getAddr32": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t* row0 = source.getAddr32(0, 0);\n    uint32_t* row1 = source.getAddr32(0, 1);\n    size_t interval = (row1 - row0) * source.bytesPerPixel();\n    SkDebugf(\"addr interval %c= rowBytes\\n\", interval == source.rowBytes() ? '=' : '!');\n}",
    "hash": "837a2bcc9fb9ce617a3420956cefc64a",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getAddr32",
        "stdout": "addr interval == rowBytes\\n"
    },
        "SkBitmap_getAddr8": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    const int width = 8;\n    const int height = 8;\n    uint8_t pixels[height][width];\n    SkImageInfo info = SkImageInfo::Make(width, height, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    if (bitmap.installPixels(info, pixels, info.minRowBytes())) {\n        SkDebugf(\"&pixels[4][2] %c= bitmap.getAddr8(2, 4)\\n\",\n                  &pixels[4][2]  == bitmap.getAddr8(2, 4) ? '=' : '!');\n    }\n}",
    "hash": "cb9a08e8ff779b6a1cf8bb54f3883aaf",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getAddr8",
        "stdout": "&pixels[4][2] == bitmap.getAddr8(2, 4)\\n"
    },
        "SkBitmap_getColor": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    SkColor colors[][w] = {\n        { 0x00000000, 0x2a0e002a, 0x55380055, 0x7f7f007f },\n        { 0x2a000e2a, 0x551c1c55, 0x7f542a7f, 0xaaaa38aa },\n        { 0x55003855, 0x7f2a547f, 0xaa7171aa, 0xd4d48dd4 },\n        { 0x7f007f7f, 0xaa38aaaa, 0xd48dd4d4, 0xffffffff }\n    };\n    SkDebugf(\"Premultiplied:\\n\");\n    for (int y = 0; y < h; ++y) {\n        SkDebugf(\"(0, %d) \", y);\n        for (int x = 0; x < w; ++x) {\n            SkDebugf(\"0x%08x%c\", colors[y][x], x == w - 1 ? '\\n' : ' ');\n        }\n    }\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), colors, w * 4);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    SkDebugf(\"Unpremultiplied:\\n\");\n    for (int y = 0; y < h; ++y) {\n        SkDebugf(\"(0, %d) \", y);\n        for (int x = 0; x < w; ++x) {\n            SkDebugf(\"0x%08x%c\", bitmap.getColor(x, y), x == w - 1 ? '\\n' : ' ');\n        }\n    }\n}",
    "hash": "193d1f6d8a43b7a8e9f27ba21de38617",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getColor",
        "stdout": "Premultiplied:\\n(0, 0) 0x00000000 0x2a0e002a 0x55380055 0x7f7f007f\\n(0, 1) 0x2a000e2a 0x551c1c55 0x7f542a7f 0xaaaa38aa\\n(0, 2) 0x55003855 0x7f2a547f 0xaa7171aa 0xd4d48dd4\\n(0, 3) 0x7f007f7f 0xaa38aaaa 0xd48dd4d4 0xffffffff\\nUnpremultiplied:\\n(0, 0) 0x00000000 0x2a5500ff 0x55a800ff 0x7fff00ff\\n(0, 1) 0x2a0055ff 0x555454ff 0x7fa954ff 0xaaff54ff\\n(0, 2) 0x5500a8ff 0x7f54a9ff 0xaaaaaaff 0xd4ffaaff\\n(0, 3) 0x7f00ffff 0xaa54ffff 0xd4aaffff 0xffffffff\\n"
    },
        "SkBitmap_getGenerationID": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    SkDebugf(\"empty id %u\\n\", bitmap.getGenerationID());\n    bitmap.allocPixels(SkImageInfo::MakeN32(64, 64, kOpaque_SkAlphaType));\n    SkDebugf(\"alloc id %u\\n\", bitmap.getGenerationID());\n    bitmap.eraseColor(SK_ColorRED);\n    SkDebugf(\"erase id %u\\n\", bitmap.getGenerationID());\n}",
    "hash": "db9dd91e0207c3941c09538555817b4b",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getGenerationID",
        "stdout": "empty id 0\\nalloc id 4\\nerase id 6\\n\\n"
    },
        "SkBitmap_getPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(4, 4, kPremul_SkAlphaType));\n    bitmap.allocPixels();\n    bitmap.eraseColor(0x00000000);\n    void* baseAddr = bitmap.getPixels();\n    *(SkPMColor*)baseAddr = 0xFFFFFFFF;\n    SkDebugf(\"bitmap.getColor(0, 1) %c= 0x00000000\\n\",\n              bitmap.getColor(0, 1)  == 0x00000000 ? '=' : '!');\n    SkDebugf(\"bitmap.getColor(0, 0) %c= 0xFFFFFFFF\\n\",\n              bitmap.getColor(0, 0)  == 0xFFFFFFFF ? '=' : '!');\n}",
    "hash": "e006bb05cf74ec8d2b3d6adeb5dba11b",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getPixels",
        "stdout": "bitmap.getColor(0, 1) == 0x00000000\\nbitmap.getColor(0, 0) == 0xFFFFFFFF\\n"
    },
        "SkBitmap_getSubset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect bounds;\n    source.getBounds(&bounds);\n    bounds.inset(100, 100);\n    SkBitmap subset;\n    source.extractSubset(&subset, bounds);\n    SkIRect r = source.getSubset();\n    SkDebugf(\"source: %d, %d, %d, %d\\n\", r.fLeft, r.fTop, r.fRight, r.fBottom);\n    r = subset.getSubset();\n    SkDebugf(\"subset: %d, %d, %d, %d\\n\", r.fLeft, r.fTop, r.fRight, r.fBottom);\n}",
    "hash": "d6dd0b425aa550f21b938a18c2e1a981",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getSubset",
        "stdout": "source: 0, 0, 512, 512\\nsubset: 100, 100, 412, 412\\n"
    },
        "SkBitmap_height": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeA8(16, 32);\n    SkBitmap bitmap;\n    bitmap.setInfo(info);\n    SkDebugf(\"bitmap height: %d  info height: %d\\n\", bitmap.height(), info.height());\n}",
    "hash": "c79a196278c58b34cd5f551b0124ecc9",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::height()",
        "stdout": "bitmap height: 32  info height: 32\\n"
    },
        "SkBitmap_info": {
    "code": "void draw(SkCanvas* canvas) {\n    // SkBitmap source;  // pre-populated with soccer ball by fiddle.skia.org\n    const SkImageInfo& info = source.info();\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkDebugf(\"width: %d height: %d color: %s alpha: %s\\n\", info.width(), info.height(),\n                colors[info.colorType()], alphas[info.alphaType()]);\n}\n",
    "hash": "ec47c4dc23e2925ad565eaba55a91553",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::info()",
        "stdout": "width: 56 height: 56 color: BGRA_8888 alpha: Opaque\\n"
    },
        "SkBitmap_installPixels": {
    "code": "static void releaseProc(void* addr, void* ) {\n    SkDebugf(\"releaseProc called\\n\");\n    delete[] (uint32_t*) addr;\n}\n\nvoid draw(SkCanvas* canvas) {\n   SkBitmap bitmap;\n   void* pixels = new uint32_t[8 * 8];\n   SkImageInfo info = SkImageInfo::MakeN32(8, 8, kOpaque_SkAlphaType);\n   SkDebugf(\"before installPixels\\n\");\n   bool installed = bitmap.installPixels(info, pixels, 16, releaseProc, nullptr);\n   SkDebugf(\"install \" \"%s\" \"successful\\n\", installed ? \"\" : \"not \");\n}\n",
    "hash": "8c4f7bf73fffa1a812ee8e88e44e639c",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::installPixels",
        "stdout": "before installPixels\\nreleaseProc called\\ninstall not successful\\n"
    },
        "SkBitmap_isImmutable": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original;\n    SkImageInfo info = SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType);\n    if (original.tryAllocPixels(info)) {\n        original.setImmutable();\n        SkBitmap copy;\n        original.extractSubset(&copy, {5, 10, 15, 20});\n        SkDebugf(\"original is \" \"%s\" \"immutable\\n\", original.isImmutable() ? \"\" : \"not \");\n        SkDebugf(\"copy is \" \"%s\" \"immutable\\n\", copy.isImmutable() ? \"\" : \"not \");\n    }\n}",
    "hash": "db61fdcd382342ee88ea1b4f27c27b95",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::isImmutable",
        "stdout": "original is immutable\\ncopy is immutable\\n"
    },
        "SkBitmap_isNull": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    SkDebugf(\"empty bitmap does %shave pixels\\n\", bitmap.isNull() ? \"not \" : \"\");\n    bitmap.setInfo(SkImageInfo::MakeA8(8, 8));\n    SkDebugf(\"bitmap with dimensions does %shave pixels\\n\", bitmap.isNull() ? \"not \" : \"\");\n    bitmap.allocPixels();\n    SkDebugf(\"allocated bitmap does %shave pixels\\n\", bitmap.isNull() ? \"not \" : \"\");\n}",
    "hash": "211ec89418011aa6e54aa2cc9567e003",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::isNull",
        "stdout": "empty bitmap does not have pixels\\nbitmap with dimensions does not have pixels\\nallocated bitmap does have pixels\\n"
    },
        "SkBitmap_isOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    const int height = 2;\n    const int width = 2;\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::Make(width, height, kN32_SkColorType, kPremul_SkAlphaType));\n    for (int index = 0; index < 2; ++index) {\n        bitmap.allocPixels();\n        bitmap.eraseColor(0x00000000);\n        SkDebugf(\"isOpaque: %s\\n\", bitmap.isOpaque() ? \"true\" : \"false\");\n        bitmap.eraseColor(0xFFFFFFFF);\n        SkDebugf(\"isOpaque: %s\\n\", bitmap.isOpaque() ? \"true\" : \"false\");\n        bitmap.setInfo(bitmap.info().makeAlphaType(kOpaque_SkAlphaType));\n    }\n}",
    "hash": "5e76b68bb46d54315eb0c12d83bd6949",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::isOpaque",
        "stdout": "isOpaque: false\\nisOpaque: false\\nisOpaque: true\\nisOpaque: true\\n"
    },
        "SkBitmap_isVolatile": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original;\n    SkImageInfo info = SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType);\n    if (original.tryAllocPixels(info)) {\n        original.setIsVolatile(true);\n        SkBitmap copy;\n        original.extractSubset(&copy, {5, 10, 15, 20});\n        SkDebugf(\"original is \" \"%s\" \"volatile\\n\", original.isVolatile() ? \"\" : \"not \");\n        SkDebugf(\"copy is \" \"%s\" \"volatile\\n\", copy.isImmutable() ? \"\" : \"not \");\n    }\n}",
    "hash": "23c4543ac6cdd0e8fe762816a0dc2e03",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::isVolatile",
        "stdout": "original is volatile\\ncopy is not volatile\\n"
    },
        "SkBitmap_move_SkBitmap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original;\n    if (original.tryAllocPixels(\n            SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType))) {\n        SkDebugf(\"original has pixels before move: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n        SkBitmap copy(std::move(original));\n        SkDebugf(\"original has pixels after move: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n        SkDebugf(\"copy has pixels: %s\\n\", copy.getPixels() ? \"true\" : \"false\");\n    }\n}\n",
    "hash": "40afd4f1fa69e02d69d92b38252088ef",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::SkBitmap(SkBitmap&& src)",
        "stdout": "original has pixels before move: true\\noriginal has pixels after move: false\\ncopy has pixels: true\\n"
    },
        "SkBitmap_move_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original;\n    if (original.tryAllocPixels(\n            SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType))) {\n        SkDebugf(\"original has pixels before move: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n        SkBitmap copy = std::move(original);\n        SkDebugf(\"original has pixels after move: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n        SkDebugf(\"copy has pixels: %s\\n\", copy.getPixels() ? \"true\" : \"false\");\n    }\n}\n",
    "hash": "35ea3fed27d8db22dc00f48670de64de",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::operator=(SkBitmap&& src)",
        "stdout": "original has pixels before move: true\\noriginal has pixels after move: false\\ncopy has pixels: true\\n"
    },
        "SkBitmap_peekPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(6, 11));\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorWHITE);\n    SkPaint paint;\n    offscreen.drawString(\"?\", 0, 10, paint);\n    SkPixmap pixmap;\n    if (bitmap.peekPixels(&pixmap)) {\n        const SkPMColor* pixels = pixmap.addr32();\n        SkPMColor pmWhite = pixels[0];\n        for (int y = 0; y < bitmap.height(); ++y) {\n            for (int x = 0; x < bitmap.width(); ++x) {\n                SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n            }\n            SkDebugf(\"\\n\");\n        }\n    }\n}",
    "hash": "0cc2c6a0dffa61a88711534bd3d43b40",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::peekPixels",
        "stdout": "------\\n-xxx--\\nx---x-\\n----x-\\n---x--\\n--x---\\n--x---\\n------\\n--x---\\n--x---\\n------\\n"
    },
        "SkBitmap_pixelRef": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap subset;\n    source.extractSubset(&subset, SkIRect::MakeXYWH(32, 64, 128, 256));\n    SkDebugf(\"src ref %c= sub ref\\n\", source.pixelRef() == subset.pixelRef() ? '=' : '!');\n    SkDebugf(\"src pixels %c= sub pixels\\n\", source.getPixels() == subset.getPixels() ? '=' : '!');\n    SkDebugf(\"src addr %c= sub addr\\n\", source.getAddr(32, 64) == subset.getAddr(0, 0) ? '=' : '!');\n}",
    "hash": "5db2d30870a7cc45f28e22578d1880c3",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::pixelRef",
        "stdout": "src ref == sub ref\\nsrc pixels != sub pixels\\nsrc addr == sub addr\\n"
    },
        "SkBitmap_pixelRefOrigin": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap subset;\n    source.extractSubset(&subset, SkIRect::MakeXYWH(32, 64, 128, 256));\n    SkIPoint sourceOrigin = source.pixelRefOrigin();\n    SkIPoint subsetOrigin = subset.pixelRefOrigin();\n    SkDebugf(\"source origin: %d, %d\\n\", sourceOrigin.fX, sourceOrigin.fY);\n    SkDebugf(\"subset origin: %d, %d\\n\", subsetOrigin.fX, subsetOrigin.fY);\n}",
    "hash": "6d31686c6c0829c70f284ae716526d6a",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::pixelRefOrigin",
        "stdout": "source origin: 0, 0\\nsubset origin: 32, 64\\n"
    },
        "SkBitmap_pixmap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(10, 11));\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorWHITE);\n    SkPaint paint;\n    offscreen.drawString(\"&\", 0, 10, paint);\n    const SkPixmap& pixmap = bitmap.pixmap();\n    if (pixmap.addr()) {\n        SkPMColor pmWhite = *pixmap.addr32(0, 0);\n        for (int y = 0; y < pixmap.height(); ++y) {\n            for (int x = 0; x < pixmap.width(); ++x) {\n                SkDebugf(\"%c\", *pixmap.addr32(x, y) == pmWhite ? '-' : 'x');\n            }\n            SkDebugf(\"\\n\");\n        }\n    }\n}",
    "hash": "7f972d742dd78d2500034d8867e9ef2f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::pixmap()",
        "stdout": "----------\\n---xx-----\\n--x--x----\\n--x-------\\n--xx------\\n--x-x---x-\\n-x---x--x-\\n-x----xx--\\n-xx---x---\\n--xxxx-xx-\\n----------\\n"
    },
        "SkBitmap_refColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap1, bitmap2;\n    bitmap1.setInfo(SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,\n            SkColorSpace::MakeSRGBLinear()));\n    bitmap2.setInfo(SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,\n            bitmap1.refColorSpace()));\n    SkColorSpace* colorSpace = bitmap2.colorSpace();\n    SkDebugf(\"gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\\n\",\n            colorSpace->gammaCloseToSRGB() ? \"true\" : \"false\",\n            colorSpace->gammaIsLinear() ? \"true\" : \"false\",\n            colorSpace->isSRGB() ? \"true\" : \"false\");\n}",
    "hash": "cb028b7931da85b949ad0953b9711f9f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::refColorSpace",
        "stdout": "gammaCloseToSRGB: false  gammaIsLinear: true  isSRGB: false\\n"
    },
        "SkBitmap_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::Make(1, 1, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));\n    bitmap.allocPixels();\n    SkDebugf(\"width:%d height:%d isNull:%s\\n\", bitmap.width(), bitmap.height(),\n             bitmap.isNull() ? \"true\" : \"false\");\n    bitmap.reset();\n    SkDebugf(\"width:%d height:%d isNull:%s\\n\", bitmap.width(), bitmap.height(),\n             bitmap.isNull() ? \"true\" : \"false\");\n}",
    "hash": "52ccaeda67924373c5b55a2b89fe314d",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::reset()",
        "stdout": "width:1 height:1 isNull:false\\nwidth:0 height:0 isNull:true\\n"
    },
        "SkBitmap_rowBytes": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    for (int rowBytes : { 2, 8 } ) {\n        bool result = bitmap.setInfo(SkImageInfo::MakeA8(4, 4), rowBytes);\n        SkDebugf(\"setInfo returned:%s rowBytes:%d\\n\", result ? \"true \" : \"false\", bitmap.rowBytes());\n     }\n}",
    "hash": "a654fd0b73f424859ae6c95e03f55099",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::rowBytes",
        "stdout": "setInfo returned:false rowBytes:0\\nsetInfo returned:true  rowBytes:8\\n"
    },
        "SkBitmap_rowBytesAsPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    for (int rowBytes : { 4, 5, 6, 7, 8} ) {\n        bitmap.setInfo(SkImageInfo::MakeN32(1, 1, kPremul_SkAlphaType), rowBytes);\n        SkDebugf(\"rowBytes: %d rowBytesAsPixels: %d\\n\", rowBytes, bitmap.rowBytesAsPixels());\n    }\n}",
    "hash": "03a9e08082a23a98de17c3e24871d61a",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::rowBytesAsPixels",
        "stdout": "rowBytes: 4 rowBytesAsPixels: 1\\nrowBytes: 5 rowBytesAsPixels: 1\\nrowBytes: 6 rowBytesAsPixels: 1\\nrowBytes: 7 rowBytesAsPixels: 1\\nrowBytes: 8 rowBytesAsPixels: 2\\n"
    },
        "SkBitmap_setAlphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = { \"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                             \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\" };\n    const char* alphas[] = {\"Unknown \", \"Opaque  \", \"Premul  \", \"Unpremul\"};\n    SkBitmap bitmap;\n    SkAlphaType alphaTypes[] = { kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType,\n    kUnpremul_SkAlphaType\n                               };\n    SkDebugf(\"%18s%15s%17s%18s%19s\\n\", \"Canonical\", \"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\");\n    for (SkColorType colorType : {\n    kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType,\n    kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType,\n    kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType,\n    kGray_8_SkColorType, kRGBA_F16_SkColorType\n                                 } ) {\n        for (SkAlphaType canonicalAlphaType : alphaTypes) {\n            SkColorTypeValidateAlphaType(colorType, kUnknown_SkAlphaType, &canonicalAlphaType );\n            SkDebugf(\"%12s %9s  \", colors[(int) colorType], alphas[(int) canonicalAlphaType ]);\n            for (SkAlphaType alphaType : alphaTypes) {\n                bitmap.setInfo(SkImageInfo::Make(4, 4, colorType, canonicalAlphaType));\n                bool result = bitmap.setAlphaType(alphaType);\n                SkDebugf(\"%s %s    \", result ? \"true \" : \"false\", alphas[(int) bitmap.alphaType()]);\n            }\n            SkDebugf(\"\\n\");\n        }\n    }\n}\n",
    "hash": "af3adcbea7b58bf90298ca5e0ea93030",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setAlphaType",
        "stdout": "Canonical        Unknown           Opaque            Premul           Unpremul\\n     Unknown  Unknown   true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n     Unknown  Unknown   true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n     Unknown  Unknown   true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n     Unknown  Unknown   true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n     Alpha_8  Unknown   true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n     Alpha_8  Opaque    false Opaque      true  Opaque      true  Premul      true  Premul      \\n     Alpha_8  Premul    false Premul      true  Opaque      true  Premul      true  Premul      \\n     Alpha_8  Unpremul  false Premul      true  Opaque      true  Premul      true  Premul      \\n     RGB_565  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n     RGB_565  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n     RGB_565  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n     RGB_565  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n   ARGB_4444  Unknown   true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n   ARGB_4444  Opaque    false Opaque      true  Opaque      true  Premul      true  Unpremul    \\n   ARGB_4444  Premul    false Premul      true  Opaque      true  Premul      true  Unpremul    \\n   ARGB_4444  Unpremul  false Unpremul    true  Opaque      true  Premul      true  Unpremul    \\n   RGBA_8888  Unknown   true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n   RGBA_8888  Opaque    false Opaque      true  Opaque      true  Premul      true  Unpremul    \\n   RGBA_8888  Premul    false Premul      true  Opaque      true  Premul      true  Unpremul    \\n   RGBA_8888  Unpremul  false Unpremul    true  Opaque      true  Premul      true  Unpremul    \\n    RGB_888x  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n    RGB_888x  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n    RGB_888x  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n    RGB_888x  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n   BGRA_8888  Unknown   true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n   BGRA_8888  Opaque    false Opaque      true  Opaque      true  Premul      true  Unpremul    \\n   BGRA_8888  Premul    false Premul      true  Opaque      true  Premul      true  Unpremul    \\n   BGRA_8888  Unpremul  false Unpremul    true  Opaque      true  Premul      true  Unpremul    \\nRGBA_1010102  Unknown   true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\nRGBA_1010102  Opaque    false Opaque      true  Opaque      true  Premul      true  Unpremul    \\nRGBA_1010102  Premul    false Premul      true  Opaque      true  Premul      true  Unpremul    \\nRGBA_1010102  Unpremul  false Unpremul    true  Opaque      true  Premul      true  Unpremul    \\n RGB_101010x  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n RGB_101010x  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n RGB_101010x  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n RGB_101010x  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n      Gray_8  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n      Gray_8  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n      Gray_8  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n      Gray_8  Opaque    true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n    RGBA_F16  Unknown   true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n    RGBA_F16  Opaque    false Opaque      true  Opaque      true  Premul      true  Unpremul    \\n    RGBA_F16  Premul    false Premul      true  Opaque      true  Premul      true  Unpremul    \\n    RGBA_F16  Unpremul  false Unpremul    true  Opaque      true  Premul      true  Unpremul    \\n"
    },
        "SkBitmap_setImmutable": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(4, 4, kPremul_SkAlphaType));\n    bitmap.allocPixels();\n    SkCanvas offscreen(bitmap);\n    SkDebugf(\"draw white\\n\");\n    offscreen.clear(SK_ColorWHITE);\n    bitmap.setImmutable();\n    SkDebugf(\"draw black\\n\");\n    offscreen.clear(SK_ColorBLACK);\n}",
    "hash": "9210060d1f4ca46e1375496237902ef3",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setImmutable",
        "stdout": "draw white\\ndraw black\\n"
    },
        "SkBitmap_shiftPerPixel": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkImageInfo info = SkImageInfo::MakeA8(1, 1);\n    SkBitmap bitmap;\n    for (SkColorType colorType : {\n    kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType,\n    kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType,\n    kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType,\n    kGray_8_SkColorType, kRGBA_F16_SkColorType\n                                 } ) {\n        bitmap.setInfo(info.makeColorType(colorType));\n        SkDebugf(\"color: k\" \"%s\" \"_SkColorType\" \"%*s\" \"shiftPerPixel: %d\\n\",\n                colors[colorType], 14 - strlen(colors[colorType]), \" \",\n                bitmap.shiftPerPixel());\n    }\n}",
    "hash": "56ede4b7d45c15d5936f81ac3d74f070",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::shiftPerPixel",
        "stdout": "color: kUnknown_SkColorType       shiftPerPixel: 0\\ncolor: kAlpha_8_SkColorType       shiftPerPixel: 0\\ncolor: kRGB_565_SkColorType       shiftPerPixel: 1\\ncolor: kARGB_4444_SkColorType     shiftPerPixel: 1\\ncolor: kRGBA_8888_SkColorType     shiftPerPixel: 2\\ncolor: kRGB_888x_SkColorType      shiftPerPixel: 2\\ncolor: kBGRA_8888_SkColorType     shiftPerPixel: 2\\ncolor: kRGBA_1010102_SkColorType  shiftPerPixel: 2\\ncolor: kRGB_101010x_SkColorType   shiftPerPixel: 2\\ncolor: kGray_8_SkColorType        shiftPerPixel: 0\\ncolor: kRGBA_F16_SkColorType      shiftPerPixel: 3\\n"
    },
        "SkBitmap_swap": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkBitmap& b) -> void {\n        const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n        const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                                \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n        SkDebugf(\"%s width:%d height:%d colorType:k%s_SkColorType alphaType:k%s_SkAlphaType\\n\",\n                 prefix, b.width(), b.height(), colors[b.colorType()], alphas[b.alphaType()]);\n    };\n    SkBitmap one, two;\n    if (!one.tryAllocPixels(\n            SkImageInfo::Make(1, 1, kRGBA_8888_SkColorType, kOpaque_SkAlphaType))) {\n        return;\n    }\n    if (!two.tryAllocPixels(\n            SkImageInfo::Make(2, 2, kBGRA_8888_SkColorType, kPremul_SkAlphaType))) {\n        return;\n    }\n    for (int index = 0; index < 2; ++index) {\n       debugster(\"one\", one);\n       debugster(\"two\", two);\n       one.swap(two);\n    }\n}\n",
    "hash": "de9be45255e48fae445c916a41063abc",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::swap()",
        "stdout": "one width:1 height:1 colorType:kRGBA_8888_SkColorType alphaType:kOpaque_SkAlphaType\\ntwo width:2 height:2 colorType:kBGRA_8888_SkColorType alphaType:kPremul_SkAlphaType\\none width:2 height:2 colorType:kBGRA_8888_SkColorType alphaType:kPremul_SkAlphaType\\ntwo width:1 height:1 colorType:kRGBA_8888_SkColorType alphaType:kOpaque_SkAlphaType\\n"
    },
        "SkBitmap_tryAllocPixelsFlags": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    if (!bitmap.tryAllocPixelsFlags(SkImageInfo::MakeN32(10000, 10000, kOpaque_SkAlphaType),\n                                    SkBitmap::kZeroPixels_AllocFlag)) {\n        SkDebugf(\"bitmap allocation failed!\\n\");\n    } else {\n        SkDebugf(\"bitmap allocation succeeded!\\n\");\n    }\n}",
    "hash": "f1d1880d38e0aea4cefd3e11745e8a09",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocPixelsFlags",
        "stdout": "bitmap allocation succeeded!\\n"
    },
        "SkBitmap_width": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeA8(16, 32);\n    SkBitmap bitmap;\n    bitmap.setInfo(info);\n    SkDebugf(\"bitmap width: %d  info width: %d\\n\", bitmap.width(), info.width());\n}",
    "hash": "d06880c42f8bb3b4c3b67bd988046049",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::width()",
        "stdout": "bitmap width: 16  info width: 16\\n"
    },
        "SkBlendMode_Name": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"default blend: SkBlendMode::k%s\\n\", SkBlendMode_Name(SkPaint().getBlendMode()));\n}",
    "hash": "3996f4994bf4e90b4cd86524c1f9f1a6",
    "file": "SkBlendMode_Reference",
    "name": "SkBlendMode_Name",
        "stdout": "default blend: SkBlendMode::kSrcOver\\n"
    },
        "SkCanvas_MakeRasterDirect": {
    "code": "void draw(SkCanvas* ) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(3, 3);  // device aligned, 32 bpp, Premultiplied\n    const size_t minRowBytes = info.minRowBytes();  // bytes used by one bitmap row\n    const size_t size = info.computeMinByteSize();  // bytes used by all rows\n    SkAutoTMalloc<SkPMColor> storage(size);  // allocate storage for pixels\n    SkPMColor* pixels = storage.get();  // get pointer to allocated storage\n    // create a SkCanvas backed by a raster device, and delete it when the\n    // function goes out of scope.\n    std::unique_ptr<SkCanvas> canvas = SkCanvas::MakeRasterDirect(info, pixels, minRowBytes);\n    canvas->clear(SK_ColorWHITE);  // white is Unpremultiplied, in ARGB order\n    canvas->flush();  // ensure that pixels are cleared\n    SkPMColor pmWhite = pixels[0];  // the Premultiplied format may vary\n    SkPaint paint;  // by default, draws black\n    canvas->drawPoint(1, 1, paint);  // draw in the center\n    canvas->flush();  // ensure that point was drawn\n    for (int y = 0; y < info.height(); ++y) {\n        for (int x = 0; x < info.width(); ++x) {\n            SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}\n",
    "hash": "525285073aae7e53eb8f454a398f880c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::MakeRasterDirect",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkCanvas_MakeRasterDirectN32": {
    "code": "void draw(SkCanvas* ) {\n    const int width = 3;\n    const int height = 3;\n    SkPMColor pixels[height][width];  // allocate a 3 by 3 Premultiplied bitmap on the stack\n    // create a SkCanvas backed by a raster device, and delete it when the\n    // function goes out of scope.\n    std::unique_ptr<SkCanvas> canvas = SkCanvas::MakeRasterDirectN32(\n            width,\n            height,\n            pixels[0],  // top-left of the bitmap\n            sizeof(pixels[0]));  // byte width of the each row\n    // write a Premultiplied value for white into all pixels in the bitmap\n    canvas->clear(SK_ColorWHITE);\n    SkPMColor pmWhite = pixels[0][0];  // the Premultiplied format may vary\n    SkPaint paint;  // by default, draws black\n    canvas->drawPoint(1, 1, paint);  // draw in the center\n    canvas->flush();  // ensure that pixels is ready to be read\n    for (int y = 0; y < height; ++y) {\n        for (int x = 0; x < width; ++x) {\n            SkDebugf(\"%c\", pixels[y][x] == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}\n",
    "hash": "87f55e62ec4c3535e1a5d0f1415b20c6",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::MakeRasterDirectN32",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkCanvas_SaveLayerRec_SaveLayerRec": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas::SaveLayerRec rec1;\n    rec1.fSaveLayerFlags = SkCanvas::kPreserveLCDText_SaveLayerFlag;\n    SkCanvas::SaveLayerRec rec2(nullptr, nullptr, SkCanvas::kPreserveLCDText_SaveLayerFlag);\n    SkDebugf(\"rec1 %c= rec2\\n\", rec1.fBounds == rec2.fBounds\n            && rec1.fPaint == rec2.fPaint\n            && rec1.fBackdrop == rec2.fBackdrop\n            && rec1.fSaveLayerFlags == rec2.fSaveLayerFlags ? '=' : '!');\n}",
    "hash": "b5cea1eed80a0eb04ddbab3f36dff73f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SaveLayerRec::SaveLayerRec()",
        "stdout": "rec1 == rec2\\n"
    },
        "SkCanvas_SaveLayerRec_const_SkRect_star_const_SkPaint_star": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas::SaveLayerRec rec1;\n    SkCanvas::SaveLayerRec rec2(nullptr, nullptr);\n    SkDebugf(\"rec1 %c= rec2\\n\", rec1.fBounds == rec2.fBounds\n            && rec1.fPaint == rec2.fPaint\n            && rec1.fBackdrop == rec2.fBackdrop\n            && rec1.fSaveLayerFlags == rec2.fSaveLayerFlags ? '=' : '!');\n}",
    "hash": "027f920259888fc19591ea9a90d92873",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SaveLayerRec::SaveLayerRec(const SkRect* bounds, const SkPaint* paint, SaveLayerFlags saveLayerFlags = 0)",
        "stdout": "rec1 == rec2\\n"
    },
        "SkCanvas_SaveLayerRec_const_SkRect_star_const_SkPaint_star_const_SkImageFilter_star": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas::SaveLayerRec rec1;\n    SkCanvas::SaveLayerRec rec2(nullptr, nullptr, nullptr, 0);\n    SkDebugf(\"rec1 %c= rec2\\n\", rec1.fBounds == rec2.fBounds\n            && rec1.fPaint == rec2.fPaint\n            && rec1.fBackdrop == rec2.fBackdrop\n            && rec1.fSaveLayerFlags == rec2.fSaveLayerFlags ? '=' : '!');\n}",
    "hash": "9b7fa2fe855642ffff6538829db15328",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SaveLayerRec::SaveLayerRec(const SkRect* bounds, const SkPaint* paint, const SkImageFilter* backdrop,                     SaveLayerFlags saveLayerFlags)",
        "stdout": "rec1 == rec2\\n"
    },
        "SkCanvas_accessTopRasterHandle": {
    "code": "static void DeleteCallback(void*, void* context) {\n    delete (char*) context;\n}\nclass CustomAllocator : public SkRasterHandleAllocator {\npublic:\n    bool allocHandle(const SkImageInfo& info, Rec* rec) override {\n        char* context = new char[4]{'s', 'k', 'i', 'a'};\n        rec->fReleaseProc = DeleteCallback;\n        rec->fReleaseCtx = context;\n        rec->fHandle = context;\n        rec->fPixels = context;\n        rec->fRowBytes = 4;\n        return true;\n    }\n    void updateHandle(Handle handle, const SkMatrix& ctm, const SkIRect& clip_bounds) override {\n        // apply canvas matrix and clip to custom environment\n    }\n};\n\nvoid draw(SkCanvas* canvas) {\n    const SkImageInfo info = SkImageInfo::MakeN32Premul(1, 1);\n    std::unique_ptr<SkCanvas> c2 =\n            SkRasterHandleAllocator::MakeCanvas(std::unique_ptr<CustomAllocator>(\n            new CustomAllocator()), info);\n    char* context = (char*) c2->accessTopRasterHandle();\n    SkDebugf(\"context = %.4s\\n\", context);\n}\n",
    "hash": "4486d0c0b22ad2931db130f42da4c80c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::accessTopRasterHandle",
        "stdout": "context = skia\\n"
    },
        "SkCanvas_const_SkBitmap_const_SkSurfaceProps": {
    "code": "void draw(SkCanvas* ) {\n    SkBitmap bitmap;\n    // create a bitmap 5 wide and 11 high\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(5, 11));\n    SkCanvas canvas(bitmap, SkSurfaceProps(0, kUnknown_SkPixelGeometry));\n    canvas.clear(SK_ColorWHITE);  // white is Unpremultiplied, in ARGB order\n    SkPixmap pixmap;  // provides guaranteed access to the drawn pixels\n    if (!canvas.peekPixels(&pixmap)) {\n        SkDebugf(\"peekPixels should never fail.\\n\");\n    }\n    const SkPMColor* pixels = pixmap.addr32();  // points to top-left of bitmap\n    SkPMColor pmWhite = pixels[0];  // the Premultiplied format may vary\n    SkPaint paint;  // by default, draws black, 12 point text\n    canvas.drawString(\"!\", 1, 10, paint);  // 1 char at baseline (1, 10)\n    for (int y = 0; y < bitmap.height(); ++y) {\n        for (int x = 0; x < bitmap.width(); ++x) {\n            SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}",
    "hash": "c26cfae4c42cb445240335cc12a50235",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SkCanvas(const SkBitmap& bitmap, const SkSurfaceProps& props)",
        "stdout": "-----\\n---x-\\n---x-\\n---x-\\n---x-\\n---x-\\n---x-\\n-----\\n---x-\\n---x-\\n-----\\n"
    },
        "SkCanvas_copy_const_SkBitmap": {
    "code": "void draw(SkCanvas* ) {\n    SkBitmap bitmap;\n    // create a bitmap 5 wide and 11 high\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(5, 11));\n    SkCanvas canvas(bitmap);\n    canvas.clear(SK_ColorWHITE);  // white is Unpremultiplied, in ARGB order\n    SkPixmap pixmap;  // provides guaranteed access to the drawn pixels\n    if (!canvas.peekPixels(&pixmap)) {\n        SkDebugf(\"peekPixels should never fail.\\n\");\n    }\n    const SkPMColor* pixels = pixmap.addr32();  // points to top-left of bitmap\n    SkPMColor pmWhite = pixels[0];  // the Premultiplied format may vary\n    SkPaint paint;  // by default, draws black, 12 point text\n    canvas.drawString(\"!\", 1, 10, paint);  // 1 char at baseline (1, 10)\n    for (int y = 0; y < bitmap.height(); ++y) {\n        for (int x = 0; x < bitmap.width(); ++x) {\n            SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}",
    "hash": "dd92db963af190e849894038f39b598a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SkCanvas(const SkBitmap& bitmap)",
        "stdout": "-----\\n---x-\\n---x-\\n---x-\\n---x-\\n---x-\\n---x-\\n-----\\n---x-\\n---x-\\n-----\\n"
    },
        "SkCanvas_empty_constructor": {
    "code": "static void check_for_rotated_ctm(const SkCanvas* canvas) {\n    const SkMatrix& matrix = canvas->getTotalMatrix();\n    SkDebugf(\"rect stays rect is %s\\n\", matrix.rectStaysRect() ? \"true\" : \"false\");\n}\n\nvoid draw(SkCanvas* canvas) {\n    check_for_rotated_ctm(canvas);\n    canvas->rotate(30);\n    check_for_rotated_ctm(canvas);\n    SkCanvas defaultCanvas;\n    check_for_rotated_ctm(&defaultCanvas);\n}\n",
    "hash": "4a00e6589e862fde5be532f4b6e316ce",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SkCanvas()",
        "stdout": "rect stays rect is true\\nrect stays rect is false\\nrect stays rect is true\\n"
    },
        "SkCanvas_getBaseLayerSize": {
    "code": "void draw(SkCanvas* ) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(20, 30));\n    SkCanvas canvas(bitmap, SkSurfaceProps(0, kUnknown_SkPixelGeometry));\n    canvas.clipRect(SkRect::MakeWH(10, 40));\n    SkIRect clipDeviceBounds = canvas.getDeviceClipBounds();\n    if (clipDeviceBounds.isEmpty()) {\n        SkDebugf(\"Empty clip bounds is unexpected!\\n\");\n    }\n    SkDebugf(\"clip=%d,%d\\n\", clipDeviceBounds.width(), clipDeviceBounds.height());\n    SkISize baseLayerSize = canvas.getBaseLayerSize();\n    SkDebugf(\"size=%d,%d\\n\", baseLayerSize.width(), baseLayerSize.height());\n}",
    "hash": "374e245d91cd729eca48fd20e631fdf3",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getBaseLayerSize",
        "stdout": "clip=10,30\\nsize=20,30\\n"
    },
        "SkCanvas_getDeviceClipBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas device(256, 256);\n    canvas = &device;\n    SkIRect bounds = canvas->getDeviceClipBounds();\n    SkDebugf(\"left:%d  top:%d  right:%d  bottom:%d\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    SkPoint clipPoints[]  = {{30, 130}, {120, 130}, {120, 230} };\n    SkPath clipPath;\n    clipPath.addPoly(clipPoints, SK_ARRAY_COUNT(clipPoints), true);\n    canvas->save();\n    canvas->clipPath(clipPath);\n    bounds = canvas->getDeviceClipBounds();\n    SkDebugf(\"left:%d  top:%d  right:%d  bottom:%d\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    canvas->restore();\n    canvas->scale(1.f/2, 1.f/2);\n    canvas->clipPath(clipPath);\n    bounds = canvas->getDeviceClipBounds();\n    SkDebugf(\"left:%d  top:%d  right:%d  bottom:%d\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n}\n",
    "hash": "556832ac5711af662a98c21c547185e9",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getDeviceClipBounds",
        "stdout": "left:0  top:0  right:256  bottom:256\\nleft:30  top:130  right:120  bottom:230\\nleft:15  top:65  right:60  bottom:115\\n"
    },
        "SkCanvas_getDeviceClipBounds_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect bounds;\n    SkDebugf(\"device bounds empty = %s\\n\", canvas->getDeviceClipBounds(&bounds)\n             ? \"false\" : \"true\");\n    SkPath path;\n    canvas->clipPath(path);\n    SkDebugf(\"device bounds empty = %s\\n\", canvas->getDeviceClipBounds(&bounds)\n             ? \"false\" : \"true\");\n}\n",
    "hash": "6abb99f849a1f0e33e1dedc00d1c4f7a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getDeviceClipBounds_2",
        "stdout": "device bounds empty = false\\ndevice bounds empty = true\\n"
    },
        "SkCanvas_getLocalClipBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas local(256, 256);\n    canvas = &local;\n    SkRect bounds = canvas->getLocalClipBounds();\n    SkDebugf(\"left:%g  top:%g  right:%g  bottom:%g\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    SkPoint clipPoints[]  = {{30, 130}, {120, 130}, {120, 230} };\n    SkPath clipPath;\n    clipPath.addPoly(clipPoints, SK_ARRAY_COUNT(clipPoints), true);\n    canvas->clipPath(clipPath);\n    bounds = canvas->getLocalClipBounds();\n    SkDebugf(\"left:%g  top:%g  right:%g  bottom:%g\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    canvas->scale(2, 2);\n    bounds = canvas->getLocalClipBounds();\n    SkDebugf(\"left:%g  top:%g  right:%g  bottom:%g\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n}",
    "hash": "7f60cb030d3f9b2473adbe3e34b19d91",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getLocalClipBounds",
        "stdout": "left:-1  top:-1  right:257  bottom:257\\nleft:29  top:129  right:121  bottom:231\\nleft:14.5  top:64.5  right:60.5  bottom:115.5\\n"
    },
        "SkCanvas_getLocalClipBounds_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas local(256, 256);\n    canvas = &local;\n    SkRect bounds;\n    SkDebugf(\"local bounds empty = %s\\n\", canvas->getLocalClipBounds(&bounds)\n             ? \"false\" : \"true\");\n    SkPath path;\n    canvas->clipPath(path);\n    SkDebugf(\"local bounds empty = %s\\n\", canvas->getLocalClipBounds(&bounds)\n             ? \"false\" : \"true\");\n}\n",
    "hash": "85496614e90c66b020f8a70db8d06f4a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getLocalClipBounds_2",
        "stdout": "local bounds empty = false\\nlocal bounds empty = true\\n"
    },
        "SkCanvas_getMetaData": {
    "code": "void draw(SkCanvas* ) {\n    const char* kHelloMetaData = \"HelloMetaData\";\n    SkCanvas canvas;\n    SkMetaData& metaData = canvas.getMetaData();\n    SkDebugf(\"before: %s\\n\", metaData.findString(kHelloMetaData));\n    metaData.setString(kHelloMetaData, \"Hello!\");\n    SkDebugf(\"during: %s\\n\", metaData.findString(kHelloMetaData));\n    metaData.removeString(kHelloMetaData);\n    SkDebugf(\"after: %s\\n\", metaData.findString(kHelloMetaData));\n}",
    "hash": "1598396056045e8d0c583b748293d652",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getMetaData",
        "stdout": "before: (null)\\nduring: Hello!\\nafter: (null)\\n"
    },
        "SkCanvas_getProps": {
    "code": "void draw(SkCanvas* ) {\n    SkBitmap bitmap;\n    SkCanvas canvas(bitmap, SkSurfaceProps(0, kRGB_V_SkPixelGeometry));\n    SkSurfaceProps surfaceProps(0, kUnknown_SkPixelGeometry);\n    SkDebugf(\"isRGB:%d\\n\", SkPixelGeometryIsRGB(surfaceProps.pixelGeometry()));\n    if (!canvas.getProps(&surfaceProps)) {\n        SkDebugf(\"getProps failed unexpectedly.\\n\");\n    }\n    SkDebugf(\"isRGB:%d\\n\", SkPixelGeometryIsRGB(surfaceProps.pixelGeometry()));\n}",
    "hash": "0fbf2dedc2619bbfbf173c9e3bc1a508",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getProps",
        "stdout": "isRGB:0\\nisRGB:1\\n"
    },
        "SkCanvas_getSaveCount": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas simple;\n    SkDebugf(\"depth = %d\\n\", simple.getSaveCount());\n    simple.save();\n    SkDebugf(\"depth = %d\\n\", simple.getSaveCount());\n    simple.restore();\n    SkDebugf(\"depth = %d\\n\", simple.getSaveCount());\n}\n",
    "hash": "005f2b207e078baac596681924fe591e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getSaveCount",
        "stdout": "depth = 1\\ndepth = 2\\ndepth = 1\\n"
    },
        "SkCanvas_getTotalMatrix": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"isIdentity %s\\n\", canvas->getTotalMatrix().isIdentity() ? \"true\" : \"false\");\n}",
    "hash": "c0d5fa544759704768f47cac91ae3832",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getTotalMatrix",
        "stdout": "isIdentity true\\n"
    },
        "SkCanvas_imageInfo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas emptyCanvas;\n    SkImageInfo canvasInfo = emptyCanvas.imageInfo();\n    SkImageInfo emptyInfo;\n    SkDebugf(\"emptyInfo %c= canvasInfo\\n\", emptyInfo == canvasInfo ? '=' : '!');\n}",
    "hash": "d93389d971f8084c4ccc7a66e4e157ee",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::imageInfo",
        "stdout": "emptyInfo == canvasInfo\\n"
    },
        "SkCanvas_int_int_const_SkSurfaceProps_star": {
    "code": "void draw(SkCanvas* ) {\n    SkCanvas canvas(10, 20);  // 10 units wide, 20 units high\n    canvas.clipRect(SkRect::MakeXYWH(30, 40, 5, 10));  // clip is outside canvas' device\n    SkDebugf(\"canvas %s empty\\n\", canvas.getDeviceClipBounds().isEmpty() ? \"is\" : \"is not\");\n}",
    "hash": "ce6a5ef2df447970b4453489d9d67930",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SkCanvas(int width, int height, const SkSurfaceProps* props = nullptr)",
        "stdout": "canvas is empty\\n"
    },
        "SkCanvas_isClipEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"clip is%s empty\\n\", canvas->isClipEmpty() ? \"\" : \" not\");\n    SkPath path;\n    canvas->clipPath(path);\n    SkDebugf(\"clip is%s empty\\n\", canvas->isClipEmpty() ? \"\" : \" not\");\n}\n",
    "hash": "f106f146a58c8604308d4d8d7086d2f5",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::isClipEmpty",
        "stdout": "clip is not empty\\nclip is empty\\n"
    },
        "SkCanvas_isClipRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"clip is%s rect\\n\", canvas->isClipRect() ? \"\" : \" not\");\n    canvas->clipRect({0, 0, 0, 0});\n    SkDebugf(\"clip is%s rect\\n\", canvas->isClipRect() ? \"\" : \" not\");\n}\n",
    "hash": "9894bfb476c78a8f6c8f49fbbca3d50d",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::isClipRect",
        "stdout": "clip is rect\\nclip is not rect\\n"
    },
        "SkCanvas_makeSurface": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surface = SkSurface::MakeRasterN32Premul(5, 6);\n    SkCanvas* smallCanvas = surface->getCanvas();\n    SkImageInfo imageInfo = SkImageInfo::MakeN32Premul(3, 4);\n    sk_sp<SkSurface> compatible = smallCanvas->makeSurface(imageInfo);\n    SkDebugf(\"compatible %c= nullptr\\n\", compatible == nullptr ? '=' : '!');\n    SkDebugf(\"size = %d, %d\\n\", compatible->width(), compatible->height());\n}",
    "hash": "1ce28351444b41ab2b8e3128a4b9b9c2",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::makeSurface",
        "stdout": "compatible != nullptr\\nsize = 3, 4\\n"
    },
        "SkCanvas_peekPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap;\n    if (canvas->peekPixels(&pixmap)) {\n        SkDebugf(\"width=%d height=%d\\n\", pixmap.bounds().width(), pixmap.bounds().height());\n    }\n}",
    "hash": "e9411d676d1fa13b46331abe9e14ad3e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::peekPixels",
        "stdout": "width=256 height=256\\n"
    },
        "SkCanvas_quickReject": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect testRect = {30, 30, 120, 129 };\n    SkRect clipRect = {30, 130, 120, 230 };\n    canvas->save();\n    canvas->clipRect(clipRect);\n    SkDebugf(\"quickReject %s\\n\", canvas->quickReject(testRect) ? \"true\" : \"false\");\n    canvas->restore();\n    canvas->rotate(10);\n    canvas->clipRect(clipRect);\n    SkDebugf(\"quickReject %s\\n\", canvas->quickReject(testRect) ? \"true\" : \"false\");\n}\n",
    "hash": "cfe4016241074477809dd45435be9cf4",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::quickReject",
        "stdout": "quickReject true\\nquickReject false\\n"
    },
        "SkCanvas_quickReject_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint testPoints[] = {{30,  30}, {120,  30}, {120, 129} };\n    SkPoint clipPoints[] = {{30, 130}, {120, 130}, {120, 230} };\n    SkPath testPath, clipPath;\n    testPath.addPoly(testPoints, SK_ARRAY_COUNT(testPoints), true);\n    clipPath.addPoly(clipPoints, SK_ARRAY_COUNT(clipPoints), true);\n    canvas->save();\n    canvas->clipPath(clipPath);\n    SkDebugf(\"quickReject %s\\n\", canvas->quickReject(testPath) ? \"true\" : \"false\");\n    canvas->restore();\n    canvas->rotate(10);\n    canvas->clipPath(clipPath);\n    SkDebugf(\"quickReject %s\\n\", canvas->quickReject(testPath) ? \"true\" : \"false\");\n}\n",
    "hash": "56dcd14f943aea6f7d7aafe0de7e6c25",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::quickReject_2",
        "stdout": "quickReject true\\nquickReject false\\n"
    },
        "SkCanvas_readPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(0x8055aaff);\n    uint32_t pixels[1] = { 0 };\n    SkPixmap pixmap(SkImageInfo::MakeN32Premul(1, 1), pixels, 4);\n    canvas->readPixels(pixmap, 0, 0);\n    SkDebugf(\"pixel = %08x\\n\", pixels[0]);\n}\n",
    "hash": "85f199032943b6483722c34a91c4e20f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::readPixels_2",
        "stdout": "pixel = 802b5580\\n"
    },
        "SkCanvas_readPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(0x8055aaff);\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(1, 1));\n    canvas->readPixels(bitmap, 0, 0);\n    SkDebugf(\"pixel = %08x\\n\", bitmap.getAddr32(0, 0)[0]);\n}\n",
    "hash": "af6dec8ef974aa67bf102f29915bcd6a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::readPixels_3",
        "stdout": "pixel = 802b5580\\n"
    },
        "SkCanvas_readPixels_a": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(0x8055aaff);\n    for (SkAlphaType alphaType : { kPremul_SkAlphaType, kUnpremul_SkAlphaType } ) {\n        uint32_t pixel = 0;\n        SkImageInfo info = SkImageInfo::Make(1, 1, kBGRA_8888_SkColorType, alphaType);\n        if (canvas->readPixels(info, &pixel, 4, 0, 0)) {\n            SkDebugf(\"pixel = %08x\\n\", pixel);\n        }\n    }\n}",
    "hash": "481e990e923a0ed34654f4361b94f096",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::readPixels_2",
        "stdout": "pixel = 802b5580\\npixel = 8056a9ff\\n"
    },
        "SkCanvas_restore": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas simple;\n    SkDebugf(\"depth = %d\\n\", simple.getSaveCount());\n    simple.restore();\n    SkDebugf(\"depth = %d\\n\", simple.getSaveCount());\n}\n",
    "hash": "e78471212a67f2f4fd39496e17a30d17",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::restore()",
        "stdout": "depth = 1\\ndepth = 1\\n"
    },
        "SkCanvas_restoreToCount": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"depth = %d\\n\", canvas->getSaveCount());\n    canvas->save();\n    canvas->save();\n    SkDebugf(\"depth = %d\\n\", canvas->getSaveCount());\n    canvas->restoreToCount(0);\n    SkDebugf(\"depth = %d\\n\", canvas->getSaveCount());\n}\n",
    "hash": "9ed0d56436e114c7097fd49eed1aea47",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::restoreToCount",
        "stdout": "depth = 1\\ndepth = 3\\ndepth = 1\\n"
    },
        "SkIPoint_Make": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint pt1 = {45, 66};\n    SkIPoint pt2 = SkIPoint::Make(45, 66);\n    SkDebugf(\"pt1 %c= pt2\\n\", pt1 == pt2 ? '=' : '!');\n}",
    "hash": "e5cf5159525bd3140f288a95fe641fae",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::Make",
        "stdout": "pt1 == pt2\\n"
    },
        "SkIPoint_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint test[] = { {0, -0}, {-1, -2}, {SK_MaxS32, -1}, {SK_NaN32, -1} };\n    for (const SkIPoint& pt : test) {\n        SkDebugf(\"pt: %d, %d  %c= pt\\n\", pt.fX, pt.fY, pt == pt ? '=' : '!');\n    }\n}",
    "hash": "37ffe2817d720f99e6c252332ce70460",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator==(const SkIPoint& a, const SkIPoint& b)",
        "stdout": "pt: 0, 0  == pt\\npt: -1, -2  == pt\\npt: 2147483647, -1  == pt\\npt: -2147483648, -1  == pt\\n"
    },
        "SkIPoint_equals": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint test[] = { {0, -0}, {-1, -2}, {SK_MaxS32, -1}, {SK_NaN32, -1} };\n    for (const SkIPoint& pt : test) {\n        SkDebugf(\"pt: %d, %d  %c= pt\\n\", pt.fX, pt.fY, pt.equals(pt.fX, pt.fY) ? '=' : '!');\n    }\n}",
    "hash": "64f575d36439d5b69aaed14ffeff1cc4",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::equals()",
        "stdout": "pt: 0, 0  == pt\\npt: -1, -2  == pt\\npt: 2147483647, -1  == pt\\npt: -2147483648, -1  == pt\\n"
    },
        "SkIPoint_isZero": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint pt = { 0, -0};\n    SkDebugf(\"pt.isZero() == %s\\n\", pt.isZero() ? \"true\" : \"false\");\n}",
    "hash": "658c1df611b4577cc7e0bb384e95737e",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::isZero",
        "stdout": "pt.isZero() == true\\n"
    },
        "SkIPoint_minus_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint test[] = { {0, -0}, {-1, -2},\n                       { SK_MaxS32, SK_MinS32 },\n                       { SK_NaN32, SK_NaN32 } };\n    for (const SkIPoint& pt : test) {\n        SkIPoint negPt = -pt;\n        SkDebugf(\"pt: %d, %d  negate: %d, %d\\n\", pt.fX, pt.fY, negPt.fX, negPt.fY);\n    }\n}",
    "hash": "b30d4780475d113a7fed3637af7f0db1",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator-() const",
        "stdout": "pt: 0, 0  negate: 0, 0\\npt: -1, -2  negate: 1, 2\\npt: 2147483647, -2147483647  negate: -2147483647, 2147483647\\npt: -2147483648, -2147483648  negate: -2147483648, -2147483648\\n"
    },
        "SkIPoint_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint test[] = { {0, -0}, {-1, -2}, {SK_MaxS32, -1}, {SK_NaN32, -1} };\n    for (const SkIPoint& pt : test) {\n        SkDebugf(\"pt: %d, %d  %c= pt\\n\", pt.fX, pt.fY, pt != pt ? '!' : '=');\n    }\n}",
    "hash": "dd89dc48dff69b53d99530b120f204bc",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator!=(const SkIPoint& a, const SkIPoint& b)",
        "stdout": "pt: 0, 0  == pt\\npt: -1, -2  == pt\\npt: 2147483647, -1  == pt\\npt: -2147483648, -1  == pt\\n"
    },
        "SkIPoint_set": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint pt1, pt2 = { SK_MinS32, SK_MaxS32 };\n    pt1.set(SK_MinS32, SK_MaxS32);\n    SkDebugf(\"pt1 %c= pt2\\n\", pt1 == pt2 ? '=' : '!');\n}",
    "hash": "165418b5718d79d8f1682a8a0ee32ba0",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::set()",
        "stdout": "pt1 == pt2\\n"
    },
        "SkIPoint_x": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint pt1 = {45, 66};\n    SkDebugf(\"pt1.fX %c= pt1.x()\\n\", pt1.fX == pt1.x() ? '=' : '!');\n}",
    "hash": "eed4185294f8a8216fc354e6ee6b2e3a",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::x()",
        "stdout": "pt1.fX == pt1.x()\\n"
    },
        "SkIPoint_y": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint pt1 = {45, 66};\n    SkDebugf(\"pt1.fY %c= pt1.y()\\n\", pt1.fY == pt1.y() ? '=' : '!');\n}",
    "hash": "35c41b8ba7cebf8c9a7a8494e610e14d",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::y()",
        "stdout": "pt1.fY == pt1.y()\\n"
    },
        "SkIRect_EmptyIRect": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkIRect& rect = SkIRect::EmptyIRect();\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "65e0b9b52e907902630577941fb3ed6d",
    "file": "SkIRect_Reference",
    "name": "SkIRect::EmptyIRect",
        "stdout": "rect: 0, 0, 0, 0\\n"
    },
        "SkIRect_Intersects": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"%s intersection\", SkIRect::Intersects({10, 40, 50, 80}, {30, 60, 70, 90}) ? \"\" : \"no \");\n}",
    "hash": "0c67cf8981389efc7108369fb9b7976b",
    "file": "SkIRect_Reference",
    "name": "SkIRect::Intersects",
        "stdout": "intersection"
    },
        "SkIRect_IntersectsNoEmptyCheck": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"%s intersection\", SkIRect::IntersectsNoEmptyCheck(\n            {10, 40, 50, 80}, {30, 60, 70, 90}) ? \"\" : \"no \");\n}",
    "hash": "dba234d15162fb5b26e1a96529ca6a2a",
    "file": "SkIRect_Reference",
    "name": "SkIRect::IntersectsNoEmptyCheck",
        "stdout": "intersection"
    },
        "SkIRect_MakeEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = SkIRect::MakeEmpty();\n    SkDebugf(\"MakeEmpty isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.offset(10, 10);\n    SkDebugf(\"offset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.inset(10, 10);\n    SkDebugf(\"inset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.outset(20, 20);\n    SkDebugf(\"outset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "0ade3971c1d2616564992e286966ec8a",
    "file": "SkIRect_Reference",
    "name": "SkIRect::MakeEmpty",
        "stdout": "MakeEmpty isEmpty: true\\noffset rect isEmpty: true\\ninset rect isEmpty: true\\noutset rect isEmpty: false\\n"
    },
        "SkIRect_MakeLTRB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = SkIRect::MakeLTRB(5, 35, 15, 25);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "ec1473b700c594f2df9749a12a06b89b",
    "file": "SkIRect_Reference",
    "name": "SkIRect::MakeLTRB",
        "stdout": "rect: 5, 35, 15, 25  isEmpty: true\\nrect: 5, 25, 15, 35  isEmpty: false\\n"
    },
        "SkIRect_MakeSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkSize size = {25.5f, 35.5f};\n    SkIRect rect = SkIRect::MakeSize(size.toRound());\n    SkDebugf(\"round width: %d  height: %d\\n\", rect.width(), rect.height());\n    rect = SkIRect::MakeSize(size.toFloor());\n    SkDebugf(\"floor width: %d  height: %d\\n\", rect.width(), rect.height());\n}",
    "hash": "c6586ff8d24869c780169b0d19c75df6",
    "file": "SkIRect_Reference",
    "name": "SkIRect::MakeSize",
        "stdout": "round width: 26  height: 36\\nfloor width: 25  height: 35\\n"
    },
        "SkIRect_MakeWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect1 = SkIRect::MakeWH(25, 35);\n    SkIRect rect2 = SkIRect::MakeSize({25, 35});\n    SkIRect rect3 = SkIRect::MakeXYWH(0, 0, 25, 35);\n    SkIRect rect4 = SkIRect::MakeLTRB(0, 0, 25, 35);\n    SkDebugf(\"all %s\" \"equal\\n\", rect1 == rect2 && rect2 == rect3 && rect3 == rect4 ?\n             \"\" : \"not \");\n}",
    "hash": "e36827a1a6ae2b1c26e7a8a08f325a07",
    "file": "SkIRect_Reference",
    "name": "SkIRect::MakeWH",
        "stdout": "all equal\\n"
    },
        "SkIRect_MakeXYWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = SkIRect::MakeXYWH(5, 35, -15, 25);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "598ee14350bd1d961cae6b36fa3df17e",
    "file": "SkIRect_Reference",
    "name": "SkIRect::MakeXYWH",
        "stdout": "rect: 5, 35, -10, 60  isEmpty: true\\nrect: -10, 35, 5, 60  isEmpty: false\\n"
    },
        "SkIRect_adjust": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 8, 11, 19, 22 };\n    rect.adjust(2, -1, 1, -2);\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "8dc91284493dd012cca3d0ce4c66bda4",
    "file": "SkIRect_Reference",
    "name": "SkIRect::adjust()",
        "stdout": "rect: 10, 10, 20, 20\\n"
    },
        "SkIRect_bottom": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fBottom: %d unsorted.bottom(): %d\\n\", unsorted.fBottom, unsorted.bottom());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fBottom: %d sorted.bottom(): %d\\n\", sorted.fBottom, sorted.bottom());\n}",
    "hash": "c32afebc296054a181621648a184b8e3",
    "file": "SkIRect_Reference",
    "name": "SkIRect::bottom()",
        "stdout": "unsorted.fBottom: 5 unsorted.bottom(): 5\\nsorted.fBottom: 25 sorted.bottom(): 25\\n"
    },
        "SkIRect_contains": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkIPoint pts[] = { { 30, 50}, { 40, 50}, { 30, 60} };\n    for (auto pt : pts) {\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.contains(pt.x(), pt.y()) ? \"contains\" : \"does not contain\", pt.x(), pt.y());\n    }\n}",
    "hash": "a7958a4e0668f5cf805a8e78eb57f51d",
    "file": "SkIRect_Reference",
    "name": "SkIRect::contains()",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50)\\nrect: (30, 50, 40, 60) does not contain (40, 50)\\nrect: (30, 50, 40, 60) does not contain (30, 60)\\n"
    },
        "SkIRect_containsNoEmptyCheck": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        bool success = rect.containsNoEmptyCheck(\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 success ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "fef2a36bee224e92500199fa9d3cbb8b",
    "file": "SkIRect_Reference",
    "name": "SkIRect::containsNoEmptyCheck",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkIRect_containsNoEmptyCheck_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.containsNoEmptyCheck(contained) ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "8f91f58001d9c10420eb146fbc169af4",
    "file": "SkIRect_Reference",
    "name": "SkIRect::containsNoEmptyCheck_2",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkIRect_contains_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        bool success = rect.contains(\n                       contained.left(), contained.top(), contained.right(), contained.bottom());\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 success ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "eae55f284818d9965ec5834747d14a48",
    "file": "SkIRect_Reference",
    "name": "SkIRect::contains_2",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkIRect_contains_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.contains(contained) ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "ee0185db622602b4eb19583c2f42c734",
    "file": "SkIRect_Reference",
    "name": "SkIRect::contains_3",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkIRect_contains_4": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%g, %g, %g, %g)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.contains(contained) ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "acbd79ffb304f332e4b38ef18e19663e",
    "file": "SkIRect_Reference",
    "name": "SkIRect::contains_4",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkIRect_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect test = {0, 0, 2, 2};\n    SkIRect sorted = test.makeSorted();\n    SkDebugf(\"test %c= sorted\\n\", test == sorted ? '=' : '!');\n}",
    "hash": "bd8f028d9051062816c9116fea4237b2",
    "file": "SkIRect_Reference",
    "name": "SkIRect::operator==(const SkIRect& a, const SkIRect& b)",
        "stdout": "test == sorted\\n"
    },
        "SkIRect_height": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 20 };\n    SkDebugf(\"unsorted height: %d\\n\", unsorted.height());\n    SkIRect large = { 1, -2147483647, 2, 2147483644 };\n    SkDebugf(\"large height: %d\\n\", large.height());\n}",
    "hash": "0175bae87fafcd9433ae661574695586",
    "file": "SkIRect_Reference",
    "name": "SkIRect::height()",
        "stdout": "unsorted height: -5\\nlarge height: -5\\n"
    },
        "SkIRect_height64": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect large = { 1, -2147483647, 2, 2147483644 };\n    SkDebugf(\"height: %d height64: %lld\\n\", large.height(), large.height64());\n}",
    "hash": "02dd98716e54bbd8c2f0ff23b7ef98cf",
    "file": "SkIRect_Reference",
    "name": "SkIRect::height64",
        "stdout": "height: -5 height64: 4294967291\\n"
    },
        "SkIRect_inset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 14, 50, 73 };\n    rect.inset(5, 13);\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "9debaded1aa8bdf5077a4de0b3015b8f",
    "file": "SkIRect_Reference",
    "name": "SkIRect::inset()",
        "stdout": "rect: 15, 27, 45, 60\\n"
    },
        "SkIRect_intersect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect leftRect =  { 10, 40, 50, 80 };\n    SkIRect rightRect = { 30, 60, 70, 90 };\n    SkDebugf(\"%s intersection: \", leftRect.intersect(rightRect) ? \"\" : \"no \");\n    SkDebugf(\"%d, %d, %d, %d\\n\", leftRect.left(), leftRect.top(),\n                                 leftRect.right(), leftRect.bottom());\n}",
    "hash": "ea233f5d5d1ae0e76fc6f2eb371c927a",
    "file": "SkIRect_Reference",
    "name": "SkIRect::intersect()",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkIRect_intersectNoEmptyCheck": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect result;\n    if (result.intersectNoEmptyCheck({ 10, 40, 50, 80 }, { 30, 60, 70, 90 })) {\n        SkDebugf(\"intersection: %d, %d, %d, %d\\n\",\n                 result.left(), result.top(), result.right(), result.bottom());\n    }\n}",
    "hash": "d35fbc9fdea71df8b8a12fd3da50d11c",
    "file": "SkIRect_Reference",
    "name": "SkIRect::intersectNoEmptyCheck",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkIRect_intersect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect result;\n    bool intersected = result.intersect({ 10, 40, 50, 80 }, { 30, 60, 70, 90 });\n    SkDebugf(\"%s intersection: %d, %d, %d, %d\\n\", intersected ? \"\" : \"no \",\n             result.left(), result.top(), result.right(), result.bottom());\n}",
    "hash": "b2db0573aacf99ca52776c5522459d02",
    "file": "SkIRect_Reference",
    "name": "SkIRect::intersect_2",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkIRect_intersect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect leftRect =  { 10, 40, 50, 80 };\n    SkDebugf(\"%s intersection: \", leftRect.intersect(30, 60, 70, 90) ? \"\" : \"no \");\n    SkDebugf(\"%d, %d, %d, %d\\n\", leftRect.left(), leftRect.top(),\n                                 leftRect.right(), leftRect.bottom());\n}",
    "hash": "200422990eded2f754ab9893118f2645",
    "file": "SkIRect_Reference",
    "name": "SkIRect::intersect_3",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkIRect_isEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};\n    for (auto rect : tests) {\n        SkDebugf(\"rect: {%d, %d, %d, %d} is\" \"%s empty\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isEmpty() ? \"\" : \" not\");\n        rect.sort();\n        SkDebugf(\"sorted: {%d, %d, %d, %d} is\" \"%s empty\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isEmpty() ? \"\" : \" not\");\n    }\n}",
    "hash": "edaad064b6de249b7a7c768dfa000adc",
    "file": "SkIRect_Reference",
    "name": "SkIRect::isEmpty",
        "stdout": "rect: {20, 40, 10, 50} is empty\\nsorted: {10, 40, 20, 50} is not empty\\nrect: {20, 40, 20, 50} is empty\\nsorted: {20, 40, 20, 50} is empty\\n"
    },
        "SkIRect_isEmpty64": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};\n    for (auto rect : tests) {\n        SkDebugf(\"rect: {%d, %d, %d, %d} is\" \"%s empty\\n\", rect.left(), rect.top(), rect.right(),\n                rect.bottom(), rect.isEmpty64() ? \"\" : \" not\");\n        rect.sort();\n        SkDebugf(\"sorted: {%d, %d, %d, %d} is\" \"%s empty\\n\", rect.left(), rect.top(), rect.right(),\n                rect.bottom(), rect.isEmpty64() ? \"\" : \" not\");\n    }\n}",
    "hash": "eb905faa1084ccab3ad0605df4c27ea4",
    "file": "SkIRect_Reference",
    "name": "SkIRect::isEmpty64",
        "stdout": "rect: {20, 40, 10, 50} is empty\\nsorted: {10, 40, 20, 50} is not empty\\nrect: {20, 40, 20, 50} is empty\\nsorted: {20, 40, 20, 50} is empty\\n"
    },
        "SkIRect_join": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 20, 15, 25};\n    rect.join(50, 60, 55, 65);\n    SkDebugf(\"join: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "c00ef06289d21db70340e465690e0e08",
    "file": "SkIRect_Reference",
    "name": "SkIRect::join()",
        "stdout": "join: 10, 20, 55, 65\\n"
    },
        "SkIRect_join_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 20, 15, 25};\n    rect.join({50, 60, 55, 65});\n    SkDebugf(\"join: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "75fd81c1d3512e63890d085593018876",
    "file": "SkIRect_Reference",
    "name": "SkIRect::join_2",
        "stdout": "join: 10, 20, 55, 65\\n"
    },
        "SkIRect_left": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 5, 10, 25 };\n    SkDebugf(\"unsorted.fLeft: %d unsorted.left(): %d\\n\", unsorted.fLeft, unsorted.left());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fLeft: %d sorted.left(): %d\\n\", sorted.fLeft, sorted.left());\n}",
    "hash": "caf38ea4431bc246ba198f6a8c2b0f01",
    "file": "SkIRect_Reference",
    "name": "SkIRect::left()",
        "stdout": "unsorted.fLeft: 15 unsorted.left(): 15\\nsorted.fLeft: 10 sorted.left(): 10\\n"
    },
        "SkIRect_makeInset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeInset(15, 32);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "1db94b2c76e0a7a71856532335fa56b6",
    "file": "SkIRect_Reference",
    "name": "SkIRect::makeInset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: 25, 82, 5, 28  isEmpty: true\\n"
    },
        "SkIRect_makeOffset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeOffset(15, 32);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "737c747df07ddf392c05970440de0927",
    "file": "SkIRect_Reference",
    "name": "SkIRect::makeOffset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: 25, 82, 35, 92  isEmpty: false\\n"
    },
        "SkIRect_makeOutset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeOutset(15, 32);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "240e2953e3455c08f6d89255feff8416",
    "file": "SkIRect_Reference",
    "name": "SkIRect::makeOutset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: -5, 18, 35, 92  isEmpty: false\\n"
    },
        "SkIRect_makeSorted": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 20, 10 };\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    SkIRect sort = rect.makeSorted();\n    SkDebugf(\"sorted: %d, %d, %d, %d\\n\", sort.fLeft, sort.fTop, sort.fRight, sort.fBottom);\n}",
    "hash": "de89926c374aa16427916900b89a3441",
    "file": "SkIRect_Reference",
    "name": "SkIRect::makeSorted",
        "stdout": "rect: 30, 50, 20, 10\\nsorted: 20, 10, 30, 50\\n"
    },
        "SkIRect_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect test = {2, 2, 0, 0};\n    SkIRect sorted = test.makeSorted();\n    SkDebugf(\"test %c= sorted\\n\", test != sorted ? '!' : '=');\n}",
    "hash": "6c4acd8aa203f632b7d85cae672abf4d",
    "file": "SkIRect_Reference",
    "name": "SkIRect::operator!=(const SkIRect& a, const SkIRect& b)",
        "stdout": "test != sorted\\n"
    },
        "SkIRect_offset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 14, 50, 73 };\n    rect.offset(5, 13);\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "77e633b2174ffae923c038b303418b50",
    "file": "SkIRect_Reference",
    "name": "SkIRect::offset()",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkIRect_offsetTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 14, 50, 73 };\n    rect.offsetTo(15, 27);\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "a2734ff23b35653956a3002e5c29ff91",
    "file": "SkIRect_Reference",
    "name": "SkIRect::offsetTo",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkIRect_offset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 14, 50, 73 };\n    rect.offset({5, 13});\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "31a4c575499e76def651eb65994876f0",
    "file": "SkIRect_Reference",
    "name": "SkIRect::offset_2",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkIRect_outset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 14, 50, 73 };\n    rect.outset(5, 13);\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "3fc62ca29428195f33a3a02b3eb74e4f",
    "file": "SkIRect_Reference",
    "name": "SkIRect::outset()",
        "stdout": "rect: 5, 1, 55, 86\\n"
    },
        "SkIRect_right": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fRight: %d unsorted.right(): %d\\n\", unsorted.fRight, unsorted.right());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fRight: %d sorted.right(): %d\\n\", sorted.fRight, sorted.right());\n}",
    "hash": "97e210976f1ee0387b30c70635cf114f",
    "file": "SkIRect_Reference",
    "name": "SkIRect::right()",
        "stdout": "unsorted.fRight: 10 unsorted.right(): 10\\nsorted.fRight: 15 sorted.right(): 15\\n"
    },
        "SkIRect_set": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect1 = {3, 4, 1, 2};\n    SkDebugf(\"rect1: {%d, %d, %d, %d}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkIRect rect2;\n    rect2.set(3, 4, 1, 2);\n    SkDebugf(\"rect2: {%d, %d, %d, %d}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "1912c37076b7f3bf6aebfa167e971bec",
    "file": "SkIRect_Reference",
    "name": "SkIRect::set()",
        "stdout": "rect1: {3, 4, 1, 2}\\nrect2: {3, 4, 1, 2}\\n"
    },
        "SkIRect_setEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = {3, 4, 1, 2};\n    for (int i = 0; i < 2; ++i) {\n    SkDebugf(\"rect: {%d, %d, %d, %d} is %s\" \"empty\\n\", rect.fLeft, rect.fTop,\n             rect.fRight, rect.fBottom, rect.isEmpty() ? \"\" : \"not \");\n    rect.setEmpty();\n    }\n}",
    "hash": "94039c3cc9e911c8ab2993d56fd06210",
    "file": "SkIRect_Reference",
    "name": "SkIRect::setEmpty",
        "stdout": "rect: {3, 4, 1, 2} is empty\\nrect: {0, 0, 0, 0} is empty\\n"
    },
        "SkIRect_setLTRB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect1 = {3, 4, 1, 2};\n    SkDebugf(\"rect1: {%d, %d, %d, %d}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkIRect rect2;\n    rect2.setLTRB(3, 4, 1, 2);\n    SkDebugf(\"rect2: {%d, %d, %d, %d}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "ead6bdcf2ae77ec19a1c5a96f5b31af8",
    "file": "SkIRect_Reference",
    "name": "SkIRect::setLTRB",
        "stdout": "rect1: {3, 4, 1, 2}\\nrect2: {3, 4, 1, 2}\\n"
    },
        "SkIRect_setXYWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect;\n    rect.setXYWH(5, 35, -15, 25);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "0e1db8c86678c004e504f47641b44b17",
    "file": "SkIRect_Reference",
    "name": "SkIRect::setXYWH",
        "stdout": "rect: 5, 35, -10, 60  isEmpty: true\\nrect: -10, 35, 5, 60  isEmpty: false\\n"
    },
        "SkIRect_size": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkIRect& rect) -> void {\n        SkISize size = rect.size();\n        SkDebugf(\"%s \", prefix);\n        SkDebugf(\"rect: %d, %d, %d, %d  \", rect.left(), rect.top(), rect.right(), rect.bottom());\n        SkDebugf(\"size: %d, %d\\n\", size.width(), size.height());\n    };\n    SkIRect rect = {20, 30, 40, 50};\n    debugster(\"original\", rect);\n    rect.offset(20, 20);\n    debugster(\"  offset\", rect);\n    rect.outset(20, 20);\n    debugster(\"  outset\", rect);\n}",
    "hash": "8b3224641cb3053a7b8a5798b6cd1cf6",
    "file": "SkIRect_Reference",
    "name": "SkIRect::size()",
        "stdout": "original rect: 20, 30, 40, 50  size: 20, 20\\n  offset rect: 40, 50, 60, 70  size: 20, 20\\n  outset rect: 20, 30, 80, 90  size: 60, 60\\n"
    },
        "SkIRect_sort": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 20, 10 };\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    rect.sort();\n    SkDebugf(\"sorted: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "fa12547fcfd4c1aef3db1a1f6aae0fe4",
    "file": "SkIRect_Reference",
    "name": "SkIRect::sort()",
        "stdout": "rect: 30, 50, 20, 10\\nsorted: 20, 10, 30, 50\\n"
    },
        "SkIRect_top": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fTop: %d unsorted.top(): %d\\n\", unsorted.fTop, unsorted.top());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fTop: %d sorted.top(): %d\\n\", sorted.fTop, sorted.top());\n}",
    "hash": "cbec1ae6530e95943775450b1d11f19e",
    "file": "SkIRect_Reference",
    "name": "SkIRect::top()",
        "stdout": "unsorted.fTop: 25 unsorted.top(): 25\\nsorted.fTop: 5 sorted.top(): 5\\n"
    },
        "SkIRect_width": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted width: %d\\n\", unsorted.width());\n    SkIRect large = { -2147483647, 1, 2147483644, 2 };\n    SkDebugf(\"large width: %d\\n\", large.width());\n}",
    "hash": "4acfbe051805940210c8916a94794142",
    "file": "SkIRect_Reference",
    "name": "SkIRect::width()",
        "stdout": "unsorted width: -5\\nlarge width: -5\\n"
    },
        "SkIRect_width64": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect large = { -2147483647, 1, 2147483644, 2 };\n    SkDebugf(\"width: %d width64: %lld\\n\", large.width(), large.width64());\n}",
    "hash": "63977f97999bbd6eecfdcc7575d75492",
    "file": "SkIRect_Reference",
    "name": "SkIRect::width64",
        "stdout": "width: -5 width64: 4294967291\\n"
    },
        "SkIRect_x": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 5, 10, 25 };\n    SkDebugf(\"unsorted.fLeft: %d unsorted.x(): %d\\n\", unsorted.fLeft, unsorted.x());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fLeft: %d sorted.x(): %d\\n\", sorted.fLeft, sorted.x());\n}",
    "hash": "2a59cbfd1330a0db520d6ebb2b7c68c7",
    "file": "SkIRect_Reference",
    "name": "SkIRect::x()",
        "stdout": "unsorted.fLeft: 15 unsorted.x(): 15\\nsorted.fLeft: 10 sorted.x(): 10\\n"
    },
        "SkIRect_y": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fTop: %d unsorted.y(): %d\\n\", unsorted.fTop, unsorted.y());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fTop: %d sorted.y(): %d\\n\", sorted.fTop, sorted.y());\n}",
    "hash": "6ea461e71f7fc80605818fbf493caa63",
    "file": "SkIRect_Reference",
    "name": "SkIRect::y()",
        "stdout": "unsorted.fTop: 25 unsorted.y(): 25\\nsorted.fTop: 5 sorted.y(): 5\\n"
    },
        "SkImageInfo_ByteSizeOverflowed": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(2, 1000000000);\n    for (size_t rowBytes = 100000000; rowBytes < 10000000000000LL; rowBytes *= 10) {\n        const size_t size = info.computeByteSize(rowBytes);\n        SkDebugf(\"rowBytes:%llu size:%llu overflowed:%s\\n\", rowBytes, size,\n                 SkImageInfo::ByteSizeOverflowed(size) ? \"true\" : \"false\");\n    }\n}",
    "hash": "6a63dfdd62ab77ff57783af8c33d7b78",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::ByteSizeOverflowed",
        "stdout": "rowBytes:100000000 size:99999999900000008 overflowed:false\\nrowBytes:1000000000 size:999999999000000008 overflowed:false\\nrowBytes:10000000000 size:9999999990000000008 overflowed:false\\nrowBytes:100000000000 size:18446744073709551615 overflowed:true\\nrowBytes:1000000000000 size:18446744073709551615 overflowed:true\\n"
    },
        "SkImageInfo_alphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    SkImageInfo info = SkImageInfo::MakeA8(16, 32);\n    SkDebugf(\"alpha type: k\" \"%s\" \"_SkAlphaType\\n\", alphas[info.alphaType()]);\n}",
    "hash": "5c1d2499a4056b6cff38c1cf924158a1",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::alphaType",
        "stdout": "alpha type: kPremul_SkAlphaType\\n"
    },
        "SkImageInfo_bytesPerPixel": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    for (SkColorType colorType : {\n    kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType,\n    kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType,\n    kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType,\n    kGray_8_SkColorType, kRGBA_F16_SkColorType\n                                 } ) {\n        SkImageInfo info = SkImageInfo::Make(1, 1, colorType, kOpaque_SkAlphaType);\n        SkDebugf(\"color: k\" \"%s\" \"_SkColorType\" \"%*s\" \"bytesPerPixel: %d\\n\",\n                colors[colorType], 13 - strlen(colors[colorType]), \" \",\n                info.bytesPerPixel());\n    }\n}",
    "hash": "9b6de4a07b2316228e9340e5a3b82134",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::bytesPerPixel",
        "stdout": "color: kUnknown_SkColorType      bytesPerPixel: 0\\ncolor: kAlpha_8_SkColorType      bytesPerPixel: 1\\ncolor: kRGB_565_SkColorType      bytesPerPixel: 2\\ncolor: kARGB_4444_SkColorType    bytesPerPixel: 2\\ncolor: kRGBA_8888_SkColorType    bytesPerPixel: 4\\ncolor: kRGB_888x_SkColorType     bytesPerPixel: 4\\ncolor: kBGRA_8888_SkColorType    bytesPerPixel: 4\\ncolor: kRGBA_1010102_SkColorType bytesPerPixel: 4\\ncolor: kRGB_101010x_SkColorType  bytesPerPixel: 4\\ncolor: kGray_8_SkColorType       bytesPerPixel: 1\\ncolor: kRGBA_F16_SkColorType     bytesPerPixel: 8\\n"
    },
        "SkImageInfo_colorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,\n            SkColorSpace::MakeSRGBLinear());\n    SkColorSpace* colorSpace = info.colorSpace();\n    SkDebugf(\"gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\\n\",\n            colorSpace->gammaCloseToSRGB() ? \"true\" : \"false\",\n            colorSpace->gammaIsLinear() ? \"true\" : \"false\",\n            colorSpace->isSRGB() ? \"true\" : \"false\");\n}",
    "hash": "5602b816d7cf75e3851274ef36a4c10f",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::colorSpace",
        "stdout": "gammaCloseToSRGB: false  gammaIsLinear: true  isSRGB: false\\n"
    },
        "SkImageInfo_colorType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkImageInfo info = SkImageInfo::MakeA8(16, 32);\n    SkDebugf(\"color type: k\" \"%s\" \"_SkColorType\\n\", colors[info.colorType()]);\n}",
    "hash": "06ecc3ce7f35cc7f930cbc2a662e3105",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::colorType",
        "stdout": "color type: kAlpha_8_SkColorType\\n"
    },
        "SkImageInfo_dimensions": {
    "code": "void draw(SkCanvas* canvas) {\n    const int height = 2;\n    const int width = 2;\n    SkImageInfo imageInfo = SkImageInfo::Make(width, height, kN32_SkColorType, kPremul_SkAlphaType);\n    SkISize dimensions = imageInfo.dimensions();\n    SkIRect bounds = imageInfo.bounds();\n    SkIRect dimensionsAsBounds = SkIRect::MakeSize(dimensions);\n    SkDebugf(\"dimensionsAsBounds %c= bounds\\n\", dimensionsAsBounds == bounds ? '=' : '!');\n}",
    "hash": "d5547cd2b302822aa85b7b0ae3f48458",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::dimensions()",
        "stdout": "dimensionsAsBounds == bounds\\n"
    },
        "SkImageInfo_equal1_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info1 = SkImageInfo::Make(10, 20, kGray_8_SkColorType, kPremul_SkAlphaType);\n    SkImageInfo info2 = SkImageInfo::Make(20, 10, kAlpha_8_SkColorType, kUnpremul_SkAlphaType);\n    SkDebugf(\"info1 %c= info2\\n\", info1 == info2 ? '=' : '!');\n    info2 = info2.makeWH(10, 20);\n    SkDebugf(\"info1 %c= info2\\n\", info1 == info2 ? '=' : '!');\n    info2 = info2.makeColorType(kGray_8_SkColorType);\n    SkDebugf(\"info1 %c= info2\\n\", info1 == info2 ? '=' : '!');\n    info2 = info2.makeAlphaType(kPremul_SkAlphaType);\n    SkDebugf(\"info1 %c= info2\\n\", info1 == info2 ? '=' : '!');\n}",
    "hash": "53c212c4f2449df0b0eedbc6227b6ab7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::operator==(const SkImageInfo& other) const",
        "stdout": "info1 != info2\\ninfo1 != info2\\ninfo1 != info2\\ninfo1 == info2\\n"
    },
        "SkImageInfo_isEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    for (int width : { 0, 2 } ) {\n        for (int height : { 0, 2 } ) {\n             SkImageInfo imageInfo= SkImageInfo::MakeA8(width, height);\n             SkDebugf(\"width: %d height: %d empty: %s\\n\", width, height,\n                      imageInfo.isEmpty() ? \"true\" : \"false\");\n        }\n    }\n}",
    "hash": "b8757200da5be0b43763cf79feb681a7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::isEmpty",
        "stdout": "width: 0 height: 0 empty: true\\nwidth: 0 height: 2 empty: true\\nwidth: 2 height: 0 empty: true\\nwidth: 2 height: 2 empty: false\\n"
    },
        "SkImageInfo_isOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    const int height = 2;\n    const int width = 2;\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(width, height, kN32_SkColorType, kPremul_SkAlphaType);\n    bitmap.setInfo(imageInfo);\n    for (int index = 0; index < 2; ++index) {\n        bitmap.allocPixels();\n        bitmap.eraseColor(0x00000000);\n        SkDebugf(\"isOpaque: %s\\n\", imageInfo.isOpaque() ? \"true\" : \"false\");\n        bitmap.eraseColor(0xFFFFFFFF);\n        SkDebugf(\"isOpaque: %s\\n\", imageInfo.isOpaque() ? \"true\" : \"false\");\n        imageInfo = imageInfo.makeAlphaType(kOpaque_SkAlphaType);\n        bitmap.setInfo(imageInfo);\n    }\n}",
    "hash": "e9bd4f02b6cfb3ac864cb7fee7d7299c",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::isOpaque",
        "stdout": "isOpaque: false\\nisOpaque: false\\nisOpaque: true\\nisOpaque: true\\n"
    },
        "SkImageInfo_minRowBytes": {
    "code": "void draw(SkCanvas* canvas) {\n    for (int shift = 24; shift < 32; ++shift) {\n        int width = 1 << shift;\n        SkImageInfo imageInfo =\n                SkImageInfo::Make(width, 1, kRGBA_F16_SkColorType, kPremul_SkAlphaType);\n        size_t minRowBytes = imageInfo.minRowBytes();\n        bool widthTooLarge = !minRowBytes;\n        SkDebugf(\"RGBA_F16 width %d (0x%08x) %s\\n\",\n                width, width, widthTooLarge ? \"too large\" : \"OK\");\n    }\n}",
    "hash": "897230ecfb36095486beca324fd369f9",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::minRowBytes",
        "stdout": "RGBA_F16 width 16777216 (0x01000000) OK\\nRGBA_F16 width 33554432 (0x02000000) OK\\nRGBA_F16 width 67108864 (0x04000000) OK\\nRGBA_F16 width 134217728 (0x08000000) OK\\nRGBA_F16 width 268435456 (0x10000000) too large\\nRGBA_F16 width 536870912 (0x20000000) too large\\nRGBA_F16 width 1073741824 (0x40000000) too large\\nRGBA_F16 width -2147483648 (0x80000000) too large\\n"
    },
        "SkImageInfo_minRowBytes64": {
    "code": "void draw(SkCanvas* canvas) {\n    for (int shift = 24; shift < 32; ++shift) {\n        int width = 1 << shift;\n        SkImageInfo imageInfo =\n                SkImageInfo::Make(width, 1, kRGBA_F16_SkColorType, kPremul_SkAlphaType);\n        uint64_t minRowBytes = imageInfo.minRowBytes64();\n        bool widthTooLarge = (uint64_t) (int32_t) minRowBytes != minRowBytes;\n        SkDebugf(\"RGBA_F16 width %d (0x%08x) %s\\n\",\n                width, width, widthTooLarge ? \"too large\" : \"OK\");\n    }\n}",
    "hash": "4b5d3904476726a39f1c3e276d6b6ba7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::minRowBytes64",
        "stdout": "RGBA_F16 width 16777216 (0x01000000) OK\\nRGBA_F16 width 33554432 (0x02000000) OK\\nRGBA_F16 width 67108864 (0x04000000) OK\\nRGBA_F16 width 134217728 (0x08000000) OK\\nRGBA_F16 width 268435456 (0x10000000) too large\\nRGBA_F16 width 536870912 (0x20000000) too large\\nRGBA_F16 width 1073741824 (0x40000000) too large\\nRGBA_F16 width -2147483648 (0x80000000) too large\\n"
    },
        "SkImageInfo_notequal1_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info1 = SkImageInfo::Make(10, 20, kGray_8_SkColorType, kPremul_SkAlphaType);\n    SkImageInfo info2 = SkImageInfo::Make(20, 10, kAlpha_8_SkColorType, kUnpremul_SkAlphaType);\n    SkDebugf(\"info1 %c= info2\\n\", info1 != info2 ? '!' : '=');\n    info2 = info2.makeWH(10, 20);\n    SkDebugf(\"info1 %c= info2\\n\", info1 != info2 ? '!' : '=');\n    info2 = info2.makeColorType(kGray_8_SkColorType);\n    SkDebugf(\"info1 %c= info2\\n\", info1 != info2 ? '!' : '=');\n    info2 = info2.makeAlphaType(kPremul_SkAlphaType);\n    SkDebugf(\"info1 %c= info2\\n\", info1 != info2 ? '!' : '=');\n}",
    "hash": "8c039fde0a476ac1aa62bf9de5d61c77",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::operator!=(const SkImageInfo& other) const",
        "stdout": "info1 != info2\\ninfo1 != info2\\ninfo1 != info2\\ninfo1 == info2\\n"
    },
        "SkImageInfo_refColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info1 = SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,\n            SkColorSpace::MakeSRGBLinear());\n    SkImageInfo info2 = SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,\n            info1.refColorSpace());\n    SkColorSpace* colorSpace = info2.colorSpace();\n    SkDebugf(\"gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\\n\",\n            colorSpace->gammaCloseToSRGB() ? \"true\" : \"false\",\n            colorSpace->gammaIsLinear() ? \"true\" : \"false\",\n            colorSpace->isSRGB() ? \"true\" : \"false\");\n}",
    "hash": "33f65524736736fd91802b4198ba6fa8",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::refColorSpace",
        "stdout": "gammaCloseToSRGB: false  gammaIsLinear: true  isSRGB: false\\n"
    },
        "SkImageInfo_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(16, 8);\n    SkImageInfo copy = info;\n    SkDebugf(\"info %c= copy\\n\", info == copy ? '=' : '!');\n    copy.reset();\n    SkDebugf(\"info %c= reset copy\\n\", info == copy ? '=' : '!');\n    SkDebugf(\"SkImageInfo() %c= reset copy\\n\", SkImageInfo() == copy ? '=' : '!');\n}",
    "hash": "ab7e73786805c936de386b6c1ebe1f13",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::reset()",
        "stdout": "info == copy\\ninfo != reset copy\\nSkImageInfo() == reset copy\\n"
    },
        "SkImageInfo_shiftPerPixel": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    for (SkColorType colorType : {\n    kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType,\n    kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType,\n    kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType,\n    kGray_8_SkColorType, kRGBA_F16_SkColorType\n                                 } ) {\n        SkImageInfo info = SkImageInfo::Make(1, 1, colorType, kOpaque_SkAlphaType);\n        SkDebugf(\"color: k\" \"%s\" \"_SkColorType\" \"%*s\" \"shiftPerPixel: %d\\n\",\n                colors[colorType], 14 - strlen(colors[colorType]), \" \",\n                info.shiftPerPixel());\n    }\n}",
    "hash": "e47b911f94fc629f756a829e523a2a89",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::shiftPerPixel",
        "stdout": "color: kUnknown_SkColorType       shiftPerPixel: 0\\ncolor: kAlpha_8_SkColorType       shiftPerPixel: 0\\ncolor: kRGB_565_SkColorType       shiftPerPixel: 1\\ncolor: kARGB_4444_SkColorType     shiftPerPixel: 1\\ncolor: kRGBA_8888_SkColorType     shiftPerPixel: 2\\ncolor: kRGB_888x_SkColorType      shiftPerPixel: 2\\ncolor: kBGRA_8888_SkColorType     shiftPerPixel: 2\\ncolor: kRGBA_1010102_SkColorType  shiftPerPixel: 2\\ncolor: kRGB_101010x_SkColorType   shiftPerPixel: 2\\ncolor: kGray_8_SkColorType        shiftPerPixel: 0\\ncolor: kRGBA_F16_SkColorType      shiftPerPixel: 3\\n"
    },
        "SkImageInfo_validRowBytes": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(16, 8);\n    for (size_t rowBytes = 60; rowBytes < 72; rowBytes += sizeof(SkPMColor)) {\n        SkDebugf(\"validRowBytes(%llu): %s\\n\", rowBytes, info.validRowBytes(rowBytes) ?\n                 \"true\" : \"false\");\n    }\n}",
    "hash": "c6b0f6a3f493cb08d9abcdefe12de245",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::validRowBytes",
        "stdout": "validRowBytes(60): false\\nvalidRowBytes(64): true\\nvalidRowBytes(68): true\\n"
    },
        "SkImage_MakeFromRaster": {
    "code": "static void releaseProc(const void* pixels, SkImage::ReleaseContext context) {\n     int* countPtr = static_cast<int*>(context);\n     *countPtr += 1;\n}\n\nvoid draw(SkCanvas* canvas) {\n    SkColor color = 0;\n    SkPixmap pixmap(SkImageInfo::MakeN32(1, 1, kPremul_SkAlphaType), &color, 4);\n    int releaseCount = 0;\n    sk_sp<SkImage> image(SkImage::MakeFromRaster(pixmap, releaseProc, &releaseCount));\n    SkDebugf(\"before reset: %d\\n\", releaseCount);\n    image.reset();\n    SkDebugf(\"after reset: %d\\n\", releaseCount);\n}\n",
    "hash": "275356b65d18c8868f4434137350cddc",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromRaster",
        "stdout": "before reset: 0\\nafter reset: 1\\n"
    },
        "SkImage_dimensions": {
    "code": "void draw(SkCanvas* canvas) {\n    SkISize dimensions = image->dimensions();\n    SkIRect bounds = image->bounds();\n    SkIRect dimensionsAsBounds = SkIRect::MakeSize(dimensions);\n    SkDebugf(\"dimensionsAsBounds %c= bounds\\n\", dimensionsAsBounds == bounds ? '=' : '!');\n}",
    "hash": "96b4bc43b3667df9ba9e2dafb770d33c",
    "file": "SkImage_Reference",
    "name": "SkImage::dimensions()",
        "stdout": "dimensionsAsBounds == bounds\\n"
    },
        "SkImage_isAlphaOnly": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t pmColors = 0;\n    sk_sp<SkImage> image = SkImage::MakeRasterCopy({SkImageInfo::MakeA8(1, 1), &pmColors, 1});\n    SkDebugf(\"alphaOnly = %s\\n\", image->isAlphaOnly() ? \"true\" : \"false\");\n}",
    "hash": "50762c73b8ea91959c5a7b68fbf1062d",
    "file": "SkImage_Reference",
    "name": "SkImage::isAlphaOnly",
        "stdout": "alphaOnly = true\\n"
    },
        "SkImage_isOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    auto check_isopaque = [](const SkImageInfo& imageInfo) -> void {\n        auto surface(SkSurface::MakeRaster(imageInfo));\n        auto image(surface->makeImageSnapshot());\n        SkDebugf(\"isOpaque = %s\\n\", image->isOpaque() ? \"true\" : \"false\");\n    };\n    check_isopaque(SkImageInfo::MakeN32Premul(5, 5));\n    check_isopaque(SkImageInfo::MakeN32(5, 5, kOpaque_SkAlphaType));\n}",
    "hash": "e3340460003b74ee286d625e68589d65",
    "file": "SkImage_Reference",
    "name": "SkImage::isOpaque",
        "stdout": "isOpaque = false\\nisOpaque = true\\n"
    },
        "SkImage_peekPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(12, 11));\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorWHITE);\n    SkPaint paint;\n    offscreen.drawString(\"%\", 1, 10, paint);\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkPixmap pixmap;\n    if (image->peekPixels(&pixmap)) {\n        const SkPMColor* pixels = pixmap.addr32();\n        SkPMColor pmWhite = pixels[0];\n        for (int y = 0; y < image->height(); ++y) {\n            for (int x = 0; x < image->width(); ++x) {\n                SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n            }\n            SkDebugf(\"\\n\");\n        }\n    }\n}",
    "hash": "900c0eab8dfdecd8301ed5be95887f8e",
    "file": "SkImage_Reference",
    "name": "SkImage::peekPixels",
        "stdout": "------------\\n--xx----x---\\n-x--x--x----\\n-x--x--x----\\n-x--x-x-----\\n--xx-xx-xx--\\n-----x-x--x-\\n----x--x--x-\\n----x--x--x-\\n---x----xx--\\n------------\\n"
    },
        "SkMatrix_I": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m1, m2, m3;\n    m1.reset();\n    m2.setIdentity();\n    m3 = SkMatrix::I();\n    SkDebugf(\"m1 %c= m2\\n\", m1 == m2 ? '=' : '!');\n    SkDebugf(\"m2 %c= m3\\n\", m1 == m2 ? '=' : '!');\n}",
    "hash": "d961d91020f19037204a8c3fd8cb1060",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::I",
        "stdout": "m1 == m2\\nm2 == m3\\n"
    },
        "SkMatrix_InvalidMatrix": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"scaleX %g\\n\", SkMatrix::InvalidMatrix().getScaleX());\n}",
    "hash": "af0b72360c1c7a25b4754bfa47011dd5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::InvalidMatrix",
        "stdout": "scaleX 3.40282e+38\\n"
    },
        "SkMatrix_MakeRectToRect": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkRect srcs[] = { {0, 0, 0, 0}, {1, 2, 3, 4} };\n    const SkRect dsts[] = { {0, 0, 0, 0}, {5, 6, 8, 9} };\n    for (auto src : srcs) {\n        for (auto dst : dsts) {\n             SkMatrix matrix = SkMatrix::MakeRectToRect(src, dst, SkMatrix::kFill_ScaleToFit);\n             SkDebugf(\"src: %g, %g, %g, %g  dst: %g, %g, %g, %g\\n\",\n                      src.fLeft, src.fTop, src.fRight, src.fBottom,\n                      dst.fLeft, dst.fTop, dst.fRight, dst.fBottom);\n             matrix.dump();\n        }\n    }\n}",
    "hash": "a1d6a6721b39350f81021f71a1b93208",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::MakeRectToRect",
        "stdout": "src: 0, 0, 0, 0  dst: 0, 0, 0, 0\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 0, 0, 0, 0  dst: 5, 6, 8, 9\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 1, 2, 3, 4  dst: 0, 0, 0, 0\\n[  0.0000   0.0000   0.0000][  0.0000   0.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 1, 2, 3, 4  dst: 5, 6, 8, 9\\n[  1.5000   0.0000   3.5000][  0.0000   1.5000   3.0000][  0.0000   0.0000   1.0000]\\n"
    },
        "SkMatrix_SetAffineIdentity": {
    "code": "void draw(SkCanvas* canvas) {\n    SkScalar affine[6];\n    SkMatrix::SetAffineIdentity(affine);\n    const char* names[] = { \"ScaleX\", \"SkewY\", \"SkewX\", \"ScaleY\", \"TransX\", \"TransY\" };\n    for (int i = 0; i < 6; ++i) {\n        SkDebugf(\"%s: %g \", names[i], affine[i]);\n    }\n    SkDebugf(\"\\n\");\n}",
    "hash": "e10adbd0bcc940c5d4d872db0e78e892",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::SetAffineIdentity",
        "stdout": "ScaleX: 1 SkewY: 0 SkewX: 0 ScaleY: 1 TransX: 0 TransY: 0 \\n"
    },
        "SkMatrix_TypeMask": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkMatrix& matrix) -> void {\n        SkString typeMask;\n        typeMask += SkMatrix::kIdentity_Mask == matrix.getType() ? \"kIdentity_Mask \" : \"\";\n        typeMask += SkMatrix::kTranslate_Mask & matrix.getType() ? \"kTranslate_Mask \" : \"\";\n        typeMask += SkMatrix::kScale_Mask & matrix.getType() ? \"kScale_Mask \" : \"\";\n        typeMask += SkMatrix::kAffine_Mask & matrix.getType() ? \"kAffine_Mask \" : \"\";\n        typeMask += SkMatrix::kPerspective_Mask & matrix.getType() ? \"kPerspective_Mask\" : \"\";\n        SkDebugf(\"after %s: %s\\n\", prefix, typeMask.c_str());\n    };\nSkMatrix matrix;\nmatrix.reset();\ndebugster(\"reset\", matrix);\nmatrix.postTranslate(1, 0);\ndebugster(\"postTranslate\", matrix);\nmatrix.postScale(2, 1);\ndebugster(\"postScale\", matrix);\nmatrix.postRotate(45);\ndebugster(\"postScale\", matrix);\nSkPoint polys[][4] = {{{0, 0}, {0, 1}, {1, 1}, {1, 0}}, {{0, 0}, {0, 1}, {2, 1}, {1, 0}}};\nmatrix.setPolyToPoly(polys[0], polys[1], 4);\ndebugster(\"setPolyToPoly\", matrix);\n}",
    "hash": "ba19b36df8cd78586f3dff54e2d4c093",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::TypeMask",
        "stdout": "after reset: kIdentity_Mask \\nafter postTranslate: kTranslate_Mask \\nafter postScale: kTranslate_Mask kScale_Mask \\nafter postScale: kTranslate_Mask kScale_Mask kAffine_Mask \\nafter setPolyToPoly: kTranslate_Mask kScale_Mask kAffine_Mask kPerspective_Mask\\n"
    },
        "SkMatrix_array1_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setIdentity();\n    SkDebugf(\"with identity matrix: x = %g\\n\", matrix.mapXY(24, 42).fX);\n    SkScalar& skewRef = matrix[SkMatrix::kMSkewX];\n    skewRef = 0;\n    SkDebugf(\"after skew x mod:     x = %g\\n\", matrix.mapXY(24, 42).fX);\n    skewRef = 1;\n    SkDebugf(\"after 2nd skew x mod: x = %g\\n\", matrix.mapXY(24, 42).fX);\n    matrix.dirtyMatrixTypeCache();\n    SkDebugf(\"after dirty cache:    x = %g\\n\", matrix.mapXY(24, 42).fX);\n}",
    "hash": "f4365ef332f51f7fd25040e0771ba9a2",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::operator[](int index)",
        "stdout": "with identity matrix: x = 24\\nafter skew x mod:     x = 24\\nafter 2nd skew x mod: x = 24\\nafter dirty cache:    x = 66\\n"
    },
        "SkMatrix_array_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScale(42, 24);\n    SkDebugf(\"matrix[SkMatrix::kMScaleX] %c= 42\\n\", matrix[SkMatrix::kMScaleX] == 42 ? '=' : '!');\n    SkDebugf(\"matrix[SkMatrix::kMScaleY] %c= 24\\n\", matrix[SkMatrix::kMScaleY] == 24 ? '=' : '!');\n}",
    "hash": "e8740493abdf0c6341762db9cee56b89",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::operator[](int index) const",
        "stdout": "matrix[SkMatrix::kMScaleX] == 42\\nmatrix[SkMatrix::kMScaleY] == 24\\n"
    },
        "SkMatrix_asAffine": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setAll(2, 3, 4, 5, 6, 7, 0, 0, 1);\n    SkScalar affine[6];\n    if (matrix.asAffine(affine)) {\n        const char* names[] = { \"ScaleX\", \"SkewY\", \"SkewX\", \"ScaleY\", \"TransX\", \"TransY\" };\n        for (int i = 0; i < 6; ++i) {\n            SkDebugf(\"%s: %g \", names[i], affine[i]);\n        }\n        SkDebugf(\"\\n\");\n    }\n}",
    "hash": "3325bdf82bd86d9fbc4199f248afa82c",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::asAffine",
        "stdout": "ScaleX: 2 SkewY: 5 SkewX: 3 ScaleY: 6 TransX: 4 TransY: 7 \\n"
    },
        "SkMatrix_cheapEqualTo": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkMatrix& a, const SkMatrix& b) -> void {\n        SkDebugf(\"%s: a %c= b a.cheapEqualTo(b): %s\\n\", prefix,\n                 a == b ? '=' : '!', a.cheapEqualTo(b) ? \"true\" : \"false\");\n    };\n    SkMatrix a, b;\n    a.setAll(1, 0, 0,   0, 1, 0,  0, 0, 1);\n    b.setIdentity();\n    debugster(\"identity\", a, b);\n    a.setAll(1, -0.0f, 0,   0, 1, 0,  0, 0, 1);\n    debugster(\"neg zero\", a, b);\n    a.setAll(1, SK_ScalarNaN, 0,   0, 1, 0,  0, 0, 1);\n    debugster(\" one NaN\", a, b);\n    b.setAll(1, SK_ScalarNaN, 0,   0, 1, 0,  0, 0, 1);\n    debugster(\"both NaN\", a, b);\n}",
    "hash": "39016b3cfc6bbabb09348a53822ce508",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::cheapEqualTo",
        "stdout": "identity: a == b a.cheapEqualTo(b): true\\nneg zero: a == b a.cheapEqualTo(b): false\\n one NaN: a != b a.cheapEqualTo(b): false\\nboth NaN: a != b a.cheapEqualTo(b): true\\n"
    },
        "SkMatrix_decomposeScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setRotate(90 * SK_Scalar1);\n    matrix.postScale(1.f / 4, 1.f / 2);\n    matrix.dump();\n    SkSize scale = {SK_ScalarNaN, SK_ScalarNaN};\n    SkMatrix remaining;\n    remaining.reset();\n    bool success = matrix.decomposeScale(&scale, &remaining);\n    SkDebugf(\"success: %s  \", success ? \"true\" : \"false\");\n    SkDebugf(\"scale: %g, %g\\n\", scale.width(), scale.height());\n    remaining.dump();\n    SkMatrix scaleMatrix = SkMatrix::MakeScale(scale.width(), scale.height());\n    SkMatrix combined = SkMatrix::Concat(scaleMatrix, remaining);\n    combined.dump();\n}",
    "hash": "139b874da0a3ede1f3df88119085c0aa",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::decomposeScale",
        "stdout": "[  0.0000  -0.2500   0.0000][  0.5000   0.0000   0.0000][  0.0000   0.0000   1.0000]\\nsuccess: true  scale: 0.5, 0.25\\n[  0.0000  -0.5000   0.0000][  2.0000   0.0000   0.0000][  0.0000   0.0000   1.0000]\\n[  0.0000  -0.2500   0.0000][  0.5000   0.0000   0.0000][  0.0000   0.0000   1.0000]\\n"
    },
        "SkMatrix_dirtyMatrixTypeCache": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setIdentity();\n    SkDebugf(\"with identity matrix: x = %g\\n\", matrix.mapXY(24, 42).fX);\n    SkScalar& skewRef = matrix[SkMatrix::kMSkewX];\n    skewRef = 0;\n    SkDebugf(\"after skew x mod:     x = %g\\n\", matrix.mapXY(24, 42).fX);\n    skewRef = 1;\n    SkDebugf(\"after 2nd skew x mod: x = %g\\n\", matrix.mapXY(24, 42).fX);\n    matrix.dirtyMatrixTypeCache();\n    SkDebugf(\"after dirty cache:    x = %g\\n\", matrix.mapXY(24, 42).fX);\n}",
    "hash": "f4365ef332f51f7fd25040e0771ba9a2",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::dirtyMatrixTypeCache",
        "stdout": "with identity matrix: x = 24\\nafter skew x mod:     x = 24\\nafter 2nd skew x mod: x = 24\\nafter dirty cache:    x = 66\\n"
    },
        "SkMatrix_dump": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setRotate(45);\n    matrix.dump();\n    SkMatrix nearlyEqual;\n    nearlyEqual.setAll(0.7071f, -0.7071f, 0,   0.7071f, 0.7071f, 0,   0, 0, 1);\n    nearlyEqual.dump();\n    SkDebugf(\"matrix %c= nearlyEqual\\n\", matrix == nearlyEqual ? '=' : '!');\n}",
    "hash": "8d72a4818e5a9188348f6c08ab5d8a40",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::dump()",
        "stdout": "[  0.7071  -0.7071   0.0000][  0.7071   0.7071   0.0000][  0.0000   0.0000   1.0000]\\n[  0.7071  -0.7071   0.0000][  0.7071   0.7071   0.0000][  0.0000   0.0000   1.0000]\\nmatrix != nearlyEqual\\n"
    },
        "SkMatrix_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkMatrix& a, const SkMatrix& b) -> void {\n        SkDebugf(\"%s: a %c= b a.cheapEqualTo(b): %s\\n\", prefix,\n                 a == b ? '=' : '!', a.cheapEqualTo(b) ? \"true\" : \"false\");\n    };\n    SkMatrix a, b;\n    a.setAll(1, 0, 0,   0, 1, 0,  0, 0, 1);\n    b.setScale(2, 4);\n    b.postScale(0.5f, 0.25f);\n    debugster(\"identity\", a, b);\n}",
    "hash": "3902859150b0f0c4aeb1f25d00434baa",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::operator==(const SkMatrix& a, const SkMatrix& b)",
        "stdout": "identity: a == b a.cheapEqualTo(b): true\\n"
    },
        "SkMatrix_get": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setSkew(42, 24);\n    SkDebugf(\"matrix.get(SkMatrix::kMSkewX) %c= 42\\n\",\n             matrix.get(SkMatrix::kMSkewX) == 42 ? '=' : '!');\n    SkDebugf(\"matrix.get(SkMatrix::kMSkewY) %c= 24\\n\",\n             matrix.get(SkMatrix::kMSkewY) == 24 ? '=' : '!');\n}",
    "hash": "f5ed382bd04fa7d50b2398cce2fca23a",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::get()",
        "stdout": "matrix.get(SkMatrix::kMSkewX) == 42\\nmatrix.get(SkMatrix::kMSkewY) == 24\\n"
    },
        "SkMatrix_get9": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix = SkMatrix::MakeRectToRect({0, 0, 1, 1}, {3, 4, 7, 9},\n                                               SkMatrix::kFill_ScaleToFit);\n    SkScalar b[9];\n    matrix.get9(b);\n    SkDebugf(\"{%g, %g, %g},\\n{%g, %g, %g},\\n{%g, %g, %g}\\n\", b[0], b[1], b[2],\n             b[3], b[4], b[5], b[6], b[7], b[8]);\n}",
    "hash": "379fc375e011050b54ed9df83c0996a7",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::get9",
        "stdout": "{4, 0, 3},\\n{0, 5, 4},\\n{0, 0, 1}\\n"
    },
        "SkMatrix_getMaxScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScale(42, 24);\n    SkDebugf(\"matrix.getMaxScale() %g\\n\", matrix.getMaxScale());\n}",
    "hash": "3fee4364929899649cf9efc37897e964",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getMaxScale",
        "stdout": "matrix.getMaxScale() 42\\n"
    },
        "SkMatrix_getMinScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScale(42, 24);\n    SkDebugf(\"matrix.getMinScale() %g\\n\", matrix.getMinScale());\n}",
    "hash": "1d6f67904c88a806c3731879e9af4ae5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getMinScale",
        "stdout": "matrix.getMinScale() 24\\n"
    },
        "SkMatrix_getScaleX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScale(42, 24);\n    SkDebugf(\"matrix.getScaleX() %c= 42\\n\", matrix.getScaleX() == 42 ? '=' : '!');\n}",
    "hash": "ab746d9be63975041ae8e50cba84dc3d",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getScaleX",
        "stdout": "matrix.getScaleX() == 42\\n"
    },
        "SkMatrix_getScaleY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScale(42, 24);\n    SkDebugf(\"matrix.getScaleY() %c= 24\\n\", matrix.getScaleY() == 24 ? '=' : '!');\n}",
    "hash": "708b1a548a2f8661b2ab570782fbc751",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getScaleY",
        "stdout": "matrix.getScaleY() == 24\\n"
    },
        "SkMatrix_getSkewX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setSkew(42, 24);\n    SkDebugf(\"matrix.getSkewX() %c= 42\\n\", matrix.getSkewX() == 42 ? '=' : '!');\n}",
    "hash": "df3a5d3c688e7597eae1e4e07bf91ae6",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getSkewX",
        "stdout": "matrix.getSkewX() == 42\\n"
    },
        "SkMatrix_getSkewY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setSkew(42, 24);\n    SkDebugf(\"matrix.getSkewY() %c= 24\\n\", matrix.getSkewY() == 24 ? '=' : '!');\n}",
    "hash": "6be5704506d029ffc91ba03b1d3e674b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getSkewY",
        "stdout": "matrix.getSkewY() == 24\\n"
    },
        "SkMatrix_getTranslateX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setTranslate(42, 24);\n    SkDebugf(\"matrix.getTranslateX() %c= 42\\n\", matrix.getTranslateX() == 42 ? '=' : '!');\n}",
    "hash": "6236f7f2b91aff977a66ba2ee2558ca4",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getTranslateX",
        "stdout": "matrix.getTranslateX() == 42\\n"
    },
        "SkMatrix_getTranslateY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setTranslate(42, 24);\n    SkDebugf(\"matrix.getTranslateY() %c= 24\\n\", matrix.getTranslateY() == 24 ? '=' : '!');\n}",
    "hash": "08464e32d22421d2b254c71a84545ef5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getTranslateY",
        "stdout": "matrix.getTranslateY() == 24\\n"
    },
        "SkMatrix_getType": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setAll(1, 0, 0,   0, 1, 0,    0, 0, 1);\n    SkDebugf(\"identity flags hex: %0x decimal: %d\\n\", matrix.getType(), matrix.getType());\n    matrix.setAll(1, 0, 0,   0, 1, 0,    0, 0, .5f);\n    SkDebugf(\"set all  flags hex: %0x decimal: %d\\n\", matrix.getType(), matrix.getType());\n}",
    "hash": "8e45fe2dd52731bb2d4318686257e1d7",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getType",
        "stdout": "identity flags hex: 0 decimal: 0\\nset all  flags hex: f decimal: 15\\n"
    },
        "SkMatrix_isFinite": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix = SkMatrix::MakeTrans(SK_ScalarNaN, 0);\n    matrix.dump();\n    SkDebugf(\"matrix is finite: %s\\n\", matrix.isFinite() ? \"true\" : \"false\");\n    SkDebugf(\"matrix %c= matrix\\n\", matrix == matrix ? '=' : '!');\n}",
    "hash": "bc6c6f6a5df770287120d87f81b922eb",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isFinite",
        "stdout": "[  1.0000   0.0000      nan][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nmatrix is finite: false\\nmatrix != matrix\\n"
    },
        "SkMatrix_isFixedStepInX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    for (SkScalar px : { 0.0f, 0.1f } ) {\n        for (SkScalar py : { 0.0f, 0.1f } ) {\n            for (SkScalar sy : { 1, 2 } ) {\n                matrix.setAll(1, 0, 0,   0, sy, 0,   px, py, 1);\n                matrix.dump();\n                SkDebugf(\"isFixedStepInX: %s\\n\", matrix.isFixedStepInX() ? \"true\" : \"false\");\n            }\n        }\n    }\n}",
    "hash": "ab57b232acef69f26de9cb23d23c8a1a",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isFixedStepInX",
        "stdout": "[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nisFixedStepInX: true\\n[  1.0000   0.0000   0.0000][  0.0000   2.0000   0.0000][  0.0000   0.0000   1.0000]\\nisFixedStepInX: true\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.1000   1.0000]\\nisFixedStepInX: true\\n[  1.0000   0.0000   0.0000][  0.0000   2.0000   0.0000][  0.0000   0.1000   1.0000]\\nisFixedStepInX: true\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.1000   0.0000   1.0000]\\nisFixedStepInX: false\\n[  1.0000   0.0000   0.0000][  0.0000   2.0000   0.0000][  0.1000   0.0000   1.0000]\\nisFixedStepInX: false\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.1000   0.1000   1.0000]\\nisFixedStepInX: false\\n[  1.0000   0.0000   0.0000][  0.0000   2.0000   0.0000][  0.1000   0.1000   1.0000]\\nisFixedStepInX: false\\n"
    },
        "SkMatrix_isIdentity": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setAll(1, 0, 0,   0, 1, 0,    0, 0, 1);\n    SkDebugf(\"is identity: %s\\n\", matrix.isIdentity() ? \"true\" : \"false\");\n    matrix.setAll(1, 0, 0,   0, 1, 0,    0, 0, 2);\n    SkDebugf(\"is identity: %s\\n\", matrix.isIdentity() ? \"true\" : \"false\");\n}",
    "hash": "780ab376325b3cfa889ea26c0769ec11",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isIdentity",
        "stdout": "is identity: true\\nis identity: false\\n"
    },
        "SkMatrix_isScaleTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    for (SkScalar scaleX : { 1, 2 } ) {\n        for (SkScalar translateX : { 0, 20 } ) {\n            matrix.setAll(scaleX, 0, translateX,   0, 1, 0,    0, 0, 1);\n            SkDebugf(\"is scale-translate: %s\\n\", matrix.isScaleTranslate() ? \"true\" : \"false\");\n        }\n    }\n}",
    "hash": "6287e29674a487eb94174992d45b9a34",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isScaleTranslate",
        "stdout": "is scale-translate: true\\nis scale-translate: true\\nis scale-translate: true\\nis scale-translate: true\\n"
    },
        "SkMatrix_isTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    for (SkScalar scaleX : { 1, 2 } ) {\n        for (SkScalar translateX : { 0, 20 } ) {\n            matrix.setAll(scaleX, 0, translateX,   0, 1, 0,    0, 0, 1);\n            SkDebugf(\"is translate: %s\\n\", matrix.isTranslate() ? \"true\" : \"false\");\n        }\n    }\n}",
    "hash": "73ac71a8a30841873577c11c6c9b38ee",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isTranslate",
        "stdout": "is translate: true\\nis translate: true\\nis translate: false\\nis translate: false\\n"
    },
        "SkMatrix_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkMatrix& a, const SkMatrix& b) -> void {\n        SkDebugf(\"%s: a %c= b a.cheapEqualTo(b): %s\\n\", prefix,\n                 a != b ? '!' : '=', a.cheapEqualTo(b) ? \"true\" : \"false\");\n    };\n    SkMatrix a, b;\n    a.setAll(1, 0, 0,   0, 1, 0,  1, 0, 1);\n    if (a.invert(&b)) {\n        debugster(\"identity\", a, b);\n    }\n}",
    "hash": "088ab41f877599f980a99523749b0afd",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::operator!=(const SkMatrix& a, const SkMatrix& b)",
        "stdout": "identity: a != b a.cheapEqualTo(b): false\\n"
    },
        "SkMatrix_preservesAxisAlignment": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    for (SkScalar angle: { 0, 90, 180, 270 } ) {\n        matrix.setRotate(angle);\n        SkDebugf(\"preservesAxisAlignment: %s\\n\", matrix.preservesAxisAlignment() ? \"true\" : \"false\");\n    }\n}",
    "hash": "7a234c96608fb7cb8135b9940b0b15f7",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preservesAxisAlignment",
        "stdout": "preservesAxisAlignment: true\\npreservesAxisAlignment: true\\npreservesAxisAlignment: true\\npreservesAxisAlignment: true\\n"
    },
        "SkMatrix_rectStaysRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    for (SkScalar angle: { 0, 90, 180, 270 } ) {\n        matrix.setRotate(angle);\n        SkDebugf(\"rectStaysRect: %s\\n\", matrix.rectStaysRect() ? \"true\" : \"false\");\n    }\n}",
    "hash": "ce5319c036c9b5086da8a0009fe409f8",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::rectStaysRect",
        "stdout": "rectStaysRect: true\\nrectStaysRect: true\\nrectStaysRect: true\\nrectStaysRect: true\\n"
    },
        "SkMatrix_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m;\n    m.reset();\n    SkDebugf(\"m.isIdentity(): %s\\n\", m.isIdentity() ? \"true\" : \"false\");\n}",
    "hash": "ca94f7922bc37ef03bbc51ad70536fcf",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::reset()",
        "stdout": "m.isIdentity(): true\\n"
    },
        "SkMatrix_set": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setIdentity();\n    SkDebugf(\"with identity matrix: x = %g\\n\", matrix.mapXY(24, 42).fX);\n    matrix.set(SkMatrix::kMSkewX, 0);\n    SkDebugf(\"after skew x mod:     x = %g\\n\", matrix.mapXY(24, 42).fX);\n    matrix.set(SkMatrix::kMSkewX, 1);\n    SkDebugf(\"after 2nd skew x mod: x = %g\\n\", matrix.mapXY(24, 42).fX);\n}",
    "hash": "1d400a92ca826cc89bcb88ea051f28c8",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::set()",
        "stdout": "with identity matrix: x = 24\\nafter skew x mod:     x = 24\\nafter 2nd skew x mod: x = 66\\n"
    },
        "SkMatrix_setAffine": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setAll(2, 3, 4, 5, 6, 7, 0, 0, 1);\n    SkScalar affine[6];\n    if (matrix.asAffine(affine)) {\n        const char* names[] = { \"ScaleX\", \"SkewY\", \"SkewX\", \"ScaleY\", \"TransX\", \"TransY\" };\n        for (int i = 0; i < 6; ++i) {\n            SkDebugf(\"%s: %g \", names[i], affine[i]);\n        }\n        SkDebugf(\"\\n\");\n        matrix.reset();\n        matrix.setAffine(affine);\n        matrix.dump();\n    }\n}",
    "hash": "f5b6d371c4d65e5b5ac6eebdd4b237d8",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setAffine",
        "stdout": "ScaleX: 2 SkewY: 5 SkewX: 3 ScaleY: 6 TransX: 4 TransY: 7 \\n[  2.0000   3.0000   4.0000][  5.0000   6.0000   7.0000][  0.0000   0.0000   1.0000]\\n"
    },
        "SkMatrix_setIdentity": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m;\n    m.setIdentity();\n    SkDebugf(\"m.isIdentity(): %s\\n\", m.isIdentity() ? \"true\" : \"false\");\n}",
    "hash": "3979c865bb482e6ef1fafc71e56bbb91",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setIdentity",
        "stdout": "m.isIdentity(): true\\n"
    },
        "SkMatrix_setRectToRect": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkRect srcs[] = { {0, 0, 0, 0}, {1, 2, 3, 4} };\n    const SkRect dsts[] = { {0, 0, 0, 0}, {5, 6, 8, 9} };\n    for (auto src : srcs) {\n        for (auto dst : dsts) {\n             SkMatrix matrix;\n             matrix.setAll(-1, -1, -1, -1, -1, -1, -1, -1, -1);\n             bool success = matrix.setRectToRect(src, dst, SkMatrix::kFill_ScaleToFit);\n             SkDebugf(\"src: %g, %g, %g, %g  dst: %g, %g, %g, %g  success: %s\\n\",\n                      src.fLeft, src.fTop, src.fRight, src.fBottom,\n                      dst.fLeft, dst.fTop, dst.fRight, dst.fBottom, success ? \"true\" : \"false\");\n             matrix.dump();\n        }\n    }\n}",
    "hash": "69cdea599dcaaec35efcb24403f4287b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setRectToRect",
        "stdout": "src: 0, 0, 0, 0  dst: 0, 0, 0, 0  success: false\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 0, 0, 0, 0  dst: 5, 6, 8, 9  success: false\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 1, 2, 3, 4  dst: 0, 0, 0, 0  success: true\\n[  0.0000   0.0000   0.0000][  0.0000   0.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 1, 2, 3, 4  dst: 5, 6, 8, 9  success: true\\n[  1.5000   0.0000   3.5000][  0.0000   1.5000   3.0000][  0.0000   0.0000   1.0000]\\n"
    },
        "SkMatrix_setScaleTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScaleTranslate(1, 2, 3, 4);\n    matrix.dump();\n}",
    "hash": "fed43797f13796529cb6731385d6f8f3",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setScaleTranslate",
        "stdout": "[  1.0000   0.0000   3.0000][  0.0000   2.0000   4.0000][  0.0000   0.0000   1.0000]\\n"
    },
        "SkPaint_containsText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    const uint16_t goodGlyph = 511;\n    const uint16_t zeroGlyph = 0;\n    const uint16_t badGlyph = 65535; // larger than glyph count in font\n    paint.setTextEncoding(SkTextEncoding::kGlyphID);\n    SkDebugf(\"0x%04x %c= has glyph\\n\", goodGlyph,\n            paint.containsText(&goodGlyph, 2) ? '=' : '!');\n    SkDebugf(\"0x%04x %c= has glyph\\n\", zeroGlyph,\n            paint.containsText(&zeroGlyph, 2) ? '=' : '!');\n    SkDebugf(\"0x%04x %c= has glyph\\n\", badGlyph,\n            paint.containsText(&badGlyph, 2) ? '=' : '!');\n}",
    "hash": "6a68cb3c8b81a5976c81ee004f559247",
    "file": "SkPaint_Reference",
    "name": "SkPaint::containsText",
        "stdout": "0x01ff == has glyph\\n0x0000 != has glyph\\n0xffff == has glyph\\n"
    },
        "SkPaint_copy_const_SkPaint": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1;\n    paint1.setColor(SK_ColorRED);\n    SkPaint paint2(paint1);\n    paint2.setColor(SK_ColorBLUE);\n    SkDebugf(\"SK_ColorRED %c= paint1.getColor()\\n\", SK_ColorRED == paint1.getColor() ? '=' : '!');\n    SkDebugf(\"SK_ColorBLUE %c= paint2.getColor()\\n\", SK_ColorBLUE == paint2.getColor() ? '=' : '!');\n}",
    "hash": "b99971ad0ef243d617925289d963b62d",
    "file": "SkPaint_Reference",
    "name": "SkPaint::SkPaint(const SkPaint& paint)",
        "stdout": "SK_ColorRED == paint1.getColor()\\nSK_ColorBLUE == paint2.getColor()\\n"
    },
        "SkPaint_copy_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint2 = paint1;\n    SkDebugf(\"SK_ColorRED %c= paint1.getColor()\\n\", SK_ColorRED == paint1.getColor() ? '=' : '!');\n    SkDebugf(\"SK_ColorRED %c= paint2.getColor()\\n\", SK_ColorRED == paint2.getColor() ? '=' : '!');\n}",
    "hash": "b476a9088f80dece176ed577807d3992",
    "file": "SkPaint_Reference",
    "name": "SkPaint::operator=(const SkPaint& paint)",
        "stdout": "SK_ColorRED == paint1.getColor()\\nSK_ColorRED == paint2.getColor()\\n"
    },
        "SkPaint_countText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    const uint8_t utf8[] = { 0x24, 0xC2, 0xA2, 0xE2, 0x82, 0xAC, 0xC2, 0xA5, 0xC2, 0xA3 };\n    SkDebugf(\"count = %d\\n\", paint.countText(utf8, sizeof(utf8)));\n}",
    "hash": "85436c71aab5410767fc688ab0573e09",
    "file": "SkPaint_Reference",
    "name": "SkPaint::countText",
        "stdout": "count = 5\\n"
    },
        "SkPaint_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint2.setColor(0xFFFF0000);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n    float intervals[] = { 5, 5 };\n    paint1.setPathEffect(SkDashPathEffect::Make(intervals, 2, 2.5f));\n    paint2.setPathEffect(SkDashPathEffect::Make(intervals, 2, 2.5f));\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "7481a948e34672720337a631830586dd",
    "file": "SkPaint_Reference",
    "name": "SkPaint::operator==(const SkPaint& a, const SkPaint& b)",
        "stdout": "paint1 == paint2\\npaint1 != paint2\\n"
    },
        "SkPaint_getAlpha": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"255 %c= paint.getAlpha()\\n\", 255 == paint.getAlpha() ? '=' : '!');\n}",
    "hash": "9a85bb62fe3d877b18fb7f952c4fa7f7",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getAlpha",
        "stdout": "255 == paint.getAlpha()\\n"
    },
        "SkPaint_getBlendMode": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"kSrcOver %c= getBlendMode\\n\",\n            SkBlendMode::kSrcOver == paint.getBlendMode() ? '=' : '!');\n   paint.setBlendMode(SkBlendMode::kSrc);\n   SkDebugf(\"kSrcOver %c= getBlendMode\\n\",\n            SkBlendMode::kSrcOver == paint.getBlendMode() ? '=' : '!');\n}\n",
    "hash": "a1e059c8f6740fa2044cc64152b39dda",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getBlendMode",
        "stdout": "kSrcOver == getBlendMode\\nkSrcOver != getBlendMode\\n"
    },
        "SkPaint_getColor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorYELLOW);\n    SkColor y = paint.getColor();\n    SkDebugf(\"Yellow is %d%% red, %d%% green, and %d%% blue.\\n\", (int) (SkColorGetR(y) / 2.55f),\n            (int) (SkColorGetG(y) / 2.55f), (int) (SkColorGetB(y) / 2.55f));\n}",
    "hash": "72d41f890203109a41f589a7403acae9",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getColor",
        "stdout": "Yellow is 100% red, 100% green, and 0% blue.\\n"
    },
        "SkPaint_getColor4f": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorYELLOW);\n    SkColor4f y = paint.getColor4f();\n    SkDebugf(\"Yellow is %d%% red, %d%% green, and %d%% blue.\\n\", (int) (y.fR * 100),\n            (int) (y.fG * 100), (int) (y.fB * 100));\n}",
    "hash": "8512ea2176f36e8f1aeef311ff228790",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getColor4f",
        "stdout": "Yellow is 100% red, 100% green, and 0% blue.\\n"
    },
        "SkPaint_getColorFilter": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= color filter\\n\", paint.getColorFilter() ? '!' : '=');\n   paint.setColorFilter(SkColorFilter::MakeModeFilter(SK_ColorLTGRAY, SkBlendMode::kSrcIn));\n   SkDebugf(\"nullptr %c= color filter\\n\", paint.getColorFilter() ? '!' : '=');\n}\n",
    "hash": "093bdc627d6b59002670fd290931f6c9",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getColorFilter",
        "stdout": "nullptr == color filter\\nnullptr != color filter\\n"
    },
        "SkPaint_getDrawLooper": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= draw looper\\n\", paint.getDrawLooper() ? '!' : '=');\n   SkLayerDrawLooper::Builder looperBuilder;\n   paint.setDrawLooper(looperBuilder.detach());\n   SkDebugf(\"nullptr %c= draw looper\\n\", paint.getDrawLooper() ? '!' : '=');\n}\n",
    "hash": "af4c5acc7a91e7f23c2af48018903ad4",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getDrawLooper",
        "stdout": "nullptr == draw looper\\nnullptr != draw looper\\n"
    },
        "SkPaint_getFilterQuality": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"kNone_SkFilterQuality %c= paint.getFilterQuality()\\n\",\n            kNone_SkFilterQuality == paint.getFilterQuality() ? '=' : '!');\n}",
    "hash": "d4ca1f23809b6835c4ba46ea98a86900",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFilterQuality",
        "stdout": "kNone_SkFilterQuality == paint.getFilterQuality()\\n"
    },
        "SkPaint_getFlags": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkDebugf(\"(SkPaint::kAntiAlias_Flag & paint.getFlags()) %c= 0\\n\",\n        SkPaint::kAntiAlias_Flag & paint.getFlags() ? '!' : '=');\n}",
    "hash": "8a3f8c309533388b01aa66e1267f322d",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFlags",
        "stdout": "(SkPaint::kAntiAlias_Flag & paint.getFlags()) != 0\\n"
    },
        "SkPaint_getFontSpacing": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    for (SkScalar textSize : { 12, 18, 24, 32 } ) {\n        paint.setTextSize(textSize);\n        SkDebugf(\"textSize: %g fontSpacing: %g\\n\", textSize, paint.getFontSpacing());\n    }\n}",
    "hash": "424741e26e1b174e43087d67422ce14f",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFontSpacing",
        "stdout": "textSize: 12 fontSpacing: 13.9688\\ntextSize: 18 fontSpacing: 20.9531\\ntextSize: 24 fontSpacing: 27.9375\\ntextSize: 32 fontSpacing: 37.25\\n"
    },
        "SkPaint_getHash": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint2.setColor(0xFFFF0000);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n    SkDebugf(\"paint1.getHash() %c= paint2.getHash()\\n\",\n             paint1.getHash() == paint2.getHash() ? '=' : '!');\n}",
    "hash": "7f7e1b701361912b344f90ae6b530393",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getHash",
        "stdout": "paint1 == paint2\\npaint1.getHash() == paint2.getHash()\\n"
    },
        "SkPaint_getHinting": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"SkFontHinting::kNormal %c= paint.getHinting()\\n\",\n            SkFontHinting::kNormal == paint.getHinting() ? '=' : ':');\n}",
    "hash": "b56b70c7ea2453c41bfa58b626953bed",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getHinting",
        "stdout": "SkFontHinting::kNormal == paint.getHinting()\\n"
    },
        "SkPaint_getImageFilter": {
    "code": "#include \"SkBlurImageFilter.h\"\n\nvoid draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= image filter\\n\", paint.getImageFilter() ? '!' : '=');\n   paint.setImageFilter(SkBlurImageFilter::Make(kOuter_SkBlurStyle, 3, nullptr, nullptr));\n   SkDebugf(\"nullptr %c= image filter\\n\", paint.getImageFilter() ? '!' : '=');\n}\n",
    "hash": "c11f8eaa1dd149bc18db21e23ce26904",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getImageFilter",
        "stdout": "nullptr == image filter\\nnullptr != image filter\\n"
    },
        "SkPaint_getMaskFilter": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= mask filter\\n\", paint.getMaskFilter() ? '!' : '=');\n   paint.setMaskFilter(SkMaskFilter::MakeBlur(kOuter_SkBlurStyle, 3));\n   SkDebugf(\"nullptr %c= mask filter\\n\", paint.getMaskFilter() ? '!' : '=');\n}\n",
    "hash": "5ac4b31371726da87bb7390b385e9fee",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getMaskFilter",
        "stdout": "nullptr == mask filter\\nnullptr != mask filter\\n"
    },
        "SkPaint_getPathEffect": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= path effect\\n\", paint.getPathEffect() ? '!' : '=');\n   paint.setPathEffect(SkCornerPathEffect::Make(10));\n   SkDebugf(\"nullptr %c= path effect\\n\", paint.getPathEffect() ? '!' : '=');\n}\n",
    "hash": "211a1b14bfa6c4332082c8eab4fbc5fd",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getPathEffect",
        "stdout": "nullptr == path effect\\nnullptr != path effect\\n"
    },
        "SkPaint_getShader": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= shader\\n\", paint.getShader() ? '!' : '=');\n   paint.setShader(SkShader::MakeEmptyShader());\n   SkDebugf(\"nullptr %c= shader\\n\", paint.getShader() ? '!' : '=');\n}\n",
    "hash": "09f15b9fd88882850da2d235eb86292f",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getShader",
        "stdout": "nullptr == shader\\nnullptr != shader\\n"
    },
        "SkPaint_getStrokeCap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"kButt_Cap %c= default stroke cap\\n\",\n            SkPaint::kButt_Cap == paint.getStrokeCap() ? '=' : '!');\n}",
    "hash": "aabf9baee8e026fae36fca30e955512b",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getStrokeCap",
        "stdout": "kButt_Cap == default stroke cap\\n"
    },
        "SkPaint_getStrokeJoin": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"kMiter_Join %c= default stroke join\\n\",\n            SkPaint::kMiter_Join == paint.getStrokeJoin() ? '=' : '!');\n}",
    "hash": "31bf751d0a8ddf176b871810820d8199",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getStrokeJoin",
        "stdout": "kMiter_Join == default stroke join\\n"
    },
        "SkPaint_getStrokeMiter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"default miter limit == %g\\n\", paint.getStrokeMiter());\n}",
    "hash": "50da74a43b725f07a914df588c867d36",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getStrokeMiter",
        "stdout": "default miter limit == 4\\n"
    },
        "SkPaint_getStrokeWidth": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"0 %c= paint.getStrokeWidth()\\n\", 0 == paint.getStrokeWidth() ? '=' : '!');\n}",
    "hash": "99aa73f64df8bbf06e656cd891a81b9e",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getStrokeWidth",
        "stdout": "0 == paint.getStrokeWidth()\\n"
    },
        "SkPaint_getStyle": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"SkPaint::kFill_Style %c= paint.getStyle()\\n\",\n            SkPaint::kFill_Style == paint.getStyle() ? '=' : '!');\n}",
    "hash": "1c5e18c3c0102d2dac86a78ba8c8ce01",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getStyle",
        "stdout": "SkPaint::kFill_Style == paint.getStyle()\\n"
    },
        "SkPaint_getTextEncoding": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"SkTextEncoding::kUTF8 %c= text encoding\\n\",\n            SkTextEncoding::kUTF8 == paint.getTextEncoding() ? '=' : '!');\n    paint.setTextEncoding(SkTextEncoding::kGlyphID);\n    SkDebugf(\"SkTextEncoding::kGlyphID %c= text encoding\\n\",\n            SkTextEncoding::kGlyphID == paint.getTextEncoding() ? '=' : '!');\n}",
    "hash": "0d21e968e9a4c78c902ae3ef494941a0",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextEncoding",
        "stdout": "SkTextEncoding::kUTF8 == text encoding\\nSkTextEncoding::kGlyphID == text encoding\\n"
    },
        "SkPaint_getTextScaleX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"1 %c= default text scale x\\n\", 1 == paint.getTextScaleX() ? '=' : '!');\n}",
    "hash": "5dc8e58f6910cb8e4de9ed60f888188b",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextScaleX",
        "stdout": "1 == default text scale x\\n"
    },
        "SkPaint_getTextSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"12 %c= default text size\\n\", 12 == paint.getTextSize() ? '=' : '!');\n}",
    "hash": "983e2a71ba72d4ba8c945420040b8f1c",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextSize",
        "stdout": "12 == default text size\\n"
    },
        "SkPaint_getTextSkewX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"0 %c= default text skew x\\n\", 0 == paint.getTextSkewX() ? '=' : '!');\n}",
    "hash": "11c10f466dae0d1639dbb9f6a0040218",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextSkewX",
        "stdout": "0 == default text skew x\\n"
    },
        "SkPaint_getTypeface": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= typeface\\n\", paint.getTypeface() ? '!' : '=');\n   paint.setTypeface(SkTypeface::MakeFromName(\"monospace\", SkFontStyle()));\n   SkDebugf(\"nullptr %c= typeface\\n\", paint.getTypeface() ? '!' : '=');\n}\n",
    "hash": "5ce718e5a184baaac80e7098d7dad67b",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTypeface",
        "stdout": "nullptr == typeface\\nnullptr != typeface\\n"
    },
        "SkPaint_isAntiAlias": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isAntiAlias() %c= !!(paint.getFlags() & SkPaint::kAntiAlias_Flag)\\n\",\n            paint.isAntiAlias() == !!(paint.getFlags() & SkPaint::kAntiAlias_Flag) ? '=' : '!');\n    paint.setAntiAlias(true);\n    SkDebugf(\"paint.isAntiAlias() %c= !!(paint.getFlags() & SkPaint::kAntiAlias_Flag)\\n\",\n            paint.isAntiAlias() == !!(paint.getFlags() & SkPaint::kAntiAlias_Flag) ? '=' : '!');\n}",
    "hash": "d7d5f4f7da7acd5104a652f490c6f7b8",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isAntiAlias",
        "stdout": "paint.isAntiAlias() == !!(paint.getFlags() & SkPaint::kAntiAlias_Flag)\\npaint.isAntiAlias() == !!(paint.getFlags() & SkPaint::kAntiAlias_Flag)\\n"
    },
        "SkPaint_isAutohinted": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    for (auto forceAutoHinting : { false, true} ) {\n    paint.setAutohinted(forceAutoHinting);\n    SkDebugf(\"paint.isAutohinted() %c=\"\n            \" !!(paint.getFlags() & SkPaint::kAutoHinting_Flag)\\n\",\n            paint.isAutohinted() ==\n            !!(paint.getFlags() & SkPaint::kAutoHinting_Flag) ? '=' : '!');\n    }\n}",
    "hash": "aa4781afbe3b90e7ef56a287e5b9ce1e",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isAutohinted",
        "stdout": "paint.isAutohinted() == !!(paint.getFlags() & SkPaint::kAutoHinting_Flag)\\npaint.isAutohinted() == !!(paint.getFlags() & SkPaint::kAutoHinting_Flag)\\n"
    },
        "SkPaint_isDither": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isDither() %c= !!(paint.getFlags() & SkPaint::kDither_Flag)\\n\",\n            paint.isDither() == !!(paint.getFlags() & SkPaint::kDither_Flag) ? '=' : '!');\n    paint.setDither(true);\n    SkDebugf(\"paint.isDither() %c= !!(paint.getFlags() & SkPaint::kDither_Flag)\\n\",\n            paint.isDither() == !!(paint.getFlags() & SkPaint::kDither_Flag) ? '=' : '!');\n}",
    "hash": "f4ce93f6c5e7335436a985377fd980c0",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isDither",
        "stdout": "paint.isDither() == !!(paint.getFlags() & SkPaint::kDither_Flag)\\npaint.isDither() == !!(paint.getFlags() & SkPaint::kDither_Flag)\\n"
    },
        "SkPaint_isEmbeddedBitmapText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isEmbeddedBitmapText() %c=\"\n            \" !!(paint.getFlags() & SkPaint::kEmbeddedBitmapText_Flag)\\n\",\n            paint.isEmbeddedBitmapText() ==\n            !!(paint.getFlags() & SkPaint::kEmbeddedBitmapText_Flag) ? '=' : '!');\n    paint.setEmbeddedBitmapText(true);\n    SkDebugf(\"paint.isEmbeddedBitmapText() %c=\"\n            \" !!(paint.getFlags() & SkPaint::kEmbeddedBitmapText_Flag)\\n\",\n            paint.isEmbeddedBitmapText() ==\n            !!(paint.getFlags() & SkPaint::kEmbeddedBitmapText_Flag) ? '=' : '!');\n}",
    "hash": "eba10b27b790e87183ae451b3fc5c4b1",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isEmbeddedBitmapText",
        "stdout": "paint.isEmbeddedBitmapText() == !!(paint.getFlags() & SkPaint::kEmbeddedBitmapText_Flag)\\npaint.isEmbeddedBitmapText() == !!(paint.getFlags() & SkPaint::kEmbeddedBitmapText_Flag)\\n"
    },
        "SkPaint_isFakeBoldText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isFakeBoldText() %c= !!(paint.getFlags() & SkPaint::kFakeBoldText_Flag)\\n\",\n        paint.isFakeBoldText() == !!(paint.getFlags() & SkPaint::kFakeBoldText_Flag) ? '=' : '!');\n    paint.setFakeBoldText(true);\n    SkDebugf(\"paint.isFakeBoldText() %c= !!(paint.getFlags() & SkPaint::kFakeBoldText_Flag)\\n\",\n        paint.isFakeBoldText() == !!(paint.getFlags() & SkPaint::kFakeBoldText_Flag) ? '=' : '!');\n}",
    "hash": "f54d1f85b16073b80b9eef2e1a1d151d",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isFakeBoldText",
        "stdout": "paint.isFakeBoldText() == !!(paint.getFlags() & SkPaint::kFakeBoldText_Flag)\\npaint.isFakeBoldText() == !!(paint.getFlags() & SkPaint::kFakeBoldText_Flag)\\n"
    },
        "SkPaint_isLCDRenderText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isLCDRenderText() %c= !!(paint.getFlags() & SkPaint::kLCDRenderText_Flag)\\n\",\n        paint.isLCDRenderText() == !!(paint.getFlags() & SkPaint::kLCDRenderText_Flag) ? '=' : '!');\n    paint.setLCDRenderText(true);\n    SkDebugf(\"paint.isLCDRenderText() %c= !!(paint.getFlags() & SkPaint::kLCDRenderText_Flag)\\n\",\n        paint.isLCDRenderText() == !!(paint.getFlags() & SkPaint::kLCDRenderText_Flag) ? '=' : '!');\n}",
    "hash": "68e1fd95dd2fd06a333899d2bd2396b9",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isLCDRenderText",
        "stdout": "paint.isLCDRenderText() == !!(paint.getFlags() & SkPaint::kLCDRenderText_Flag)\\npaint.isLCDRenderText() == !!(paint.getFlags() & SkPaint::kLCDRenderText_Flag)\\n"
    },
        "SkPaint_isSrcOver": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"isSrcOver %c= true\\n\", paint.isSrcOver() ? '=' : '!');\n   paint.setBlendMode(SkBlendMode::kSrc);\n   SkDebugf(\"isSrcOver %c= true\\n\", paint.isSrcOver() ? '=' : '!');\n}\n",
    "hash": "257c9473db7a2b3a0fb2b9e2431e59a6",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isSrcOver",
        "stdout": "isSrcOver == true\\nisSrcOver != true\\n"
    },
        "SkPaint_isSubpixelText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isSubpixelText() %c= !!(paint.getFlags() & SkPaint::kSubpixelText_Flag)\\n\",\n        paint.isSubpixelText() == !!(paint.getFlags() & SkPaint::kSubpixelText_Flag) ? '=' : '!');\n    paint.setSubpixelText(true);\n    SkDebugf(\"paint.isSubpixelText() %c= !!(paint.getFlags() & SkPaint::kSubpixelText_Flag)\\n\",\n        paint.isSubpixelText() == !!(paint.getFlags() & SkPaint::kSubpixelText_Flag) ? '=' : '!');\n}",
    "hash": "abe9afc0932e2199324ae6cbb396e67c",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isSubpixelText",
        "stdout": "paint.isSubpixelText() == !!(paint.getFlags() & SkPaint::kSubpixelText_Flag)\\npaint.isSubpixelText() == !!(paint.getFlags() & SkPaint::kSubpixelText_Flag)\\n"
    },
        "SkPaint_measureText_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"default width = %g\\n\", paint.measureText(\"!\", 1));\n    paint.setTextSize(paint.getTextSize() * 2);\n    SkDebugf(\"double width = %g\\n\", paint.measureText(\"!\", 1));\n}",
    "hash": "f1139a5ddd17fd47c2f45f6e642cac76",
    "file": "SkPaint_Reference",
    "name": "SkPaint::measureText_2",
        "stdout": "default width = 5\\ndouble width = 10\\n"
    },
        "SkPaint_move_SkPaint": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    float intervals[] = { 5, 5 };\n    paint.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 2.5f));\n    SkPaint dashed(std::move(paint));\n    SkDebugf(\"path effect unique: %s\\n\", dashed.getPathEffect()->unique() ? \"true\" : \"false\");\n}",
    "hash": "8ed1488a503cd5282b86a51614aa90b1",
    "file": "SkPaint_Reference",
    "name": "SkPaint::SkPaint(SkPaint&& paint)",
        "stdout": "path effect unique: true\\n"
    },
        "SkPaint_move_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint2 = std::move(paint1);\n    SkDebugf(\"SK_ColorRED == paint2.getColor()\\n\", SK_ColorRED == paint2.getColor() ? '=' : '!');\n}",
    "hash": "9fb7459b097d713f5f1fe5675afe14f5",
    "file": "SkPaint_Reference",
    "name": "SkPaint::operator=(SkPaint&& paint)",
        "stdout": "SK_ColorRED == paint2.getColor()\\n"
    },
        "SkPaint_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint2.setColor(0xFFFF0000);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 != paint2 ? '!' : '=');\n}",
    "hash": "b6c8484b1187f555b435ad5369833be4",
    "file": "SkPaint_Reference",
    "name": "SkPaint::operator!=(const SkPaint& a, const SkPaint& b)",
        "stdout": "paint1 == paint2\\npaint1 == paint2\\n"
    },
        "SkPaint_nothingToDraw": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPaint& p) -> void {\n        SkDebugf(\"%s nothing to draw: %s\\n\", prefix,\n                 p.nothingToDraw() ? \"true\" : \"false\");\n    };\n    SkPaint paint;\n    debugster(\"initial\", paint);\n    paint.setBlendMode(SkBlendMode::kDst);\n    debugster(\"blend dst\", paint);\n    paint.setBlendMode(SkBlendMode::kSrcOver);\n    debugster(\"blend src over\", paint);\n    paint.setAlpha(0);\n    debugster(\"alpha 0\", paint);\n}\n",
    "hash": "2973b05bfbb6b4c29332c8ac4fcf3995",
    "file": "SkPaint_Reference",
    "name": "SkPaint::nothingToDraw",
        "stdout": "initial nothing to draw: false\\nblend dst nothing to draw: true\\nblend src over nothing to draw: false\\nalpha 0 nothing to draw: true\\n"
    },
        "SkPaint_refColorFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColorFilter(SkColorFilter::MakeModeFilter(0xFFFF0000, SkBlendMode::kSrcATop));\n    SkDebugf(\"color filter unique: %s\\n\", paint1.getColorFilter()->unique() ? \"true\" : \"false\");\n    paint2.setColorFilter(paint1.refColorFilter());\n    SkDebugf(\"color filter unique: %s\\n\", paint1.getColorFilter()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "b588c95fa4c86ddbc4b0546762f08297",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refColorFilter",
        "stdout": "color filter unique: true\\ncolor filter unique: false\\n"
    },
        "SkPaint_refDrawLooper": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    SkLayerDrawLooper::Builder looperBuilder;\n    paint1.setDrawLooper(looperBuilder.detach());\n    SkDebugf(\"draw looper unique: %s\\n\", paint1.getDrawLooper()->unique() ? \"true\" : \"false\");\n    paint2.setDrawLooper(paint1.refDrawLooper());\n    SkDebugf(\"draw looper unique: %s\\n\", paint1.getDrawLooper()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "2a3782c33f04ed17a725d0e449c6f7c3",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refDrawLooper",
        "stdout": "draw looper unique: true\\ndraw looper unique: false\\n"
    },
        "SkPaint_refImageFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setImageFilter(SkOffsetImageFilter::Make(25, 25, nullptr));\n    SkDebugf(\"image filter unique: %s\\n\", paint1.getImageFilter()->unique() ? \"true\" : \"false\");\n    paint2.setImageFilter(paint1.refImageFilter());\n    SkDebugf(\"image filter unique: %s\\n\", paint1.getImageFilter()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "13f09088b569251547107d14ae989dc1",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refImageFilter",
        "stdout": "image filter unique: true\\nimage filter unique: false\\n"
    },
        "SkPaint_refMaskFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setMaskFilter(SkMaskFilter::MakeBlur(kNormal_SkBlurStyle, 1));\n    SkDebugf(\"mask filter unique: %s\\n\", paint1.getMaskFilter()->unique() ? \"true\" : \"false\");\n    paint2.setMaskFilter(paint1.refMaskFilter());\n    SkDebugf(\"mask filter unique: %s\\n\", paint1.getMaskFilter()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "084b0dc3cebd78718c651d58f257f799",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refMaskFilter",
        "stdout": "mask filter unique: true\\nmask filter unique: false\\n"
    },
        "SkPaint_refPathEffect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    SkScalar intervals[] = {1, 2};\n    paint1.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 10));\n    SkDebugf(\"path effect unique: %s\\n\", paint1.getPathEffect()->unique() ? \"true\" : \"false\");\n    paint2.setPathEffect(paint1.refPathEffect());\n    SkDebugf(\"path effect unique: %s\\n\", paint1.getPathEffect()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "f56039b94c702c2704c8c5100e623aca",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refPathEffect",
        "stdout": "path effect unique: true\\npath effect unique: false\\n"
    },
        "SkPaint_refShader": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint1, paint2;\n   paint1.setShader(SkShader::MakeEmptyShader());\n   SkDebugf(\"shader unique: %s\\n\", paint1.getShader()->unique() ? \"true\" : \"false\");\n   paint2.setShader(paint1.refShader());\n   SkDebugf(\"shader unique: %s\\n\", paint1.getShader()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "53da0295972a418cbc9607bbb17feaa8",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refShader",
        "stdout": "shader unique: true\\nshader unique: false\\n"
    },
        "SkPaint_refTypeface": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint1, paint2;\n   paint1.setTypeface(SkTypeface::MakeFromName(\"monospace\",\n            SkFontStyle(SkFontStyle::kNormal_Weight, SkFontStyle::kNormal_Width,\n            SkFontStyle::kItalic_Slant)));\n   SkDebugf(\"typeface1 %c= typeface2\\n\",\n            paint1.getTypeface() == paint2.getTypeface() ? '=' : '!');\n   paint2.setTypeface(paint1.refTypeface());\n   SkDebugf(\"typeface1 %c= typeface2\\n\",\n            paint1.getTypeface() == paint2.getTypeface() ? '=' : '!');\n}\n",
    "hash": "8b5aa7e555a0dc31be69db7cadf471a1",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refTypeface",
        "stdout": "typeface1 != typeface2\\ntypeface1 == typeface2\\n"
    },
        "SkPaint_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint1.reset();\n    SkDebugf(\"paint1 %c= paint2\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "ef269937ade7e7353635121d9a64f9f7",
    "file": "SkPaint_Reference",
    "name": "SkPaint::reset()",
        "stdout": "paint1 == paint2"
    },
        "SkPaint_setARGB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint transRed1, transRed2;\n    transRed1.setARGB(255 / 2, 255, 0, 0);\n    transRed2.setColor(SkColorSetARGB(255 / 2, 255, 0, 0));\n    SkDebugf(\"transRed1 %c= transRed2\", transRed1 == transRed2 ? '=' : '!');\n}",
    "hash": "cb62e4755789ed32f7120dc55984959d",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setARGB",
        "stdout": "transRed1 == transRed2"
    },
        "SkPaint_setAlpha": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(0x00112233);\n    paint.setAlpha(0x44);\n    SkDebugf(\"0x44112233 %c= paint.getColor()\\n\", 0x44112233 == paint.getColor() ? '=' : '!');\n}",
    "hash": "6ddc0360512dfb9947e75c17e6a8103d",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setAlpha",
        "stdout": "0x44112233 == paint.getColor()\\n"
    },
        "SkPaint_setAntiAlias": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setAntiAlias(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kAntiAlias_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "c2ff148374d01cbef845b223e725905c",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setAntiAlias",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setBlendMode": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"isSrcOver %c= true\\n\", paint.isSrcOver() ? '=' : '!');\n   paint.setBlendMode(SkBlendMode::kSrc);\n   SkDebugf(\"isSrcOver %c= true\\n\", paint.isSrcOver() ? '=' : '!');\n}\n",
    "hash": "257c9473db7a2b3a0fb2b9e2431e59a6",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setBlendMode",
        "stdout": "isSrcOver == true\\nisSrcOver != true\\n"
    },
        "SkPaint_setColor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint green1, green2;\n    unsigned a = 255;\n    unsigned r = 0;\n    unsigned g = 255;\n    unsigned b = 0;\n    green1.setColor((a << 24) + (r << 16) + (g << 8) + (b << 0));\n    green2.setColor(0xFF00FF00);\n    SkDebugf(\"green1 %c= green2\\n\", green1 == green2 ? '=' : '!');\n}",
    "hash": "6e70f18300bd676a3c056ceb6b62f8df",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setColor",
        "stdout": "green1 == green2\\n"
    },
        "SkPaint_setColor4f": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint green1, green2;\n    green1.setColor4f({0, 1, 0, 1}, nullptr);  // R=0 G=1 B=0 A=1\n    green2.setColor(0xFF00FF00); // A=255 R=0 G=255 B=0\n    SkDebugf(\"green1 %c= green2\\n\", green1 == green2 ? '=' : '!');\n}",
    "hash": "fa60859e3d03bdc117a05b32e093a8f1",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setColor4f",
        "stdout": "green1 == green2\\n"
    },
        "SkPaint_setDither": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setDither(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kDither_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "69b7162e8324d9239dd02dd9ada2bdff",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setDither",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setEmbeddedBitmapText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setEmbeddedBitmapText(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kEmbeddedBitmapText_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "246dffdd93a484ba4ad7ecf71198a5d4",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setEmbeddedBitmapText",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setFakeBoldText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setFakeBoldText(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kFakeBoldText_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "594d47858eb11028cb626515a520910a",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setFakeBoldText",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setFilterQuality": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setFilterQuality(kHigh_SkFilterQuality);\n    SkDebugf(\"kHigh_SkFilterQuality %c= paint.getFilterQuality()\\n\",\n            kHigh_SkFilterQuality == paint.getFilterQuality() ? '=' : '!');\n}",
    "hash": "e4288fabf24ee60b645e8bb6ea0afadf",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setFilterQuality",
        "stdout": "kHigh_SkFilterQuality == paint.getFilterQuality()\\n"
    },
        "SkPaint_setFlags": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setFlags((uint32_t) (SkPaint::kAntiAlias_Flag | SkPaint::kDither_Flag));\n    SkDebugf(\"paint.isAntiAlias()\\n\", paint.isAntiAlias() ? '!' : '=');\n    SkDebugf(\"paint.isDither()\\n\", paint.isDither() ? '!' : '=');\n}",
    "hash": "54baed3f6bc4b9c31ba664e27767fdc7",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setFlags",
        "stdout": "paint.isAntiAlias()\\npaint.isDither()\\n"
    },
        "SkPaint_setHinting": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint2.setHinting(SkFontHinting::kNormal);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : ':');\n}",
    "hash": "bb179ec5698ec1398ff18f3657ab73f7",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setHinting",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setLCDRenderText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setLCDRenderText(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kLCDRenderText_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "50dedf8450159571a3edaf4f0050defe",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setLCDRenderText",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setStrokeCap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeCap(SkPaint::kRound_Cap);\n    paint.setStrokeCap((SkPaint::Cap) SkPaint::kCapCount);\n    SkDebugf(\"kRound_Cap %c= paint.getStrokeCap()\\n\",\n            SkPaint::kRound_Cap == paint.getStrokeCap() ? '=' : '!');\n}",
    "hash": "de83fbd848a4625345b4b87a6e55d98a",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setStrokeCap",
        "stdout": "kRound_Cap == paint.getStrokeCap()\\n"
    },
        "SkPaint_setStrokeJoin": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeJoin(SkPaint::kMiter_Join);\n    paint.setStrokeJoin((SkPaint::Join) SkPaint::kJoinCount);\n    SkDebugf(\"kMiter_Join %c= paint.getStrokeJoin()\\n\",\n            SkPaint::kMiter_Join == paint.getStrokeJoin() ? '=' : '!');\n}",
    "hash": "48d963ad4286eddf680f9c511eb6da91",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setStrokeJoin",
        "stdout": "kMiter_Join == paint.getStrokeJoin()\\n"
    },
        "SkPaint_setStrokeMiter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeMiter(8);\n    paint.setStrokeMiter(-1);\n    SkDebugf(\"default miter limit == %g\\n\", paint.getStrokeMiter());\n}",
    "hash": "700b284dbc97785c6a9c9636088713ad",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setStrokeMiter",
        "stdout": "default miter limit == 8\\n"
    },
        "SkPaint_setStrokeWidth": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(5);\n    paint.setStrokeWidth(-1);\n    SkDebugf(\"5 %c= paint.getStrokeWidth()\\n\", 5 == paint.getStrokeWidth() ? '=' : '!');\n}",
    "hash": "0c4446c0870b5c7b5a2efe77ff92afb8",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setStrokeWidth",
        "stdout": "5 == paint.getStrokeWidth()\\n"
    },
        "SkPaint_setSubpixelText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setSubpixelText(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kSubpixelText_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "a77bbc1a4e3be9a8ab0f842f877c5ee4",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setSubpixelText",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setTextEncoding": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextEncoding((SkTextEncoding) 4);\n    SkDebugf(\"4 %c= text encoding\\n\", (SkTextEncoding) 4 == paint.getTextEncoding() ? '=' : '!');\n}",
    "hash": "a5d1ba0dbf42afb797ffdb07647b5cb9",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setTextEncoding",
        "stdout": "4 != text encoding\\n"
    },
        "SkPaint_setTextScaleX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextScaleX(0.f / 0.f);\n    SkDebugf(\"text scale %s-a-number\\n\", SkScalarIsNaN(paint.getTextScaleX()) ? \"not\" : \"is\");\n}",
    "hash": "a75bbdb8bb866b125c4c1dd5e967d470",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setTextScaleX",
        "stdout": "text scale not-a-number\\n"
    },
        "SkPaint_setTextSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"12 %c= text size\\n\", 12 == paint.getTextSize() ? '=' : '!');\n    paint.setTextSize(-20);\n    SkDebugf(\"12 %c= text size\\n\", 12 == paint.getTextSize() ? '=' : '!');\n}",
    "hash": "6510c9e2f57b83c47e67829e7a68d493",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setTextSize",
        "stdout": "12 == text size\\n12 == text size\\n"
    },
        "SkPaint_setTextSkewX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextScaleX(1.f / 0.f);\n    SkDebugf(\"text scale %s-finite\\n\", SkScalarIsFinite(paint.getTextScaleX()) ? \"is\" : \"not\");\n}",
    "hash": "6bd705a6e0c5f8ee24f302fe531bfabc",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setTextSkewX",
        "stdout": "text scale not-finite\\n"
    },
        "SkPath_ConvertToNonInverseFillType": {
    "code": "#define nameValue(fill) { SkPath::fill, #fill }\n\nvoid draw(SkCanvas* canvas) {\n    struct {\n        SkPath::FillType fill;\n        const char* name;\n    } fills[] = {\n        nameValue(kWinding_FillType),\n        nameValue(kEvenOdd_FillType),\n        nameValue(kInverseWinding_FillType),\n        nameValue(kInverseEvenOdd_FillType),\n    };\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(fills); ++i) {\n        if (fills[i].fill != (SkPath::FillType) i) {\n            SkDebugf(\"fills array order does not match FillType enum order\");\n            break;\n        }\n        SkDebugf(\"ConvertToNonInverseFillType(%s) == %s\\n\", fills[i].name,\n                fills[(int) SkPath::ConvertToNonInverseFillType(fills[i].fill)].name);\n    }\n}\n",
    "hash": "319f6b124458dcc0f9ce4d7bbde65810",
    "file": "SkPath_Reference",
    "name": "SkPath::ConvertToNonInverseFillType",
        "stdout": "ConvertToNonInverseFillType(kWinding_FillType) == kWinding_FillType\\nConvertToNonInverseFillType(kEvenOdd_FillType) == kEvenOdd_FillType\\nConvertToNonInverseFillType(kInverseWinding_FillType) == kWinding_FillType\\nConvertToNonInverseFillType(kInverseEvenOdd_FillType) == kEvenOdd_FillType\\n"
    },
        "SkPath_IsCubicDegenerate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint points[] = {{1, 0}, {0, 0}, {0, 0}, {0, 0}};\n    SkScalar step = 1;\n    SkScalar prior, length = 0, degenerate = 0;\n    do {\n        prior = points[0].fX;\n        step /= 2;\n        if (SkPath::IsCubicDegenerate(points[0], points[1], points[2], points[3], false)) {\n            degenerate = prior;\n            points[0].fX += step;\n        } else {\n            length = prior;\n            points[0].fX -= step;\n        }\n    } while (prior != points[0].fX);\n    SkDebugf(\"%1.8g is degenerate\\n\", degenerate);\n    SkDebugf(\"%1.8g is length\\n\", length);\n}\n",
    "hash": "6b97099acdae80b16df0c4241f593991",
    "file": "SkPath_Reference",
    "name": "SkPath::IsCubicDegenerate",
        "stdout": "0.00024414062 is degenerate\\n0.00024414065 is length\\n"
    },
        "SkPath_IsInverseFillType": {
    "code": "#define nameValue(fill) { SkPath::fill, #fill }\n\nvoid draw(SkCanvas* canvas) {\n    struct {\n        SkPath::FillType fill;\n        const char* name;\n    } fills[] = {\n        nameValue(kWinding_FillType),\n        nameValue(kEvenOdd_FillType),\n        nameValue(kInverseWinding_FillType),\n        nameValue(kInverseEvenOdd_FillType),\n    };\n    for (auto fill: fills ) {\n        SkDebugf(\"IsInverseFillType(%s) == %s\\n\", fill.name, SkPath::IsInverseFillType(fill.fill) ?\n                 \"true\" : \"false\");\n    }\n}\n",
    "hash": "1453856a9d0c73e8192bf298c4143563",
    "file": "SkPath_Reference",
    "name": "SkPath::IsInverseFillType",
        "stdout": "IsInverseFillType(kWinding_FillType) == false\\nIsInverseFillType(kEvenOdd_FillType) == false\\nIsInverseFillType(kInverseWinding_FillType) == true\\nIsInverseFillType(kInverseEvenOdd_FillType) == true\\n"
    },
        "SkPath_IsLineDegenerate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint points[] = { {100, 100}, {100.000001f, 100.000001f}, {100.0001f, 100.0001f} };\n    for (size_t i = 0; i < SK_ARRAY_COUNT(points) - 1; ++i) {\n        for (bool exact : { false, true } ) {\n            SkDebugf(\"line from (%1.8g,%1.8g) to (%1.8g,%1.8g) is %s\" \"degenerate, %s\\n\",\n                    points[i].fX, points[i].fY, points[i + 1].fX, points[i + 1].fY,\n                    SkPath::IsLineDegenerate(points[i], points[i + 1], exact)\n                    ? \"\" : \"not \", exact ? \"exactly\" : \"nearly\");\n        }\n    }\n}\n",
    "hash": "97a031f9186ade586928563840ce9116",
    "file": "SkPath_Reference",
    "name": "SkPath::IsLineDegenerate",
        "stdout": "line from (100,100) to (100,100) is degenerate, nearly\\nline from (100,100) to (100,100) is degenerate, exactly\\nline from (100,100) to (100.0001,100.0001) is degenerate, nearly\\nline from (100,100) to (100.0001,100.0001) is not degenerate, exactly\\n"
    },
        "SkPath_IsQuadDegenerate": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const SkPath& path, bool exact) -> void {\n        SkDebugf(\"quad (%1.8g,%1.8g), (%1.8g,%1.8g), (%1.8g,%1.8g) is %s\" \"degenerate, %s\\n\",\n            path.getPoint(0).fX, path.getPoint(0).fY, path.getPoint(1).fX,\n            path.getPoint(1).fY, path.getPoint(2).fX, path.getPoint(2).fY,\n            SkPath::IsQuadDegenerate(path.getPoint(0), path.getPoint(1), path.getPoint(2), exact) ?\n            \"\" : \"not \", exact ? \"exactly\" : \"nearly\");\n    };\n    SkPath path, offset;\n    path.moveTo({100, 100});\n    path.quadTo({100.00001f, 100.00001f}, {100.00002f, 100.00002f});\n    offset.addPath(path, 1000, 1000);\n    for (bool exact : { false, true } ) {\n        debugster(path, exact);\n        debugster(offset, exact);\n    }\n}\n",
    "hash": "a2b255a7dac1926cc3a247d318d63c62",
    "file": "SkPath_Reference",
    "name": "SkPath::IsQuadDegenerate",
        "stdout": "quad (100,100), (100.00001,100.00001), (100.00002,100.00002) is degenerate, nearly\\nquad (1100,1100), (1100,1100), (1100,1100) is degenerate, nearly\\nquad (100,100), (100.00001,100.00001), (100.00002,100.00002) is not degenerate, exactly\\nquad (1100,1100), (1100,1100), (1100,1100) is degenerate, exactly\\n"
    },
        "SkPath_Iter_Iter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath::Iter iter;\n    SkPoint points[4];\n    SkDebugf(\"iter is \" \"%s\" \"done\\n\", SkPath::kDone_Verb == iter.next(points) ? \"\" : \"not \");\n    SkPath path;\n    iter.setPath(path, false);\n    SkDebugf(\"iter is \" \"%s\" \"done\\n\", SkPath::kDone_Verb == iter.next(points) ? \"\" : \"not \");\n}\n",
    "hash": "01648775cb9b354b2f1836dad82a25ab",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::Iter()",
        "stdout": "iter is done\\niter is done\\n"
    },
        "SkPath_Iter_conicWeight": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPath path;\n   path.conicTo(1, 2, 3, 4, .5f);\n   SkPath::Iter iter(path, false);\n   SkPoint p[4];\n   SkDebugf(\"first verb is \" \"%s\" \"move\\n\", SkPath::kMove_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"next verb is \" \"%s\" \"conic\\n\", SkPath::kConic_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"conic points: {%g,%g}, {%g,%g}, {%g,%g}\\n\", p[0].fX, p[0].fY, p[1].fX, p[1].fY,\n                p[2].fX, p[2].fY);\n   SkDebugf(\"conic weight: %g\\n\", iter.conicWeight());\n}\n",
    "hash": "7cdea37741d50f0594c6244eb07fd175",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::conicWeight",
        "stdout": "first verb is move\\nnext verb is conic\\nconic points: {0,0}, {1,2}, {3,4}\\nconic weight: 0.5\\n"
    },
        "SkPath_Iter_const_SkPath": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, SkPath::Iter& iter) -> void {\n        SkDebugf(\"%s:\\n\", prefix);\n        const char* verbStr[] =  { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\", \"Done\" };\n        const int pointCount[] = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n        SkPath::Verb verb;\n        do {\n           SkPoint points[4];\n           verb = iter.next(points);\n           SkDebugf(\"k%s_Verb \", verbStr[(int) verb]);\n           for (int i = 0; i < pointCount[(int) verb]; ++i) {\n                SkDebugf(\"{%g, %g}, \", points[i].fX, points[i].fY);\n           }\n           if (SkPath::kConic_Verb == verb) {\n               SkDebugf(\"weight = %g\", iter.conicWeight());\n           }\n           SkDebugf(\"\\n\");\n        } while (SkPath::kDone_Verb != verb);\n        SkDebugf(\"\\n\");\n    };\n    SkPath path;\n    path.quadTo(10, 20, 30, 40);\n    SkPath::Iter openIter(path, false);\n    debugster(\"open\", openIter);\n    SkPath::Iter closedIter(path, true);\n    debugster(\"closed\", closedIter);\n}\n",
    "hash": "13044dbf68885c0f15322c0633b633a3",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::Iter(const SkPath& path, bool forceClose)",
        "stdout": "open:\\nkMove_Verb {0, 0}, \\nkQuad_Verb {0, 0}, {10, 20}, {30, 40}, \\nkDone_Verb \\n\\nclosed:\\nkMove_Verb {0, 0}, \\nkQuad_Verb {0, 0}, {10, 20}, {30, 40}, \\nkLine_Verb {30, 40}, {0, 0}, \\nkClose_Verb {0, 0}, \\nkDone_Verb \\n\\n"
    },
        "SkPath_Iter_isCloseLine": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPath path;\n   path.moveTo(6, 7);\n   path.conicTo(1, 2, 3, 4, .5f);\n   path.close();\n   SkPath::Iter iter(path, false);\n   SkPoint p[4];\n   SkDebugf(\"1st verb is \" \"%s\" \"move\\n\", SkPath::kMove_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"moveTo point: {%g,%g}\\n\", p[0].fX, p[0].fY);\n   SkDebugf(\"2nd verb is \" \"%s\" \"conic\\n\", SkPath::kConic_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"3rd verb is \" \"%s\" \"line\\n\", SkPath::kLine_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"line points: {%g,%g}, {%g,%g}\\n\", p[0].fX, p[0].fY, p[1].fX, p[1].fY);\n   SkDebugf(\"line \" \"%s\" \"generated by close\\n\", iter.isCloseLine() ? \"\" : \"not \");\n   SkDebugf(\"4th verb is \" \"%s\" \"close\\n\", SkPath::kClose_Verb == iter.next(p) ? \"\" : \"not \");\n}\n",
    "hash": "7000b501f49341629bfdd9f80e686103",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::isCloseLine",
        "stdout": "1st verb is move\\nmoveTo point: {6,7}\\n2nd verb is conic\\n3rd verb is line\\nline points: {3,4}, {6,7}\\nline generated by close\\n4th verb is close\\n"
    },
        "SkPath_Iter_isClosedContour": {
    "code": "void draw(SkCanvas* canvas) {\n   for (bool forceClose : { false, true } ) {\n       SkPath path;\n       path.conicTo(1, 2, 3, 4, .5f);\n       SkPath::Iter iter(path, forceClose);\n       SkDebugf(\"without close(), forceClose is %s: isClosedContour returns %s\\n\",\n           forceClose ? \"true \" : \"false\", iter.isClosedContour() ? \"true\" : \"false\");\n       path.close();\n       iter.setPath(path, forceClose);\n       SkDebugf(\"with close(),    forceClose is %s: isClosedContour returns %s\\n\",\n           forceClose ? \"true \" : \"false\", iter.isClosedContour() ? \"true\" : \"false\");\n    }\n}\n",
    "hash": "b0d48a6e949db1cb545216ae9c3c3c70",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::isClosedContour",
        "stdout": "without close(), forceClose is false: isClosedContour returns false\\nwith close(),    forceClose is false: isClosedContour returns true\\nwithout close(), forceClose is true : isClosedContour returns true\\nwith close(),    forceClose is true : isClosedContour returns true\\n"
    },
        "SkPath_Iter_next": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path, bool degen, bool exact) -> void {\n        SkPath::Iter iter(path, false);\n        SkDebugf(\"%s:\\n\", prefix);\n        const char* verbStr[] =  { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\", \"Done\" };\n        const int pointCount[] = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n        SkPath::Verb verb;\n        do {\n           SkPoint points[4];\n           verb = iter.next(points, degen, exact);\n           SkDebugf(\"k%s_Verb \", verbStr[(int) verb]);\n           for (int i = 0; i < pointCount[(int) verb]; ++i) {\n                SkDebugf(\"{%1.8g, %1.8g}, \", points[i].fX, points[i].fY);\n           }\n           SkDebugf(\"\\n\");\n        } while (SkPath::kDone_Verb != verb);\n        SkDebugf(\"\\n\");\n    };\n    SkPath path;\n    path.moveTo(10, 10);\n    path.moveTo(20, 20);\n    path.quadTo(10, 20, 30, 40);\n    path.moveTo(1, 1);\n    path.close();\n    path.moveTo(30, 30);\n    path.lineTo(30, 30);\n    path.moveTo(30, 30);\n    path.lineTo(30.00001f, 30);\n    debugster(\"skip degenerate\", path, true, false);\n    debugster(\"skip degenerate if exact\", path, true, true);\n    debugster(\"skip none\", path, false, false);\n}\n",
    "hash": "00ae8984856486bdb626d0ed6587855a",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::next()",
        "stdout": "skip degenerate:\\nkMove_Verb {20, 20}, \\nkQuad_Verb {20, 20}, {10, 20}, {30, 40}, \\nkDone_Verb \\n\\nskip degenerate if exact:\\nkMove_Verb {20, 20}, \\nkQuad_Verb {20, 20}, {10, 20}, {30, 40}, \\nkMove_Verb {30, 30}, \\nkLine_Verb {30, 30}, {30.00001, 30}, \\nkDone_Verb \\n\\nskip none:\\nkMove_Verb {10, 10}, \\nkMove_Verb {20, 20}, \\nkQuad_Verb {20, 20}, {10, 20}, {30, 40}, \\nkMove_Verb {1, 1}, \\nkClose_Verb {1, 1}, \\nkMove_Verb {30, 30}, \\nkLine_Verb {30, 30}, {30, 30}, \\nkMove_Verb {30, 30}, \\nkLine_Verb {30, 30}, {30.00001, 30}, \\nkDone_Verb \\n\\n"
    },
        "SkPath_Iter_setPath": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, SkPath::Iter& iter) -> void {\n        SkDebugf(\"%s:\\n\", prefix);\n        const char* verbStr[] =  { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\", \"Done\" };\n        const int pointCount[] = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n        SkPath::Verb verb;\n        do {\n           SkPoint points[4];\n           verb = iter.next(points);\n           SkDebugf(\"k%s_Verb \", verbStr[(int) verb]);\n           for (int i = 0; i < pointCount[(int) verb]; ++i) {\n                SkDebugf(\"{%g, %g}, \", points[i].fX, points[i].fY);\n           }\n           if (SkPath::kConic_Verb == verb) {\n               SkDebugf(\"weight = %g\", iter.conicWeight());\n           }\n           SkDebugf(\"\\n\");\n        } while (SkPath::kDone_Verb != verb);\n        SkDebugf(\"\\n\");\n    };\n    SkPath path;\n    path.quadTo(10, 20, 30, 40);\n    SkPath::Iter iter(path, false);\n    debugster(\"quad open\", iter);\n    SkPath path2;\n    path2.conicTo(1, 2, 3, 4, .5f);\n    iter.setPath(path2, true);\n    debugster(\"conic closed\", iter);\n}\n",
    "hash": "6c9688008cea8937ad5cc188b38ecf16",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::setPath",
        "stdout": "quad open:\\nkMove_Verb {0, 0}, \\nkQuad_Verb {0, 0}, {10, 20}, {30, 40}, \\nkDone_Verb \\n\\nconic closed:\\nkMove_Verb {0, 0}, \\nkConic_Verb {0, 0}, {1, 2}, {3, 4}, weight = 0.5\\nkLine_Verb {3, 4}, {0, 0}, \\nkClose_Verb {0, 0}, \\nkDone_Verb \\n\\n"
    },
        "SkPath_RawIter_conicWeight": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPath path;\n   path.conicTo(1, 2, 3, 4, .5f);\n   SkPath::RawIter iter(path);\n   SkPoint p[4];\n   SkDebugf(\"first verb is \" \"%s\" \"move\\n\", SkPath::kMove_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"next verb is \" \"%s\" \"conic\\n\", SkPath::kConic_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"conic points: {%g,%g}, {%g,%g}, {%g,%g}\\n\", p[0].fX, p[0].fY, p[1].fX, p[1].fY,\n                p[2].fX, p[2].fY);\n   SkDebugf(\"conic weight: %g\\n\", iter.conicWeight());\n}\n",
    "hash": "69f360a0ba8f40c51ef4cd9f972c5893",
    "file": "SkPath_Reference",
    "name": "SkPath::RawIter::conicWeight",
        "stdout": "first verb is move\\nnext verb is conic\\nconic points: {0,0}, {1,2}, {3,4}\\nconic weight: 0.5\\n"
    },
        "SkPath_RawIter_next": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(50, 60);\n    path.quadTo(10, 20, 30, 40);\n    path.close();\n    path.lineTo(30, 30);\n    path.conicTo(1, 2, 3, 4, .5f);\n    path.cubicTo(-1, -2, -3, -4, -5, -6);\n    SkPath::RawIter iter(path);\n    const char* verbStr[] =  { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\", \"Done\" };\n    const int pointCount[] = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n    SkPath::Verb verb;\n    do {\n        SkPoint points[4];\n        verb = iter.next(points);\n        SkDebugf(\"k%s_Verb \", verbStr[(int) verb]);\n        for (int i = 0; i < pointCount[(int) verb]; ++i) {\n            SkDebugf(\"{%1.8g, %1.8g}, \", points[i].fX, points[i].fY);\n        }\n        if (SkPath::kConic_Verb == verb) {\n            SkDebugf(\"weight = %g\", iter.conicWeight());\n        }\n        SkDebugf(\"\\n\");\n    } while (SkPath::kDone_Verb != verb);\n}\n",
    "hash": "944a80c7ff8c04e1fecc4aec4a47ea60",
    "file": "SkPath_Reference",
    "name": "SkPath::RawIter::next()",
        "stdout": "kMove_Verb {50, 60}, \\nkQuad_Verb {50, 60}, {10, 20}, {30, 40}, \\nkClose_Verb {50, 60}, \\nkMove_Verb {50, 60}, \\nkLine_Verb {50, 60}, {30, 30}, \\nkConic_Verb {30, 30}, {1, 2}, {3, 4}, weight = 0.5\\nkCubic_Verb {3, 4}, {-1, -2}, {-3, -4}, {-5, -6}, \\nkDone_Verb \\n"
    },
        "SkPath_RawIter_peek": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.quadTo(10, 20, 30, 40);\n    path.conicTo(1, 2, 3, 4, .5f);\n    path.cubicTo(1, 2, 3, 4, .5, 6);\n    SkPath::RawIter iter(path);\n    SkPath::Verb verb, peek = iter.peek();\n    const char* verbStr[] =  { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\", \"Done\" };\n    do {\n        SkPoint points[4];\n        verb = iter.next(points);\n        SkDebugf(\"peek %s %c= verb %s\\n\", verbStr[peek], peek == verb ? '=' : '!', verbStr[verb]);\n        peek = iter.peek();\n    } while (SkPath::kDone_Verb != verb);\n    SkDebugf(\"peek %s %c= verb %s\\n\", verbStr[peek], peek == verb ? '=' : '!', verbStr[verb]);\n}",
    "hash": "eb5fa5bea23059ce538e883502f828f5",
    "file": "SkPath_Reference",
    "name": "SkPath::RawIter::peek()",
        "stdout": "peek Move == verb Move\\npeek Quad == verb Quad\\npeek Conic == verb Conic\\npeek Cubic == verb Cubic\\npeek Done == verb Done\\npeek Done == verb Done\\n\\n"
    },
        "SkPath_SegmentMask": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.conicTo(10, 10, 20, 30, 1);\n    SkDebugf(\"Path kConic_SegmentMask is %s\\n\", path.getSegmentMasks() &\n          SkPath::kConic_SegmentMask ? \"set\" : \"clear\");\n    SkDebugf(\"Path kQuad_SegmentMask is %s\\n\", path.getSegmentMasks() &\n          SkPath::kQuad_SegmentMask ? \"set\" : \"clear\");\n}",
    "hash": "a61e5758574e28190ec4ed8c4ae7e7fa",
    "file": "SkPath_Reference",
    "name": "SkPath::SegmentMask",
        "stdout": "Path kConic_SegmentMask is clear\\nPath kQuad_SegmentMask is set\\n"
    },
        "SkPath_Verb": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.lineTo(20, 20);\n    path.quadTo(-10, -10, 30, 30);\n    path.close();\n    path.cubicTo(1, 2, 3, 4, 5, 6);\n    path.conicTo(0, 0, 0, 0, 2);\n    uint8_t verbs[7];\n    int count = path.getVerbs(verbs, (int) SK_ARRAY_COUNT(verbs));\n    const char* verbStr[] = { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\" };\n    SkDebugf(\"verb count: %d\\nverbs: \", count);\n    for (int i = 0; i < count; ++i) {\n        SkDebugf(\"k%s_Verb \", verbStr[verbs[i]]);\n    }\n    SkDebugf(\"\\n\");\n}\n",
    "hash": "799096fdc1298aa815934a74e76570ca",
    "file": "SkPath_Reference",
    "name": "SkPath::Verb",
        "stdout": "verb count: 7\\nverbs: kMove_Verb kLine_Verb kQuad_Verb kClose_Verb kMove_Verb kCubic_Verb kConic_Verb \\n"
    },
        "SkPath_arcTo_2_b": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo({156, 20});\n    path.arcTo(200, 20, 170, 50, 50);\n    SkPath::Iter iter(path, false);\n    SkPoint p[4];\n    SkPath::Verb verb;\n    while (SkPath::kDone_Verb != (verb = iter.next(p))) {\n        switch (verb) {\n            case SkPath::kMove_Verb:\n                SkDebugf(\"move to (%g,%g)\\n\", p[0].fX, p[0].fY);\n                break;\n            case SkPath::kLine_Verb:\n                SkDebugf(\"line (%g,%g),(%g,%g)\\n\", p[0].fX, p[0].fY, p[1].fX, p[1].fY);\n                break;\n            case SkPath::kConic_Verb:\n                SkDebugf(\"conic (%g,%g),(%g,%g),(%g,%g) weight %g\\n\",\n                         p[0].fX, p[0].fY, p[1].fX, p[1].fY, p[2].fX, p[2].fY, iter.conicWeight());\n                break;\n            default:\n                SkDebugf(\"unexpected verb\\n\");\n        }\n    }\n}\n",
    "hash": "498360fa0a201cc5db04b1c27256358f",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_2_3",
        "stdout": "move to (156,20)\\nline (156,20),(79.2893,20)\\nconic (79.2893,20),(200,20),(114.645,105.355) weight 0.382683\\n"
    },
        "SkPath_arcTo_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo({156, 20});\n    path.arcTo({200, 20}, {170, 20}, 50);\n    SkPath::Iter iter(path, false);\n    SkPoint p[4];\n    SkPath::Verb verb;\n    while (SkPath::kDone_Verb != (verb = iter.next(p))) {\n        switch (verb) {\n            case SkPath::kMove_Verb:\n                SkDebugf(\"move to (%g,%g)\\n\", p[0].fX, p[0].fY);\n                break;\n            case SkPath::kLine_Verb:\n                SkDebugf(\"line (%g,%g),(%g,%g)\\n\", p[0].fX, p[0].fY, p[1].fX, p[1].fY);\n                break;\n            case SkPath::kConic_Verb:\n                SkDebugf(\"conic (%g,%g),(%g,%g),(%g,%g) weight %g\\n\",\n                          p[0].fX, p[0].fY, p[1].fX, p[1].fY, p[2].fX, p[2].fY, iter.conicWeight());\n                break;\n            default:\n                SkDebugf(\"unexpected verb\\n\");\n        }\n    }\n}\n",
    "hash": "0c056264a361579c18e5d02d3172d4d4",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_3",
        "stdout": "move to (156,20)\\nline (156,20),(200,20)\\n"
    },
        "SkPath_computeTightBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n            const SkRect& bounds = path.computeTightBounds();\n            SkDebugf(\"%s bounds = %g, %g, %g, %g\\n\", prefix,\n                     bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    };\n    SkPath path;\n    debugster(\"empty\", path);\n    path.addCircle(50, 45, 25);\n    debugster(\"circle\", path);\n    SkMatrix matrix;\n    matrix.setRotate(45, 50, 45);\n    path.transform(matrix);\n    debugster(\"rotated circle\", path);\n}",
    "hash": "9a39c56e95b19a657133b7ad1fe0cf03",
    "file": "SkPath_Reference",
    "name": "SkPath::computeTightBounds",
        "stdout": "empty bounds = 0, 0, 0, 0\\ncircle bounds = 25, 20, 75, 70\\nrotated circle bounds = 25, 20, 75, 70\\n"
    },
        "SkPath_copy_const_SkPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.lineTo(20, 20);\n    SkPath path2(path);\n    path2.close();\n    SkDebugf(\"path verbs: %d\\n\", path.countVerbs());\n    SkDebugf(\"path2 verbs: %d\\n\", path2.countVerbs());\n    path.reset();\n    SkDebugf(\"after reset\\n\" \"path verbs: %d\\n\", path.countVerbs());\n    SkDebugf(\"path2 verbs: %d\\n\", path2.countVerbs());\n}",
    "hash": "647312aacd946c8a6eabaca797140432",
    "file": "SkPath_Reference",
    "name": "SkPath::SkPath(const SkPath& path)",
        "stdout": "path verbs: 2\\npath2 verbs: 3\\nafter reset\\npath verbs: 0\\npath2 verbs: 3\\n"
    },
        "SkPath_copy_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path1;\n    path1.addRect({10, 20, 30, 40});\n    SkPath path2 = path1;\n    const SkRect& b1 = path1.getBounds();\n    SkDebugf(\"path1 bounds = %g, %g, %g, %g\\n\", b1.fLeft, b1.fTop, b1.fRight, b1.fBottom);\n    const SkRect& b2 = path2.getBounds();\n    SkDebugf(\"path2 bounds = %g, %g, %g, %g\\n\", b2.fLeft, b2.fTop, b2.fRight, b2.fBottom);\n}",
    "hash": "bba288f5f77fc8e37e89d2ec08e0ac60",
    "file": "SkPath_Reference",
    "name": "SkPath::operator=(const SkPath& path)",
        "stdout": "path1 bounds = 10, 20, 30, 40\\npath2 bounds = 10, 20, 30, 40\\n"
    },
        "SkPath_countPoints": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n         SkDebugf(\"%s point count: %d\\n\", prefix, path.countPoints());\n    };\n    SkPath path;\n    debugster(\"empty\", path);\n    path.lineTo(0, 0);\n    debugster(\"zero line\", path);\n    path.rewind();\n    path.moveTo(10, 10);\n    path.lineTo(20, 20);\n    debugster(\"line\", path);\n    path.moveTo(20, 20);\n    debugster(\"second move\", path);\n}\n",
    "hash": "bca6379ccef62cb081b10db7381deb27",
    "file": "SkPath_Reference",
    "name": "SkPath::countPoints",
        "stdout": "empty point count: 0\\nzero line point count: 2\\nline point count: 2\\nsecond move point count: 3\\n"
    },
        "SkPath_countVerbs": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"empty verb count: %d\\n\", path.countVerbs());\n    path.addRoundRect({10, 20, 30, 40}, 5, 5);\n    SkDebugf(\"round rect verb count: %d\\n\", path.countVerbs());\n}",
    "hash": "af0c66aea3ef81b709664c7007f48aae",
    "file": "SkPath_Reference",
    "name": "SkPath::countVerbs",
        "stdout": "empty verb count: 0\\nround rect verb count: 10\\n"
    },
        "SkPath_destructor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath* path = new SkPath();\n    path->lineTo(20, 20);\n    SkPath path2(*path);\n    delete path;\n    SkDebugf(\"path2 is \" \"%s\" \"empty\", path2.isEmpty() ? \"\" : \"not \");\n}\n",
    "hash": "01ad6be9b7d15a2217daea273eb3d466",
    "file": "SkPath_Reference",
    "name": "SkPath::~SkPath()",
        "stdout": "path2 is not empty"
    },
        "SkPath_dump": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.quadTo(20, 30, 40, 50);\n    for (bool forceClose : { false, true } ) {\n        for (bool dumpAsHex : { false, true } ) {\n            path.dump(nullptr, forceClose, dumpAsHex);\n            SkDebugf(\"\\n\");\n        }\n    }\n}",
    "hash": "8036d764452a62f9953af50846f0f3c0",
    "file": "SkPath_Reference",
    "name": "SkPath::dump()",
        "stdout": "path.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(0, 0);\\npath.quadTo(20, 30, 40, 50);\\n\\npath.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(SkBits2Float(0x00000000), SkBits2Float(0x00000000));  // 0, 0\\npath.quadTo(SkBits2Float(0x41a00000), SkBits2Float(0x41f00000), SkBits2Float(0x42200000), SkBits2Float(0x42480000));  // 20, 30, 40, 50\\n\\npath.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(0, 0);\\npath.quadTo(20, 30, 40, 50);\\npath.lineTo(0, 0);\\npath.close();\\n\\npath.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(SkBits2Float(0x00000000), SkBits2Float(0x00000000));  // 0, 0\\npath.quadTo(SkBits2Float(0x41a00000), SkBits2Float(0x41f00000), SkBits2Float(0x42200000), SkBits2Float(0x42480000));  // 20, 30, 40, 50\\npath.lineTo(SkBits2Float(0x00000000), SkBits2Float(0x00000000));  // 0, 0\\npath.close();\\n\\n"
    },
        "SkPath_dumpHex": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, copy;\n    path.lineTo(6.f / 7, 2.f / 3);\n    path.dumpHex();\n    copy.setFillType(SkPath::kWinding_FillType);\n    copy.moveTo(SkBits2Float(0x00000000), SkBits2Float(0x00000000));  // 0, 0\n    copy.lineTo(SkBits2Float(0x3f5b6db7), SkBits2Float(0x3f2aaaab));  // 0.857143f, 0.666667f\n    SkDebugf(\"path is \" \"%s\" \"equal to copy\\n\", path == copy ? \"\" : \"not \");\n}",
    "hash": "72a92fe058e8b3be6c8a30fad7fd1266",
    "file": "SkPath_Reference",
    "name": "SkPath::dumpHex",
        "stdout": "path.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(SkBits2Float(0x00000000), SkBits2Float(0x00000000));  // 0, 0\\npath.lineTo(SkBits2Float(0x3f5b6db7), SkBits2Float(0x3f2aaaab));  // 0.857143f, 0.666667f\\npath is equal to copy\\n"
    },
        "SkPath_dump_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, copy;\n    path.lineTo(6.f / 7, 2.f / 3);\n    path.dump();\n    copy.setFillType(SkPath::kWinding_FillType);\n    copy.moveTo(0, 0);\n    copy.lineTo(0.857143f, 0.666667f);\n    SkDebugf(\"path is \" \"%s\" \"equal to copy\\n\", path == copy ? \"\" : \"not \");\n}",
    "hash": "92e0032f85181795d1f8b5a2c8e4e4b7",
    "file": "SkPath_Reference",
    "name": "SkPath::dump_2",
        "stdout": "path.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(0, 0);\\npath.lineTo(0.857143f, 0.666667f);\\npath is not equal to copy\\n"
    },
        "SkPath_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"path is \" \"%s\" \"empty\", path.isEmpty() ? \"\" : \"not \");\n}",
    "hash": "0a0026fca638d1cd75c0ab884e3ee1c6",
    "file": "SkPath_Reference",
    "name": "SkPath::SkPath()",
        "stdout": "path is empty"
    },
        "SkPath_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& a, const SkPath& b) -> void {\n                SkDebugf(\"%s one %c= two\\n\", prefix, a == b ? '=' : '!');\n    };\n    SkPath one;\n    SkPath two;\n    debugster(\"empty\", one, two);\n    one.moveTo(0, 0);\n    debugster(\"moveTo\", one, two);\n    one.rewind();\n    debugster(\"rewind\", one, two);\n    one.moveTo(0, 0);\n    one.reset();\n    debugster(\"reset\", one, two);\n}\n",
    "hash": "31883f51bb357f2ac5990d88f8b82e02",
    "file": "SkPath_Reference",
    "name": "SkPath::operator==(const SkPath& a, const SkPath& b)",
        "stdout": "empty one == two\\nmoveTo one != two\\nrewind one == two\\nreset one == two\\n"
    },
        "SkPath_getBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n            const SkRect& bounds = path.getBounds();\n            SkDebugf(\"%s bounds = %g, %g, %g, %g\\n\", prefix,\n                     bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    };\n    SkPath path;\n    debugster(\"empty\", path);\n    path.addCircle(50, 45, 25);\n    debugster(\"circle\", path);\n    SkMatrix matrix;\n    matrix.setRotate(45, 50, 45);\n    path.transform(matrix);\n    debugster(\"rotated circle\", path);\n}",
    "hash": "45c0fc3acb74fab99d544b80eadd10ad",
    "file": "SkPath_Reference",
    "name": "SkPath::getBounds",
        "stdout": "empty bounds = 0, 0, 0, 0\\ncircle bounds = 25, 20, 75, 70\\nrotated circle bounds = 14.6447, 9.64466, 85.3553, 80.3553\\n"
    },
        "SkPath_getConvexity": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s path convexity is %s\\n\", prefix,\n                SkPath::kUnknown_Convexity == path.getConvexity() ? \"unknown\" :\n                SkPath::kConvex_Convexity == path.getConvexity() ? \"convex\" : \"concave\"); };\n    SkPath path;\n    debugster(\"initial\", path);\n    path.lineTo(50, 0);\n    debugster(\"first line\", path);\n    path.lineTo(50, 50);\n    debugster(\"second line\", path);\n    path.lineTo(100, 50);\n    debugster(\"third line\", path);\n}\n",
    "hash": "a8f36f2fa90003e3691fd0da0bb0c243",
    "file": "SkPath_Reference",
    "name": "SkPath::getConvexity",
        "stdout": "initial path convexity is convex\\nfirst line path convexity is convex\\nsecond line path convexity is convex\\nthird line path convexity is concave\\n"
    },
        "SkPath_getConvexityOrUnknown": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s path convexity is %s\\n\", prefix,\n            SkPath::kUnknown_Convexity == path.getConvexityOrUnknown() ? \"unknown\" :\n            SkPath::kConvex_Convexity == path.getConvexityOrUnknown() ? \"convex\" : \"concave\"); };\n    SkPath path;\n    debugster(\"initial\", path);\n    path.lineTo(50, 0);\n    debugster(\"first line\", path);\n    path.getConvexity();\n    path.lineTo(50, 50);\n    debugster(\"second line\", path);\n    path.lineTo(100, 50);\n    path.getConvexity();\n    debugster(\"third line\", path);\n}\n",
    "hash": "111c59e9afadb940ab8f41bdc25378a4",
    "file": "SkPath_Reference",
    "name": "SkPath::getConvexityOrUnknown",
        "stdout": "initial path convexity is unknown\\nfirst line path convexity is unknown\\nsecond line path convexity is unknown\\nthird line path convexity is concave\\n"
    },
        "SkPath_getFillType": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"default path fill type is %s\\n\",\n            path.getFillType() == SkPath::kWinding_FillType ? \"kWinding_FillType\" :\n            path.getFillType() == SkPath::kEvenOdd_FillType ? \"kEvenOdd_FillType\" :\n            path.getFillType() == SkPath::kInverseWinding_FillType ? \"kInverseWinding_FillType\" :\n                                                                     \"kInverseEvenOdd_FillType\");\n}",
    "hash": "019af90e778914e8a109d6305ede4fc4",
    "file": "SkPath_Reference",
    "name": "SkPath::getFillType",
        "stdout": "default path fill type is kWinding_FillType\\n"
    },
        "SkPath_getGenerationID": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"empty genID = %u\\n\", path.getGenerationID());\n    path.lineTo(1, 2);\n    SkDebugf(\"1st lineTo genID = %u\\n\", path.getGenerationID());\n    path.rewind();\n    SkDebugf(\"empty genID = %u\\n\", path.getGenerationID());\n    path.lineTo(1, 2);\n    SkDebugf(\"2nd lineTo genID = %u\\n\", path.getGenerationID());\n}",
    "hash": "a0f166715d6479f91258d854e63e586d",
    "file": "SkPath_Reference",
    "name": "SkPath::getGenerationID",
        "stdout": "empty genID = 1\\n1st lineTo genID = 2\\nempty genID = 1\\n2nd lineTo genID = 3\\n"
    },
        "SkPath_getLastPt": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(100, 100);\n    path.quadTo(100, 20, 20, 100);\n    SkMatrix matrix;\n    matrix.setRotate(36, 100, 100);\n    path.transform(matrix);\n    SkPoint last;\n    path.getLastPt(&last);\n    SkDebugf(\"last point: %g, %g\\n\", last.fX, last.fY);\n}",
    "hash": "df8160dd7ac8aa4b40fce7286fe49952",
    "file": "SkPath_Reference",
    "name": "SkPath::getLastPt",
        "stdout": "last point: 35.2786, 52.9772\\n"
    },
        "SkPath_getPoint": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.lineTo(20, 20);\n    path.offset(-10, -10);\n    for (int i= 0; i < path.countPoints(); ++i) {\n         SkDebugf(\"point %d: (%1.8g,%1.8g)\\n\", i, path.getPoint(i).fX, path.getPoint(i).fY);\n    }\n}\n",
    "hash": "42885f1df13de109adccc5d531f62111",
    "file": "SkPath_Reference",
    "name": "SkPath::getPoint",
        "stdout": "point 0: (-10,-10)\\npoint 1: (10,10)\\n"
    },
        "SkPath_getPoints": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path, SkPoint* points, int max) -> void {\n         int count = path.getPoints(points, max);\n         SkDebugf(\"%s point count: %d  \", prefix, count);\n         for (int i = 0; i < SkTMin(count, max) && points; ++i) {\n             SkDebugf(\"(%1.8g,%1.8g) \", points[i].fX, points[i].fY);\n         }\n         SkDebugf(\"\\n\");\n    };\n    SkPath path;\n    path.lineTo(20, 20);\n    path.lineTo(-10, -10);\n    SkPoint points[3];\n    debugster(\"no points\",  path, nullptr, 0);\n    debugster(\"zero max\",  path, points, 0);\n    debugster(\"too small\",  path, points, 2);\n    debugster(\"just right\",  path, points, path.countPoints());\n}\n",
    "hash": "9bc86efda08cbcd9c6f7c5f220294a24",
    "file": "SkPath_Reference",
    "name": "SkPath::getPoints",
        "stdout": "no points point count: 3  \\nzero max point count: 3  \\ntoo small point count: 3  (0,0) (20,20) \\njust right point count: 3  (0,0) (20,20) (-10,-10) \\n"
    },
        "SkPath_getSegmentMasks": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.quadTo(20, 30, 40, 50);\n    path.close();\n    const char* masks[] = { \"line\", \"quad\", \"conic\", \"cubic\" };\n    int index = 0;\n    for (auto mask : { SkPath::kLine_SegmentMask, SkPath::kQuad_SegmentMask,\n            SkPath::kConic_SegmentMask, SkPath::kCubic_SegmentMask } ) {\n        if (mask & path.getSegmentMasks()) {\n           SkDebugf(\"mask %s set\\n\", masks[index]);\n        }\n        ++index;\n    }\n}",
    "hash": "657a3f3e11acafea92b84d6bb0c13633",
    "file": "SkPath_Reference",
    "name": "SkPath::getSegmentMasks",
        "stdout": "mask quad set\\n"
    },
        "SkPath_getVerbs": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path, uint8_t* verbs, int max) -> void {\n         int count = path.getVerbs(verbs, max);\n         SkDebugf(\"%s verb count: %d  \", prefix, count);\n         const char* verbStr[] = { \"move\", \"line\", \"quad\", \"conic\", \"cubic\", \"close\" };\n         for (int i = 0; i < SkTMin(count, max) && verbs; ++i) {\n             SkDebugf(\"%s \", verbStr[verbs[i]]);\n         }\n         SkDebugf(\"\\n\");\n    };\n    SkPath path;\n    path.lineTo(20, 20);\n    path.lineTo(-10, -10);\n    uint8_t verbs[3];\n    debugster(\"no verbs\",  path, nullptr, 0);\n    debugster(\"zero max\",  path, verbs, 0);\n    debugster(\"too small\",  path, verbs, 2);\n    debugster(\"just right\",  path, verbs, path.countVerbs());\n}\n",
    "hash": "2ec66880966a6133ddd9331ce7323438",
    "file": "SkPath_Reference",
    "name": "SkPath::getVerbs",
        "stdout": "no verbs verb count: 3  \\nzero max verb count: 3  \\ntoo small verb count: 3  move line \\njust right verb count: 3  move line line \\n"
    },
        "SkPath_isEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s path is %s\" \"empty\\n\", prefix, path.isEmpty() ? \"\" : \"not \");\n    };\n    SkPath path;\n    debugster(\"initial\", path);\n    path.moveTo(0, 0);\n    debugster(\"after moveTo\", path);\n    path.rewind();\n    debugster(\"after rewind\", path);\n    path.lineTo(0, 0);\n    debugster(\"after lineTo\", path);\n    path.reset();\n    debugster(\"after reset\", path);\n}\n",
    "hash": "0b34e6d55d11586744adeb889d2a12f4",
    "file": "SkPath_Reference",
    "name": "SkPath::isEmpty",
        "stdout": "initial path is empty\\nafter moveTo path is not empty\\nafter rewind path is empty\\nafter lineTo path is not empty\\nafter reset path is empty\\n"
    },
        "SkPath_isFinite": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s path is %s\" \"finite\\n\", prefix, path.isFinite() ? \"\" : \"not \");\n    };\n    SkPath path;\n    debugster(\"initial\", path);\n    path.lineTo(SK_ScalarMax, SK_ScalarMax);\n    debugster(\"after line\", path);\n    SkMatrix matrix;\n    matrix.setScale(2, 2);\n    path.transform(matrix);\n    debugster(\"after scale\", path);\n}\n",
    "hash": "dd4e4dd2aaa8039b2430729c6b3af817",
    "file": "SkPath_Reference",
    "name": "SkPath::isFinite",
        "stdout": "initial path is finite\\nafter line path is finite\\nafter scale path is not finite\\n"
    },
        "SkPath_isInterpolatable": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, path2;\n    path.moveTo(20, 20);\n    path.lineTo(40, 40);\n    path.lineTo(20, 20);\n    path.lineTo(40, 40);\n    path.close();\n    path2.addRect({20, 20, 40, 40});\n    SkDebugf(\"paths are \" \"%s\" \"interpolatable\", path.isInterpolatable(path2) ? \"\" : \"not \");\n}",
    "hash": "c81fc7dfaf785c3fb77209c7f2ebe5b8",
    "file": "SkPath_Reference",
    "name": "SkPath::isInterpolatable",
        "stdout": "paths are interpolatable"
    },
        "SkPath_isInverseFillType": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"default path fill type is inverse: %s\\n\",\n            path.isInverseFillType() ? \"true\" : \"false\");\n}",
    "hash": "2a2d39f5da611545caa18bbcea873ab2",
    "file": "SkPath_Reference",
    "name": "SkPath::isInverseFillType",
        "stdout": "default path fill type is inverse: false\\n"
    },
        "SkPath_isLastContourClosed": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s last contour is %s\" \"closed\\n\", prefix,\n                 path.isLastContourClosed() ? \"\" : \"not \");\n    };\n    SkPath path;\n    debugster(\"initial\", path);\n    path.close();\n    debugster(\"after close\", path);\n    path.lineTo(0, 0);\n    debugster(\"after lineTo\", path);\n    path.close();\n    debugster(\"after close\", path);\n}\n",
    "hash": "03b740ab94b9017800a52e30b5e7fee7",
    "file": "SkPath_Reference",
    "name": "SkPath::isLastContourClosed",
        "stdout": "initial last contour is not closed\\nafter close last contour is not closed\\nafter lineTo last contour is not closed\\nafter close last contour is closed\\n"
    },
        "SkPath_isLine": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkPoint line[2];\n        if (path.isLine(line)) {\n            SkDebugf(\"%s is line (%1.8g,%1.8g) (%1.8g,%1.8g)\\n\", prefix,\n                 line[0].fX, line[0].fY, line[1].fX, line[1].fY);\n        } else {\n            SkDebugf(\"%s is not line\\n\", prefix);\n        }\n    };\n    SkPath path;\n    debugster(\"empty\", path);\n    path.lineTo(0, 0);\n    debugster(\"zero line\", path);\n    path.rewind();\n    path.moveTo(10, 10);\n    path.lineTo(20, 20);\n    debugster(\"line\", path);\n    path.moveTo(20, 20);\n    debugster(\"second move\", path);\n}\n",
    "hash": "1ad07d56e4258e041606d50cad969392",
    "file": "SkPath_Reference",
    "name": "SkPath::isLine",
        "stdout": "empty is not line\\nzero line is line (0,0) (0,0)\\nline is line (10,10) (20,20)\\nsecond move is not line\\n"
    },
        "SkPath_isNestedFillRects": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(5);\n    SkPath path;\n    path.addRect({10, 20, 30, 40});\n    paint.getFillPath(path, &path);\n    SkRect rects[2];\n    SkPath::Direction directions[2];\n    if (path.isNestedFillRects(rects, directions)) {\n        for (int i = 0; i < 2; ++i) {\n            SkDebugf(\"%s (%g, %g, %g, %g); direction %s\\n\", i ? \"inner\" : \"outer\",\n                     rects[i].fLeft, rects[i].fTop, rects[i].fRight, rects[i].fBottom,\n                     SkPath::kCW_Direction == directions[i] ? \"CW\" : \"CCW\");\n        }\n    } else {\n        SkDebugf(\"is not nested rectangles\\n\");\n    }\n}\n",
    "hash": "77e4394caf9fa083c19c21c2462efe14",
    "file": "SkPath_Reference",
    "name": "SkPath::isNestedFillRects",
        "stdout": "outer (7.5, 17.5, 32.5, 42.5); direction CW\\ninner (12.5, 22.5, 27.5, 37.5); direction CCW\\n"
    },
        "SkPath_isRect": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkRect rect;\n        SkPath::Direction direction;\n        bool isClosed;\n        path.isRect(&rect, &isClosed, &direction) ?\n                SkDebugf(\"%s is rect (%g, %g, %g, %g); is %s\" \"closed; direction %s\\n\", prefix,\n                         rect.fLeft, rect.fTop, rect.fRight, rect.fBottom, isClosed ? \"\" : \"not \",\n                         SkPath::kCW_Direction == direction ? \"CW\" : \"CCW\") :\n                SkDebugf(\"%s is not rect\\n\", prefix);\n    };\n    SkPath path;\n    debugster(\"empty\", path);\n    path.addRect({10, 20, 30, 40});\n    debugster(\"addRect\", path);\n    path.moveTo(60, 70);\n    debugster(\"moveTo\", path);\n    path.lineTo(60, 70);\n    debugster(\"lineTo\", path);\n    path.reset();\n    const SkPoint pts[] = { {0, 0}, {0, 80}, {80, 80}, {80, 0}, {40, 0}, {20, 0} };\n    path.addPoly(pts, SK_ARRAY_COUNT(pts), false);\n    debugster(\"addPoly\", path);\n}\n",
    "hash": "81a2aac1b8f0ff3d4c8d35ccb9149b16",
    "file": "SkPath_Reference",
    "name": "SkPath::isRect",
        "stdout": "empty is not rect\\naddRect is rect (10, 20, 30, 40); is closed; direction CW\\nmoveTo is rect (10, 20, 30, 40); is closed; direction CW\\nlineTo is not rect\\naddPoly is rect (0, 0, 80, 80); is not closed; direction CCW\\n"
    },
        "SkPath_isVolatile": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"volatile by default is %s\\n\", path.isVolatile() ? \"true\" : \"false\");\n}",
    "hash": "c722ebe8ac991d77757799ce29e509e1",
    "file": "SkPath_Reference",
    "name": "SkPath::isVolatile",
        "stdout": "volatile by default is false\\n"
    },
        "SkPath_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& a, const SkPath& b) -> void {\n                SkDebugf(\"%s one %c= two\\n\", prefix, a != b ? '!' : '=');\n    };\n    SkPath one;\n    SkPath two;\n    debugster(\"empty\", one, two);\n    one.addRect({10, 20, 30, 40});\n    two.addRect({10, 20, 30, 40});\n    debugster(\"add rect\", one, two);\n    one.setConvexity(SkPath::kConcave_Convexity);\n    debugster(\"setConvexity\", one, two);\n    SkDebugf(\"convexity %c=\\n\", one.getConvexity() == two.getConvexity() ? '=' : '!');\n}\n",
    "hash": "bbbda1cc818d96c9c0d2a06c0c48902b",
    "file": "SkPath_Reference",
    "name": "SkPath::operator!=(const SkPath& a, const SkPath& b)",
        "stdout": "empty one == two\\nadd rect one == two\\nsetConvexity one == two\\nconvexity !=\\n"
    },
        "SkPath_readFromMemory": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, copy;\n    path.lineTo(6.f / 7, 2.f / 3);\n    size_t size = path.writeToMemory(nullptr);\n    SkTDArray<char> storage;\n    storage.setCount(size);\n    path.writeToMemory(storage.begin());\n    size_t wrongSize = size - 4;\n    size_t bytesRead = copy.readFromMemory(storage.begin(), wrongSize);\n    SkDebugf(\"length = %u; returned by readFromMemory = %u\\n\", wrongSize, bytesRead);\n    size_t largerSize = size + 4;\n    bytesRead = copy.readFromMemory(storage.begin(), largerSize);\n    SkDebugf(\"length = %u; returned by readFromMemory = %u\\n\", largerSize, bytesRead);\n}\n",
    "hash": "9c6edd836c573a0fd232d2b8aa11a678",
    "file": "SkPath_Reference",
    "name": "SkPath::readFromMemory",
        "stdout": "length = 32; returned by readFromMemory = 0\\nlength = 40; returned by readFromMemory = 36\\n"
    },
        "SkPath_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path1, path2;\n    path1.setFillType(SkPath::kInverseWinding_FillType);\n    path1.addRect({10, 20, 30, 40});\n    SkDebugf(\"path1 %c= path2\\n\", path1 == path2 ? '=' : '!');\n    path1.reset();\n    SkDebugf(\"path1 %c= path2\\n\", path1 == path2 ? '=' : '!');\n}",
    "hash": "8cdca35d2964bbbecb93d79a13f71c65",
    "file": "SkPath_Reference",
    "name": "SkPath::reset()",
        "stdout": "path1 != path2\\npath1 == path2\\n"
    },
        "SkPath_rewind": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path1, path2;\n    path1.setFillType(SkPath::kInverseWinding_FillType);\n    path1.addRect({10, 20, 30, 40});\n    SkDebugf(\"path1 %c= path2\\n\", path1 == path2 ? '=' : '!');\n    path1.rewind();\n    SkDebugf(\"path1 %c= path2\\n\", path1 == path2 ? '=' : '!');\n}",
    "hash": "f1fedbb89da9c2a33a91805175663012",
    "file": "SkPath_Reference",
    "name": "SkPath::rewind()",
        "stdout": "path1 != path2\\npath1 == path2\\n"
    },
        "SkPath_serialize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, copy;\n    path.lineTo(6.f / 7, 2.f / 3);\n    sk_sp<SkData> data = path.serialize();\n    copy.readFromMemory(data->data(), data->size());\n    SkDebugf(\"path is \" \"%s\" \"equal to copy\\n\", path == copy ? \"\" : \"not \");\n}\n",
    "hash": "2c6aff73608cd198659db6d1eeaaae4f",
    "file": "SkPath_Reference",
    "name": "SkPath::serialize()",
        "stdout": "path is equal to copy\\n"
    },
        "SkPath_setConvexity": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s path convexity is %s\\n\", prefix,\n                SkPath::kUnknown_Convexity == path.getConvexity() ? \"unknown\" :\n                SkPath::kConvex_Convexity == path.getConvexity() ? \"convex\" : \"concave\"); };\n        SkPoint quad[] = {{70, 70}, {20, 20}, {120, 20}, {120, 120}};\n        SkPath path;\n        path.addPoly(quad, SK_ARRAY_COUNT(quad), true);\n        debugster(\"initial\", path);\n        path.setConvexity(SkPath::kConcave_Convexity);\n        debugster(\"after forcing concave\", path);\n        path.setConvexity(SkPath::kUnknown_Convexity);\n        debugster(\"after forcing unknown\", path);\n}\n",
    "hash": "875e32b4b1cb48d739325705fc0fa42c",
    "file": "SkPath_Reference",
    "name": "SkPath::setConvexity",
        "stdout": "initial path convexity is convex\\nafter forcing concave path convexity is concave\\nafter forcing unknown path convexity is convex\\n"
    },
        "SkPath_swap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path1, path2;\n    path1.addRect({10, 20, 30, 40});\n    path1.swap(path2);\n    const SkRect& b1 = path1.getBounds();\n    SkDebugf(\"path1 bounds = %g, %g, %g, %g\\n\", b1.fLeft, b1.fTop, b1.fRight, b1.fBottom);\n    const SkRect& b2 = path2.getBounds();\n    SkDebugf(\"path2 bounds = %g, %g, %g, %g\\n\", b2.fLeft, b2.fTop, b2.fRight, b2.fBottom);\n}",
    "hash": "4c5ebee2b5039e5faefa07ae63a15467",
    "file": "SkPath_Reference",
    "name": "SkPath::swap()",
        "stdout": "path1 bounds = 0, 0, 0, 0\\npath2 bounds = 10, 20, 30, 40\\n"
    },
        "SkPath_updateBoundsCache": {
    "code": "void draw(SkCanvas* canvas) {\n    double times[2] = { 0, 0 };\n    for (int i = 0; i < 10000; ++i) {\n      SkPath path;\n      for (int j = 1; j < 100; ++ j) {\n        path.addCircle(50 + j, 45 + j, 25 + j);\n      }\n      if (1 & i) {\n        path.updateBoundsCache();\n      }\n      double start = SkTime::GetNSecs();\n      (void) path.getBounds();\n      times[1 & i] += SkTime::GetNSecs() - start;\n    }\n    SkDebugf(\"uncached avg: %g ms\\n\", times[0] * 1e-6);\n    SkDebugf(\"cached avg: %g ms\\n\", times[1] * 1e-6);\n}",
    "hash": "bb761cd858e6d0ca05627262cd22ff5e",
    "file": "SkPath_Reference",
    "name": "SkPath::updateBoundsCache",
        "stdout": "uncached avg: 0.18048 ms\\ncached avg: 0.182784 ms\\n\\n"
    },
        "SkPath_writeToMemory": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, copy;\n    path.lineTo(6.f / 7, 2.f / 3);\n    size_t size = path.writeToMemory(nullptr);\n    SkTDArray<char> storage;\n    storage.setCount(size);\n    path.writeToMemory(storage.begin());\n    copy.readFromMemory(storage.begin(), size);\n    SkDebugf(\"path is \" \"%s\" \"equal to copy\\n\", path == copy ? \"\" : \"not \");\n}\n",
    "hash": "e5f16eda6a1c2d759556285f72598445",
    "file": "SkPath_Reference",
    "name": "SkPath::writeToMemory",
        "stdout": "path is equal to copy\\n"
    },
        "SkPicture_uniqueID": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    recorder.beginRecording({0, 0, 0, 0});\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    SkDebugf(\"empty picture id = %d\\n\", picture->uniqueID());\n    sk_sp<SkPicture> placeholder = SkPicture::MakePlaceholder({0, 0, 0, 0});\n    SkDebugf(\"placeholder id = %d\\n\", placeholder->uniqueID());\n}",
    "hash": "8e4257245c988c600410fe4fd7293f07",
    "file": "SkPicture_Reference",
    "name": "SkPicture::uniqueID",
        "stdout": "empty picture id = 1\\nplaceholder id = 2\\n"
    },
        "SkPixmap_addr": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    pixels.resize(image->height() * image->width() * 4);\n    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,\n            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n    image->readPixels(pixmap, 0, 0);\n    SkDebugf(\"pixels address: 0x%llx\\n\", pixmap.addr());\n    SkPixmap inset;\n    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {\n         SkDebugf(\"inset address:  0x%llx\\n\", inset.addr());\n    }\n}",
    "hash": "17bcabaaee2dbb7beba562e9ca50b55e",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr()",
        "stdout": "pixels address: 0x7f2a440bb010\\ninset address:  0x7f2a440fb210\\n\\n"
    },
        "SkPixmap_addr16": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint16_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kARGB_4444_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr16() %c= storage\\n\",\n              pixmap.addr16()  == storage ? '=' : '!');\n}",
    "hash": "9b16012d265c954c6de13f3fc960da52",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr16",
        "stdout": "pixmap.addr16() == storage\\n"
    },
        "SkPixmap_addr16_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint16_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kARGB_4444_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr16(1, 2) %c= &storage[1 + 2 * w]\\n\",\n              pixmap.addr16(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');\n}",
    "hash": "2c0c88a546d4ef093ab63ff72dac00b9",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr16_2",
        "stdout": "pixmap.addr16(1, 2) == &storage[1 + 2 * w]\\n"
    },
        "SkPixmap_addr32": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint32_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr32() %c= storage\\n\",\n              pixmap.addr32()  == storage ? '=' : '!');\n}",
    "hash": "6b90c7ae9f254fe4ea9ef638f893a3e6",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr32",
        "stdout": "pixmap.addr32() == storage\\n"
    },
        "SkPixmap_addr32_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint32_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_8888_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr32(1, 2) %c= &storage[1 + 2 * w]\\n\",\n              pixmap.addr32(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');\n}",
    "hash": "12f8b5ce9fb25604f33df336677f5d62",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr32_2",
        "stdout": "pixmap.addr32(1, 2) == &storage[1 + 2 * w]\\n"
    },
        "SkPixmap_addr64": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint64_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr64() %c= storage\\n\",\n              pixmap.addr64()  == storage ? '=' : '!');\n}",
    "hash": "0d17085a4698a8a2e2235fad9041b4b4",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr64",
        "stdout": "pixmap.addr64() == storage\\n"
    },
        "SkPixmap_addr64_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint64_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr64(1, 2) %c= &storage[1 + 2 * w]\\n\",\n              pixmap.addr64(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');\n}",
    "hash": "5449f65fd7673273b0b57807fd3117ff",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr64_2",
        "stdout": "pixmap.addr64(1, 2) == &storage[1 + 2 * w]\\n"
    },
        "SkPixmap_addr8": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint8_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kGray_8_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr8() %c= storage\\n\",\n              pixmap.addr8()  == storage ? '=' : '!');\n}",
    "hash": "9adda80b2dd1b08ec5ccf66da7c8bd91",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr8",
        "stdout": "pixmap.addr8() == storage\\n"
    },
        "SkPixmap_addr8_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint8_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kGray_8_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr8(1, 2) %c= &storage[1 + 2 * w]\\n\",\n              pixmap.addr8(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');\n}",
    "hash": "5b986272268ef2c52045c1856f8b6107",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr8_2",
        "stdout": "pixmap.addr8(1, 2) == &storage[1 + 2 * w]\\n"
    },
        "SkPixmap_addrF16": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint16_t storage[w * h * 4];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),\n                    storage, w * 4 * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addrF16() %c= storage\\n\",\n              pixmap.addrF16()  == storage ? '=' : '!');\n}",
    "hash": "54e8525a592f05623c33b375aebc90c1",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addrF16",
        "stdout": "pixmap.addrF16() == storage\\n"
    },
        "SkPixmap_addrF16_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    const int wordsPerPixel = 4;\n    const int rowWords = w * wordsPerPixel;\n    uint16_t storage[rowWords * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),\n                    storage, rowWords * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addrF16(1, 2) %c= &storage[1 * wordsPerPixel + 2 * rowWords]\\n\",\n              pixmap.addrF16(1, 2)  == &storage[1 * wordsPerPixel + 2 * rowWords] ? '=' : '!');\n}",
    "hash": "f6076cad455bc80af5d06eb121d3b6f2",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addrF16_2",
        "stdout": "pixmap.addrF16(1, 2) == &storage[1 * wordsPerPixel + 2 * rowWords]\\n"
    },
        "SkPixmap_addr_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    std::vector<SkPMColor> storage;\n    storage.resize(w * h);\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), &storage.front(), w * 4);\n    SkDebugf(\"pixmap.addr(1, 2) %c= &storage[1 + 2 * w]\\n\",\n              pixmap.addr(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');\n}",
    "hash": "6e6e29e860eafed77308c973400cc84d",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr_2",
        "stdout": "pixmap.addr(1, 2) == &storage[1 + 2 * w]\\n"
    },
        "SkPixmap_alphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);\n    SkDebugf(\"alpha type: k\" \"%s\" \"_SkAlphaType\\n\", alphas[pixmap.alphaType()]);\n}",
    "hash": "070b1a60232be499eb10c6ea62371804",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::alphaType",
        "stdout": "alpha type: kPremul_SkAlphaType\\n"
    },
        "SkPixmap_bounds": {
    "code": "void draw(SkCanvas* canvas) {\n    for (int width : { 0, 2 } ) {\n        for (int height : { 0, 2 } ) {\n             SkPixmap pixmap(SkImageInfo::MakeA8(width, height), nullptr, width);\n             SkDebugf(\"width: %d height: %d empty: %s\\n\", width, height,\n                      pixmap.bounds().isEmpty() ? \"true\" : \"false\");\n        }\n    }\n}",
    "hash": "79750fb1d898a4e5c8c828b7bc9acec5",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::bounds()",
        "stdout": "width: 0 height: 0 empty: true\\nwidth: 0 height: 2 empty: true\\nwidth: 2 height: 0 empty: true\\nwidth: 2 height: 2 empty: false\\n"
    },
        "SkPixmap_colorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap(SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,\n            SkColorSpace::MakeSRGBLinear()), nullptr, 64);\n    SkColorSpace* colorSpace = pixmap.colorSpace();\n    SkDebugf(\"gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\\n\",\n            colorSpace->gammaCloseToSRGB() ? \"true\" : \"false\",\n            colorSpace->gammaIsLinear() ? \"true\" : \"false\",\n            colorSpace->isSRGB() ? \"true\" : \"false\");\n}",
    "hash": "3421bb20a302d563832ba7bb45e0cc58",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::colorSpace",
        "stdout": "gammaCloseToSRGB: false  gammaIsLinear: true  isSRGB: false\\n"
    },
        "SkPixmap_colorType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);\n    SkDebugf(\"color type: k\" \"%s\" \"_SkColorType\\n\", colors[pixmap.colorType()]);\n}",
    "hash": "0ab5c7af272685f2ce177cc79e6b9457",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::colorType",
        "stdout": "color type: kAlpha_8_SkColorType\\n"
    },
        "SkPixmap_computeByteSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap;\n    for (int width : { 1, 1000, 1000000 } ) {\n        for (int height: { 1, 1000, 1000000 } ) {\n            SkImageInfo imageInfo = SkImageInfo::MakeN32(width, height, kPremul_SkAlphaType);\n            pixmap.reset(imageInfo, nullptr, width * 5);\n            SkDebugf(\"width: %7d height: %7d computeByteSize: %13lld\\n\", width, height,\n                     pixmap.computeByteSize());\n        }\n    }\n}",
    "hash": "410d14ddc45d272598c5a4e52bb047de",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::computeByteSize",
        "stdout": "width:       1 height:       1 computeByteSize:             4\\nwidth:       1 height:    1000 computeByteSize:          4999\\nwidth:       1 height: 1000000 computeByteSize:       4999999\\nwidth:    1000 height:       1 computeByteSize:          4000\\nwidth:    1000 height:    1000 computeByteSize:       4999000\\nwidth:    1000 height: 1000000 computeByteSize:    4999999000\\nwidth: 1000000 height:       1 computeByteSize:       4000000\\nwidth: 1000000 height:    1000 computeByteSize:    4999000000\\nwidth: 1000000 height: 1000000 computeByteSize: 4999999000000\\n"
    },
        "SkPixmap_computeIsOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<uint32_t> pixels;\n    const int height = 2;\n    const int width = 2;\n    pixels.resize(height * width * 4);\n    SkPixmap pixmap(SkImageInfo::Make(width, height, kN32_SkColorType,\n            kPremul_SkAlphaType), (const void*) &pixels.front(), width * 4);\n    for (int index = 0; index < 2; ++index) {\n        pixmap.erase(0x00000000);\n        SkDebugf(\"computeIsOpaque: %s\\n\", pixmap.computeIsOpaque() ? \"true\" : \"false\");\n        pixmap.erase(0xFFFFFFFF);\n        SkDebugf(\"computeIsOpaque: %s\\n\", pixmap.computeIsOpaque() ? \"true\" : \"false\");\n        pixmap.reset(pixmap.info().makeAlphaType(kOpaque_SkAlphaType),\n                     (const void*) &pixels.front(), width * 4);\n    }\n}",
    "hash": "6ef37d5be03d0bfaec992dbb5a94c66f",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::computeIsOpaque",
        "stdout": "computeIsOpaque: false\\ncomputeIsOpaque: true\\ncomputeIsOpaque: false\\ncomputeIsOpaque: true\\n"
    },
        "SkPixmap_const_SkImageInfo_const_star": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"image alpha only = %s\\n\", image->isAlphaOnly() ? \"true\" : \"false\");\n    SkPMColor pmColors = 0;\n    sk_sp<SkImage> copy = SkImage::MakeRasterCopy({SkImageInfo::MakeA8(1, 1),\n                                                  (uint8_t*)&pmColors,\n                                                  1});\n    SkDebugf(\"copy alpha only = %s\\n\", copy->isAlphaOnly() ? \"true\" : \"false\");\n}",
    "hash": "9a00774be57d7308313b3a9073e6e696",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::SkPixmap(const SkImageInfo& info, const void* addr, size_t rowBytes)",
        "stdout": "image alpha only = false\\ncopy alpha only = true\\n"
    },
        "SkPixmap_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkPixmap pixmap;\n    for (int i = 0; i < 2; ++i) {\n       SkDebugf(\"width: %2d  height: %2d\", pixmap.width(), pixmap.height());\n       SkDebugf(\"  color: k%s_SkColorType\", colors[pixmap.colorType()]);\n       SkDebugf(\"  alpha: k%s_SkAlphaType\\n\", alphas[pixmap.alphaType()]);\n       pixmap.reset(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType),\n                    nullptr, 0);\n    }\n}\n",
    "hash": "9547e74a9d37553a667b913ffd1312dd",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::SkPixmap()",
        "stdout": "width:  0  height:  0  color: kUnknown_SkColorType  alpha: kUnknown_SkAlphaType\\nwidth: 25  height: 35  color: kRGBA_8888_SkColorType  alpha: kOpaque_SkAlphaType\\n"
    },
        "SkPixmap_getColor": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    std::vector<SkPMColor> storage;\n    storage.resize(w * h);\n    SkDebugf(\"Premultiplied:\\n\");\n    for (int y = 0; y < h; ++y) {\n        SkDebugf(\"(0, %d) \", y);\n        for (int x = 0; x < w; ++x) {\n            int a = 0xFF * (x + y) / (w - 1 + h - 1);\n            storage[x + y * w] = SkPackARGB32(a, a * x / (w - 1), a * y / (h - 1), a);\n            SkDebugf(\"0x%08x%c\", storage[x + y * w], x == w - 1 ? '\\n' : ' ');\n        }\n    }\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), &storage.front(), w * 4);\n    SkDebugf(\"Unpremultiplied:\\n\");\n    for (int y = 0; y < h; ++y) {\n        SkDebugf(\"(0, %d) \", y);\n        for (int x = 0; x < w; ++x) {\n            SkDebugf(\"0x%08x%c\", pixmap.getColor(x, y), x == w - 1 ? '\\n' : ' ');\n        }\n    }\n}",
    "hash": "94ad244056dc80ecd87daae004266334",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::getColor",
        "stdout": "Premultiplied:\\n(0, 0) 0x00000000 0x2a0e002a 0x55380055 0x7f7f007f\\n(0, 1) 0x2a000e2a 0x551c1c55 0x7f542a7f 0xaaaa38aa\\n(0, 2) 0x55003855 0x7f2a547f 0xaa7171aa 0xd4d48dd4\\n(0, 3) 0x7f007f7f 0xaa38aaaa 0xd48dd4d4 0xffffffff\\nUnpremultiplied:\\n(0, 0) 0x00000000 0x2a5500ff 0x55a800ff 0x7fff00ff\\n(0, 1) 0x2a0055ff 0x555454ff 0x7fa954ff 0xaaff54ff\\n(0, 2) 0x5500a8ff 0x7f54a9ff 0xaaaaaaff 0xd4ffaaff\\n(0, 3) 0x7f00ffff 0xaa54ffff 0xd4aaffff 0xffffffff\\n"
    },
        "SkPixmap_height": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);\n    SkDebugf(\"pixmap height: %d  info height: %d\\n\", pixmap.height(), pixmap.info().height());\n}",
    "hash": "4a996d32122f469d51ddd0186efb48cc",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::height()",
        "stdout": "pixmap height: 32  info height: 32\\n"
    },
        "SkPixmap_info": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    pixels.resize(image->height() * image->width() * 4);\n    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,\n            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n    image->readPixels(pixmap, 0, 0);\n    SkPixmap inset;\n    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {\n        const SkImageInfo& info = inset.info();\n        const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n        const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\",\n                \"RGB_888x\", \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n        SkDebugf(\"width: %d height: %d color: %s alpha: %s\\n\", info.width(), info.height(),\n                 colors[info.colorType()], alphas[info.alphaType()]);\n    }\n}",
    "hash": "6e0f558bf7fabc655041116288559134",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::info()",
        "stdout": "width: 384 height: 384 color: BGRA_8888 alpha: Opaque\\n"
    },
        "SkPixmap_isOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<uint32_t> pixels;\n    const int height = 2;\n    const int width = 2;\n    pixels.resize(height * width * 4);\n    SkPixmap pixmap(SkImageInfo::Make(width, height, kN32_SkColorType,\n            kPremul_SkAlphaType), (const void*) &pixels.front(), width * 4);\n    for (int index = 0; index < 2; ++index) {\n        pixmap.erase(0x00000000);\n        SkDebugf(\"isOpaque: %s\\n\", pixmap.isOpaque() ? \"true\" : \"false\");\n        pixmap.erase(0xFFFFFFFF);\n        SkDebugf(\"isOpaque: %s\\n\", pixmap.isOpaque() ? \"true\" : \"false\");\n        pixmap.reset(pixmap.info().makeAlphaType(kOpaque_SkAlphaType),\n                     (const void*) &pixels.front(), width * 4);\n    }\n}",
    "hash": "efd083f121e888a523455ea8a49e50d1",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::isOpaque",
        "stdout": "isOpaque: false\\nisOpaque: false\\nisOpaque: true\\nisOpaque: true\\n"
    },
        "SkPixmap_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkPixmap pixmap(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType),\n                    nullptr, 0);\n    for (int i = 0; i < 2; ++i) {\n       SkDebugf(\"width: %2d  height: %2d\", pixmap.width(), pixmap.height());\n       SkDebugf(\"  color: k%s_SkColorType\", colors[pixmap.colorType()]);\n       SkDebugf(\"  alpha: k%s_SkAlphaType\\n\", alphas[pixmap.alphaType()]);\n       pixmap.reset();\n    }\n}\n",
    "hash": "d9eb583c39f4f0baea79896b89245c98",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::reset()",
        "stdout": "width: 25  height: 35  color: kRGBA_8888_SkColorType  alpha: kOpaque_SkAlphaType\\nwidth:  0  height:  0  color: kUnknown_SkColorType  alpha: kUnknown_SkAlphaType\\n"
    },
        "SkPixmap_rowBytes": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap badPixmap = {SkImageInfo::MakeA8(4, 4), nullptr, 2};\n    SkPixmap okPixmap = {SkImageInfo::MakeA8(4, 4), nullptr, 8};\n    for (auto& pixmap : { badPixmap, okPixmap } ) {\n        SkDebugf(\"rowBytes: %d minRowBytes: %d\\n\", pixmap.rowBytes(),\n           pixmap.info().minRowBytes());\n    }\n}",
    "hash": "19ac8bb81854680bd408fec8cb797d5c",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::rowBytes",
        "stdout": "rowBytes: 2 minRowBytes: 4\\nrowBytes: 8 minRowBytes: 4\\n"
    },
        "SkPixmap_rowBytesAsPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    for (int rowBytes : { 4, 5, 6, 7, 8} ) {\n        SkPixmap pixmap(SkImageInfo::MakeN32(1, 1, kPremul_SkAlphaType), nullptr, rowBytes);\n        SkDebugf(\"rowBytes: %d rowBytesAsPixels: %d\\n\", rowBytes, pixmap.rowBytesAsPixels());\n    }\n}",
    "hash": "6231bb212d0c231b5bc44eac626fbcb5",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::rowBytesAsPixels",
        "stdout": "rowBytes: 4 rowBytesAsPixels: 1\\nrowBytes: 5 rowBytesAsPixels: 1\\nrowBytes: 6 rowBytesAsPixels: 1\\nrowBytes: 7 rowBytesAsPixels: 1\\nrowBytes: 8 rowBytesAsPixels: 2\\n"
    },
        "SkPixmap_setColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap;\n    sk_sp<SkColorSpace> colorSpace1 = SkColorSpace::MakeRGB(SkColorSpace::kLinear_RenderTargetGamma,\n                                                            SkColorSpace::kRec2020_Gamut);\n    SkDebugf(\"is %sunique\\n\", colorSpace1->unique() ? \"\" : \"not \");\n    pixmap.setColorSpace(colorSpace1);\n    SkDebugf(\"is %sunique\\n\", colorSpace1->unique() ? \"\" : \"not \");\n}\n",
    "hash": "30d70aec4de17c831dba71e03dc9664a",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::setColorSpace",
        "stdout": "is unique\\nis not unique\\n"
    },
        "SkPixmap_shiftPerPixel": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkImageInfo info = SkImageInfo::MakeA8(1, 1);\n    for (SkColorType colorType : { kUnknown_SkColorType,   kAlpha_8_SkColorType,\n                                   kRGB_565_SkColorType,   kARGB_4444_SkColorType,\n                                   kRGBA_8888_SkColorType, kBGRA_8888_SkColorType,\n                                   kGray_8_SkColorType,    kRGBA_F16_SkColorType } ) {\n        SkPixmap pixmap(info.makeColorType(colorType), nullptr, 4);\n        SkDebugf(\"color: k\" \"%s\" \"_SkColorType\" \"%*s\" \"bytesPerPixel: %d shiftPerPixel: %d\\n\",\n                colors[colorType], 10 - strlen(colors[colorType]), \" \",\n                pixmap.info().bytesPerPixel(), pixmap.shiftPerPixel());\n    }\n}",
    "hash": "bf31ee140e2c163c3957276e6d4c4f0c",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::shiftPerPixel",
        "stdout": "color: kUnknown_SkColorType   bytesPerPixel: 0 shiftPerPixel: 0\\ncolor: kAlpha_8_SkColorType   bytesPerPixel: 1 shiftPerPixel: 0\\ncolor: kRGB_565_SkColorType   bytesPerPixel: 2 shiftPerPixel: 1\\ncolor: kARGB_4444_SkColorType bytesPerPixel: 2 shiftPerPixel: 1\\ncolor: kRGBA_8888_SkColorType bytesPerPixel: 4 shiftPerPixel: 2\\ncolor: kBGRA_8888_SkColorType bytesPerPixel: 4 shiftPerPixel: 2\\ncolor: kGray_8_SkColorType    bytesPerPixel: 1 shiftPerPixel: 0\\ncolor: kRGBA_F16_SkColorType  bytesPerPixel: 8 shiftPerPixel: 3\\n"
    },
        "SkPixmap_width": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeA8(16, 32);\n    SkPixmap pixmap(info, nullptr, 64);\n    SkDebugf(\"pixmap width: %d  info width: %d\\n\", pixmap.width(), info.width());\n}",
    "hash": "f68617b7153a20b2ed3d7f9ed5c6e5e4",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::width()",
        "stdout": "pixmap width: 16  info width: 16\\n"
    },
        "SkPixmap_writable_addr": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    SkPMColor storage[w * h * 4];\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), storage, w * 4);\n    SkDebugf(\"pixmap.writable_addr() %c= (void *)storage\\n\",\n              pixmap.writable_addr()  == (void *)storage ? '=' : '!');\n    pixmap.erase(0x00000000);\n    *(SkPMColor*)pixmap.writable_addr() = 0xFFFFFFFF;\n    SkDebugf(\"pixmap.getColor(0, 1) %c= 0x00000000\\n\",\n              pixmap.getColor(0, 1)  == 0x00000000 ? '=' : '!');\n    SkDebugf(\"pixmap.getColor(0, 0) %c= 0xFFFFFFFF\\n\",\n              pixmap.getColor(0, 0)  == 0xFFFFFFFF ? '=' : '!');\n}",
    "hash": "74ef460f89ed5904334d0f8883e781c4",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr",
        "stdout": "pixmap.writable_addr() == (void *)storage\\npixmap.getColor(0, 1) == 0x00000000\\npixmap.getColor(0, 0) == 0xFFFFFFFF\\n"
    },
        "SkPixmap_writable_addr_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    SkPMColor storage[w * h * 4];\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), storage, w * 4);\n    SkDebugf(\"pixmap.writable_addr() %c= (void *)storage\\n\",\n              pixmap.writable_addr()  == (void *)storage ? '=' : '!');\n    pixmap.erase(0x00000000);\n    *(SkPMColor*)pixmap.writable_addr(1, 2) = 0xFFFFFFFF;\n    SkDebugf(\"pixmap.getColor(0, 0) %c= 0x00000000\\n\",\n              pixmap.getColor(0, 0)  == 0x00000000 ? '=' : '!');\n    SkDebugf(\"pixmap.getColor(1, 2) %c= 0xFFFFFFFF\\n\",\n              pixmap.getColor(1, 2)  == 0xFFFFFFFF ? '=' : '!');\n}",
    "hash": "559eaca89c765bc8466ea1ba3331d4db",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr_2",
        "stdout": "pixmap.writable_addr() == (void *)storage\\npixmap.getColor(0, 0) == 0x00000000\\npixmap.getColor(1, 2) == 0xFFFFFFFF\\n"
    },
        "SkPoint_Make": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt1 = {45, 66};\n    SkPoint pt2 = SkPoint::Make(45, 66);\n    SkVector v1 = {45, 66};\n    SkVector v2 = SkPoint::Make(45, 66);\n    SkDebugf(\"all %s\" \"equal\\n\", pt1 == pt2 && pt2 == v1 && v1 == v2 ? \"\" : \"not \");\n}",
    "hash": "d266e70977847001f7c42f8a2513bee7",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Make",
        "stdout": "all equal\\n"
    },
        "SkPoint_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0, -0.f}, {-1, -2}, {SK_ScalarInfinity, 1}, {SK_ScalarNaN, -1} };\n    for (const SkPoint& pt : test) {\n        SkDebugf(\"pt: %g, %g  %c= pt\\n\", pt.fX, pt.fY, pt == pt ? '=' : '!');\n    }\n}",
    "hash": "741f793334a48a35dadf4310d7ea52cb",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator==(const SkPoint& a, const SkPoint& b)",
        "stdout": "pt: 0, -0  == pt\\npt: -1, -2  == pt\\npt: inf, 1  == pt\\npt: nan, -1  != pt\\n"
    },
        "SkPoint_equals": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0, -0.f}, {-1, -2}, {SK_ScalarInfinity, 1}, {SK_ScalarNaN, -1} };\n    for (const SkPoint& pt : test) {\n        SkDebugf(\"pt: %g, %g  %c= pt\\n\", pt.fX, pt.fY, pt.equals(pt.fX, pt.fY) ? '=' : '!');\n    }\n}",
    "hash": "4cecb878c8b66beffda051f26c00f817",
    "file": "SkPoint_Reference",
    "name": "SkPoint::equals()",
        "stdout": "pt: 0, -0  == pt\\npt: -1, -2  == pt\\npt: inf, 1  == pt\\npt: nan, -1  != pt\\n"
    },
        "SkPoint_isFinite": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0, -0.f}, {-1, -2}, {SK_ScalarInfinity, 1}, {SK_ScalarNaN, -1} };\n    for (const SkPoint& pt : test) {\n        SkDebugf(\"pt: %g, %g  finite: %s\\n\", pt.fX, pt.fY, pt.isFinite() ? \"true\" : \"false\");\n    }\n}",
    "hash": "937cc166cc0e220f33fb82501141d0b3",
    "file": "SkPoint_Reference",
    "name": "SkPoint::isFinite",
        "stdout": "pt: 0, -0  finite: true\\npt: -1, -2  finite: true\\npt: inf, 1  finite: false\\npt: nan, -1  finite: false\\n"
    },
        "SkPoint_isZero": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt = { 0.f, -0.f};\n    SkDebugf(\"pt.fX=%c%g pt.fY=%c%g\\n\", std::signbit(pt.fX) ? '-' : '+', fabsf(pt.fX),\n                                        std::signbit(pt.fY) ? '-' : '+', fabsf(pt.fY));\n    SkDebugf(\"pt.isZero() == %s\\n\", pt.isZero() ? \"true\" : \"false\");\n}",
    "hash": "81b9665110b88ef6bcbc20464aed7da1",
    "file": "SkPoint_Reference",
    "name": "SkPoint::isZero",
        "stdout": "pt.fX=+0 pt.fY=-0\\npt.isZero() == true\\n"
    },
        "SkPoint_iset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt1, pt2 = { SK_MinS16, SK_MaxS16 };\n    pt1.iset(SK_MinS16, SK_MaxS16);\n    SkDebugf(\"pt1 %c= pt2\\n\", pt1 == pt2 ? '=' : '!');\n}",
    "hash": "0d9e8ed734981b5b113f22c7bfde5357",
    "file": "SkPoint_Reference",
    "name": "SkPoint::iset()",
        "stdout": "pt1 == pt2\\n"
    },
        "SkPoint_iset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint iPt = { SK_MinS32, SK_MaxS32 };\n    SkPoint fPt;\n    fPt.iset(iPt);\n    SkDebugf(\"iPt: %d, %d\\n\", iPt.fX, iPt.fY);\n    SkDebugf(\"fPt: %g, %g\\n\", fPt.fX, fPt.fY);\n}",
    "hash": "12b7164a769e232bb772f19c59600ee7",
    "file": "SkPoint_Reference",
    "name": "SkPoint::iset_2",
        "stdout": "iPt: -2147483647, 2147483647\\nfPt: -2.14748e+09, 2.14748e+09\\n"
    },
        "SkPoint_minus_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0.f, -0.f}, {-1, -2},\n                       { SK_ScalarInfinity, SK_ScalarNegativeInfinity },\n                       { SK_ScalarNaN, -SK_ScalarNaN } };\n    for (const SkPoint& pt : test) {\n        SkPoint negPt = -pt;\n        SkDebugf(\"pt: %g, %g  negate: %g, %g\\n\", pt.fX, pt.fY, negPt.fX, negPt.fY);\n    }\n}",
    "hash": "9baf247cfcd8272c0ddf6ce93f676b37",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator-() const",
        "stdout": "pt: 0, -0  negate: -0, 0\\npt: -1, -2  negate: 1, 2\\npt: inf, -inf  negate: -inf, inf\\npt: nan, -nan  negate: -nan, nan\\n"
    },
        "SkPoint_negate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0.f, -0.f}, {-1, -2},\n                       { SK_ScalarInfinity, SK_ScalarNegativeInfinity },\n                       { SK_ScalarNaN, -SK_ScalarNaN } };\n    for (const SkPoint& pt : test) {\n        SkPoint negPt = pt;\n        negPt.negate();\n        SkDebugf(\"pt: %g, %g  negate: %g, %g\\n\", pt.fX, pt.fY, negPt.fX, negPt.fY);\n    }\n}",
    "hash": "312c0c8065ab5d0adfda80cccf2d11e6",
    "file": "SkPoint_Reference",
    "name": "SkPoint::negate()",
        "stdout": "pt: 0, -0  negate: -0, 0\\npt: -1, -2  negate: 1, 2\\npt: inf, -inf  negate: -inf, inf\\npt: nan, -nan  negate: -nan, nan\\n"
    },
        "SkPoint_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0, -0.f}, {-1, -2}, {SK_ScalarInfinity, 1}, {SK_ScalarNaN, -1} };\n    for (const SkPoint& pt : test) {\n        SkDebugf(\"pt: %g, %g  %c= pt\\n\", pt.fX, pt.fY, pt != pt ? '!' : '=');\n    }\n}",
    "hash": "8fe8572685eaa617f25a5a6767a874dc",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator!=(const SkPoint& a, const SkPoint& b)",
        "stdout": "pt: 0, -0  == pt\\npt: -1, -2  == pt\\npt: inf, 1  == pt\\npt: nan, -1  != pt\\n"
    },
        "SkPoint_set": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt1, pt2 = { SK_ScalarPI, SK_ScalarSqrt2 };\n    pt1.set(SK_ScalarPI, SK_ScalarSqrt2);\n    SkDebugf(\"pt1 %c= pt2\\n\", pt1 == pt2 ? '=' : '!');\n}",
    "hash": "d08d1e7dafcad4342d1619fdbb2f5781",
    "file": "SkPoint_Reference",
    "name": "SkPoint::set()",
        "stdout": "pt1 == pt2\\n"
    },
        "SkPoint_setAbs": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0.f, -0.f}, {-1, -2},\n                       { SK_ScalarInfinity, SK_ScalarNegativeInfinity },\n                       { SK_ScalarNaN, -SK_ScalarNaN } };\n    for (const SkPoint& pt : test) {\n        SkPoint absPt;\n        absPt.setAbs(pt);\n        SkDebugf(\"pt: %g, %g  abs: %g, %g\\n\", pt.fX, pt.fY, absPt.fX, absPt.fY);\n    }\n}",
    "hash": "7f70860e820b67a347cff03c00488426",
    "file": "SkPoint_Reference",
    "name": "SkPoint::setAbs",
        "stdout": "pt: 0, -0  abs: 0, 0\\npt: -1, -2  abs: 1, 2\\npt: inf, -inf  abs: inf, inf\\npt: nan, -nan  abs: nan, nan\\n"
    },
        "SkPoint_x": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt1 = {45, 66};\n    SkDebugf(\"pt1.fX %c= pt1.x()\\n\", pt1.fX == pt1.x() ? '=' : '!');\n}",
    "hash": "9f3fe446b800ae1d940785d438634941",
    "file": "SkPoint_Reference",
    "name": "SkPoint::x()",
        "stdout": "pt1.fX == pt1.x()\\n"
    },
        "SkPoint_y": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt1 = {45, 66};\n    SkDebugf(\"pt1.fY %c= pt1.y()\\n\", pt1.fY == pt1.y() ? '=' : '!');\n}",
    "hash": "4c962850c2dbea4d2325df469400680e",
    "file": "SkPoint_Reference",
    "name": "SkPoint::y()",
        "stdout": "pt1.fY == pt1.y()\\n"
    },
        "SkRGBA4f_FromColor": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t red = 77, green = 101, blue = 153, alpha = 43;\n    SkColor argb = SkColorSetARGB(alpha, red, green, blue);\n    SkColor4f color4f = SkColor4f::FromColor(argb);\n    SkDebugf(\"red=%g green=%g blue=%g alpha=%g\\n\", color4f.fR, color4f.fG, color4f.fB, color4f.fA);\n    SkColor fromColor4f = color4f.toSkColor();\n    SkDebugf(\"red=%d green=%d blue=%d alpha=%d\\n\", SkColorGetR(fromColor4f),\n             SkColorGetG(fromColor4f), SkColorGetB(fromColor4f), SkColorGetA(fromColor4f));\n}",
    "hash": "33b029064e8d1928e42a587c953d0e4e",
    "file": "SkColor4f_Reference",
    "name": "SkRGBA4f::FromColor",
        "stdout": "red=0.301961 green=0.396078 blue=0.6 alpha=0.168627\\nred=77 green=101 blue=153 alpha=43\\n"
    },
        "SkRGBA4f_equal1_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor4f colorRed = { 1, 0, 0, 1 };\n    SkColor4f colorNamedRed = SkColor4f::FromColor(SK_ColorRED);\n    SkDebugf(\"colorRed %c= colorNamedRed\", colorRed == colorNamedRed ? '=' : '!');\n}",
    "hash": "e5b34bcb7f80f2ed890cdacaa059db0d",
    "file": "SkColor4f_Reference",
    "name": "SkRGBA4f::operator==(const SkRGBA4f& other) const",
        "stdout": "colorRed == colorNamedRed"
    },
        "SkRGBA4f_notequal1_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor4f colorGray = { .5, .5, .5, 1 };\n    SkColor4f colorNamedGray = SkColor4f::FromColor(SK_ColorGRAY);\n    SkDebugf(\"colorGray %c= colorNamedGray \", colorGray != colorNamedGray ? '!' : '=');\n}",
    "hash": "82f1a9b4c2b27aa547061786d1f33dab",
    "file": "SkColor4f_Reference",
    "name": "SkRGBA4f::operator!=(const SkRGBA4f& other) const",
        "stdout": "colorGray != colorNamedGray"
    },
        "SkRGBA4f_toSkColor": {
    "code": "void draw(SkCanvas* canvas) {\n    float red = 0.07, green = 0.13, blue = 0.32, alpha = 0.17;\n    SkColor4f color4f = { red, green, blue, alpha };\n    SkColor argb = color4f.toSkColor();\n    SkDebugf(\"red=%d green=%d blue=%d alpha=%d\\n\", SkColorGetR(argb),\n             SkColorGetG(argb), SkColorGetB(argb), SkColorGetA(argb));\n    SkColor4f fromSkColor = SkColor4f::FromColor(argb);\n    SkDebugf(\"red=%g green=%g blue=%g alpha=%g\\n\", fromSkColor.fR, fromSkColor.fG,\n                                                   fromSkColor.fB, fromSkColor.fA);\n}",
    "hash": "edc5fd18d961f7607d2bcbf7f7d427e5",
    "file": "SkColor4f_Reference",
    "name": "SkRGBA4f::toSkColor",
        "stdout": "red=18 green=33 blue=82 alpha=43\\nred=0.0705882 green=0.129412 blue=0.321569 alpha=0.168627\\n"
    },
        "SkRGBA4f_vec": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor4f color = SkColor4f::FromColor(0x884488CC);\n    SkDebugf(\"red=%g green=%g blue=%g alpha=%g\\n\", color.fR, color.fG, color.fB, color.fA);\n    const float* array = color.vec();\n    SkDebugf(\"[0]=%g [1]=%g [2]=%g [3]=%g\\n\", array[0], array[1], array[2], array[3]);\n}",
    "hash": "229057023515224358a36acf15508cf6",
    "file": "SkColor4f_Reference",
    "name": "SkRGBA4f::vec()",
        "stdout": "red=0.266667 green=0.533333 blue=0.8 alpha=0.533333\\n[0]=0.266667 [1]=0.533333 [2]=0.8 [3]=0.533333\\n"
    },
        "SkRGBA4f_vec_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor4f color = SkColor4f::FromColor(0x884488CC);\n    SkDebugf(\"red=%g green=%g blue=%g alpha=%g\\n\", color.fR, color.fG, color.fB, color.fA);\n    float* array = color.vec();\n    array[3] = 1;\n    SkDebugf(\"[0]=%g [1]=%g [2]=%g [3]=%g\\n\", array[0], array[1], array[2], array[3]);\n}",
    "hash": "7420bf0a7cae5c6577c4c4a4613e7e7e",
    "file": "SkColor4f_Reference",
    "name": "SkRGBA4f::vec_2",
        "stdout": "red=0.266667 green=0.533333 blue=0.8 alpha=0.533333\\n[0]=0.266667 [1]=0.533333 [2]=0.8 [3]=1\\n"
    },
        "SkRRect_dump": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect = SkRRect::MakeRect({6.f / 7, 2.f / 3, 6.f / 7, 2.f / 3});\n    for (bool dumpAsHex : { false, true } ) {\n        rrect.dump(dumpAsHex);\n    }\n}",
    "hash": "265b8d23288dc8026ff788e809360af7",
    "file": "SkRRect_Reference",
    "name": "SkRRect::dump()",
        "stdout": "SkRect::MakeLTRB(0.857143f, 0.666667f, 0.857143f, 0.666667f);\\nconst SkPoint corners[] = {\\n    { 0, 0 },\\n    { 0, 0 },\\n    { 0, 0 },\\n    { 0, 0 },\\n};\\nSkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */\\n                 SkBits2Float(0x3f2aaaab), /* 0.666667 */\\n                 SkBits2Float(0x3f5b6db7), /* 0.857143 */\\n                 SkBits2Float(0x3f2aaaab)  /* 0.666667 */);\\nconst SkPoint corners[] = {\\n    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\\n    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\\n    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\\n    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\\n};\\n"
    },
        "SkRRect_dumpHex": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect = SkRRect::MakeRect({6.f / 7, 2.f / 3, 6.f / 7, 2.f / 3});\n    rrect.dumpHex();\n    SkRect bounds = SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */\n                     SkBits2Float(0x3f2aaaab), /* 0.666667 */\n                     SkBits2Float(0x3f5b6db7), /* 0.857143 */\n                     SkBits2Float(0x3f2aaaab)  /* 0.666667 */);\n    const SkPoint corners[] = {\n        { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\n        { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\n        { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\n        { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\n    };\n    SkRRect copy;\n    copy.setRectRadii(bounds, corners);\n    SkDebugf(\"rrect is \" \"%s\" \"equal to copy\\n\", rrect == copy ? \"\" : \"not \");\n}",
    "hash": "c73f5e2644d949b859f05bd367883454",
    "file": "SkRRect_Reference",
    "name": "SkRRect::dumpHex",
        "stdout": "SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */\\n                 SkBits2Float(0x3f2aaaab), /* 0.666667 */\\n                 SkBits2Float(0x3f5b6db7), /* 0.857143 */\\n                 SkBits2Float(0x3f2aaaab)  /* 0.666667 */);\\nconst SkPoint corners[] = {\\n    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\\n    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\\n    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\\n    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */\\n};\\nrrect is equal to copy\\n"
    },
        "SkRRect_dump_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect = SkRRect::MakeRect({6.f / 7, 2.f / 3, 6.f / 7, 2.f / 3});\n    rrect.dump();\n    SkRect bounds = SkRect::MakeLTRB(0.857143f, 0.666667f, 0.857143f, 0.666667f);\n    const SkPoint corners[] = {\n        { 0, 0 },\n        { 0, 0 },\n        { 0, 0 },\n        { 0, 0 },\n    };\n    SkRRect copy;\n    copy.setRectRadii(bounds, corners);\n    SkDebugf(\"rrect is \" \"%s\" \"equal to copy\\n\", rrect == copy ? \"\" : \"not \");\n}",
    "hash": "f850423c7c0c4f803d479ecd92221059",
    "file": "SkRRect_Reference",
    "name": "SkRRect::dump_2",
        "stdout": "SkRect::MakeLTRB(0.857143f, 0.666667f, 0.857143f, 0.666667f);\\nconst SkPoint corners[] = {\\n    { 0, 0 },\\n    { 0, 0 },\\n    { 0, 0 },\\n    { 0, 0 },\\n};\\nrrect is not equal to copy\\n"
    },
        "SkRRect_height": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect unsorted = SkRRect::MakeRect({ 15, 25, 10, 20 });\n    SkDebugf(\"unsorted height: %g\\n\", unsorted.height());\n    SkRRect large = SkRRect::MakeRect({ 1, -FLT_MAX, 2, FLT_MAX });\n    SkDebugf(\"large height: %.0f\\n\", large.height());\n}",
    "hash": "5a3eb1755164a7becec33cec6e6eca31",
    "file": "SkRRect_Reference",
    "name": "SkRRect::height()",
        "stdout": "unsorted height: 5\\nlarge height: inf\\n"
    },
        "SkRRect_radii": {
    "code": "void draw(SkCanvas* canvas) {\n    for (SkScalar radiusX : { SK_ScalarNaN, SK_ScalarInfinity, 100.f, 50.f, 25.f} ) {\n        SkRRect rrect1 = SkRRect::MakeRectXY({10, 20, 60, 220}, radiusX, 200);\n        SkDebugf(\"left corner: (%g) %g\\n\", radiusX, rrect1.radii(SkRRect::kUpperLeft_Corner).fX);\n    }\n}",
    "hash": "8d5c88478528584913867ada423e0d59",
    "file": "SkRRect_Reference",
    "name": "SkRRect::radii()",
        "stdout": "left corner: (nan) 0\\nleft corner: (inf) 0\\nleft corner: (100) 25\\nleft corner: (50) 25\\nleft corner: (25) 12.5\\n"
    },
        "SkRRect_rect": {
    "code": "void draw(SkCanvas* canvas) {\n    for (SkScalar left : { SK_ScalarNaN, SK_ScalarInfinity, 100.f, 50.f, 25.f} ) {\n        SkRRect rrect1 = SkRRect::MakeRectXY({left, 20, 60, 220}, 50, 200);\n        SkDebugf(\"left bounds: (%g) %g\\n\", left, rrect1.rect().fLeft);\n    }\n}",
    "hash": "6831adf4c536047f4709c686feb10c48",
    "file": "SkRRect_Reference",
    "name": "SkRRect::rect()",
        "stdout": "left bounds: (nan) 0\\nleft bounds: (inf) 0\\nleft bounds: (100) 60\\nleft bounds: (50) 50\\nleft bounds: (25) 25\\n"
    },
        "SkRRect_width": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect unsorted = SkRRect::MakeRect({ 15, 25, 10, 5 });\n    SkDebugf(\"unsorted width: %g\\n\", unsorted.width());\n    SkRRect large = SkRRect::MakeRect({ -FLT_MAX, 1, FLT_MAX, 2 });\n    SkDebugf(\"large width: %.0f\\n\", large.width());\n}",
    "hash": "c675a480b41dee157f84fa2550a2a53c",
    "file": "SkRRect_Reference",
    "name": "SkRRect::width()",
        "stdout": "unsorted width: 5\\nlarge width: inf\\n"
    },
        "SkRect_Intersects": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"%s intersection\", SkRect::Intersects({10, 40, 50, 80}, {30, 60, 70, 90}) ? \"\" : \"no \");\n}",
    "hash": "795061764b10c9e05efb466c9cb60644",
    "file": "SkRect_Reference",
    "name": "SkRect::Intersects",
        "stdout": "intersection"
    },
        "SkRect_Make": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = SkRect::MakeSize({2, 35});\n    SkRect rect2 = SkRect::MakeIWH(2, 35);\n    SkDebugf(\"rect1 %c= rect2\\n\", rect1 == rect2 ? '=' : '!');\n}",
    "hash": "e866f5e4f6ac52e89acadf48e54ac8e0",
    "file": "SkRect_Reference",
    "name": "SkRect::Make",
        "stdout": "rect1 == rect2\\n"
    },
        "SkRect_MakeEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = SkRect::MakeEmpty();\n    SkDebugf(\"MakeEmpty isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.offset(10, 10);\n    SkDebugf(\"offset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.inset(10, 10);\n    SkDebugf(\"inset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.outset(20, 20);\n    SkDebugf(\"outset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "2e262d0ac4b8ef51695e0525fc3ecdf6",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeEmpty",
        "stdout": "MakeEmpty isEmpty: true\\noffset rect isEmpty: true\\ninset rect isEmpty: true\\noutset rect isEmpty: false\\n"
    },
        "SkRect_MakeIWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect i_rect = SkIRect::MakeWH(25, 35);\n    SkRect  f_rect = SkRect::MakeIWH(25, 35);\n    SkDebugf(\"i_rect width: %d f_rect width:%g\\n\", i_rect.width(), f_rect.width());\n    i_rect = SkIRect::MakeWH(125000111, 0);\n    f_rect = SkRect::MakeIWH(125000111, 0);\n    SkDebugf(\"i_rect width: %d f_rect width:%.0f\\n\", i_rect.width(), f_rect.width());\n}",
    "hash": "faa660ac19eaddc3f3eab57a0bddfdcb",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeIWH",
        "stdout": "i_rect width: 25 f_rect width:25\\ni_rect width: 125000111 f_rect width:125000112\\n"
    },
        "SkRect_MakeLTRB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = SkRect::MakeLTRB(5, 35, 15, 25);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "158b8dd9d02d65a5ae5ab7d1595a5b4c",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeLTRB",
        "stdout": "rect: 5, 35, 15, 25  isEmpty: true\\nrect: 5, 25, 15, 35  isEmpty: false\\n"
    },
        "SkRect_MakeSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkSize size = {25.5f, 35.5f};\n    SkRect rect = SkRect::MakeSize(size);\n    SkDebugf(\"rect width: %g  height: %g\\n\", rect.width(), rect.height());\n    SkISize floor = size.toFloor();\n    rect = SkRect::MakeSize(SkSize::Make(floor));\n    SkDebugf(\"floor width: %g  height: %g\\n\", rect.width(), rect.height());\n}",
    "hash": "ab2c1a55016c8de9172b77fdf69e00a2",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeSize",
        "stdout": "rect width: 25.5  height: 35.5\\nfloor width: 25  height: 35\\n"
    },
        "SkRect_MakeWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = SkRect::MakeWH(25, 35);\n    SkRect rect2 = SkRect::MakeIWH(25, 35);\n    SkRect rect3 = SkRect::MakeXYWH(0, 0, 25, 35);\n    SkRect rect4 = SkRect::MakeLTRB(0, 0, 25, 35);\n    SkDebugf(\"all %s\" \"equal\\n\", rect1 == rect2 && rect2 == rect3 && rect3 == rect4 ?\n             \"\" : \"not \");\n}",
    "hash": "8009d30f431e01f8aea4808e9017d9bf",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeWH",
        "stdout": "all equal\\n"
    },
        "SkRect_MakeXYWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = SkRect::MakeXYWH(5, 35, -15, 25);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "38e464dba13be11ac21e210fbf3b5afc",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeXYWH",
        "stdout": "rect: 5, 35, -10, 60  isEmpty: true\\nrect: -10, 35, 5, 60  isEmpty: false\\n"
    },
        "SkRect_Make_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect i_rect1 = {2, 35, 22, 53};\n    SkRect f_rect = SkRect::Make(i_rect1);\n    f_rect.offset(0.49f, 0.49f);\n    SkIRect i_rect2;\n    f_rect.round(&i_rect2);\n    SkDebugf(\"i_rect1 %c= i_rect2\\n\", i_rect1 == i_rect2? '=' : '!');\n}",
    "hash": "dd801faa1e60a0fe9e0657674461e063",
    "file": "SkRect_Reference",
    "name": "SkRect::Make_2",
        "stdout": "i_rect1 == i_rect2\\n"
    },
        "SkRect_asScalars": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {7, 11, 13, 17};\n SkDebugf(\"rect.asScalars() %c= &rect.fLeft\\n\", rect.asScalars() == &rect.fLeft? '=' : '!');\n}",
    "hash": "e1ea5f949d80276f3637931eae93a07c",
    "file": "SkRect_Reference",
    "name": "SkRect::asScalars",
        "stdout": "rect.asScalars() == &rect.fLeft\\n"
    },
        "SkRect_bottom": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fBottom: %g unsorted.bottom(): %g\\n\", unsorted.fBottom, unsorted.bottom());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fBottom: %g sorted.bottom(): %g\\n\", sorted.fBottom, sorted.bottom());\n}",
    "hash": "a98993a66616ae406d8bdc54adfb1411",
    "file": "SkRect_Reference",
    "name": "SkRect::bottom()",
        "stdout": "unsorted.fBottom: 5 unsorted.bottom(): 5\\nsorted.fBottom: 25 sorted.bottom(): 25\\n"
    },
        "SkRect_centerX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect tests[] = {{20, 30, 41, 51}, {-20, -30, -41, -51}};\n    for (auto rect : tests) {\n        SkDebugf(\"left: %3g right: %3g centerX: %3g\\n\", rect.left(), rect.right(), rect.centerX());\n        rect.sort();\n        SkDebugf(\"left: %3g right: %3g centerX: %3g\\n\", rect.left(), rect.right(), rect.centerX());\n    }\n}",
    "hash": "d8439ba8d23a424fa032fb97147fd2d2",
    "file": "SkRect_Reference",
    "name": "SkRect::centerX",
        "stdout": "left:  20 right:  41 centerX: 30.5\\nleft:  20 right:  41 centerX: 30.5\\nleft: -20 right: -41 centerX: -30.5\\nleft: -41 right: -20 centerX: -30.5\\n"
    },
        "SkRect_centerY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 2e+38, 2e+38, 3e+38, 3e+38 };\n    SkDebugf(\"left: %g right: %g centerX: %g \", rect.left(), rect.right(), rect.centerX());\n    SkDebugf(\"safe mid x: %g\\n\", rect.left() / 2 + rect.right() / 2);\n}",
    "hash": "ebeeafafeb8fe39d5ffc9115b02c2340",
    "file": "SkRect_Reference",
    "name": "SkRect::centerY",
        "stdout": "left: 2e+38 right: 3e+38 centerX: 2.5e+38 safe mid x: 2.5e+38\\n"
    },
        "SkRect_contains": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30, 50, 40, 60 };\n    SkPoint tests[] = { { 30, 50 }, { 39, 49 }, { 29, 59 } };\n    for (auto contained : tests) {\n        SkDebugf(\"rect: (%g, %g, %g, %g) %s (%g, %g)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.contains(contained.x(), contained.y()) ? \"contains\" : \"does not contain\",\n                 contained.x(), contained.y());\n    }\n}",
    "hash": "85be528a78945a6dc4f7dccb80a80746",
    "file": "SkRect_Reference",
    "name": "SkRect::contains()",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50)\\nrect: (30, 50, 40, 60) does not contain (39, 49)\\nrect: (30, 50, 40, 60) does not contain (29, 59)\\n"
    },
        "SkRect_contains_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30, 50, 40, 60 };\n    SkRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        SkDebugf(\"rect: (%g, %g, %g, %g) %s (%g, %g, %g, %g)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.contains(contained) ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "92f9e6aa5bb76791139a24cf7d8df99e",
    "file": "SkRect_Reference",
    "name": "SkRect::contains_2",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkRect_contains_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30, 50, 40, 60 };\n    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        SkDebugf(\"rect: (%g, %g, %g, %g) %s (%d, %d, %d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.contains(contained) ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "dd58b699551dd44026a2c6386be27d88",
    "file": "SkRect_Reference",
    "name": "SkRect::contains_3",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkRect_dump": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {20, 30, 40, 50};\n     for (bool dumpAsHex : { false, true } ) {\n         rect.dump(dumpAsHex);\n         SkDebugf(\"\\n\");\n     }\n}",
    "hash": "cea049ffff702a5923da41fe0ae0763b",
    "file": "SkRect_Reference",
    "name": "SkRect::dump()",
        "stdout": "SkRect::MakeLTRB(20, 30, 40, 50);\\n\\nSkRect::MakeLTRB(SkBits2Float(0x41a00000), /* 20.000000 */\\n                 SkBits2Float(0x41f00000), /* 30.000000 */\\n                 SkBits2Float(0x42200000), /* 40.000000 */\\n                 SkBits2Float(0x42480000)  /* 50.000000 */);\\n\\n"
    },
        "SkRect_dumpHex": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {6.f / 7, 2.f / 3, 26.f / 10, 42.f / 6};\n rect.dumpHex();\n SkRect copy = SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */\n                  SkBits2Float(0x3f2aaaab), /* 0.666667 */\n                  SkBits2Float(0x40266666), /* 2.600000 */\n                  SkBits2Float(0x40e00000)  /* 7.000000 */);\n SkDebugf(\"rect is \" \"%s\" \"equal to copy\\n\", rect == copy ? \"\" : \"not \");\n}",
    "hash": "824b5a3fcfd46a7e1c5f9e3c16e6bb39",
    "file": "SkRect_Reference",
    "name": "SkRect::dumpHex",
        "stdout": "SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */\\n                 SkBits2Float(0x3f2aaaab), /* 0.666667 */\\n                 SkBits2Float(0x40266666), /* 2.600000 */\\n                 SkBits2Float(0x40e00000)  /* 7.000000 */);\\nrect is equal to copy\\n"
    },
        "SkRect_dump_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {6.f / 7, 2.f / 3, 26.f / 10, 42.f / 6};\n    rect.dump();\n    SkRect copy = SkRect::MakeLTRB(0.857143f, 0.666667f, 2.6f, 7);\n    SkDebugf(\"rect is \" \"%s\" \"equal to copy\\n\", rect == copy ? \"\" : \"not \");\n}",
    "hash": "9fb76971b1a104a2a59816e0392267a7",
    "file": "SkRect_Reference",
    "name": "SkRect::dump_2",
        "stdout": "SkRect::MakeLTRB(0.857143f, 0.666667f, 2.6f, 7);\\nrect is not equal to copy\\n"
    },
        "SkRect_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const SkRect& test) -> void {\n        SkRect negZero = {-0.0f, -0.0f, 2, 2};\n        SkDebugf(\"{%g, %g, %g, %g} %c= {%g, %g, %g, %g} %s numerically equal\\n\",\n                 test.fLeft, test.fTop, test.fRight, test.fBottom,\n                 negZero.fLeft, negZero.fTop, negZero.fRight, negZero.fBottom,\n                 test == negZero ? '=' : '!',\n                 test.fLeft == negZero.fLeft && test.fTop == negZero.fTop &&\n                 test.fRight == negZero.fRight && test.fBottom == negZero.fBottom ?\n                 \"and are\" : \"yet are not\");\n    };\n    SkRect tests[] = {{0, 0, 2, 2}, {-0, -0, 2, 2}, {0.0f, 0.0f, 2, 2}};\n    SkDebugf(\"tests are %s\" \"equal\\n\", tests[0] == tests[1] && tests[1] == tests[2] ? \"\" : \"not \");\n    for (auto rect : tests) {\n        debugster(rect);\n    }\n}",
    "hash": "c6c5b40cad7c3a839fdf576b380391a6",
    "file": "SkRect_Reference",
    "name": "SkRect::operator==(const SkRect& a, const SkRect& b)",
        "stdout": "tests are equal\\n{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal\\n{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal\\n{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal\\n"
    },
        "SkRect_height": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 20 };\n    SkDebugf(\"unsorted height: %g\\n\", unsorted.height());\n    SkRect large = { 1, -2147483647.f, 2, 2147483644.f };\n    SkDebugf(\"large height: %.0f\\n\", large.height());\n}",
    "hash": "39429e45f05240218ecd511443ab3e44",
    "file": "SkRect_Reference",
    "name": "SkRect::height()",
        "stdout": "unsorted height: -5\\nlarge height: 4294967296\\n"
    },
        "SkRect_inset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 14, 50, 73 };\n    rect.inset(5, 13);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "dae21340941dc6e4d048816dfd9f204c",
    "file": "SkRect_Reference",
    "name": "SkRect::inset()",
        "stdout": "rect: 15, 27, 45, 60\\n"
    },
        "SkRect_intersect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect leftRect =  { 10, 40, 50, 80 };\n    SkRect rightRect = { 30, 60, 70, 90 };\n    SkDebugf(\"%s intersection: \", leftRect.intersect(rightRect) ? \"\" : \"no \");\n    SkDebugf(\"%g, %g, %g, %g\\n\", leftRect.left(), leftRect.top(),\n                                 leftRect.right(), leftRect.bottom());\n}",
    "hash": "5d0b12e0ef6f1c181dddded4274230ca",
    "file": "SkRect_Reference",
    "name": "SkRect::intersect()",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkRect_intersect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect leftRect =  { 10, 40, 50, 80 };\n    SkDebugf(\"%s intersection: \", leftRect.intersect(30, 60, 70, 90) ? \"\" : \"no \");\n    SkDebugf(\"%g, %g, %g, %g\\n\", leftRect.left(), leftRect.top(),\n                                 leftRect.right(), leftRect.bottom());\n}",
    "hash": "5002f65a72def2787086a33131933e70",
    "file": "SkRect_Reference",
    "name": "SkRect::intersect_2",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkRect_intersect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect result;\n    bool intersected = result.intersect({ 10, 40, 50, 80 }, { 30, 60, 70, 90 });\n    SkDebugf(\"%s intersection: %g, %g, %g, %g\\n\", intersected ? \"\" : \"no \",\n             result.left(), result.top(), result.right(), result.bottom());\n}",
    "hash": "d610437a65dd3e952719efe605cbd0c7",
    "file": "SkRect_Reference",
    "name": "SkRect::intersect_3",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkRect_intersects": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 40, 50, 80 };\n    SkDebugf(\"%s intersection\", rect.intersects(30, 60, 70, 90) ? \"\" : \"no \");\n}",
    "hash": "7145dc17ebce4f54e892102f6c98e811",
    "file": "SkRect_Reference",
    "name": "SkRect::intersects()",
        "stdout": "intersection"
    },
        "SkRect_intersects_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 40, 50, 80 };\n    SkDebugf(\"%s intersection\", rect.intersects({30, 60, 70, 90}) ? \"\" : \"no \");\n}",
    "hash": "ca37b4231b21eb8296cb19ba9e0c781b",
    "file": "SkRect_Reference",
    "name": "SkRect::intersects_2",
        "stdout": "intersection"
    },
        "SkRect_isEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};\n    for (auto rect : tests) {\n        SkDebugf(\"rect: {%g, %g, %g, %g} is\" \"%s empty\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isEmpty() ? \"\" : \" not\");\n        rect.sort();\n        SkDebugf(\"sorted: {%g, %g, %g, %g} is\" \"%s empty\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isEmpty() ? \"\" : \" not\");\n    }\n}",
    "hash": "1d7b924d6ca2a6aef09684a8a632439c",
    "file": "SkRect_Reference",
    "name": "SkRect::isEmpty",
        "stdout": "rect: {20, 40, 10, 50} is empty\\nsorted: {10, 40, 20, 50} is not empty\\nrect: {20, 40, 20, 50} is empty\\nsorted: {20, 40, 20, 50} is empty\\n"
    },
        "SkRect_isFinite": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect largest = { SK_ScalarMin, SK_ScalarMin, SK_ScalarMax, SK_ScalarMax };\n        SkDebugf(\"largest is finite: %s\\n\", largest.isFinite() ? \"true\" : \"false\");\n        SkDebugf(\"large width %g\\n\", largest.width());\n        SkRect widest = SkRect::MakeWH(largest.width(), largest.height());\n        SkDebugf(\"widest is finite: %s\\n\", widest.isFinite() ? \"true\" : \"false\");\n}",
    "hash": "443fe5f8296d4cdb19cc9862a9cf77a4",
    "file": "SkRect_Reference",
    "name": "SkRect::isFinite",
        "stdout": "largest is finite: true\\nlarge width inf\\nwidest is finite: false\\n"
    },
        "SkRect_isSorted": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};\n    for (auto rect : tests) {\n        SkDebugf(\"rect: {%g, %g, %g, %g} is\" \"%s sorted\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isSorted() ? \"\" : \" not\");\n        rect.sort();\n        SkDebugf(\"sorted: {%g, %g, %g, %g} is\" \"%s sorted\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isSorted() ? \"\" : \" not\");\n    }\n}",
    "hash": "c7065a83b220a96f903dbbb65906fe7b",
    "file": "SkRect_Reference",
    "name": "SkRect::isSorted",
        "stdout": "rect: {20, 40, 10, 50} is not sorted\\nsorted: {10, 40, 20, 50} is sorted\\nrect: {20, 40, 20, 50} is sorted\\nsorted: {20, 40, 20, 50} is sorted\\n"
    },
        "SkRect_iset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = {3, 4, 1, 2};\n    SkDebugf(\"rect1: {%g, %g, %g, %g}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkRect rect2;\n    rect2.iset(3, 4, 1, 2);\n    SkDebugf(\"rect2: {%g, %g, %g, %g}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "18532f1aa90b76364fb8d7ea072f1892",
    "file": "SkRect_Reference",
    "name": "SkRect::iset()",
        "stdout": "rect1: {3, 4, 1, 2}\\nrect2: {3, 4, 1, 2}\\n"
    },
        "SkRect_isetWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = {0, 0, 1, 2};\n    SkDebugf(\"rect1: {%g, %g, %g, %g}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkRect rect2;\n    rect2.isetWH(1, 2);\n    SkDebugf(\"rect2: {%g, %g, %g, %g}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "ee6000080fc7123214ea404018cf9176",
    "file": "SkRect_Reference",
    "name": "SkRect::isetWH",
        "stdout": "rect1: {0, 0, 1, 2}\\nrect2: {0, 0, 1, 2}\\n"
    },
        "SkRect_join": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 20, 15, 25};\n    rect.join(50, 60, 55, 65);\n    SkDebugf(\"join: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "afa9c6b4d05bb669db07fe0b7b97e6aa",
    "file": "SkRect_Reference",
    "name": "SkRect::join()",
        "stdout": "join: 10, 20, 55, 65\\n"
    },
        "SkRect_joinNonEmptyArg": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 100, 15, 0};\n    SkRect sorted = rect.makeSorted();\n    SkRect toJoin = { 50, 60, 55, 65 };\n    rect.joinNonEmptyArg(toJoin);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    sorted.joinNonEmptyArg(toJoin);\n    SkDebugf(\"sorted: %g, %g, %g, %g\\n\", sorted.fLeft, sorted.fTop, sorted.fRight, sorted.fBottom);\n}",
    "hash": "88439de2aa0911262c60c0eb506396cb",
    "file": "SkRect_Reference",
    "name": "SkRect::joinNonEmptyArg",
        "stdout": "rect: 50, 60, 55, 65\\nsorted: 10, 0, 55, 100\\n"
    },
        "SkRect_joinPossiblyEmptyRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 100, 15, 0};\n    SkRect sorted = rect.makeSorted();\n    SkRect toJoin = { 50, 60, 55, 65 };\n    rect.joinPossiblyEmptyRect(toJoin);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    sorted.joinPossiblyEmptyRect(toJoin);\n    SkDebugf(\"sorted: %g, %g, %g, %g\\n\", sorted.fLeft, sorted.fTop, sorted.fRight, sorted.fBottom);\n}",
    "hash": "a476548d0001296afd8e58c1eba1b70b",
    "file": "SkRect_Reference",
    "name": "SkRect::joinPossiblyEmptyRect",
        "stdout": "rect: 10, 60, 55, 65\\nsorted: 10, 0, 55, 100\\n"
    },
        "SkRect_join_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 20, 15, 25};\n    rect.join({50, 60, 55, 65});\n    SkDebugf(\"join: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "26500032494cf93c5fa3423110fe82af",
    "file": "SkRect_Reference",
    "name": "SkRect::join_2",
        "stdout": "join: 10, 20, 55, 65\\n"
    },
        "SkRect_left": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 5, 10, 25 };\n    SkDebugf(\"unsorted.fLeft: %g unsorted.left(): %g\\n\", unsorted.fLeft, unsorted.left());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fLeft: %g sorted.left(): %g\\n\", sorted.fLeft, sorted.left());\n}",
    "hash": "900dc96c3549795a87036d6458c4fde6",
    "file": "SkRect_Reference",
    "name": "SkRect::left()",
        "stdout": "unsorted.fLeft: 15 unsorted.left(): 15\\nsorted.fLeft: 10 sorted.left(): 10\\n"
    },
        "SkRect_makeInset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeInset(15, 32);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "b8d32ab2f7ea3d4d5fb5a4ea2156f1c5",
    "file": "SkRect_Reference",
    "name": "SkRect::makeInset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: 25, 82, 5, 28  isEmpty: true\\n"
    },
        "SkRect_makeOffset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeOffset(15, 32);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "98841ab0a932f99cccd8e6a34d94ba05",
    "file": "SkRect_Reference",
    "name": "SkRect::makeOffset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: 25, 82, 35, 92  isEmpty: false\\n"
    },
        "SkRect_makeOutset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeOutset(15, 32);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "87176fc60914cbca9c6a20998a033c24",
    "file": "SkRect_Reference",
    "name": "SkRect::makeOutset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: -5, 18, 35, 92  isEmpty: false\\n"
    },
        "SkRect_makeSorted": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 20.5f, 10.5f };\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    SkRect sort = rect.makeSorted();\n    SkDebugf(\"sorted: %g, %g, %g, %g\\n\", sort.fLeft, sort.fTop, sort.fRight, sort.fBottom);\n}",
    "hash": "f59567042b87f6b26f9bfeeb04468032",
    "file": "SkRect_Reference",
    "name": "SkRect::makeSorted",
        "stdout": "rect: 30.5, 50.5, 20.5, 10.5\\nsorted: 20.5, 10.5, 30.5, 50.5\\n"
    },
        "SkRect_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect test = {0, 0, 2, SK_ScalarNaN};\n    SkDebugf(\"test with NaN is %s\" \"equal to itself\\n\", test == test ? \"\" : \"not \");\n}",
    "hash": "286072f8c27ff15be9eb945fa38dc9f7",
    "file": "SkRect_Reference",
    "name": "SkRect::operator!=(const SkRect& a, const SkRect& b)",
        "stdout": "test with NaN is not equal to itself\\n"
    },
        "SkRect_offset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 14, 50, 73 };\n    rect.offset(5, 13);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "04eb33f0fd376f2942ca5f1c7f6cbcfc",
    "file": "SkRect_Reference",
    "name": "SkRect::offset()",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkRect_offsetTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 14, 50, 73 };\n    rect.offsetTo(15, 27);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "bedb04b7b3e1af3e8039f9cffe66989e",
    "file": "SkRect_Reference",
    "name": "SkRect::offsetTo",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkRect_offset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 14, 50, 73 };\n    rect.offset({5, 13});\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "b24cf65561c98c1858a06c39f10fb797",
    "file": "SkRect_Reference",
    "name": "SkRect::offset_2",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkRect_outset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 14, 50, 73 };\n    rect.outset(5, 13);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "861f873ba660af8c8bf8b0b83d829cf4",
    "file": "SkRect_Reference",
    "name": "SkRect::outset()",
        "stdout": "rect: 5, 1, 55, 86\\n"
    },
        "SkRect_right": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fRight: %g unsorted.right(): %g\\n\", unsorted.fRight, unsorted.right());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fRight: %g sorted.right(): %g\\n\", sorted.fRight, sorted.right());\n}",
    "hash": "ca3de7e5e292b3ad3633b1c39a31d3ab",
    "file": "SkRect_Reference",
    "name": "SkRect::right()",
        "stdout": "unsorted.fRight: 10 unsorted.right(): 10\\nsorted.fRight: 15 sorted.right(): 15\\n"
    },
        "SkRect_round": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkIRect round;\n    rect.round(&round);\n    SkDebugf(\"round: %d, %d, %d, %d\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "8b9e5a9af0a9b878f76919534d88f41e",
    "file": "SkRect_Reference",
    "name": "SkRect::round()",
        "stdout": "round: 31, 51, 41, 61\\n"
    },
        "SkRect_roundIn": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkIRect round;\n    rect.roundIn(&round);\n    SkDebugf(\"round: %d, %d, %d, %d\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "abb337da8fc1891f016c61258681c64c",
    "file": "SkRect_Reference",
    "name": "SkRect::roundIn",
        "stdout": "round: 31, 51, 40, 60\\n"
    },
        "SkRect_roundOut": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkIRect round;\n    rect.roundOut(&round);\n    SkDebugf(\"round: %d, %d, %d, %d\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "0bd13d7e6426ae7a3befa2ab151ac5fc",
    "file": "SkRect_Reference",
    "name": "SkRect::roundOut",
        "stdout": "round: 30, 50, 41, 61\\n"
    },
        "SkRect_roundOut_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkRect round;\n    rect.roundOut(&round);\n    SkDebugf(\"round: %g, %g, %g, %g\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "e09a6a12869a8ac21e9c2af98a5bb686",
    "file": "SkRect_Reference",
    "name": "SkRect::roundOut_2",
        "stdout": "round: 30, 50, 41, 61\\n"
    },
        "SkRect_roundOut_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkIRect round = rect.roundOut();\n    SkDebugf(\"round: %d, %d, %d, %d\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "05f0f65ae148f192656cd87df90f1d57",
    "file": "SkRect_Reference",
    "name": "SkRect::roundOut_3",
        "stdout": "round: 30, 50, 41, 61\\n"
    },
        "SkRect_round_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkIRect round = rect.round();\n    SkDebugf(\"round: %d, %d, %d, %d\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "ef7ae1dd522c235b0afe41b55a624f46",
    "file": "SkRect_Reference",
    "name": "SkRect::round_2",
        "stdout": "round: 31, 51, 41, 61\\n"
    },
        "SkRect_set": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect i_rect = {3, 4, 1, 2};\n    SkDebugf(\"i_rect: {%d, %d, %d, %d}\\n\", i_rect.fLeft, i_rect.fTop, i_rect.fRight, i_rect.fBottom);\n    SkRect f_rect;\n    f_rect.set(i_rect);\n    SkDebugf(\"f_rect: {%g, %g, %g, %g}\\n\", f_rect.fLeft, f_rect.fTop, f_rect.fRight, f_rect.fBottom);\n}",
    "hash": "a10ad8d97062bc3f40942f47e5108917",
    "file": "SkRect_Reference",
    "name": "SkRect::set()",
        "stdout": "i_rect: {3, 4, 1, 2}\\nf_rect: {3, 4, 1, 2}\\n"
    },
        "SkRect_setBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};\n    for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {\n        SkRect rect;\n        rect.setBounds(points, count);\n        if (count > 0) {\n            SkDebugf(\"added: %3g, %g \", points[count - 1].fX,  points[count - 1].fY);\n        } else {\n            SkDebugf(\"%14s\", \" \");\n        }\n        SkDebugf(\"count: %d rect: %g, %g, %g, %g\\n\", count,\n                rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    }\n}",
    "hash": "cf0da15f48aa54fd1889e7f913601710",
    "file": "SkRect_Reference",
    "name": "SkRect::setBounds",
        "stdout": "count: 0 rect: 0, 0, 0, 0\\nadded:   3, 4 count: 1 rect: 3, 4, 3, 4\\nadded:   1, 2 count: 2 rect: 1, 2, 3, 4\\nadded:   5, 6 count: 3 rect: 1, 2, 5, 6\\nadded: nan, 8 count: 4 rect: 0, 0, 0, 0\\n"
    },
        "SkRect_setBoundsCheck": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};\n    for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {\n        SkRect rect;\n        bool success = rect.setBoundsCheck(points, count);\n        if (count > 0) {\n            SkDebugf(\"added: %3g, %g \", points[count - 1].fX,  points[count - 1].fY);\n        } else {\n            SkDebugf(\"%14s\", \" \");\n        }\n        SkDebugf(\"count: %d rect: %g, %g, %g, %g success: %s\\n\", count,\n                rect.fLeft, rect.fTop, rect.fRight, rect.fBottom, success ? \"true\" : \"false\");\n    }\n}",
    "hash": "83d879b92683b15f9daaf0c9e71c5b35",
    "file": "SkRect_Reference",
    "name": "SkRect::setBoundsCheck",
        "stdout": "count: 0 rect: 0, 0, 0, 0 success: true\\nadded:   3, 4 count: 1 rect: 3, 4, 3, 4 success: true\\nadded:   1, 2 count: 2 rect: 1, 2, 3, 4 success: true\\nadded:   5, 6 count: 3 rect: 1, 2, 5, 6 success: true\\nadded: nan, 8 count: 4 rect: 0, 0, 0, 0 success: false\\n"
    },
        "SkRect_setBoundsNoCheck": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint points[] = {{3, 4}, {1, 2}, {SK_ScalarInfinity, 6}, {SK_ScalarNaN, 8}};\n    for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {\n        SkRect rect;\n        rect.setBoundsNoCheck(points, count);\n        if (count > 0) {\n            SkDebugf(\"added: %3g, %g \", points[count - 1].fX,  points[count - 1].fY);\n        } else {\n            SkDebugf(\"%14s\", \" \");\n        }\n        SkDebugf(\"count: %d rect: %g, %g, %g, %g\\n\", count,\n                rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    }\n}",
    "hash": "be10cb1411dbcf7e38e0198e8a9b8b0e",
    "file": "SkRect_Reference",
    "name": "SkRect::setBoundsNoCheck",
        "stdout": "count: 0 rect: 0, 0, 0, 0\\nadded:   3, 4 count: 1 rect: 3, 4, 3, 4\\nadded:   1, 2 count: 2 rect: 1, 2, 3, 4\\nadded: inf, 6 count: 3 rect: nan, nan, nan, nan\\nadded: nan, 8 count: 4 rect: nan, nan, nan, nan\\n"
    },
        "SkRect_setEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {3, 4, 1, 2};\n    for (int i = 0; i < 2; ++i) {\n    SkDebugf(\"rect: {%g, %g, %g, %g} is %s\" \"empty\\n\", rect.fLeft, rect.fTop,\n             rect.fRight, rect.fBottom, rect.isEmpty() ? \"\" : \"not \");\n    rect.setEmpty();\n    }\n}",
    "hash": "2cf67542d45ef5d7a7efb673b651ff54",
    "file": "SkRect_Reference",
    "name": "SkRect::setEmpty",
        "stdout": "rect: {3, 4, 1, 2} is empty\\nrect: {0, 0, 0, 0} is empty\\n"
    },
        "SkRect_setLTRB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = {3, 4, 1, 2};\n    SkDebugf(\"rect1: {%g, %g, %g, %g}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkRect rect2;\n    rect2.setLTRB(3, 4, 1, 2);\n    SkDebugf(\"rect2: {%g, %g, %g, %g}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "70692838793454c8e045d6eaf7edcbff",
    "file": "SkRect_Reference",
    "name": "SkRect::setLTRB",
        "stdout": "rect1: {3, 4, 1, 2}\\nrect2: {3, 4, 1, 2}\\n"
    },
        "SkRect_setWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect;\n    rect.setWH(-15, 25);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "9cb5fee17802fa49341f3707bdf5d235",
    "file": "SkRect_Reference",
    "name": "SkRect::setWH",
        "stdout": "rect: 0, 0, -15, 25  isEmpty: true\\nrect: -15, 0, 0, 25  isEmpty: false\\n"
    },
        "SkRect_setXYWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect;\n    rect.setXYWH(5, 35, -15, 25);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "373cce4c61b9da0384b735b838765163",
    "file": "SkRect_Reference",
    "name": "SkRect::setXYWH",
        "stdout": "rect: 5, 35, -10, 60  isEmpty: true\\nrect: -10, 35, 5, 60  isEmpty: false\\n"
    },
        "SkRect_set_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = {3, 4, 1, 2};\n    SkDebugf(\"rect1: {%g, %g, %g, %g}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkRect rect2;\n    rect2.set(3, 4, 1, 2);\n    SkDebugf(\"rect2: {%g, %g, %g, %g}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "9b29ea460d69b4d47323fd9e3e17721e",
    "file": "SkRect_Reference",
    "name": "SkRect::set_2",
        "stdout": "rect1: {3, 4, 1, 2}\\nrect2: {3, 4, 1, 2}\\n"
    },
        "SkRect_set_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};\n    for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {\n        SkRect rect;\n        rect.set(points, count);\n        if (count > 0) {\n            SkDebugf(\"added: %3g, %g \", points[count - 1].fX,  points[count - 1].fY);\n        } else {\n            SkDebugf(\"%14s\", \" \");\n        }\n        SkDebugf(\"count: %d rect: %g, %g, %g, %g\\n\", count,\n                rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    }\n}",
    "hash": "94295fa5197e21256171b99b4023dd48",
    "file": "SkRect_Reference",
    "name": "SkRect::set_3",
        "stdout": "count: 0 rect: 0, 0, 0, 0\\nadded:   3, 4 count: 1 rect: 3, 4, 3, 4\\nadded:   1, 2 count: 2 rect: 1, 2, 3, 4\\nadded:   5, 6 count: 3 rect: 1, 2, 5, 6\\nadded: nan, 8 count: 4 rect: 0, 0, 0, 0\\n"
    },
        "SkRect_set_4": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint point1 = {SK_ScalarNaN, 8};\n    SkPoint point2 = {3, 4};\n    SkRect rect;\n    rect.set(point1, point2);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    rect.set(point2, point1);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "ee72450381f768f3869153cdbeccdc3e",
    "file": "SkRect_Reference",
    "name": "SkRect::set_4",
        "stdout": "rect: 3, 4, 3, 8\\nrect: nan, 4, nan, 8\\n"
    },
        "SkRect_sort": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 20.5f, 10.5f };\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    rect.sort();\n    SkDebugf(\"sorted: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "e624fe398e3d770b573c09fc74c0c400",
    "file": "SkRect_Reference",
    "name": "SkRect::sort()",
        "stdout": "rect: 30.5, 50.5, 20.5, 10.5\\nsorted: 20.5, 10.5, 30.5, 50.5\\n"
    },
        "SkRect_toQuad": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {1, 2, 3, 4};\n    SkPoint corners[4];\n    rect.toQuad(corners);\n    SkDebugf(\"rect: {%g, %g, %g, %g}\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    SkDebugf(\"corners:\");\n    for (auto corner : corners) {\n        SkDebugf(\" {%g, %g}\", corner.fX, corner.fY);\n    }\n    SkDebugf(\"\\n\");\n}",
    "hash": "59a6e7d202ac17ab80ec21b233e51f59",
    "file": "SkRect_Reference",
    "name": "SkRect::toQuad",
        "stdout": "rect: {1, 2, 3, 4}\\ncorners: {1, 2} {3, 2} {3, 4} {1, 4}\\n"
    },
        "SkRect_top": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fTop: %g unsorted.top(): %g\\n\", unsorted.fTop, unsorted.top());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fTop: %g sorted.top(): %g\\n\", sorted.fTop, sorted.top());\n}",
    "hash": "3cfc24b011aef1ca8ccb57c05711620c",
    "file": "SkRect_Reference",
    "name": "SkRect::top()",
        "stdout": "unsorted.fTop: 25 unsorted.top(): 25\\nsorted.fTop: 5 sorted.top(): 5\\n"
    },
        "SkRect_width": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted width: %g\\n\", unsorted.width());\n    SkRect large = { -2147483647.f, 1, 2147483644.f, 2 };\n    SkDebugf(\"large width: %.0f\\n\", large.width());\n}",
    "hash": "11f8f0efe6291019fee0ac17844f6c1a",
    "file": "SkRect_Reference",
    "name": "SkRect::width()",
        "stdout": "unsorted width: -5\\nlarge width: 4294967296\\n"
    },
        "SkRect_x": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 5, 10, 25 };\n    SkDebugf(\"unsorted.fLeft: %g unsorted.x(): %g\\n\", unsorted.fLeft, unsorted.x());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fLeft: %g sorted.x(): %g\\n\", sorted.fLeft, sorted.x());\n}",
    "hash": "23c77a35ac54a439a2989f840aa5cb99",
    "file": "SkRect_Reference",
    "name": "SkRect::x()",
        "stdout": "unsorted.fLeft: 15 unsorted.x(): 15\\nsorted.fLeft: 10 sorted.x(): 10\\n"
    },
        "SkRect_y": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fTop: %g unsorted.y(): %g\\n\", unsorted.fTop, unsorted.y());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fTop: %g sorted.y(): %g\\n\", sorted.fTop, sorted.y());\n}",
    "hash": "c653d9017983d2a047b1fee6a481d82b",
    "file": "SkRect_Reference",
    "name": "SkRect::y()",
        "stdout": "unsorted.fTop: 25 unsorted.y(): 25\\nsorted.fTop: 5 sorted.y(): 5\\n"
    },
        "SkRegion_Cliperator_const_SkRegion_const_SkIRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    region.setRect({1, 2, 3, 4});\n    SkRegion::Cliperator clipper(region, {0, 0, 2, 3});\n    auto r = clipper.rect();\n    SkDebugf(\"rect={%d,%d,%d,%d}\\n\", r.fLeft, r.fTop, r.fRight, r.fBottom);\n}",
    "hash": "3831fb6006a7e0ad5d140c266c22be78",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Cliperator::Cliperator(const SkRegion& region, const SkIRect& clip)",
        "stdout": "rect={1,2,2,3}\\n"
    },
        "SkRegion_Cliperator_done": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion& region) -> void {\n        SkRegion::Cliperator clipper(region, {0, 0, 5, 5});\n        SkDebugf(\"%14s done=%s\\n\", label, clipper.done() ? \"true\" : \"false\"); \n    };\n    SkRegion region;\n    debugster(\"empty region\", region);\n    region.setRect({1, 2, 3, 4});\n    debugster(\"after add rect\", region);\n}",
    "hash": "6cca7b96836266800d852664a1366453",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Cliperator::done()",
        "stdout": "empty region done=true\\nafter add rect done=false\\n"
    },
        "SkRegion_Cliperator_next": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    SkIRect rects[] = {{1, 2, 3, 4}, {5, 6, 7, 8}};\n    region.setRects(rects, SK_ARRAY_COUNT(rects));\n    SkRegion::Cliperator clipper(region, {0, 3, 8, 7});\n    do {\n        auto r2 = clipper.rect();\n        SkDebugf(\"rect={%d,%d,%d,%d}\\n\", r2.fLeft, r2.fTop, r2.fRight, r2.fBottom);\n        clipper.next();\n    } while (!clipper.done());\n}",
    "hash": "3bbcc7eec19c808a8167bbcc987199f8",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Cliperator::next()",
        "stdout": "rect={1,3,3,4}\\nrect={5,6,7,7}\\n"
    },
        "SkRegion_Cliperator_rect": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion& region) -> void {\n        SkRegion::Cliperator clipper(region, {0, 0, 5, 3});\n        auto r = clipper.rect();\n        SkDebugf(\"%14s rect={%d,%d,%d,%d}\\n\", label, r.fLeft, r.fTop, r.fRight, r.fBottom); \n    };\n    SkRegion region;\n    debugster(\"empty region\", region);\n    region.setRect({1, 2, 3, 4});\n    debugster(\"after set rect\", region);\n}",
    "hash": "05791751f00b4c2426093fa143b43bc7",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Cliperator::rect()",
        "stdout": "empty region rect={1094713344,1065353216,0,-1}\\nafter set rect rect={1,2,3,3}\\n\\n"
    },
        "SkRegion_Iterator_Iterator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion::Iterator iter;\n    SkRegion region;\n    region.setRect({1, 2, 3, 4});\n    iter.reset(region);\n    auto r = iter.rect();\n    SkDebugf(\"rect={%d,%d,%d,%d}\\n\", r.fLeft, r.fTop, r.fRight, r.fBottom);\n}",
    "hash": "a2db43ee3cbf6893e9b23927fb44298a",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Iterator::Iterator()",
        "stdout": "rect={1,2,3,4}\\n"
    },
        "SkRegion_Iterator_copy_const_SkRegion": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    region.setRect({1, 2, 3, 4});\n    SkRegion::Iterator iter(region);\n    auto r = iter.rect();\n    SkDebugf(\"rect={%d,%d,%d,%d}\\n\", r.fLeft, r.fTop, r.fRight, r.fBottom);\n}",
    "hash": "e317ceca48a6a7504219af58f35d2c95",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Iterator::Iterator(const SkRegion& region)",
        "stdout": "rect={1,2,3,4}\\n"
    },
        "SkRegion_Iterator_done": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    SkRegion::Iterator iter(region);\n    SkDebugf(\"done=%s\\n\", iter.done() ? \"true\" : \"false\"); \n    region.setRect({1, 2, 3, 4});\n    iter.rewind();\n    SkDebugf(\"done=%s\\n\", iter.done() ? \"true\" : \"false\");\n}",
    "hash": "814efa7d7f4ae52dfc861a937c1b5c25",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Iterator::done()",
        "stdout": "done=true\\ndone=false\\n"
    },
        "SkRegion_Iterator_next": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    SkIRect rects[] = {{1, 2, 3, 4}, {5, 6, 7, 8}};\n    region.setRects(rects, SK_ARRAY_COUNT(rects));\n    SkRegion::Iterator iter(region);\n    do {\n        auto r2 = iter.rect();\n        SkDebugf(\"rect={%d,%d,%d,%d}\\n\", r2.fLeft, r2.fTop, r2.fRight, r2.fBottom);\n        iter.next();\n    } while (!iter.done());\n}",
    "hash": "771236c2eadfc2fcd02a3e61a0875d39",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Iterator::next()",
        "stdout": "rect={1,2,3,4}\\nrect={5,6,7,8}\\n"
    },
        "SkRegion_Iterator_rect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    SkRegion::Iterator iter(region);\n    auto r1 = iter.rect();\n    SkDebugf(\"rect={%d,%d,%d,%d}\\n\", r1.fLeft, r1.fTop, r1.fRight, r1.fBottom); \n    region.setRect({1, 2, 3, 4});\n    iter.rewind();\n    auto r2 = iter.rect();\n    SkDebugf(\"rect={%d,%d,%d,%d}\\n\", r2.fLeft, r2.fTop, r2.fRight, r2.fBottom);\n}",
    "hash": "0e7c58ab5d3bcfb36b1f8464cf6c7d89",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Iterator::rect()",
        "stdout": "rect={0,0,0,0}\\nrect={1,2,3,4}\\n\\n"
    },
        "SkRegion_Iterator_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion::Iterator& iter) -> void {\n        SkDebugf(\"%14s: done=%s\\n\", label, iter.done() ? \"true\" : \"false\");\n    };\n    SkRegion region;\n    SkRegion::Iterator iter(region);\n    debugster(\"empty region\", iter);\n    region.setRect({1, 2, 3, 4});\n    debugster(\"after set rect\", iter);\n    iter.reset(region);\n    debugster(\"after reset\", iter);\n}",
    "hash": "d153f87bd518a4ab947b7e407ea1db79",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Iterator::reset()",
        "stdout": "empty region: done=true\\nafter set rect: done=true\\n   after reset: done=false\\n"
    },
        "SkRegion_Iterator_rewind": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion::Iterator& iter, bool addRewind) -> void {\n        if (addRewind) {\n            bool success = iter.rewind();\n            SkDebugf(\"%14s rewind success=%s\\n\", label, success ? \"true\" : \"false\");\n        }\n        auto r = iter.rect();\n        SkDebugf(\"%14s rect={%d,%d,%d,%d}\\n\", label, r.fLeft, r.fTop, r.fRight, r.fBottom);\n    };\n    SkRegion::Iterator iter;\n    debugster(\"empty iter\", iter, true);\n    SkRegion region;\n    iter.reset(region);\n    debugster(\"empty region\", iter, true);\n    region.setRect({1, 2, 3, 4});\n    iter.reset(region);\n    debugster(\"after set rect\", iter, false);\n    debugster(\"after rewind\", iter, true);\n}",
    "hash": "32d51e959d6cc720a74ec4822511e2cd",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Iterator::rewind()",
        "stdout": "empty iter rewind success=false\\nempty iter rect={0,0,0,0}\\nempty region rewind success=true\\nempty region rect={0,0,0,0}\\nafter set rect rect={1,2,3,4}\\nafter rewind rewind success=true\\nafter rewind rect={1,2,3,4}\\n\\n"
    },
        "SkRegion_Iterator_rgn": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    SkIRect rects[] = {{1, 2, 3, 4}, {3, 4, 5, 6}};\n    region.setRects(rects, SK_ARRAY_COUNT(rects));\n    SkRegion::Iterator iter(region);\n    auto r = iter.rect();\n    SkDebugf(\"rect={%d,%d,%d,%d}\\n\", r.fLeft, r.fTop, r.fRight, r.fBottom);\n    auto b = iter.rgn()->getBounds();\n    SkDebugf(\"bounds={%d,%d,%d,%d}\\n\", b.fLeft, b.fTop, b.fRight, b.fBottom);\n}",
    "hash": "bbc3c454a21186e2a16e843a5b061c44",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Iterator::rgn()",
        "stdout": "rect={1,2,3,4}\\nbounds={1,2,5,6}\\n"
    },
        "SkRegion_Spanerator_const_SkRegion_int_int_int": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    region.setRect({1, 2, 3, 4});\n    SkRegion::Spanerator spanner(region, 3, 2, 4);\n    int left, right;\n    bool result = spanner.next(&left, &right);\n    SkDebugf(\"result=%s left=%d right=%d\\n\", result ? \"true\" : \"false\", left, right);\n}",
    "hash": "3073b3f8ea7252871b6156ff674dc385",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Spanerator::Spanerator(const SkRegion& region, int y, int left, int right)",
        "stdout": "result=true left=2 right=3\\n"
    },
        "SkRegion_Spanerator_next": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion& region) -> void {\n        SkRegion::Spanerator spanner(region, 3, 2, 4);\n        int left, right;\n        bool result = spanner.next(&left, &right);\n        SkDebugf(\"%14s: result=%s\", label, result ? \"true\" : \"false\");\n        if (result) SkDebugf(\" left=%d right=%d\", left, right);\n        SkDebugf(\"\\n\");\n    };\n    SkRegion region;\n    debugster(\"empty region\", region);\n    region.setRect({1, 2, 3, 4});\n    debugster(\"after set rect\", region);\n}",
    "hash": "03d02180fee5f64ec4a3347e118fb2ec",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Spanerator::next()",
        "stdout": "empty region: result=false\\nafter set rect: result=true left=2 right=3\\n"
    },
        "SkRegion_computeRegionComplexity": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, const SkRegion& region) -> void {\n                SkDebugf(\"%s: region complexity %d\\n\", label, region.computeRegionComplexity());\n    };\n    SkRegion region;\n    debugster(\"initial\", region);\n    region.setRect({1, 2, 3, 4});\n    debugster(\"set rect\", region);\n    region.op({2, 3, 4, 5}, SkRegion::kUnion_Op);\n    debugster(\"op rect\", region);\n}",
    "hash": "c4984fefdcecdd1090be160f80939d87",
    "file": "SkRegion_Reference",
    "name": "SkRegion::computeRegionComplexity",
        "stdout": "initial: region complexity 0\\nset rect: region complexity 1\\nop rect: region complexity 3\\n"
    },
        "SkRegion_copy_const_SkIRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region({1, 2, 3, 4});\n    SkRegion region2;\n    region2.setRect({1, 2, 3, 4});\n    SkDebugf(\"region %c= region2\\n\", region == region2 ? '=' : '!');\n}",
    "hash": "5253910233f7961c30b4c18ab911e917",
    "file": "SkRegion_Reference",
    "name": "SkRegion::SkRegion(const SkIRect& rect)",
        "stdout": "region == region2\\n"
    },
        "SkRegion_copy_const_SkRegion": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion& region) -> void {\n        auto r = region.getBounds();\n        SkDebugf(\"%14s: {%d,%d,%d,%d}\\n\", label, r.fLeft, r.fTop, r.fRight, r.fBottom);\n    };\n    SkRegion region({1, 2, 3, 4});\n    SkRegion region2(region);\n    debugster(\"region bounds\", region);\n    debugster(\"region2 bounds\", region2);\n    region.setEmpty();\n    SkDebugf(\"    after region set empty:\\n\");\n    debugster(\"region bounds\", region);\n    debugster(\"region2 bounds\", region2);\n}",
    "hash": "3daa83fca809b9ec6560d2ef9e2da5e6",
    "file": "SkRegion_Reference",
    "name": "SkRegion::SkRegion(const SkRegion& region)",
        "stdout": "region bounds: {1,2,3,4}\\nregion2 bounds: {1,2,3,4}\\n    after region set empty:\\n region bounds: {0,0,0,0}\\nregion2 bounds: {1,2,3,4}\\n"
    },
        "SkRegion_copy_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion& region) -> void {\n        auto r = region.getBounds();\n        SkDebugf(\"%14s: {%d,%d,%d,%d}\\n\", label, r.fLeft, r.fTop, r.fRight, r.fBottom);\n    };\n    SkRegion region1({1, 2, 3, 4});\n    SkRegion region2 = region1;\n    debugster(\"region1 bounds\", region1);\n    debugster(\"region2 bounds\", region2);\n}",
    "hash": "e8513f6394c24efaa301d41921c5241a",
    "file": "SkRegion_Reference",
    "name": "SkRegion::operator=(const SkRegion& region)",
        "stdout": "region1 bounds: {1,2,3,4}\\nregion2 bounds: {1,2,3,4}\\n"
    },
        "SkRegion_destructor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion* region = new SkRegion({1, 2, 3, 4});\n    SkRegion region2(*region);\n    delete region;\n    auto r = region2.getBounds();\n    SkDebugf(\"region2 bounds: {%d,%d,%d,%d}\\n\", r.fLeft, r.fTop, r.fRight, r.fBottom);\n}",
    "hash": "985ff654a6b67288d322c748132a088e",
    "file": "SkRegion_Reference",
    "name": "SkRegion::~SkRegion()",
        "stdout": "region2 bounds: {1,2,3,4}\\n"
    },
        "SkRegion_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    SkIRect r = region.getBounds();\n    SkDebugf(\"region bounds: {%d, %d, %d, %d}\\n\", r.fLeft, r.fTop, r.fRight, r.fBottom);\n}",
    "hash": "4549dcda3e0f9a41b3daee0ed37deca8",
    "file": "SkRegion_Reference",
    "name": "SkRegion::SkRegion()",
        "stdout": "region bounds: {0, 0, 0, 0}\\n"
    },
        "SkRegion_equal1_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkRegion& a, const SkRegion& b) -> void {\n                SkDebugf(\"%s one %c= two\\n\", prefix, a == b ? '=' : '!');\n    };\n    SkRegion one;\n    SkRegion two;\n    debugster(\"empty\", one, two);\n    one.setRect({1, 2, 3, 4});\n    debugster(\"set rect\", one, two);\n    one.setEmpty();\n    debugster(\"set empty\", one, two);\n}",
    "hash": "d7f4fdc8bc63ca8410ed166ecef0aef3",
    "file": "SkRegion_Reference",
    "name": "SkRegion::operator==(const SkRegion& other) const",
        "stdout": "empty one == two\\nset rect one != two\\nset empty one == two\\n"
    },
        "SkRegion_getBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region({1, 2, 3, 4});\n    region.op({2, 3, 4, 5}, SkRegion::kUnion_Op);\n    auto r = region.getBounds();\n    SkDebugf(\"bounds: {%d,%d,%d,%d}\\n\", r.fLeft, r.fTop, r.fRight, r.fBottom);\n}",
    "hash": "651632582d385d2531e7aa551c31e331",
    "file": "SkRegion_Reference",
    "name": "SkRegion::getBounds",
        "stdout": "bounds: {1,2,4,5}\\n"
    },
        "SkRegion_isComplex": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, const SkRegion& region) -> void {\n                SkDebugf(\"%s: region is %s\" \"complex\\n\", label, region.isComplex() ? \"\" : \"not \");\n    };\n    SkRegion region;\n    debugster(\"initial\", region);\n    region.setRect({1, 2, 3, 4});\n    debugster(\"set rect\", region);\n    region.op({2, 3, 4, 5}, SkRegion::kUnion_Op);\n    debugster(\"op rect\", region);\n}",
    "hash": "1fbd76d75ca2d280e81856311de4e54e",
    "file": "SkRegion_Reference",
    "name": "SkRegion::isComplex",
        "stdout": "initial: region is not complex\\nset rect: region is not complex\\nop rect: region is complex\\n"
    },
        "SkRegion_isEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion& region) -> void {\n        SkDebugf(\"%14s: region is %s\" \"empty\\n\", label, region.isEmpty() ? \"\" : \"not \");\n    };\n    SkRegion region;\n    debugster(\"initial\", region);\n    region.setRect({1, 2, 3, 4});\n    debugster(\"set rect\", region);\n    region.setEmpty();\n    debugster(\"set empty\", region);\n}",
    "hash": "10ef0de39e8553dd97cf8668ce185070",
    "file": "SkRegion_Reference",
    "name": "SkRegion::isEmpty",
        "stdout": "initial: region is empty\\n      set rect: region is not empty\\n     set empty: region is empty\\n"
    },
        "SkRegion_isRect": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, const SkRegion& region) -> void {\n                SkDebugf(\"%s: region is %s\" \"rect\\n\", label, region.isRect() ? \"\" : \"not \");\n    };\n    SkRegion region;\n    debugster(\"initial\", region);\n    region.setRect({1, 2, 3, 4});\n    debugster(\"set rect\", region);\n    region.setEmpty();\n    debugster(\"set empty\", region);\n}",
    "hash": "b6adbdddf7fe45a1098121c4e5fd57ea",
    "file": "SkRegion_Reference",
    "name": "SkRegion::isRect",
        "stdout": "initial: region is not rect\\nset rect: region is rect\\nset empty: region is not rect\\n"
    },
        "SkRegion_notequal1_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkRegion& a, const SkRegion& b) -> void {\n                SkDebugf(\"%s one %c= two\\n\", prefix, a != b ? '!' : '=');\n    };\n    SkRegion one;\n    SkRegion two;\n    debugster(\"empty\", one, two);\n    one.setRect({1, 2, 3, 4});\n    two.setRect({1, 2, 3, 3});\n    debugster(\"set rect\", one, two);\n    two.op({1, 3, 3, 4}, SkRegion::kUnion_Op);\n    debugster(\"union rect\", one, two);\n}",
    "hash": "3357caa9d8d810f200cbccb668182496",
    "file": "SkRegion_Reference",
    "name": "SkRegion::operator!=(const SkRegion& other) const",
        "stdout": "empty one == two\\nset rect one != two\\nunion rect one == two\\n"
    },
        "SkRegion_quickContains": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region({1, 2, 3, 4});\n    SkIRect test = {2, 2, 3, 3};\n    SkDebugf(\"quickContains 1: %s\\n\", region.quickContains(test) ? \"true\" : \"false\");\n    region.op({1, 4, 3, 6}, SkRegion::kUnion_Op);\n    SkDebugf(\"quickContains 2: %s\\n\", region.quickContains(test) ? \"true\" : \"false\");\n    region.op({1, 7, 3, 8}, SkRegion::kUnion_Op);\n    SkDebugf(\"quickContains 3: %s\\n\", region.quickContains(test) ? \"true\" : \"false\");\n}",
    "hash": "d8e5eac373e2e7cfc1b8cd0229647ba6",
    "file": "SkRegion_Reference",
    "name": "SkRegion::quickContains",
        "stdout": "quickContains 1: true\\nquickContains 2: true\\nquickContains 3: false\\n"
    },
        "SkRegion_quickContains_2": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion& region) -> void {\n        SkDebugf(\"%s: %s\\n\", label, region.quickContains(2, 2, 3, 3) ? \"true\" : \"false\");\n    };\n    SkRegion region({1, 2, 3, 4});\n    debugster(\"quickContains 1\", region);\n    region.op({1, 4, 3, 6}, SkRegion::kUnion_Op);\n    debugster(\"quickContains 2\", region);\n    region.op({1, 7, 3, 8}, SkRegion::kUnion_Op);\n    debugster(\"quickContains 3\", region);\n}",
    "hash": "eb6d290887e1a3a0b051b4d7b012f5e1",
    "file": "SkRegion_Reference",
    "name": "SkRegion::quickContains_2",
        "stdout": "quickContains 1: true\\nquickContains 2: true\\nquickContains 3: false\\n"
    },
        "SkRegion_quickReject": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region({1, 2, 3, 4});\n    SkIRect test = {4, 2, 5, 3};\n    SkDebugf(\"quickReject 1: %s\\n\", region.quickReject(test) ? \"true\" : \"false\");\n    region.op({1, 4, 3, 6}, SkRegion::kUnion_Op);\n    SkDebugf(\"quickReject 2: %s\\n\", region.quickReject(test) ? \"true\" : \"false\");\n    region.op({4, 7, 5, 8}, SkRegion::kUnion_Op);\n    SkDebugf(\"quickReject 3: %s\\n\", region.quickReject(test) ? \"true\" : \"false\");\n}",
    "hash": "71ac24b7d91ac5ca7c14b43930d5f85d",
    "file": "SkRegion_Reference",
    "name": "SkRegion::quickReject",
        "stdout": "quickReject 1: true\\nquickReject 2: true\\nquickReject 3: false\\n"
    },
        "SkRegion_quickReject_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region({1, 2, 3, 4});\n    SkRegion test;\n    SkIRect rects[] = {{4, 2, 5, 3}, {7, 2, 8, 3}};\n    test.setRects(rects, SK_ARRAY_COUNT(rects));\n    SkDebugf(\"quickReject 1: %s\\n\", region.quickReject(test) ? \"true\" : \"false\");\n    region.op({1, 4, 3, 6}, SkRegion::kUnion_Op);\n    SkDebugf(\"quickReject 2: %s\\n\", region.quickReject(test) ? \"true\" : \"false\");\n    region.op({4, 7, 5, 8}, SkRegion::kUnion_Op);\n    SkDebugf(\"quickReject 3: %s\\n\", region.quickReject(test) ? \"true\" : \"false\");\n}",
    "hash": "def7dba38947c33b203e4f9db6c88be3",
    "file": "SkRegion_Reference",
    "name": "SkRegion::quickReject_2",
        "stdout": "quickReject 1: true\\nquickReject 2: true\\nquickReject 3: false\\n"
    },
        "SkRegion_set": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion& region) -> void {\n        auto r = region.getBounds();\n        SkDebugf(\"%14s: {%d,%d,%d,%d}\\n\", label, r.fLeft, r.fTop, r.fRight, r.fBottom);\n    };\n    SkRegion region1({1, 2, 3, 4});\n    SkRegion region2;\n    region2.set(region1);\n    debugster(\"region1 bounds\", region1);\n    debugster(\"region2 bounds\", region2);\n}",
    "hash": "b3538117c7ae2cb7de3b42ca45fe1b13",
    "file": "SkRegion_Reference",
    "name": "SkRegion::set()",
        "stdout": "region1 bounds: {1,2,3,4}\\nregion2 bounds: {1,2,3,4}\\n"
    },
        "SkRegion_setEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion& region) -> void {\n        auto r = region.getBounds();\n        SkDebugf(\"%14s: {%d,%d,%d,%d}\\n\", label, r.fLeft, r.fTop, r.fRight, r.fBottom);\n    };\n    SkRegion region({1, 2, 3, 4});\n    debugster(\"region bounds\", region);\n    region.setEmpty();\n    SkDebugf(\"    after region set empty:\\n\");\n    debugster(\"region bounds\", region);\n}",
    "hash": "1314f7250963775c5ee89cc5981eee24",
    "file": "SkRegion_Reference",
    "name": "SkRegion::setEmpty",
        "stdout": "region bounds: {1,2,3,4}\\n    after region set empty:\\n region bounds: {0,0,0,0}\\n"
    },
        "SkRegion_setRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region({1, 2, 3, 4});\n    SkDebugf(\"region is %s\" \"empty\\n\", region.isEmpty() ? \"\" : \"not \");\n    bool setEmpty = region.setRect({1, 2, 1, 4});\n    SkDebugf(\"region is %s\" \"empty\\n\", region.isEmpty() ? \"\" : \"not \");\n    SkDebugf(\"setEmpty: %s\\n\", setEmpty ? \"true\" : \"false\");\n}",
    "hash": "e12575ffcd262f2364e0e6bece98a825",
    "file": "SkRegion_Reference",
    "name": "SkRegion::setRect",
        "stdout": "region is not empty\\nregion is empty\\nsetEmpty: false\\n"
    },
        "SkRegion_setRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, bool success, SkRegion& region) -> void {\n        auto r = region.getBounds();\n        SkDebugf(\"%14s: success:%s {%d,%d,%d,%d}\\n\", label, success ? \"true\" : \"false\",\n                 r.fLeft, r.fTop, r.fRight, r.fBottom);\n    };\n    SkRegion region;\n    bool success = region.setRect(1, 2, 3, 4);\n    debugster(\"set to: 1,2,3,4\", success, region);\n    success = region.setRect(3, 2, 1, 4);\n    debugster(\"set to: 3,2,1,4\", success, region);\n}",
    "hash": "5b31a1b077818a8150ad50f3b19e7bfe",
    "file": "SkRegion_Reference",
    "name": "SkRegion::setRect_2",
        "stdout": "set to: 1,2,3,4: success:true {1,2,3,4}\\nset to: 3,2,1,4: success:false {0,0,0,0}\\n"
    },
        "SkRegion_setRegion": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion& region) -> void {\n        auto r = region.getBounds();\n        SkDebugf(\"%14s: {%d,%d,%d,%d}\\n\", label, r.fLeft, r.fTop, r.fRight, r.fBottom);\n    };\n    SkRegion region({1, 2, 3, 4});\n    SkRegion region2;\n    region2.setRegion(region);\n    debugster(\"region bounds\", region);\n    debugster(\"region2 bounds\", region2);\n    region2.setEmpty();\n    SkDebugf(\"    after region set empty:\\n\");\n    debugster(\"region bounds\", region);\n    debugster(\"region2 bounds\", region2);\n}",
    "hash": "5d75d22bd155576838155762ab040751",
    "file": "SkRegion_Reference",
    "name": "SkRegion::setRegion",
        "stdout": "region bounds: {1,2,3,4}\\nregion2 bounds: {1,2,3,4}\\n    after region set empty:\\n region bounds: {1,2,3,4}\\nregion2 bounds: {0,0,0,0}\\n"
    },
        "SkRegion_swap": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* label, SkRegion& region) -> void {\n        auto r = region.getBounds();\n        SkDebugf(\"%14s: {%d,%d,%d,%d}\\n\", label, r.fLeft, r.fTop, r.fRight, r.fBottom);\n    };\n    SkRegion region1({1, 2, 3, 4});\n    SkRegion region2;\n    region1.swap(region2);\n    debugster(\"region1 bounds\", region1);\n    debugster(\"region2 bounds\", region2);\n}",
    "hash": "ae67b7b4c198b46c58e48f5af061c8f1",
    "file": "SkRegion_Reference",
    "name": "SkRegion::swap()",
        "stdout": "region1 bounds: {0,0,0,0}\\nregion2 bounds: {1,2,3,4}\\n"
    },
        "SkSurface_MakeNull": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"SkSurface::MakeNull(0, 0) %c= nullptr\\n\", SkSurface::MakeNull(0, 0) == nullptr ?\n             '=' : '!');\n    const int w = 37;\n    const int h = 1000;\n    auto surf = SkSurface::MakeNull(w, h);\n    auto nullCanvas = surf->getCanvas();\n    nullCanvas->drawPaint(SkPaint());   // does not crash, nothing draws\n    SkDebugf(\"surf->makeImageSnapshot() %c= nullptr\\n\", surf->makeImageSnapshot() == nullptr ?\n            '=' : '!');\n}",
    "hash": "99a54b814ccab7d2b1143c88581649ff",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeNull",
        "stdout": "SkSurface::MakeNull(0, 0) == nullptr\\nsurf->makeImageSnapshot() == nullptr\\n"
    },
        "SkSurface_MakeRaster": {
    "code": "void draw(SkCanvas* ) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(3, 3);\n    const size_t rowBytes = 64;\n    sk_sp<SkSurface> surface(SkSurface::MakeRaster(info, rowBytes, nullptr));\n    SkCanvas* canvas = surface->getCanvas();\n    canvas->clear(SK_ColorWHITE);\n    SkPixmap pixmap;\n    if (surface->peekPixels(&pixmap)) {\n        const uint32_t* colorPtr = pixmap.addr32();\n        SkPMColor pmWhite = colorPtr[0];\n        SkPaint paint;\n        canvas->drawPoint(1, 1, paint);\n        canvas->flush();  // ensure that point was drawn\n        for (int y = 0; y < info.height(); ++y) {\n            for (int x = 0; x < info.width(); ++x) {\n                SkDebugf(\"%c\", colorPtr[x] == pmWhite ? '-' : 'x');\n            }\n            colorPtr += rowBytes / sizeof(colorPtr[0]);\n            SkDebugf(\"\\n\");\n        }\n    }\n}\n",
    "hash": "a803910ada4f8733f0b62456afead55f",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRaster",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkSurface_MakeRasterDirect": {
    "code": "void draw(SkCanvas* ) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(3, 3);\n    const size_t size = info.computeMinByteSize();\n    SkAutoTMalloc<SkPMColor> storage(size);\n    SkPMColor* pixels = storage.get();\n    sk_sp<SkSurface> surface(SkSurface::MakeRasterDirect(info, pixels, info.minRowBytes()));\n    SkCanvas* canvas = surface->getCanvas();\n    canvas->clear(SK_ColorWHITE);\n    SkPMColor pmWhite = pixels[0];\n    SkPaint paint;\n    canvas->drawPoint(1, 1, paint);\n    canvas->flush();  // ensure that point was drawn\n    for (int y = 0; y < info.height(); ++y) {\n        for (int x = 0; x < info.width(); ++x) {\n            SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}\n",
    "hash": "3f5aeb870104187643197354a7f1d27a",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRasterDirect",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkSurface_MakeRasterDirectReleaseProc": {
    "code": "static void release_direct_surface_storage(void* pixels, void* context) {\n    if (pixels == context) {\n        SkDebugf(\"expected release context\\n\");\n    }\n    sk_free(pixels);\n}\n\nvoid draw(SkCanvas* ) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(3, 3);\n    const size_t rowBytes = info.minRowBytes();\n    void* pixels = sk_malloc_throw(info.computeByteSize(rowBytes));\n    sk_sp<SkSurface> surface(SkSurface::MakeRasterDirectReleaseProc(info, pixels, rowBytes,\n            release_direct_surface_storage, pixels));\n    SkCanvas* canvas = surface->getCanvas();\n    canvas->clear(SK_ColorWHITE);\n    SkPMColor* colorPtr = (SkPMColor*) pixels;\n    SkPMColor pmWhite = colorPtr[0];\n    SkPaint paint;\n    canvas->drawPoint(1, 1, paint);\n    canvas->flush();  // ensure that point was drawn\n    for (int y = 0; y < info.height(); ++y) {\n        for (int x = 0; x < info.width(); ++x) {\n            SkDebugf(\"%c\", *colorPtr++ == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}\n",
    "hash": "8e6530b26ab4096a9a91cfaadda1c568",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRasterDirectReleaseProc",
        "stdout": "---\\n-x-\\n---\\nexpected release context\\n"
    },
        "SkSurface_MakeRasterN32Premul": {
    "code": "void draw(SkCanvas* ) {\n    sk_sp<SkSurface> surface(SkSurface::MakeRasterN32Premul(3, 3));\n    SkCanvas* canvas = surface->getCanvas();\n    canvas->clear(SK_ColorWHITE);\n    SkPixmap pixmap;\n    if (surface->peekPixels(&pixmap)) {\n        const uint32_t* colorPtr = pixmap.addr32();\n        SkPMColor pmWhite = colorPtr[0];\n        SkPaint paint;\n        canvas->drawPoint(1, 1, paint);\n        canvas->flush();  // ensure that point was drawn\n        for (int y = 0; y < surface->height(); ++y) {\n            for (int x = 0; x < surface->width(); ++x) {\n                SkDebugf(\"%c\", colorPtr[x] == pmWhite ? '-' : 'x');\n            }\n            colorPtr += surface->width();\n            SkDebugf(\"\\n\");\n        }\n    }\n}\n",
    "hash": "b932a2bd68455fb0af2e7a1ed19e36b3",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRasterN32Premul",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkSurface_MakeRaster_2": {
    "code": "void draw(SkCanvas* ) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(3, 3);\n    sk_sp<SkSurface> surface(SkSurface::MakeRaster(info));\n    SkCanvas* canvas = surface->getCanvas();\n    canvas->clear(SK_ColorWHITE);\n    SkPixmap pixmap;\n    if (surface->peekPixels(&pixmap)) {\n        const uint32_t* colorPtr = pixmap.addr32();\n        SkPMColor pmWhite = colorPtr[0];\n        SkPaint paint;\n        canvas->drawPoint(1, 1, paint);\n        canvas->flush();  // ensure that point was drawn\n        for (int y = 0; y < info.height(); ++y) {\n            for (int x = 0; x < info.width(); ++x) {\n                SkDebugf(\"%c\", colorPtr[x] == pmWhite ? '-' : 'x');\n            }\n            colorPtr += info.width();\n            SkDebugf(\"\\n\");\n        }\n    }\n}\n",
    "hash": "c6197d204ef9e4ccfb583242651fb2a7",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRaster_2",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkSurface_generationID": {
    "code": "void draw(SkCanvas* canvas) {\n    auto surface = SkSurface::MakeRasterN32Premul(1, 1);\n    for (int i = 0; i < 3; ++i) {\n        SkDebugf(\"surface generationID: %d\\n\", surface->generationID());\n        if (0 == i) {\n            surface->getCanvas()->drawColor(SK_ColorBLACK);\n        } else {\n            surface->notifyContentWillChange(SkSurface::kDiscard_ContentChangeMode);\n        }\n    }\n}",
    "hash": "be9574c4a14f891e1abb4ec2b1e51d6c",
    "file": "SkSurface_Reference",
    "name": "SkSurface::generationID",
        "stdout": "surface generationID: 1\\nsurface generationID: 2\\nsurface generationID: 3\\n"
    },
        "SkSurface_height": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 37;\n    const int height = 1000;\n    auto surf = SkSurface::MakeNull(width, height);\n    auto nullCanvas = surf->getCanvas();\n    SkDebugf(\"surface height=%d  canvas height=%d\\n\", surf->height(),\n             nullCanvas->getBaseLayerSize().fHeight);\n}",
    "hash": "20571cc23e3146deaa09046b64cc0aef",
    "file": "SkSurface_Reference",
    "name": "SkSurface::height()",
        "stdout": "surface height=1000  canvas height=1000\\n"
    },
        "SkSurface_notifyContentWillChange": {
    "code": "void draw(SkCanvas* canvas) {\n    auto surface = SkSurface::MakeRasterN32Premul(1, 1);\n    for (int i = 0; i < 3; ++i) {\n        SkDebugf(\"surface generationID: %d\\n\", surface->generationID());\n        if (0 == i) {\n            surface->getCanvas()->drawColor(SK_ColorBLACK);\n        } else {\n            surface->notifyContentWillChange(SkSurface::kDiscard_ContentChangeMode);\n        }\n    }\n}",
    "hash": "be9574c4a14f891e1abb4ec2b1e51d6c",
    "file": "SkSurface_Reference",
    "name": "SkSurface::notifyContentWillChange",
        "stdout": "surface generationID: 1\\nsurface generationID: 2\\nsurface generationID: 3\\n"
    },
        "SkSurface_props": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* names[] = { \"Unknown\", \"RGB_H\", \"BGR_H\", \"RGB_V\", \"BGR_V\" };\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    SkDebugf(\"surf.props(): k%s_SkPixelGeometry\\n\", names[surf->props().pixelGeometry()]);\n}",
    "hash": "13cf9e7b2894ae6e98c1fd719040bf01",
    "file": "SkSurface_Reference",
    "name": "SkSurface::props()",
        "stdout": "surf.props(): kRGB_H_SkPixelGeometry\\n"
    },
        "SkSurface_width": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 37;\n    const int height = 1000;\n    auto surf = SkSurface::MakeNull(width, height);\n    auto nullCanvas = surf->getCanvas();\n    SkDebugf(\"surface width=%d  canvas width=%d\\n\", surf->width(),\n             nullCanvas->getBaseLayerSize().fWidth);\n}",
    "hash": "df066b56dd97c7c589fd2bb6a2539de8",
    "file": "SkSurface_Reference",
    "name": "SkSurface::width()",
        "stdout": "surface width=37  canvas width=37\\n"
    },
        "SkTextBlobBuilder_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkTextBlobBuilder builder;\n    sk_sp<SkTextBlob> blob = builder.make();\n    SkDebugf(\"blob \" \"%s\" \" nullptr\", blob == nullptr ? \"equals\" : \"does not equal\");\n}",
    "hash": "d9dbabfe24aad92ee3c8144513e90d81",
    "file": "SkTextBlobBuilder_Reference",
    "name": "SkTextBlobBuilder::SkTextBlobBuilder()",
        "stdout": "blob equals nullptr"
    },
        "SkTextBlobBuilder_make": {
    "code": "void draw(SkCanvas* canvas) {\n    SkTextBlobBuilder builder;\n    sk_sp<SkTextBlob> blob = builder.make();\n    SkDebugf(\"blob \" \"%s\" \" nullptr\\n\", blob == nullptr ? \"equals\" : \"does not equal\");\n    SkPaint paint;\n    paint.setTextEncoding(SkTextEncoding::kGlyphID);\n    SkFont font;\n    paint.textToGlyphs(\"x\", 1, builder.allocRun(font, 1, 20, 20).glyphs);\n    blob = builder.make();\n    SkDebugf(\"blob \" \"%s\" \" nullptr\\n\", blob == nullptr ? \"equals\" : \"does not equal\");\n    blob = builder.make();\n    SkDebugf(\"blob \" \"%s\" \" nullptr\\n\", blob == nullptr ? \"equals\" : \"does not equal\");\n}",
    "hash": "34c37c0212cc0aef670d96945d08fe24",
    "file": "SkTextBlobBuilder_Reference",
    "name": "SkTextBlobBuilder::make()",
        "stdout": "blob equals nullptr\\nblob does not equal nullptr\\nblob equals nullptr\\n"
    }
    }

    var pngs = {"Blend_Mode_Clear": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->saveLayer(nullptr, nullptr);\n    canvas->drawColor(SK_ColorYELLOW, SkBlendMode::kClear);\n    SkPaint paint;\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN } ) {\n        SkColor colors[] = { color, SkColorSetA(color, 0) }; \n        paint.setShader(SkGradientShader::MakeRadial({ 64, 64}, 100,\n                colors, nullptr, SK_ARRAY_COUNT(colors), SkShader::kClamp_TileMode));\n        canvas->drawCircle(64, 64, 100, paint);\n        canvas->translate(64, 64);\n    }\n    canvas->restore();\n}",
    "width": 256,
    "height": 256,
    "hash": "a9b56a26ca469bab9ab10e16f62fb2e2",
    "file": "SkBlendMode_Reference",
    "name": "Clear"
},
    "Blend_Mode_Color": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    canvas->drawColor(0xFF00FF00, SkBlendMode::kColor);\n}",
    "width": 256,
    "height": 256,
    "hash": "5d7c6e23a34ca9bf3ba8cda4cdc94cc4",
    "file": "SkBlendMode_Reference",
    "name": "Color"
},
    "Blend_Mode_Color_Burn": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    canvas->clipRect({128, 0, 256, 256});\n    canvas->drawColor(SkColorSetARGB(0x80, 0x90, 0x90, 0x90), SkBlendMode::kColorBurn);\n}",
    "width": 256,
    "height": 256,
    "hash": "3eeef529375d8083ae0d615789d55e89",
    "file": "SkBlendMode_Reference",
    "name": "Color_Burn"
},
    "Blend_Mode_Color_Dodge": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    canvas->clipRect({128, 0, 256, 256});\n    canvas->drawColor(SkColorSetARGB(0x80, 0x90, 0x90, 0x90), SkBlendMode::kColorDodge);\n}",
    "width": 256,
    "height": 256,
    "hash": "280ad6267a7d2d77b6d2c4531c6fc0bf",
    "file": "SkBlendMode_Reference",
    "name": "Color_Dodge"
},
    "Blend_Mode_Darken": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    SkColor colors[] = { SK_ColorWHITE, SK_ColorBLACK };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    paint.setBlendMode(SkBlendMode::kDarken);\n    canvas->drawPaint(paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "23c974d2759f523ca2f4a78ae86855c3",
    "file": "SkBlendMode_Reference",
    "name": "Darken"
},
    "Blend_Mode_Difference": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    canvas->drawImage(image, 128, 0);\n    canvas->drawImage(image, 0, 128);\n    canvas->drawImage(image, 128, 128);\n    SkPaint paint;\n    paint.setBlendMode(SkBlendMode::kDstATop);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(0x80bb9977, SkBlendMode::kDifference);\n}",
    "width": 256,
    "height": 256,
    "hash": "52d2c8d1b9b428de4477b4caa1543a3d",
    "file": "SkBlendMode_Reference",
    "name": "Difference"
},
    "Blend_Mode_Dst": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRSXform xforms[] = { { .5f, 0, 0, 0 }, {0, .5f, 125, 128 } };\n    SkRect tex[] = { { 0, 0, 250, 250 }, { 0, 0, 250, 250 } };\n    SkColor colors[] = { 0x7f55aa00, 0x7f3333bf };\n    canvas->drawAtlas(image.get(), xforms, tex, colors, 2, SkBlendMode::kSrc, nullptr, nullptr);\n    canvas->translate(128, 0);\n    canvas->drawAtlas(image.get(), xforms, tex, colors, 2, SkBlendMode::kDst, nullptr, nullptr);\n}",
    "width": 256,
    "height": 256,
    "hash": "35915a2273be1076f00f2e47998ce808",
    "file": "SkBlendMode_Reference",
    "name": "Dst"
},
    "Blend_Mode_Dst_Atop": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    paint.setBlendMode(SkBlendMode::kDstATop);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(SkColorSetA(SK_ColorGREEN, 128), SkBlendMode::kSrcATop);\n}",
    "width": 256,
    "height": 256,
    "hash": "1955856d45773a4fd914fcc1f813222f",
    "file": "SkBlendMode_Reference",
    "name": "Dst_Atop"
},
    "Blend_Mode_Dst_In": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    paint.setBlendMode(SkBlendMode::kDstIn);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(SkColorSetA(SK_ColorGREEN, 128), SkBlendMode::kDstIn);\n}",
    "width": 256,
    "height": 256,
    "hash": "a5eeba05ccf6097a5d110a9d64f97c25",
    "file": "SkBlendMode_Reference",
    "name": "Dst_In"
},
    "Blend_Mode_Dst_Out": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    paint.setBlendMode(SkBlendMode::kDstIn);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(SkColorSetA(SK_ColorGREEN, 128), SkBlendMode::kDstOut);\n}",
    "width": 256,
    "height": 256,
    "hash": "b9a894c9accfc5d94081bbd77d5d790a",
    "file": "SkBlendMode_Reference",
    "name": "Dst_Out"
},
    "Blend_Mode_Dst_Over": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    paint.setBlendMode(SkBlendMode::kDstIn);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(SkColorSetA(SK_ColorGREEN, 128), SkBlendMode::kDstOver);\n}",
    "width": 256,
    "height": 256,
    "hash": "10dbb4d97902956ef5f5f8562f65119e",
    "file": "SkBlendMode_Reference",
    "name": "Dst_Over"
},
    "Blend_Mode_Exclusion": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    canvas->drawImage(image, 128, 0);\n    canvas->drawImage(image, 0, 128);\n    canvas->drawImage(image, 128, 128);\n    SkPaint paint;\n    paint.setBlendMode(SkBlendMode::kDstATop);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(0x80bb9977, SkBlendMode::kExclusion);\n}",
    "width": 256,
    "height": 256,
    "hash": "a544ee1c67c7c557a9e54d5e99f94bb6",
    "file": "SkBlendMode_Reference",
    "name": "Exclusion"
},
    "Blend_Mode_Hard_Light": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    const SkColor colors[] = { 0xFFFFFFFF, 0x00000000 };\n    SkPaint paint;\n    paint.setBlendMode(SkBlendMode::kHardLight);\n    paint.setShader(SkGradientShader::MakeRadial({ 128, 128}, 100, colors,\n         nullptr, SK_ARRAY_COUNT(colors), SkShader::kClamp_TileMode));\n    canvas->clipRect({0, 128, 256, 256});\n    canvas->drawPaint(paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "ac2fe555e2196e15863ea4ce74db3d54",
    "file": "SkBlendMode_Reference",
    "name": "Hard_Light"
},
    "Blend_Mode_Hue": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    canvas->drawColor(0xFF00FF00, SkBlendMode::kHue);\n}",
    "width": 256,
    "height": 256,
    "hash": "41e45570d682397d3b8ff2f51bd9c574",
    "file": "SkBlendMode_Reference",
    "name": "Hue"
},
    "Blend_Mode_Lighten": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    SkColor colors[] = { SK_ColorBLACK, SK_ColorWHITE };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    paint.setBlendMode(SkBlendMode::kLighten);\n    canvas->drawPaint(paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "95cb08b8c8db3af3b2c9ad56ae7d6bc1",
    "file": "SkBlendMode_Reference",
    "name": "Lighten"
},
    "Blend_Mode_Luminosity": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    canvas->drawColor(0xFF00FF00, SkBlendMode::kLuminosity);\n}",
    "width": 256,
    "height": 256,
    "hash": "7d42fe34ae20dd9e12c39dc3950e9989",
    "file": "SkBlendMode_Reference",
    "name": "Luminosity"
},
    "Blend_Mode_Modulate": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawSquare = [=](int dx, int dy, SkBlendMode mode, const char* label) -> void {\n        const SkColor colors[] = { SK_ColorBLACK, SK_ColorWHITE };\n        const SkPoint horz[] = { { 0, 0 }, { 128, 0 } };\n        SkPaint paint;\n        paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n                SkShader::kClamp_TileMode));\n        paint.setBlendMode(mode);\n        canvas->translate(dx, dy);\n        canvas->drawRect({0, 0, 128, 128}, paint);\n        paint.setBlendMode(SkBlendMode::kXor);\n        canvas->drawString(label, 40, 100, paint);\n    };\n    drawSquare(0, 0, SkBlendMode::kSrc, \"destination\");\n    drawSquare(128, 0, SkBlendMode::kSrc, \"\");\n    drawSquare(0, 128, SkBlendMode::kSrc, \"\");\n    canvas->translate(-128, -128);\n    canvas->rotate(90, 0, 128);\n    drawSquare(0, 0, SkBlendMode::kSrc, \"source\");\n    drawSquare(0, -128, SkBlendMode::kModulate, \"modulate\");\n    drawSquare(-128, 0, SkBlendMode::kMultiply, \"multiply\");\n}",
    "width": 256,
    "height": 256,
    "hash": "3fdac2b2f48bd227d2e74234c260bc8e",
    "file": "SkBlendMode_Reference",
    "name": "Modulate"
},
    "Blend_Mode_Multiply": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    canvas->drawImage(image, 128, 0);\n    canvas->drawImage(image, 0, 128);\n    canvas->drawImage(image, 128, 128);\n    SkPaint paint;\n    paint.setBlendMode(SkBlendMode::kDstATop);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(0x80bb9977, SkBlendMode::kMultiply);\n}",
    "width": 256,
    "height": 256,
    "hash": "eb29c896f008dfbef09e16b85114fc3a",
    "file": "SkBlendMode_Reference",
    "name": "Multiply"
},
    "Blend_Mode_Overlay": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    paint.setBlendMode(SkBlendMode::kDstATop);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(SkColorSetA(SK_ColorGREEN, 128), SkBlendMode::kOverlay);\n}",
    "width": 256,
    "height": 256,
    "hash": "03bf042201de02d6d131938ccd3172eb",
    "file": "SkBlendMode_Reference",
    "name": "Overlay"
},
    "Blend_Mode_Plus": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawColor(SK_ColorBLACK);\n    SkPaint paint;\n    paint.setBlendMode(SkBlendMode::kPlus);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN } ) {\n        SkColor colors[] = { color, SkColorSetA(color, 192), SkColorSetA(color, 128),\n                             SkColorSetA(color, 0) }; \n        paint.setShader(SkGradientShader::MakeRadial({ 64, 64}, 100,\n                colors, nullptr, SK_ARRAY_COUNT(colors), SkShader::kClamp_TileMode));\n        canvas->drawCircle(64, 64, 100, paint);\n        canvas->translate(64, 64);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "05383441e510d54008402e128fc8ad2b",
    "file": "SkBlendMode_Reference",
    "name": "Plus"
},
    "Blend_Mode_Saturation": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    canvas->drawColor(0xFF00FF00, SkBlendMode::kSaturation);\n}",
    "width": 256,
    "height": 256,
    "hash": "a48698975d236573cef512f94a7e360b",
    "file": "SkBlendMode_Reference",
    "name": "Saturation"
},
    "Blend_Mode_Screen": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    paint.setBlendMode(SkBlendMode::kDstATop);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(SkColorSetA(SK_ColorGREEN, 128), SkBlendMode::kScreen);\n}",
    "width": 256,
    "height": 256,
    "hash": "b7b42965927788d853f449f08ddf46de",
    "file": "SkBlendMode_Reference",
    "name": "Screen"
},
    "Blend_Mode_Soft_Light": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkColor colors[] = { 0xFFFFFFFF, 0x3FFFFFFF };\n    SkPaint paint;\n    paint.setBlendMode(SkBlendMode::kSoftLight);\n    paint.setShader(SkGradientShader::MakeRadial({ 128, 128}, 100, colors,\n         nullptr, SK_ARRAY_COUNT(colors), SkShader::kClamp_TileMode));\n    canvas->drawImage(image, 0, 0);\n    canvas->drawCircle(128, 128, 100, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "ac93f30dff13f8a8bb31398de370863b",
    "file": "SkBlendMode_Reference",
    "name": "Soft_Light"
},
    "Blend_Mode_Src": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawImage(image, 0, 0);\n    canvas->clipRect({50, 50, 200, 200});\n    SkPaint srcBlend;\n    srcBlend.setBlendMode(SkBlendMode::kSrc);\n    canvas->saveLayer(nullptr, &srcBlend);\n    canvas->drawColor(0);\n    SkPaint transRed;\n    transRed.setColor(SkColorSetA(SK_ColorRED, 127));\n    canvas->drawCircle(125, 125, 75, transRed);\n    canvas->restore();\n}",
    "width": 256,
    "height": 256,
    "hash": "0fc85dd916cc1a5896d36c80b9847391",
    "file": "SkBlendMode_Reference",
    "name": "Src"
},
    "Blend_Mode_Src_Atop": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    paint.setBlendMode(SkBlendMode::kDstIn);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(SkColorSetA(SK_ColorGREEN, 128), SkBlendMode::kSrcATop);\n}",
    "width": 256,
    "height": 256,
    "hash": "a13148977bfc985934a92752c83a2041",
    "file": "SkBlendMode_Reference",
    "name": "Src_Atop"
},
    "Blend_Mode_Src_In": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    paint.setBlendMode(SkBlendMode::kDstIn);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(SkColorSetA(SK_ColorGREEN, 128), SkBlendMode::kSrcIn);\n}",
    "width": 256,
    "height": 256,
    "hash": "b0833c18fe8b0eeaab9bd6d2160d272f",
    "file": "SkBlendMode_Reference",
    "name": "Src_In"
},
    "Blend_Mode_Src_Out": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    paint.setBlendMode(SkBlendMode::kDstIn);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(SkColorSetA(SK_ColorGREEN, 128), SkBlendMode::kSrcOut);\n}",
    "width": 256,
    "height": 256,
    "hash": "ccc1e74226e0c9eacbc21f1eed017b84",
    "file": "SkBlendMode_Reference",
    "name": "Src_Out"
},
    "Blend_Mode_Src_Over": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE };\n    SkPoint horz[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(horz, colors, nullptr, SK_ARRAY_COUNT(colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    paint.setBlendMode(SkBlendMode::kDstIn);\n    SkColor alphas[] = { SK_ColorBLACK, SK_ColorTRANSPARENT };\n    SkPoint vert[] = { { 0, 0 }, { 0, 256 } };\n    paint.setShader(SkGradientShader::MakeLinear(vert, alphas, nullptr, SK_ARRAY_COUNT(alphas),\n            SkShader::kClamp_TileMode));\n    canvas->drawPaint(paint);\n    canvas->clipRect( { 30, 30, 226, 226 } );\n    canvas->drawColor(SkColorSetA(SK_ColorGREEN, 128), SkBlendMode::kSrcOver);\n}",
    "width": 256,
    "height": 256,
    "hash": "2ea9c149964a06cdb4929158cb4f15f8",
    "file": "SkBlendMode_Reference",
    "name": "Src_Over"
},
    "Blend_Mode_Xor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setBlendMode(SkBlendMode::kXor);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN } ) {\n        SkColor colors[] = { color, SkColorSetA(color, 192), SkColorSetA(color, 128),\n                             SkColorSetA(color, 0) }; \n        paint.setShader(SkGradientShader::MakeRadial({ 64, 64}, 100,\n                colors, nullptr, SK_ARRAY_COUNT(colors), SkShader::kClamp_TileMode));\n        canvas->drawCircle(64, 64, 100, paint);\n        canvas->translate(64, 64);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "29db2c7493d9098b8a086ddbe30dd6d6",
    "file": "SkBlendMode_Reference",
    "name": "Xor"
},
    "Canvas_Clip": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint redPaint, scalePaint;\n    redPaint.setAntiAlias(true);\n    redPaint.setColor(SK_ColorRED);\n    canvas->save();\n    for (bool antialias : { false, true } ) {\n        canvas->save();\n        canvas->clipRect(SkRect::MakeWH(19.5f, 11.5f), antialias);\n        canvas->drawCircle(17, 11, 8, redPaint);\n        canvas->restore();\n        canvas->translate(16, 0);\n    }\n    canvas->restore();\n    SkMatrix matrix;\n    matrix.setScale(6, 6);\n    scalePaint.setImageFilter(\n            SkImageFilter::MakeMatrixFilter(matrix, kNone_SkFilterQuality, nullptr));\n    SkCanvas::SaveLayerRec saveLayerRec(\n            nullptr, &scalePaint, SkCanvas::kInitWithPrevious_SaveLayerFlag);\n    canvas->saveLayer(saveLayerRec);\n    canvas->restore();\n}",
    "width": 256,
    "height": 90,
    "hash": "862cc026601a41a58df49c0b9f0d7777",
    "file": "SkCanvas_Reference",
    "name": "Clip"
},
    "Canvas_State_Stack": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->save();                             // records stack depth to restore\n    canvas->clipRect(SkRect::MakeWH(100, 100)); // constrains drawing to clip\n    canvas->clear(SK_ColorRED);                 // draws to limit of clip\n    canvas->save();                             // records stack depth to restore\n    canvas->clipRect(SkRect::MakeWH(50, 150));  // Rect below 100 is ignored\n    canvas->clear(SK_ColorBLUE);                // draws to smaller clip\n    canvas->restore();                          // enlarges clip\n    canvas->drawLine(20, 20, 150, 150, paint);  // line below 100 is not drawn\n    canvas->restore();                          // enlarges clip\n    canvas->drawLine(150, 20, 50, 120, paint);  // line below 100 is drawn\n}\n",
    "width": 256,
    "height": 160,
    "hash": "bb1dbfdca3aedf716beb6f07e2aab065",
    "file": "SkCanvas_Reference",
    "name": "State_Stack"
},
    "Canvas_State_Stack_a": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clipRect(SkRect::MakeWH(100, 100));\n    canvas->clear(SK_ColorRED);\n    canvas->scale(.5, .5);\n    canvas->clipRect(SkRect::MakeWH(100, 100));\n    canvas->clear(SK_ColorBLUE);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "9f563a2d60aa31d4b26742e5aa17aa4e",
    "file": "SkCanvas_Reference",
    "name": "State_Stack_2"
},
    "Color_Alpha_Constants": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    srcPixels.resize(source.height() * source.rowBytes());\n    SkPixmap pixmap(SkImageInfo::MakeN32Premul(source.width(), source.height()),\n                    &srcPixels.front(), source.rowBytes());\n    source.readPixels(pixmap, 0, 0);\n    for (int y = 0; y < 16; ++y) {\n        for (int x = 0; x < 16; ++x) {\n            int32_t* blockStart = &srcPixels.front() + y * source.width() * 16 + x * 16;\n            size_t transparentCount = 0;\n            for (int fillY = 0; fillY < source.height() / 16; ++fillY) {\n                for (int fillX = 0; fillX < source.width() / 16; ++fillX) {\n                    const SkColor color = SkUnPreMultiply::PMColorToColor(blockStart[fillX]);\n                    transparentCount += SkColorGetA(color) == SK_AlphaTRANSPARENT;\n                }\n                blockStart += source.width();\n            }\n            if (transparentCount > 200) {\n                blockStart = &srcPixels.front() + y * source.width() * 16 + x * 16;\n                for (int fillY = 0; fillY < source.height() / 16; ++fillY) {\n                    for (int fillX = 0; fillX < source.width() / 16; ++fillX) {\n                        blockStart[fillX] = SK_ColorRED;\n                    }\n                    blockStart += source.width();\n                }\n            }\n        }\n    }\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 128,
    "hash": "bc9c7ea424d10bbcd1e5a88770d4794e",
    "file": "SkColor_Reference",
    "name": "Alpha_Constants"
},
    "Color_Alpha_Constants_a": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    srcPixels.resize(source.height() * source.rowBytes());\n    SkPixmap pixmap(SkImageInfo::MakeN32Premul(source.width(), source.height()),\n                    &srcPixels.front(), source.rowBytes());\n    source.readPixels(pixmap, 0, 0);\n    for (int y = 0; y < source.height(); ++y) {\n        for (int x = 0; x < source.width(); ++x) {\n            SkPMColor pixel = srcPixels[y * source.width() + x];\n            const SkColor color = SkUnPreMultiply::PMColorToColor(pixel);\n            if (SkColorGetA(color) == SK_AlphaOPAQUE) {\n                srcPixels[y * source.width() + x] = SK_ColorGREEN;\n            }\n        }\n    }\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 128,
    "hash": "0424f67ebc2858e8fd04ae3367b115ff",
    "file": "SkColor_Reference",
    "name": "Alpha_Constants_2"
},
    "Color_Color_Constants": {
    "code": "#define SKIA_COLOR_PAIR(name) \"SK_Color\" #name, SK_Color##name\n\nvoid draw(SkCanvas* canvas) {\n    struct ColorCompare {\n        const char* fSVGName;\n        SkColor fSVGColor;\n        const char* fSkiaName;\n        SkColor fSkiaColor;\n    } colorCompare[] = {  // see https://www.w3.org/TR/SVG/types.html#ColorKeywords\n        {\"black\",     SkColorSetRGB(  0,   0,   0),    SKIA_COLOR_PAIR(BLACK) },\n        {\"darkgray\",  SkColorSetRGB(169, 169, 169),    SKIA_COLOR_PAIR(DKGRAY) },\n        {\"gray\",      SkColorSetRGB(128, 128, 128),    SKIA_COLOR_PAIR(GRAY) },\n        {\"lightgray\", SkColorSetRGB(211, 211, 211),    SKIA_COLOR_PAIR(LTGRAY) },\n        {\"white\",     SkColorSetRGB(255, 255, 255),    SKIA_COLOR_PAIR(WHITE) },\n        {\"red\",       SkColorSetRGB(255,   0,   0),    SKIA_COLOR_PAIR(RED) },\n        {\"green\",     SkColorSetRGB(  0, 128,   0),    SKIA_COLOR_PAIR(GREEN) },\n        {\"blue\",      SkColorSetRGB(  0,   0, 255),    SKIA_COLOR_PAIR(BLUE) },\n        {\"yellow\",    SkColorSetRGB(255, 255,   0),    SKIA_COLOR_PAIR(YELLOW) },\n        {\"aqua\",      SkColorSetRGB(  0, 255, 255),    SKIA_COLOR_PAIR(CYAN) },\n        {\"fuchsia\",   SkColorSetRGB(255,   0, 255),    SKIA_COLOR_PAIR(MAGENTA) },\n    };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(14);\n    for (auto compare : colorCompare) {\n        paint.setStyle(SkPaint::kFill_Style);\n        paint.setColor(compare.fSVGColor);\n        canvas->drawRect({5, 5, 15, 15}, paint);\n        paint.setColor(SK_ColorBLACK);\n        canvas->drawString(compare.fSVGName, 20, 16, paint);\n        paint.setColor(compare.fSkiaColor);\n        canvas->drawRect({105, 5, 115, 15}, paint);\n        paint.setColor(SK_ColorBLACK);\n        canvas->drawString(compare.fSkiaName, 120, 16, paint);\n        paint.setStyle(SkPaint::kStroke_Style);\n        canvas->drawRect({5, 5, 15, 15}, paint);\n        canvas->drawRect({105, 5, 115, 15}, paint);\n        canvas->translate(0, 20);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "1c2e38321464818847f953ddd45cb5a1",
    "file": "SkColor_Reference",
    "name": "Color_Constants"
},
    "Color_Color_Constants_a": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<uint32_t> srcPixels;\n    constexpr int width = 256;\n    constexpr int height = 256;\n    srcPixels.resize(width * height);\n    SkImageInfo imageInfo = SkImageInfo::MakeN32Premul(width, height);\n    SkPixmap pixmap(imageInfo, &srcPixels.front(), imageInfo.minRowBytes());\n    pixmap.erase(SK_ColorTRANSPARENT);\n    pixmap.erase(SK_ColorRED, { 24, 24, 192, 192 } );\n    pixmap.erase(SK_ColorTRANSPARENT, { 48, 48, 168, 168 } );\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n    canvas->drawBitmap(bitmap, 48, 48);\n}",
    "width": 256,
    "height": 256,
    "hash": "9ca1e2a5b9b4c92ecf4409d0813867d6",
    "file": "SkColor_Reference",
    "name": "Color_Constants_2"
},
    "Color_Color_Constants_b": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<uint32_t> srcPixels;\n    constexpr int width = 256;\n    constexpr int height = 256;\n    srcPixels.resize(width * height);\n    SkImageInfo imageInfo = SkImageInfo::MakeN32Premul(width, height);\n    SkPixmap pixmap(imageInfo, &srcPixels.front(), imageInfo.minRowBytes());\n    pixmap.erase(SK_ColorTRANSPARENT);\n    pixmap.erase(SK_ColorRED, { 24, 24, 192, 192 } );\n    pixmap.erase(SK_ColorBLACK, { 48, 48, 168, 168 } );\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n    canvas->drawBitmap(bitmap, 48, 48);\n}",
    "width": 256,
    "height": 256,
    "hash": "6971489f28291f08e429cc6ccc73b09b",
    "file": "SkColor_Reference",
    "name": "Color_Constants_3"
},
    "Color_Color_Constants_c": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<uint32_t> srcPixels;\n    constexpr int width = 256;\n    constexpr int height = 256;\n    srcPixels.resize(width * height);\n    SkImageInfo imageInfo = SkImageInfo::MakeN32Premul(width, height);\n    SkPixmap pixmap(imageInfo, &srcPixels.front(), imageInfo.minRowBytes());\n    pixmap.erase(SK_ColorTRANSPARENT);\n    pixmap.erase(SK_ColorRED, { 24, 24, 192, 192 } );\n    pixmap.erase(SK_ColorWHITE, { 48, 48, 168, 168 } );\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n    canvas->drawBitmap(bitmap, 48, 48);\n}",
    "width": 256,
    "height": 256,
    "hash": "fce650f997e802d4e55edf62b8437a2d",
    "file": "SkColor_Reference",
    "name": "Color_Constants_4"
},
    "Illustrations_Blend_Mode_Overview_Color_Blends": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    SkPaint srcPaint;\n    srcPaint.setAntiAlias(true);\n    SkPaint labelPaint = srcPaint;\n    labelPaint.setTextSize(16);\n    SkPaint dstPaint = labelPaint;\n    dstPaint.setTextSize(80);\n    dstPaint.setColor(0xFF606080);\n    dstPaint.setTypeface(SkTypeface::MakeFromName(\"Roboto\", SkFontStyle::Bold()));\n    srcPaint.setColor(0xFFcc6633);\n    SkPath srcPath;\n    const SkPoint points[] = {{20, 20}, {80, 45}, {45, 80}};\n    srcPath.addPoly(points, SK_ARRAY_COUNT(points), true);\n    canvas->drawColor(0, SkBlendMode::kClear);\n    for (auto blend : { SkBlendMode::kHue, SkBlendMode::kSaturation, SkBlendMode::kColor,\n                        SkBlendMode::kLuminosity } ) {\n        SkTextUtils::DrawString(canvas, \"&\", 50, 80, dstPaint, SkTextUtils::kCenter_Align);\n        srcPaint.setBlendMode(blend);\n        canvas->drawPath(srcPath, srcPaint);\n        SkTextUtils::DrawString(canvas, SkBlendMode_Name(blend), 50, 100, labelPaint,\n                SkTextUtils::kCenter_Align);\n        canvas->translate(90, 0);\n    }\n}\n",
    "width": 480,
    "height": 110,
    "hash": "630fe21aea8369b307231f5bcf8b2d50",
    "file": "illustrations",
    "name": "Blend_Mode_Overview_Color_Blends"
},
    "Illustrations_Blend_Mode_Overview_Lighten_Darken": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    SkPaint srcPaint;\n    srcPaint.setAntiAlias(true);\n    SkPaint labelPaint = srcPaint;\n    labelPaint.setTextSize(16);\n    SkPaint dstPaint = labelPaint;\n    dstPaint.setTextSize(80);\n    dstPaint.setColor(0xFF606080);\n    dstPaint.setTypeface(SkTypeface::MakeFromName(\"Roboto\", SkFontStyle::Bold()));\n    srcPaint.setColor(0xFFcc6633);\n    SkPath srcPath;\n    const SkPoint points[] = {{20, 20}, {80, 45}, {45, 80}};\n    srcPath.addPoly(points, SK_ARRAY_COUNT(points), true);\n    canvas->drawColor(0, SkBlendMode::kClear);\n    for (auto blend : { SkBlendMode::kPlus, SkBlendMode::kScreen, SkBlendMode::kOverlay,\n            SkBlendMode::kDarken, SkBlendMode::kLighten, SkBlendMode::kColorDodge,\n            SkBlendMode::kColorBurn, SkBlendMode::kHardLight, SkBlendMode::kSoftLight,\n            SkBlendMode::kDifference, SkBlendMode::kExclusion, SkBlendMode::kMultiply } ) {\n        SkTextUtils::DrawString(canvas, \"&\", 50, 80, dstPaint, SkTextUtils::kCenter_Align);\n        srcPaint.setBlendMode(blend);\n        canvas->drawPath(srcPath, srcPaint);\n        SkTextUtils::DrawString(canvas, SkBlendMode_Name(blend), 50, 100, labelPaint, SkTextUtils::kCenter_Align);\n        canvas->translate(90, 0);\n        if (SkBlendMode::kLighten == blend || SkBlendMode::kDifference == blend) {\n            canvas->translate(-90 * 5, 100);\n        }\n    }\n}\n",
    "width": 480,
    "height": 330,
    "hash": "23a33fa04cdd0204b2490d05e340f87c",
    "file": "illustrations",
    "name": "Blend_Mode_Overview_Lighten_Darken"
},
    "Illustrations_Blend_Mode_Overview_Modulate_Blend": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    SkPaint srcPaint;\n    srcPaint.setAntiAlias(true);\n    SkPaint labelPaint = srcPaint;\n    labelPaint.setTextSize(16);\n    SkPaint dstPaint = labelPaint;\n    dstPaint.setTextSize(80);\n    dstPaint.setColor(0xFF606080);\n    dstPaint.setTypeface(SkTypeface::MakeFromName(\"Roboto\", SkFontStyle::Bold()));\n    SkBitmap srcBits;\n    srcBits.allocN32Pixels(80, 84);\n    SkCanvas srcCanvas(srcBits);\n    srcPaint.setColor(0xFFcc6633);\n    SkPath srcPath;\n    const SkPoint points[] = {{20, 20}, {80, 45}, {45, 80}};\n    srcPath.addPoly(points, SK_ARRAY_COUNT(points), true);\n    srcBits.eraseColor(0);\n    srcCanvas.drawPath(srcPath, srcPaint);\n    canvas->drawColor(0, SkBlendMode::kClear);\n    srcPaint.setBlendMode(SkBlendMode::kModulate);\n    for (auto step: { 1, 2 } ) {\n        SkTextUtils::DrawString(canvas, \"&\", 50, 80, dstPaint, SkTextUtils::kCenter_Align);\n        if (1 == step) {\n            canvas->drawBitmap(srcBits, 0, 0, &srcPaint);\n            SkTextUtils::DrawString(canvas, \"Bitmap\", 50, 18, labelPaint, SkTextUtils::kCenter_Align);\n        } else {\n            canvas->drawPath(srcPath, srcPaint);\n            SkTextUtils::DrawString(canvas, \"Geometry\", 50, 18, labelPaint, SkTextUtils::kCenter_Align);\n        }\n        SkTextUtils::DrawString(canvas, SkBlendMode_Name(SkBlendMode::kModulate), 50, 100, labelPaint,\n                SkTextUtils::kCenter_Align);\n        canvas->translate(120, 0);\n    }\n}\n",
    "width": 480,
    "height": 110,
    "hash": "877f96610ab7638a310432674b04f837",
    "file": "illustrations",
    "name": "Blend_Mode_Overview_Modulate_Blend"
},
    "Illustrations_Blend_Mode_Overview_Porter_Duff": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    SkPaint srcPaint;\n    srcPaint.setAntiAlias(true);\n    SkPaint labelPaint = srcPaint;\n    labelPaint.setTextSize(16);\n    SkPaint dstPaint = labelPaint;\n    dstPaint.setTextSize(80);\n    dstPaint.setColor(0xFF606080);\n    dstPaint.setTypeface(SkTypeface::MakeFromName(\"Roboto\", SkFontStyle::Bold()));\n    SkBitmap srcBits;\n    srcBits.allocN32Pixels(80, 84);\n    SkCanvas srcCanvas(srcBits);\n    srcPaint.setColor(0xFFcc6633);\n    SkPath srcPath;\n    const SkPoint points[] = {{20, 20}, {80, 45}, {45, 80}};\n    srcPath.addPoly(points, SK_ARRAY_COUNT(points), true);\n    srcBits.eraseColor(0);\n    srcCanvas.drawPath(srcPath, srcPaint);\n    canvas->drawColor(0, SkBlendMode::kClear);\n    for (auto blend : { SkBlendMode::kSrc, SkBlendMode::kSrcATop, SkBlendMode::kSrcOver,\n                        SkBlendMode::kSrcIn, SkBlendMode::kSrcOut,\n                        SkBlendMode::kDst, SkBlendMode::kDstATop, SkBlendMode::kDstOver,\n                        SkBlendMode::kDstIn, SkBlendMode::kDstOut,\n                        SkBlendMode::kClear, SkBlendMode::kXor } ) {\n        SkTextUtils::DrawString(canvas, \"&\", 50, 80, dstPaint, SkTextUtils::kCenter_Align);\n        srcPaint.setBlendMode(blend);\n        canvas->drawBitmap(srcBits, 0, 0, &srcPaint);\n        SkTextUtils::DrawString(canvas, SkBlendMode_Name(blend), 50, 100, labelPaint, SkTextUtils::kCenter_Align);\n        canvas->translate(80, 0);\n        if (SkBlendMode::kSrcOut == blend || SkBlendMode::kDstOut == blend) {\n            canvas->translate(-80 * 5, 100);\n        }\n    }\n}\n",
    "width": 480,
    "height": 330,
    "hash": "819903e0bb125385269948474b6c8a84",
    "file": "illustrations",
    "name": "Blend_Mode_Overview_Porter_Duff"
},
    "Illustrations_Blend_Mode_Overview_Porter_Duff_2": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    SkPaint srcPaint;\n    srcPaint.setAntiAlias(true);\n    SkPaint labelPaint = srcPaint;\n    labelPaint.setTextSize(16);\n    SkPaint dstPaint = labelPaint;\n    dstPaint.setTextSize(80);\n    dstPaint.setColor(0xFF606080);\n    dstPaint.setTypeface(SkTypeface::MakeFromName(\"Roboto\", SkFontStyle::Bold()));\n    srcPaint.setColor(0xFFcc6633);\n    SkPath srcPath;\n    const SkPoint points[] = {{20, 20}, {80, 45}, {45, 80}};\n    srcPath.addPoly(points, SK_ARRAY_COUNT(points), true);\n    canvas->drawColor(0, SkBlendMode::kClear);\n    SkBitmap dstBits;\n    dstBits.allocN32Pixels(80, 80);\n    SkCanvas dstCanvas(dstBits);\n    for (auto blend : { SkBlendMode::kSrc, SkBlendMode::kSrcATop, SkBlendMode::kSrcOver,\n                        SkBlendMode::kSrcIn, SkBlendMode::kSrcOut,\n                        SkBlendMode::kDst, SkBlendMode::kDstATop, SkBlendMode::kDstOver,\n                        SkBlendMode::kDstIn, SkBlendMode::kDstOut,\n                        SkBlendMode::kClear, SkBlendMode::kXor } ) {\n        SkTextUtils::DrawString(canvas, \"&\", 50, 80, dstPaint, SkTextUtils::kCenter_Align);\n        srcPaint.setBlendMode(blend);\n        canvas->drawPath(srcPath, srcPaint);\n        SkTextUtils::DrawString(canvas, SkBlendMode_Name(blend), 50, 100, labelPaint, SkTextUtils::kCenter_Align);\n        canvas->translate(80, 0);\n        if (SkBlendMode::kSrcOut == blend || SkBlendMode::kDstOut == blend) {\n            canvas->translate(-80 * 5, 100);\n        }\n    }\n}\n",
    "width": 480,
    "height": 330,
    "hash": "8f320c1e94e77046e00f7e9e843caa27",
    "file": "illustrations",
    "name": "Blend_Mode_Overview_Porter_Duff_2"
},
    "Illustrations_Image_Info_Color_Type_ARGB_4444": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    canvas->scale(1.25f, 1.25f);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    SkTextUtils::DrawString(canvas, \"16-bit word\", 5 + 20 * 8, 20, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"little endian byte order\", 5 + 20 * 4, 85, paint, SkTextUtils::kCenter_Align);\n    auto drawBoxText = [=](SkScalar e[], const char* s[], int count, int n, SkScalar yPos) -> void {\n        SkPaint p(paint);\n        p.setColor(SK_ColorRED);\n        SkScalar xPos = 15;\n        int width = n % 32 + 1;\n        int lastN = n > 32 ? 32 : 0;\n        for (; n >= lastN; --n) {\n            for (int i = 0; i <= count; ++i) {\n                int a = width - e[i];\n                if (a == n || a == n + 1 || a == n - 32 || a == n - 31) {\n                    char num[3] = {(char) ('0' + n / 10), (char) ('0' + n % 10), '\\0'};\n                    SkTextUtils::DrawString(canvas, n >= 10 ? num : &num[1], xPos, yPos - 5, p, SkTextUtils::kCenter_Align);\n                    break;\n                }\n            }\n            xPos += 20;\n        }\n        p.setColor(SK_ColorBLACK);\n        for (int i = 0; i < count; ++i) {\n            SkTextUtils::DrawString(canvas, s[i], 5 + (e[i] + e[i + 1]) * 10, yPos + 10, p, SkTextUtils::kCenter_Align);\n        }\n        p.setStyle(SkPaint::kStroke_Style);\n        for (int i = 0; i <= count; ++i) {\n            canvas->drawLine(5 + e[i] * 20, yPos, 5 + e[i] * 20, yPos + 15, p);\n        }\n        for (int i = 0; i < 2; ++i) {\n            canvas->drawLine(5 + e[0] * 20, yPos + i * 15, 5 + e[count] * 20, yPos + i * 15, p);\n        }\n    };\n    SkScalar edges[] = { 0, 4, 8, 12, 16 };\n    const char* labels[] = { \"red\", \"green\", \"blue\", \"alpha\" };\n    drawBoxText(&edges[0], &labels[0], 4, 15, 45);\n    drawBoxText(&edges[0], &labels[2], 2, 7, 110);\n    drawBoxText(&edges[0], &labels[0], 2, 7, 160);\n}\n",
    "width": 415,
    "height": 250,
    "hash": "e8008512f0d197051e3f26faa67bafc2",
    "file": "illustrations",
    "name": "Image_Info_Color_Type_ARGB_4444"
},
    "Illustrations_Image_Info_Color_Type_BGRA_8888": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    canvas->scale(1.25f, 1.25f);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    SkTextUtils::DrawString(canvas, \"32-bit word\", 5 + 20 * 16, 20, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"little endian byte order\", 5 + 20 * 4, 85, paint, SkTextUtils::kCenter_Align);\n    auto drawBoxText = [=](SkScalar e[], const char* s[], int count, int n, SkScalar yPos) -> void {\n        SkPaint p(paint);\n        p.setColor(SK_ColorRED);\n        SkScalar xPos = 15;\n        int width = n % 32 + 1;\n        int lastN = n > 32 ? 32 : 0;\n        for (; n >= lastN; --n) {\n            for (int i = 0; i <= count; ++i) {\n                int a = width - e[i];\n                if (a == n || a == n + 1 || a == n - 32 || a == n - 31) {\n                    char num[3] = {(char) ('0' + n / 10), (char) ('0' + n % 10), '\\0'};\n                    SkTextUtils::DrawString(canvas, n >= 10 ? num : &num[1], xPos, yPos - 5, p, SkTextUtils::kCenter_Align);\n                    break;\n                }\n            }\n            xPos += 20;\n        }\n        p.setColor(SK_ColorBLACK);\n        for (int i = 0; i < count; ++i) {\n            SkTextUtils::DrawString(canvas, s[i], 5 + (e[i] + e[i + 1]) * 10, yPos + 10, p, SkTextUtils::kCenter_Align);\n        }\n        p.setStyle(SkPaint::kStroke_Style);\n        for (int i = 0; i <= count; ++i) {\n            canvas->drawLine(5 + e[i] * 20, yPos, 5 + e[i] * 20, yPos + 15, p);\n        }\n        for (int i = 0; i < 2; ++i) {\n            canvas->drawLine(5 + e[0] * 20, yPos + i * 15, 5 + e[count] * 20, yPos + i * 15, p);\n        }\n    };\n    SkScalar edges[] = { 0, 8, 16, 24, 32 };\n    const char* labels[] = { \"alpha\", \"red\", \"green\", \"blue\" };\n    drawBoxText(edges, &labels[0], 4, 31, 45);\n    drawBoxText(edges, &labels[3], 1, 7, 110);\n    drawBoxText(edges, &labels[2], 1, 7, 160);\n    drawBoxText(edges, &labels[1], 1, 7, 210);\n    drawBoxText(edges, &labels[0], 1, 7, 260);\n}\n",
    "width": 812,
    "height": 365,
    "hash": "6c35ca14d88b0de200ba7f897f889ad7",
    "file": "illustrations",
    "name": "Image_Info_Color_Type_BGRA_8888"
},
    "Illustrations_Image_Info_Color_Type_RGBA_1010102": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    canvas->scale(1.25f, 1.25f);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    SkTextUtils::DrawString(canvas, \"32-bit word\", 5 + 20 * 16, 20, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"little endian byte order\", 5 + 20 * 4, 85, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(low bits)\", 5 + 20 * 4, 137, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(low bits)\", 5 + 20 * 3, 187, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(high bits)\", 5 + 20 * 7, 187, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(low bits)\", 5 + 20 * 2, 237, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(high bits)\", 5 + 20 * 6, 237, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(high bits)\", 5 + 20 * 5, 287, paint, SkTextUtils::kCenter_Align);\n    auto drawBoxText = [=](SkScalar e[], const char* s[], int count, int n, SkScalar yPos) -> void {\n        SkPaint p(paint);\n        p.setColor(SK_ColorRED);\n        SkScalar xPos = 15;\n        int width = n % 32 + 1;\n        int lastN = n > 32 ? 32 : 0;\n        for (; n >= lastN; --n) {\n            for (int i = 0; i <= count; ++i) {\n                int a = width - e[i];\n                if (a == n || a == n + 1 || a == n - 32 || a == n - 31) {\n                    char num[3] = {(char) ('0' + n / 10), (char) ('0' + n % 10), '\\0'};\n                    SkTextUtils::DrawString(canvas, n >= 10 ? num : &num[1], xPos, yPos - 5, p, SkTextUtils::kCenter_Align);\n                    break;\n                }\n            }\n            xPos += 20;\n        }\n        p.setColor(SK_ColorBLACK);\n        for (int i = 0; i < count; ++i) {\n            SkTextUtils::DrawString(canvas, s[i], 5 + (e[i] + e[i + 1]) * 10, yPos + 10, p, SkTextUtils::kCenter_Align);\n        }\n        p.setStyle(SkPaint::kStroke_Style);\n        for (int i = 0; i <= count; ++i) {\n            canvas->drawLine(5 + e[i] * 20, yPos, 5 + e[i] * 20, yPos + 15, p);\n        }\n        for (int i = 0; i < 2; ++i) {\n            canvas->drawLine(5 + e[0] * 20, yPos + i * 15, 5 + e[count] * 20, yPos + i * 15, p);\n        }\n    };\n    SkScalar edges[] = { 0, 2, 12, 22, 32,\n                         0, 8,\n                         0, 6, 8,\n                         0, 4, 8,\n                         0, 2, 8\n                        };\n    const char* labels[] = { \"alpha\", \"blue\", \"green\", \"red\" };\n    drawBoxText(&edges[0], &labels[0], 4, 31, 45);\n    drawBoxText(&edges[5], &labels[3], 1, 7, 110);\n    drawBoxText(&edges[7], &labels[2], 2, 7, 160);\n    drawBoxText(&edges[10], &labels[1], 2, 7, 210);\n    drawBoxText(&edges[13], &labels[0], 2, 7, 260);\n}\n",
    "width": 812,
    "height": 380,
    "hash": "8d78daf69145f611054f289a7443a670",
    "file": "illustrations",
    "name": "Image_Info_Color_Type_RGBA_1010102"
},
    "Illustrations_Image_Info_Color_Type_RGBA_8888": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    canvas->scale(1.25f, 1.25f);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    SkTextUtils::DrawString(canvas, \"32-bit word\", 5 + 20 * 16, 20, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"little endian byte order\", 5 + 20 * 4, 85, paint, SkTextUtils::kCenter_Align);\n    auto drawBoxText = [=](SkScalar e[], const char* s[], int count, int n, SkScalar yPos) -> void {\n        SkPaint p(paint);\n        p.setColor(SK_ColorRED);\n        SkScalar xPos = 15;\n        int width = n % 32 + 1;\n        int lastN = n > 32 ? 32 : 0;\n        for (; n >= lastN; --n) {\n            for (int i = 0; i <= count; ++i) {\n                int a = width - e[i];\n                if (a == n || a == n + 1 || a == n - 32 || a == n - 31) {\n                    char num[3] = {(char) ('0' + n / 10), (char) ('0' + n % 10), '\\0'};\n                    SkTextUtils::DrawString(canvas, n >= 10 ? num : &num[1], xPos, yPos - 5, p, SkTextUtils::kCenter_Align);\n                    break;\n                }\n            }\n            xPos += 20;\n        }\n        p.setColor(SK_ColorBLACK);\n        for (int i = 0; i < count; ++i) {\n            SkTextUtils::DrawString(canvas, s[i], 5 + (e[i] + e[i + 1]) * 10, yPos + 10, p, SkTextUtils::kCenter_Align);\n        }\n        p.setStyle(SkPaint::kStroke_Style);\n        for (int i = 0; i <= count; ++i) {\n            canvas->drawLine(5 + e[i] * 20, yPos, 5 + e[i] * 20, yPos + 15, p);\n        }\n        for (int i = 0; i < 2; ++i) {\n            canvas->drawLine(5 + e[0] * 20, yPos + i * 15, 5 + e[count] * 20, yPos + i * 15, p);\n        }\n    };\n    SkScalar edges[] = { 0, 8, 16, 24, 32 };\n    const char* labels[] = { \"alpha\", \"blue\", \"green\", \"red\" };\n    drawBoxText(edges, &labels[0], 4, 31, 45);\n    drawBoxText(edges, &labels[3], 1, 7, 110);\n    drawBoxText(edges, &labels[2], 1, 7, 160);\n    drawBoxText(edges, &labels[1], 1, 7, 210);\n    drawBoxText(edges, &labels[0], 1, 7, 260);\n}\n",
    "width": 812,
    "height": 365,
    "hash": "9abc324f670e6468f09385551aae5a1c",
    "file": "illustrations",
    "name": "Image_Info_Color_Type_RGBA_8888"
},
    "Illustrations_Image_Info_Color_Type_RGBA_F16": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    canvas->scale(1.25f, 1.25f);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    SkTextUtils::DrawString(canvas, \"64-bit word\", 5 + 20 * 16, 20, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"little endian byte order\", 5 + 20 * 4, 135, paint, SkTextUtils::kCenter_Align);\n    for (int i = 0; i < 4; ++i) {\n        SkTextUtils::DrawString(canvas, \"(low bits)\", 5 + 20 * 4, 187 + i * 100, paint, SkTextUtils::kCenter_Align);\n        SkTextUtils::DrawString(canvas, \"(high bits)\", 5 + 20 * 4, 237 + i * 100, paint, SkTextUtils::kCenter_Align);\n    }\n    auto drawBoxText = [=](SkScalar e[], const char* s[], int count, int n, SkScalar yPos) -> void {\n        SkPaint p(paint);\n        p.setColor(SK_ColorRED);\n        SkScalar xPos = 15;\n        int width = n % 32 + 1;\n        int lastN = n > 32 ? 32 : 0;\n        for (; n >= lastN; --n) {\n            for (int i = 0; i <= count; ++i) {\n                int a = width - e[i];\n                if (a == n || a == n + 1 || a == n - 32 || a == n - 31) {\n                    char num[3] = {(char) ('0' + n / 10), (char) ('0' + n % 10), '\\0'};\n                    SkTextUtils::DrawString(canvas, n >= 10 ? num : &num[1], xPos, yPos - 5, p, SkTextUtils::kCenter_Align);\n                    break;\n                }\n            }\n            xPos += 20;\n        }\n        p.setColor(SK_ColorBLACK);\n        for (int i = 0; i < count; ++i) {\n            SkTextUtils::DrawString(canvas, s[i], 5 + (e[i] + e[i + 1]) * 10, yPos + 10, p, SkTextUtils::kCenter_Align);\n        }\n        p.setStyle(SkPaint::kStroke_Style);\n        for (int i = 0; i <= count; ++i) {\n            canvas->drawLine(5 + e[i] * 20, yPos, 5 + e[i] * 20, yPos + 15, p);\n        }\n        for (int i = 0; i < 2; ++i) {\n            canvas->drawLine(5 + e[0] * 20, yPos + i * 15, 5 + e[count] * 20, yPos + i * 15, p);\n        }\n    };\n    SkScalar edges[] = { 0, 16, 32,\n                         0, 8\n                       };\n    const char* labels[] = { \"alpha\", \"blue\", \"green\", \"red\" };\n    drawBoxText(&edges[0], &labels[0], 2, 63, 45);\n    drawBoxText(&edges[0], &labels[2], 2, 31, 95);\n    drawBoxText(&edges[3], &labels[3], 1, 7, 160);\n    drawBoxText(&edges[3], &labels[3], 1, 7, 210);\n    drawBoxText(&edges[3], &labels[2], 1, 7, 260);\n    drawBoxText(&edges[3], &labels[2], 1, 7, 310);\n    drawBoxText(&edges[3], &labels[1], 1, 7, 360);\n    drawBoxText(&edges[3], &labels[1], 1, 7, 410);\n    drawBoxText(&edges[3], &labels[0], 1, 7, 460);\n    drawBoxText(&edges[3], &labels[0], 1, 7, 510);\n}\n",
    "width": 812,
    "height": 685,
    "hash": "1bb35ae52173e0fef874022ca8138adc",
    "file": "illustrations",
    "name": "Image_Info_Color_Type_RGBA_F16"
},
    "Illustrations_Image_Info_Color_Type_RGBA_F32": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    canvas->scale(1.25f, 1.25f);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    SkTextUtils::DrawString(canvas, \"128-bit word\", 5 + 20 * 16, 20, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"little endian byte order\", 5 + 20 * 4, 135, paint, SkTextUtils::kCenter_Align);\n    for (int i = 0; i < 4; ++i) {\n        SkTextUtils::DrawString(canvas, \"(low bits)\", 5 + 10 * 4, 187 + i * 100, paint, SkTextUtils::kCenter_Align);\n        SkTextUtils::DrawString(canvas, \"(high bits)\", 105 + 10 * 4, 237 + i * 100, paint, SkTextUtils::kCenter_Align);\n    }\n    auto drawBoxText = [=](SkScalar e[], const char* s[], const char* nums[] , \n             int count, int n, SkScalar yPos) -> void {\n        SkPaint p(paint);\n        p.setColor(SK_ColorRED);\n        SkScalar xPos = 15;\n        int stringIndex = 0;\n        for (int i = n; i >= 0; --i) {\n            if (0 == i || n == i || 32 == i || 31 == i) {\n                int x = xPos;\n                if (2 == count) {\n                    x += stringIndex * 12 + (stringIndex ? 8 : 0);\n                }\n                SkTextUtils::DrawString(canvas, nums[stringIndex], x, yPos - 5, p, SkTextUtils::kCenter_Align);\n                if (1 == count) {\n                    SkTextUtils::DrawString(canvas, nums[stringIndex], xPos + 100, yPos - 5, p, SkTextUtils::kCenter_Align);\n                }\n                ++stringIndex;\n            }\n            xPos += 9;\n        }\n        p.setColor(SK_ColorBLACK);\n        for (int i = 0; i < count; ++i) {\n            SkTextUtils::DrawString(canvas, s[i], 5 + (e[i] + e[i + 1]) * 5, yPos + 10, p, SkTextUtils::kCenter_Align);\n            if (1 == count) {\n                SkTextUtils::DrawString(canvas, s[i], 105 + (e[i] + e[i + 1]) * 5, yPos + 10, p, SkTextUtils::kCenter_Align);\n            }\n        }\n        p.setStyle(SkPaint::kStroke_Style);\n        for (int i = 0; i <= count; ++i) {\n            canvas->drawLine(5 + e[i] * 10, yPos, 5 + e[i] * 10, yPos + 15, p);\n            if (1 == count) {\n                canvas->drawLine(105 + e[i] * 10, yPos, 105 + e[i] * 10, yPos + 15, p);\n            }\n        }\n        for (int i = 0; i < 2; ++i) {\n            canvas->drawLine(5 + e[0] * 10, yPos + i * 15,\n                             5 + e[count] * 10, yPos + i * 15, p);\n            if (1 == count) {\n                canvas->drawLine(105 + e[0] * 10, yPos + i * 15,\n                                 105 + e[count] * 10, yPos + i * 15, p);\n            }\n        }\n    };\n    SkScalar edges[] = { 0, 32, 64,\n                         0, 8\n                       };\n    const char* labels[] = { \"alpha\", \"blue\", \"green\", \"red\" };\n    const char* nums128[] = { \"127\", \"96\", \"95\", \"64\"};\n    const char* nums64[] = { \"63\", \"32\", \"31\", \"0\"};\n    const char* nums8[] = { \"7\", \"0\"};\n    drawBoxText(&edges[0], &labels[0], nums128, 2, 63, 45);\n    drawBoxText(&edges[0], &labels[2], nums64, 2, 63, 95);\n    drawBoxText(&edges[3], &labels[3], nums8, 1, 7, 160);\n    drawBoxText(&edges[3], &labels[3], nums8, 1, 7, 210);\n    drawBoxText(&edges[3], &labels[2], nums8, 1, 7, 260);\n    drawBoxText(&edges[3], &labels[2], nums8, 1, 7, 310);\n    drawBoxText(&edges[3], &labels[1], nums8, 1, 7, 360);\n    drawBoxText(&edges[3], &labels[1], nums8, 1, 7, 410);\n    drawBoxText(&edges[3], &labels[0], nums8, 1, 7, 460);\n    drawBoxText(&edges[3], &labels[0], nums8, 1, 7, 510);\n}\n",
    "width": 812,
    "height": 685,
    "hash": "4ba31a8f9bc94a996f34da81ef541a9c",
    "file": "illustrations",
    "name": "Image_Info_Color_Type_RGBA_F32"
},
    "Illustrations_Image_Info_Color_Type_RGB_101010": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    canvas->scale(1.25f, 1.25f);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    SkTextUtils::DrawString(canvas, \"32-bit word\", 5 + 20 * 16, 20, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"little endian byte order\", 5 + 20 * 4, 85, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(low bits)\", 5 + 20 * 4, 137, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(low bits)\", 5 + 20 * 3, 187, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(high bits)\", 5 + 20 * 7, 187, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(low bits)\", 5 + 20 * 2, 237, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(high bits)\", 5 + 20 * 6, 237, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(high bits)\", 5 + 20 * 5, 287, paint, SkTextUtils::kCenter_Align);\n    auto drawBoxText = [=](SkScalar e[], const char* s[], int count, int n, SkScalar yPos) -> void {\n        SkPaint p(paint);\n        p.setColor(SK_ColorRED);\n        SkScalar xPos = 15;\n        int width = n % 32 + 1;\n        int lastN = n > 32 ? 32 : 0;\n        for (; n >= lastN; --n) {\n            for (int i = 0; i <= count; ++i) {\n                int a = width - e[i];\n                if (a == n || a == n + 1 || a == n - 32 || a == n - 31) {\n                    char num[3] = {(char) ('0' + n / 10), (char) ('0' + n % 10), '\\0'};\n                    SkTextUtils::DrawString(canvas, n >= 10 ? num : &num[1], xPos, yPos - 5, p, SkTextUtils::kCenter_Align);\n                    break;\n                }\n            }\n            xPos += 20;\n        }\n        p.setColor(SK_ColorBLACK);\n        for (int i = 0; i < count; ++i) {\n            SkTextUtils::DrawString(canvas, s[i], 5 + (e[i] + e[i + 1]) * 10, yPos + 10, p, SkTextUtils::kCenter_Align);\n        }\n        p.setStyle(SkPaint::kStroke_Style);\n        for (int i = 0; i <= count; ++i) {\n            canvas->drawLine(5 + e[i] * 20, yPos, 5 + e[i] * 20, yPos + 15, p);\n        }\n        for (int i = 0; i < 2; ++i) {\n            canvas->drawLine(5 + e[0] * 20, yPos + i * 15, 5 + e[count] * 20, yPos + i * 15, p);\n        }\n    };\n    SkScalar edges[] = { 0, 2, 12, 22, 32,\n                         0, 8,\n                         0, 6, 8,\n                         0, 4, 8,\n                         0, 2, 8\n                        };\n    const char* labels[] = { \"unused\", \"blue\", \"green\", \"red\" };\n    drawBoxText(&edges[0], &labels[0], 4, 31, 45);\n    drawBoxText(&edges[5], &labels[3], 1, 7, 110);\n    drawBoxText(&edges[7], &labels[2], 2, 7, 160);\n    drawBoxText(&edges[10], &labels[1], 2, 7, 210);\n    drawBoxText(&edges[13], &labels[0], 2, 7, 260);\n}\n",
    "width": 812,
    "height": 380,
    "hash": "4c9f4d939e2047269d73fa3507caf01f",
    "file": "illustrations",
    "name": "Image_Info_Color_Type_RGB_101010"
},
    "Illustrations_Image_Info_Color_Type_RGB_565": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    canvas->scale(1.25f, 1.25f);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    SkTextUtils::DrawString(canvas, \"16-bit word\", 5 + 20 * 8, 20, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"little endian byte order\", 5 + 20 * 4, 85, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(low bits)\", 5 + 20 * 1.5f, 137, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"(high bits)\", 5 + 20 * 6.5f, 187, paint, SkTextUtils::kCenter_Align);\n    auto drawBoxText = [=](SkScalar e[], const char* s[], int count, int n, SkScalar yPos) -> void {\n        SkPaint p(paint);\n        p.setColor(SK_ColorRED);\n        SkScalar xPos = 15;\n        int width = n % 32 + 1;\n        int lastN = n > 32 ? 32 : 0;\n        for (; n >= lastN; --n) {\n            for (int i = 0; i <= count; ++i) {\n                int a = width - e[i];\n                if (a == n || a == n + 1 || a == n - 32 || a == n - 31) {\n                    char num[3] = {(char) ('0' + n / 10), (char) ('0' + n % 10), '\\0'};\n                    SkTextUtils::DrawString(canvas, n >= 10 ? num : &num[1], xPos, yPos - 5, p, SkTextUtils::kCenter_Align);\n                    break;\n                }\n            }\n            xPos += 20;\n        }\n        p.setColor(SK_ColorBLACK);\n        for (int i = 0; i < count; ++i) {\n            SkTextUtils::DrawString(canvas, s[i], 5 + (e[i] + e[i + 1]) * 10, yPos + 10, p, SkTextUtils::kCenter_Align);\n        }\n        p.setStyle(SkPaint::kStroke_Style);\n        for (int i = 0; i <= count; ++i) {\n            canvas->drawLine(5 + e[i] * 20, yPos, 5 + e[i] * 20, yPos + 15, p);\n        }\n        for (int i = 0; i < 2; ++i) {\n            canvas->drawLine(5 + e[0] * 20, yPos + i * 15, 5 + e[count] * 20, yPos + i * 15, p);\n        }\n    };\n    SkScalar edges[] = { 0, 5, 11, 16,\n                         0, 3, 8,\n                         0, 5, 8 };\n    const char* labels[] = { \"red\", \"green\", \"blue\" };\n    drawBoxText(&edges[0], &labels[0], 3, 15, 45);\n    drawBoxText(&edges[4], &labels[1], 2, 7, 110);\n    drawBoxText(&edges[7], &labels[0], 2, 7, 160);\n}\n",
    "width": 415,
    "height": 250,
    "hash": "6dec0226490a4ac1977dc87a31564147",
    "file": "illustrations",
    "name": "Image_Info_Color_Type_RGB_565"
},
    "Illustrations_Image_Info_Color_Type_RGB_888": {
    "code": "#include \"SkTextUtils.h\"\n\nvoid draw(SkCanvas* canvas) {\n    canvas->scale(1.25f, 1.25f);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    SkTextUtils::DrawString(canvas, \"32-bit word\", 5 + 20 * 16, 20, paint, SkTextUtils::kCenter_Align);\n    SkTextUtils::DrawString(canvas, \"little endian byte order\", 5 + 20 * 4, 85, paint, SkTextUtils::kCenter_Align);\n    auto drawBoxText = [=](SkScalar e[], const char* s[], int count, int n, SkScalar yPos) -> void {\n        SkPaint p(paint);\n        p.setColor(SK_ColorRED);\n        SkScalar xPos = 15;\n        int width = n % 32 + 1;\n        int lastN = n > 32 ? 32 : 0;\n        for (; n >= lastN; --n) {\n            for (int i = 0; i <= count; ++i) {\n                int a = width - e[i];\n                if (a == n || a == n + 1 || a == n - 32 || a == n - 31) {\n                    char num[3] = {(char) ('0' + n / 10), (char) ('0' + n % 10), '\\0'};\n                    SkTextUtils::DrawString(canvas, n >= 10 ? num : &num[1], xPos, yPos - 5, p, SkTextUtils::kCenter_Align);\n                    break;\n                }\n            }\n            xPos += 20;\n        }\n        p.setColor(SK_ColorBLACK);\n        for (int i = 0; i < count; ++i) {\n            SkTextUtils::DrawString(canvas, s[i], 5 + (e[i] + e[i + 1]) * 10, yPos + 10, p, SkTextUtils::kCenter_Align);\n        }\n        p.setStyle(SkPaint::kStroke_Style);\n        for (int i = 0; i <= count; ++i) {\n            canvas->drawLine(5 + e[i] * 20, yPos, 5 + e[i] * 20, yPos + 15, p);\n        }\n        for (int i = 0; i < 2; ++i) {\n            canvas->drawLine(5 + e[0] * 20, yPos + i * 15, 5 + e[count] * 20, yPos + i * 15, p);\n        }\n    };\n    SkScalar edges[] = { 0, 8, 16, 24, 32 };\n    const char* labels[] = { \"(unused)\", \"blue\", \"green\", \"red\" };\n    drawBoxText(edges, &labels[0], 4, 31, 45);\n    drawBoxText(edges, &labels[3], 1, 7, 110);\n    drawBoxText(edges, &labels[2], 1, 7, 160);\n    drawBoxText(edges, &labels[1], 1, 7, 210);\n    drawBoxText(edges, &labels[0], 1, 7, 260);\n}\n",
    "width": 812,
    "height": 365,
    "hash": "7527d7ade4764302818e250cd4e03962",
    "file": "illustrations",
    "name": "Image_Info_Color_Type_RGB_888"
},
    "Illustrations_Path_Arc": {
    "code": "struct data {\n   const char* name;\n   char super;\n   int yn[10];\n};\nconst data dataSet[] = {\n{ \"arcTo sweep\",    '1', {1,  3, 1, 0, 0, 0, 0, 1, 0, 0 }},\n{ \"drawArc\",         0,  {1, -1, 1, 1, 1, 1, 1, 0, 0, 0 }},\n{ \"addArc\",          0,  {1,  1, 1, 4, 0, 1, 1, 1, 0, 0 }},\n{ \"arcTo tangents\", '4', {0,  0, 0, 0, 0, 0, 0, 1, 1, 0 }},\n{ \"arcTo radii\",    '5', {1,  0, 1, 0, 0, 0, 0, 1, 1, 0 }},\n{ \"conicTo\",         0,  {1,  1, 0, 0, 0, 0, 0, 1, 1, 1 }}\n};\n#define __degree_symbol__ \"\\xC2\" \"\\xB0\"\nconst char* headers[] = {\n    \"Oval part\",\n    \"force moveTo\",\n    \"can draw 180\" __degree_symbol__,\n    \"can draw 360\" __degree_symbol__,\n    \"can draw greater than 360\" __degree_symbol__,\n    \"ignored if radius is zero\",\n    \"ignored if sweep is zero\",\n    \"requires Path\",\n    \"describes rotation\",\n    \"describes perspective\",\n};\nconst char* yna[] = {\n     \"n/a\",\n     \"no\",\n     \"yes\"\n};\n\nvoid draw(SkCanvas* canvas) {\n    SkPaint lp;\n    lp.setAntiAlias(true);\n    SkPaint tp(lp);\n    SkPaint sp(tp);\n    SkPaint bp(tp);\n    bp.setFakeBoldText(true);\n    sp.setTextSize(10);\n    lp.setColor(SK_ColorGRAY);\n    canvas->translate(0, 32);\n    const int tl = 115;\n    for (unsigned col = 0; col <= SK_ARRAY_COUNT(headers); ++col) {\n       canvas->drawLine(tl + col * 35, 100, tl + col * 35, 250, lp);\n       if (0 == col) {\n          continue;\n       }\n       canvas->drawLine( tl +        col * 35, 100,  tl + 100  + col * 35,   0, lp);\n       SkPoint pts[] = {{tl - 10.f + col * 35, 98}, {tl + 90.f + col * 35,  -2}};\n       SkVector v = pts[1] - pts[0];\n       v.normalize();\n       SkMatrix matrix;\n       matrix.setSinCos(v.fY, v.fX, pts[0].fX, pts[0].fY);\n       canvas->save();\n       canvas->concat(matrix);\n       canvas->drawText(headers[col -1], strlen(headers[col -1]), pts[0].fX, pts[0].fY, bp);\n       canvas->restore();\n    }\n    for (unsigned row = 0; row <= SK_ARRAY_COUNT(dataSet); ++row) {\n        if (0 == row) {\n            canvas->drawLine(tl, 100, tl + 350, 100, lp);\n        } else {\n            canvas->drawLine(5, 100 + row * 25, tl + 350, 100 + row * 25, lp);\n        }\n        if (row == SK_ARRAY_COUNT(dataSet)) {\n            break;\n        }\n        canvas->drawString(dataSet[row].name, 5, 117 + row * 25, bp);\n        if (dataSet[row].super) {\n            SkScalar width = bp.measureText(dataSet[row].name, strlen(dataSet[row].name));\n            canvas->drawText(&dataSet[row].super, 1, 8 + width, 112 + row * 25, sp);\n        }\n        for (unsigned col = 0; col < SK_ARRAY_COUNT(headers); ++col) {\n            int val = dataSet[row].yn[col];\n            canvas->drawString(yna[SkTMin(2, val + 1)], tl + 5 + col * 35, 117 + row * 25, tp);\n            if (val > 1) {\n                char supe = '0' + val - 1;\n                canvas->drawText(&supe, 1, tl + 25 + col * 35, 112 + row * 25, sp);\n            }\n        }\n    }\n}\n",
    "width": 600,
    "height": 300,
    "hash": "e17e48e9d2182e9afc0f5d26b72c60f0",
    "file": "illustrations",
    "name": "Path_Arc"
},
    "Image_Info_Alpha_Type_Opaque": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPMColor color = SkPreMultiplyARGB(255, 50, 100, 150);\n    SkString s;\n    s.printf(\"%u %u %u %u\", SkColorGetA(color), SkColorGetR(color),\n                            SkColorGetG(color), SkColorGetB(color));\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawString(s, 10, 62, paint);\n    canvas->scale(50, 50);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(1, 1, kN32_SkColorType, kOpaque_SkAlphaType);\n    if (bitmap.installPixels(imageInfo, (void*) &color, imageInfo.minRowBytes())) {\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "79146a1a41d58d22582fdc567c6ffe4e",
    "file": "SkImageInfo_Reference",
    "name": "Alpha_Type_Opaque"
},
    "Image_Info_Alpha_Type_Premul": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPMColor color = SkPreMultiplyARGB(150, 50, 100, 150);\n    SkString s;\n    s.printf(\"%u %u %u %u\", SkColorGetA(color), SkColorGetR(color),\n                            SkColorGetG(color), SkColorGetB(color));\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawString(s, 10, 62, paint);\n    canvas->scale(50, 50);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(1, 1, kN32_SkColorType, kPremul_SkAlphaType);\n    if (bitmap.installPixels(imageInfo, (void*) &color, imageInfo.minRowBytes())) {\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "ad696b39c915803d566e96896ec3a36c",
    "file": "SkImageInfo_Reference",
    "name": "Alpha_Type_Premul"
},
    "Image_Info_Alpha_Type_Unpremul": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor color = SkColorSetARGB(150, 50, 100, 255);\n    SkString s;\n    s.printf(\"%u %u %u %u\", SkColorGetA(color), SkColorGetR(color),\n                            SkColorGetG(color), SkColorGetB(color));\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawString(s, 10, 62, paint);\n    canvas->scale(50, 50);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(1, 1, kN32_SkColorType, kUnpremul_SkAlphaType);\n    if (bitmap.installPixels(imageInfo, (void*) &color, imageInfo.minRowBytes())) {\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "b8216a9e5ff5bc61a0e46eba7d36307b",
    "file": "SkImageInfo_Reference",
    "name": "Alpha_Type_Unpremul"
},
    "Image_Info_Color_Type_ARGB_4444": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(16, 16);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kARGB_4444_SkColorType, kPremul_SkAlphaType);\n    bitmap.allocPixels(imageInfo);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 0, 0);\n    auto pack4444 = [](unsigned a, unsigned r, unsigned g, unsigned b) -> uint16_t {\n        return (a << 0) | (b << 4) | (g << 8) | (r << 12);\n    };\n    uint16_t red4444[] =  { pack4444(0xF, 0xF, 0x0, 0x0), pack4444(0xF, 0xb, 0x0, 0x0),\n                            pack4444(0xF, 0x7, 0x0, 0x0), pack4444(0xF, 0x3, 0x0, 0x0) };\n    uint16_t blue4444[] = { pack4444(0xF, 0x0, 0x0, 0xF), pack4444(0xF, 0x0, 0x0, 0xb),\n                            pack4444(0xF, 0x0, 0x0, 0x7), pack4444(0xF, 0x0, 0x0, 0x3) };\n    SkPixmap redPixmap(imageInfo, &red4444, imageInfo.minRowBytes());\n    if (bitmap.writePixels(redPixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 2, 2);\n    }\n    SkPixmap bluePixmap(imageInfo, &blue4444, imageInfo.minRowBytes());\n    if (bitmap.writePixels(bluePixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 4, 4);\n    }\n}",
    "width": 256,
    "height": 96,
    "hash": "33a360c3404ac21db801943336843d8e",
    "file": "SkImageInfo_Reference",
    "name": "Color_Type_ARGB_4444"
},
    "Image_Info_Color_Type_Alpha_8": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(16, 16);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kAlpha_8_SkColorType, kOpaque_SkAlphaType);\n    bitmap.allocPixels(imageInfo);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorGREEN);\n    SkPaint orangePaint;\n    orangePaint.setARGB(0xFF, 0xFF, 0xA5, 0x00);\n    canvas->drawBitmap(bitmap, 0, 0, &orangePaint);\n    uint8_t alpha8[] = { 0xFF, 0xBB, 0x77, 0x33 };\n    SkPixmap alphaPixmap(imageInfo, &alpha8, imageInfo.minRowBytes());\n    if (bitmap.writePixels(alphaPixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 2, 2, &orangePaint);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "21ae21e4ce53d2018e042dd457997300",
    "file": "SkImageInfo_Reference",
    "name": "Color_Type_Alpha_8"
},
    "Image_Info_Color_Type_BGRA_8888": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(16, 16);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kBGRA_8888_SkColorType, kPremul_SkAlphaType);\n    bitmap.allocPixels(imageInfo);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 0, 0);\n    auto pack8888 = [](unsigned a, unsigned r, unsigned g, unsigned b) -> uint32_t {\n        return (b << 0) | (g << 8) | (r << 16) | (a << 24);\n    };\n    uint32_t red8888[] = { pack8888(0xFF, 0xFF, 0x0, 0x0), pack8888(0xFF, 0xbb, 0x0, 0x0),\n                           pack8888(0xFF, 0x99, 0x0, 0x0), pack8888(0xFF, 0x55, 0x0, 0x0) };\n    uint32_t blue8888[] = { pack8888(0xFF, 0x0, 0x0, 0x0FF), pack8888(0xFF, 0x0, 0x0, 0x0bb),\n                            pack8888(0xFF, 0x0, 0x0, 0x099), pack8888(0xFF, 0x0, 0x0, 0x055) };\n    SkPixmap redPixmap(imageInfo, &red8888, imageInfo.minRowBytes());\n    if (bitmap.writePixels(redPixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 2, 2);\n    }\n    SkPixmap bluePixmap(imageInfo, &blue8888, imageInfo.minRowBytes());\n    if (bitmap.writePixels(bluePixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 4, 4);\n    }\n}",
    "width": 256,
    "height": 96,
    "hash": "945ce5344fce5470f8604b2e06e9f9ae",
    "file": "SkImageInfo_Reference",
    "name": "Color_Type_BGRA_8888"
},
    "Image_Info_Color_Type_Gray_8": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(16, 16);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    bitmap.allocPixels(imageInfo);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 0, 0);\n    uint8_t gray8[] = { 0xFF, 0xBB, 0x77, 0x33 };\n    SkPixmap grayPixmap(imageInfo, &gray8, imageInfo.minRowBytes());\n    if (bitmap.writePixels(grayPixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 2, 2);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "93da0eb0b6722a4f33dc7dae094abf0b",
    "file": "SkImageInfo_Reference",
    "name": "Color_Type_Gray_8"
},
    "Image_Info_Color_Type_RGBA_1010102": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(16, 16);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGBA_1010102_SkColorType, kOpaque_SkAlphaType);\n    bitmap.allocPixels(imageInfo);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 0, 0);\n    auto pack1010102 = [](unsigned r, unsigned g, unsigned b, unsigned a) -> uint32_t {\n        return (r << 0) | (g << 10) | (b << 20) | (a << 30);\n    };\n    uint32_t redBits[] =  { pack1010102(0x3FF, 0x000, 0x000, 0x3),\n                            pack1010102(0x2ff, 0x000, 0x000, 0x3),\n                            pack1010102(0x1ff, 0x000, 0x000, 0x3),\n                            pack1010102(0x0ff, 0x000, 0x000, 0x3) };\n    uint32_t blueBits[] = { pack1010102(0x000, 0x000, 0x3FF, 0x3),\n                            pack1010102(0x000, 0x000, 0x2ff, 0x3),\n                            pack1010102(0x000, 0x000, 0x1ff, 0x3),\n                            pack1010102(0x000, 0x000, 0x0ff, 0x3) };\n    if (bitmap.installPixels(imageInfo, (void*) redBits, imageInfo.minRowBytes())) {\n        canvas->drawBitmap(bitmap, 2, 2);\n    }\n    SkPixmap bluePixmap(imageInfo, &blueBits, imageInfo.minRowBytes());\n    if (bitmap.installPixels(imageInfo, (void*) blueBits, imageInfo.minRowBytes())) {\n        canvas->drawBitmap(bitmap, 4, 4);\n    }\n}",
    "width": 256,
    "height": 96,
    "hash": "1282dc1127ce1b0061544619ae4de0f0",
    "file": "SkImageInfo_Reference",
    "name": "Color_Type_RGBA_1010102"
},
    "Image_Info_Color_Type_RGBA_8888": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(16, 16);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGBA_8888_SkColorType, kPremul_SkAlphaType);\n    bitmap.allocPixels(imageInfo);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 0, 0);\n    auto pack8888 = [](unsigned a, unsigned r, unsigned g, unsigned b) -> uint32_t {\n        return (r << 0) | (g << 8) | (b << 16) | (a << 24);\n    };\n    uint32_t red8888[] = { pack8888(0xFF, 0xFF, 0x0, 0x0), pack8888(0xFF, 0xbb, 0x0, 0x0),\n                           pack8888(0xFF, 0x77, 0x0, 0x0), pack8888(0xFF, 0x33, 0x0, 0x0) };\n    uint32_t blue8888[] = { pack8888(0xFF, 0x0, 0x0, 0x0FF), pack8888(0xFF, 0x0, 0x0, 0x0bb),\n                            pack8888(0xFF, 0x0, 0x0, 0x077), pack8888(0xFF, 0x0, 0x0, 0x033) };\n    SkPixmap redPixmap(imageInfo, &red8888, imageInfo.minRowBytes());\n    if (bitmap.writePixels(redPixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 2, 2);\n    }\n    SkPixmap bluePixmap(imageInfo, &blue8888, imageInfo.minRowBytes());\n    if (bitmap.writePixels(bluePixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 4, 4);\n    }\n}",
    "width": 256,
    "height": 96,
    "hash": "947922a19d59893fe7f9d9ee1954379b",
    "file": "SkImageInfo_Reference",
    "name": "Color_Type_RGBA_8888"
},
    "Image_Info_Color_Type_RGBA_F16": {
    "code": "union FloatUIntUnion {\n    uint32_t fUInt;\n    float    fFloat;\n};\nuint16_t FloatToHalf(float f) {\n    static const FloatUIntUnion magic = { 15 << 23 };\n    static const uint32_t round_mask = ~0xfffu;\n    FloatUIntUnion floatUnion;\n    floatUnion.fFloat = f;\n    uint32_t sign = floatUnion.fUInt & 0x80000000u;\n    floatUnion.fUInt ^= sign;\n    floatUnion.fUInt &= round_mask;\n    floatUnion.fFloat *= magic.fFloat;\n    floatUnion.fUInt -= round_mask;\n    return (floatUnion.fUInt >> 13) | (sign >> 16);\n}\n\nvoid draw(SkCanvas* canvas) {\n    canvas->scale(16, 16);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGBA_F16_SkColorType, kPremul_SkAlphaType);\n    bitmap.allocPixels(imageInfo);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 0, 0);\n    auto H = [](float c) -> uint16_t {\n        return FloatToHalf(c);\n    };\n                             //     R        G        B        A\n    uint16_t red_f16[][4] =  { { H(1.0), H(0.0), H(0.0), H(1.0) },\n                               { H(.75), H(0.0), H(0.0), H(1.0) },\n                               { H(.50), H(0.0), H(0.0), H(1.0) },\n                               { H(.25), H(0.0), H(0.0), H(1.0) } };\n    uint16_t blue_f16[][4] = { { H(0.0), H(0.0), H(1.0), H(1.0) },\n                               { H(0.0), H(0.0), H(.75), H(1.0) },\n                               { H(0.0), H(0.0), H(.50), H(1.0) },\n                               { H(0.0), H(0.0), H(.25), H(1.0) } };\n    SkPixmap redPixmap(imageInfo, red_f16, imageInfo.minRowBytes());\n    if (bitmap.writePixels(redPixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 2, 2);\n    }\n    SkPixmap bluePixmap(imageInfo, blue_f16, imageInfo.minRowBytes());\n    if (bitmap.writePixels(bluePixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 4, 4);\n    }\n}\n",
    "width": 256,
    "height": 96,
    "hash": "dd81527bbdf5eaae7dd21ac04ab84f9e",
    "file": "SkImageInfo_Reference",
    "name": "Color_Type_RGBA_F16"
},
    "Image_Info_Color_Type_RGB_101010": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(16, 16);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGB_101010x_SkColorType, kOpaque_SkAlphaType);\n    bitmap.allocPixels(imageInfo);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 0, 0);\n    auto pack101010x = [](unsigned r, unsigned g, unsigned b) -> uint32_t {\n        return (r << 0) | (g << 10) | (b << 20);\n    };\n    uint32_t redBits[] =  { pack101010x(0x3FF, 0x000, 0x000), pack101010x(0x2ff, 0x000, 0x000),\n    pack101010x(0x1ff, 0x000, 0x000), pack101010x(0x0ff, 0x000, 0x000) };\n    uint32_t blueBits[] = { pack101010x(0x000, 0x000, 0x3FF), pack101010x(0x000, 0x000, 0x2ff),\n    pack101010x(0x000, 0x000, 0x1ff), pack101010x(0x000, 0x000, 0x0ff) };\n    if (bitmap.installPixels(imageInfo, (void*) redBits, imageInfo.minRowBytes())) {\n        canvas->drawBitmap(bitmap, 2, 2);\n    }\n    SkPixmap bluePixmap(imageInfo, &blueBits, imageInfo.minRowBytes());\n    if (bitmap.installPixels(imageInfo, (void*) blueBits, imageInfo.minRowBytes())) {\n        canvas->drawBitmap(bitmap, 4, 4);\n    }\n}",
    "width": 256,
    "height": 96,
    "hash": "92f81aa0459230459600a01e79ccff29",
    "file": "SkImageInfo_Reference",
    "name": "Color_Type_RGB_101010"
},
    "Image_Info_Color_Type_RGB_565": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(16, 16);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGB_565_SkColorType, kOpaque_SkAlphaType);\n    bitmap.allocPixels(imageInfo);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 0, 0);\n    auto pack565 = [](unsigned r, unsigned g, unsigned b) -> uint16_t {\n        return (b << 0) | (g << 5) | (r << 11);\n    };\n    uint16_t red565[] =  { pack565(0x1F, 0x00, 0x00), pack565(0x17, 0x00, 0x00),\n                           pack565(0x0F, 0x00, 0x00), pack565(0x07, 0x00, 0x00) };\n    uint16_t blue565[] = { pack565(0x00, 0x00, 0x1F), pack565(0x00, 0x00, 0x17),\n                           pack565(0x00, 0x00, 0x0F), pack565(0x00, 0x00, 0x07) };\n    SkPixmap redPixmap(imageInfo, &red565, imageInfo.minRowBytes());\n    if (bitmap.writePixels(redPixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 2, 2);\n    }\n    SkPixmap bluePixmap(imageInfo, &blue565, imageInfo.minRowBytes());\n    if (bitmap.writePixels(bluePixmap, 0, 0)) {\n        canvas->drawBitmap(bitmap, 4, 4);\n    }\n}",
    "width": 256,
    "height": 96,
    "hash": "7e7c46bb4572e21e13529ff364eb0a9c",
    "file": "SkImageInfo_Reference",
    "name": "Color_Type_RGB_565"
},
    "Image_Info_Color_Type_RGB_888": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(16, 16);\n    SkBitmap bitmap;\n    SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGB_888x_SkColorType, kOpaque_SkAlphaType);\n    bitmap.allocPixels(imageInfo);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 0, 0);\n    auto pack888 = [](unsigned r, unsigned g, unsigned b) -> uint32_t {\n        return (r << 0) | (g << 8) | (b << 16);\n    };\n    uint32_t red888[] =  { pack888(0xFF, 0x00, 0x00), pack888(0xbb, 0x00, 0x00),\n        pack888(0x77, 0x00, 0x00), pack888(0x33, 0x00, 0x00) };\n    uint32_t blue888[] = { pack888(0x00, 0x00, 0xFF), pack888(0x00, 0x00, 0xbb),\n        pack888(0x00, 0x00, 0x77), pack888(0x00, 0x00, 0x33) };\n    if (bitmap.installPixels(imageInfo, (void*) red888, imageInfo.minRowBytes())) {\n        canvas->drawBitmap(bitmap, 2, 2);\n    }\n    if (bitmap.installPixels(imageInfo, (void*) blue888, imageInfo.minRowBytes())) {\n        canvas->drawBitmap(bitmap, 4, 4);\n    }\n}",
    "width": 256,
    "height": 96,
    "hash": "4260d6cc15db2c60c07f6fdc8d9ae425",
    "file": "SkImageInfo_Reference",
    "name": "Color_Type_RGB_888"
},
    "Matrix_MemberIndex": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint black;\n    black.setAntiAlias(true);\n    black.setTextSize(48);\n    SkPaint gray = black;\n    gray.setColor(0xFF9f9f9f);\n    SkScalar offset[] = { 1.5f, 1.5f, 20,   1.5f, 1.5f, 20,   .03f, .01f, 2 };\n    for (int i : { SkMatrix::kMScaleX, SkMatrix::kMSkewX,  SkMatrix::kMTransX,\n                   SkMatrix::kMSkewY,  SkMatrix::kMScaleY, SkMatrix::kMTransY,\n                   SkMatrix::kMPersp0, SkMatrix::kMPersp1, SkMatrix::kMPersp2 } ) {\n        SkMatrix m;\n        m.setIdentity();\n        m.set(i, offset[i]);\n        SkAutoCanvasRestore autoRestore(canvas, true);\n        canvas->translate(22 + (i % 3) * 88, 44 + (i / 3) * 88);\n        canvas->drawString(\"&\", 0, 0, gray);\n        canvas->concat(m);\n        canvas->drawString(\"&\", 0, 0, black);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "3bbf75f4748420810aa2586e3c8548d9",
    "file": "SkMatrix_Reference",
    "name": "MemberIndex"
},
    "Paint_Anti_Alias": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocN32Pixels(50, 50);\n    SkCanvas offscreen(bitmap);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    for (bool antialias : { false, true }) {\n        paint.setColor(antialias ? SK_ColorRED : SK_ColorBLUE);\n        paint.setAntiAlias(antialias);\n        bitmap.eraseColor(0);\n        offscreen.drawLine(5, 5, 15, 30, paint);\n        canvas->drawLine(5, 5, 15, 30, paint);\n        canvas->save();\n        canvas->scale(10, 10);\n        canvas->drawBitmap(bitmap, antialias ? 12 : 0, 0);\n        canvas->restore();\n        canvas->translate(15, 0);\n    }\n}\n",
    "width": 512,
    "height": 256,
    "hash": "a6575a49467ce8d28bb01cc7638fa04d",
    "file": "SkPaint_Reference",
    "name": "Anti_Alias"
},
    "Paint_Blend_Mode_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint normal, blender;\n    normal.setColor(0xFF58a889);\n    blender.setColor(0xFF8958a8);\n    canvas->clear(0);\n    for (SkBlendMode m : { SkBlendMode::kSrcOver, SkBlendMode::kSrcIn, SkBlendMode::kSrcOut } ) {\n        normal.setBlendMode(SkBlendMode::kSrcOver);\n        canvas->drawOval(SkRect::MakeXYWH(30, 30, 30, 80), normal);\n        blender.setBlendMode(m);\n        canvas->drawOval(SkRect::MakeXYWH(10, 50, 80, 30), blender);\n        canvas->translate(70, 70);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "73092d4d06faecea3c204d852a4dd8a8",
    "file": "SkPaint_Reference",
    "name": "Blend_Mode_Methods"
},
    "Paint_Color_Filter_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColorFilter(SkColorMatrixFilter::MakeLightingFilter(0xFFFFFF, 0xFF0000));\n    for (SkColor c : { SK_ColorBLACK, SK_ColorGREEN } ) {\n        paint.setColor(c);\n        canvas->drawRect(SkRect::MakeXYWH(10, 10, 50, 50), paint);\n        paint.setAlpha(0x80);\n        canvas->drawRect(SkRect::MakeXYWH(60, 60, 50, 50), paint);\n        canvas->translate(100, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "5abde56ca2f89a18b8e231abd1b57c56",
    "file": "SkPaint_Reference",
    "name": "Color_Filter_Methods"
},
    "Paint_Color_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(0x8000FF00);  // transparent green\n    canvas->drawCircle(50, 50, 40, paint);\n    paint.setARGB(128, 255, 0, 0); // transparent red\n    canvas->drawCircle(80, 50, 40, paint);\n    paint.setColor(SK_ColorBLUE);\n    paint.setAlpha(0x80);\n    canvas->drawCircle(65, 65, 40, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "214b559d75c65a7bef6ef4be1f860053",
    "file": "SkPaint_Reference",
    "name": "Color_Methods"
},
    "Paint_Device_Text": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocN32Pixels(24, 33);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorWHITE);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(20);\n    for (bool lcd : { false, true }) {\n        paint.setLCDRenderText(lcd);\n        for (bool subpixel : { false, true }) {\n            paint.setSubpixelText(subpixel);\n            offscreen.drawString(\",,,,\", 0, 4, paint);\n            offscreen.translate(0, 7);\n        }\n    }\n    canvas->drawBitmap(bitmap, 4, 12);\n    canvas->scale(9, 9);\n    canvas->drawBitmap(bitmap, 4, -1);\n}",
    "width": 256,
    "height": 256,
    "hash": "4606ae1be792d6bc46d496432f050ee9",
    "file": "SkPaint_Reference",
    "name": "Device_Text"
},
    "Paint_Dither": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bm16;\n    bm16.allocPixels(SkImageInfo::Make(32, 32, kRGB_565_SkColorType, kOpaque_SkAlphaType));\n    SkCanvas c16(bm16);\n    SkPaint colorPaint;\n    for (auto dither : { false, true } ) {\n        colorPaint.setDither(dither);\n        for (auto colors : { 0xFF333333, 0xFF666666, 0xFF999999, 0xFFCCCCCC } ) {\n            for (auto mask : { 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFFFF } ) {\n                 colorPaint.setColor(colors & mask);\n                 c16.drawRect({0, 0, 8, 4}, colorPaint);\n                 c16.translate(8, 0);\n            }\n            c16.translate(-32, 4);\n        }\n    }\n    canvas->scale(8, 8);\n    canvas->drawBitmap(bm16, 0, 0);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8b26507690b71462f44642b911890bbf",
    "file": "SkPaint_Reference",
    "name": "Dither"
},
    "Paint_Dither_a": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(0);\n    SkBitmap bm32;\n    bm32.allocPixels(SkImageInfo::Make(20, 10, kN32_SkColorType, kPremul_SkAlphaType));\n    SkCanvas c32(bm32);\n    SkPoint points[] = {{0, 0}, {20, 0}};\n    SkColor colors[] = {0xFF334455, 0xFF662211 };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(\n                     points, colors, nullptr, SK_ARRAY_COUNT(colors),\n                     SkShader::kClamp_TileMode, 0, nullptr));\n    paint.setDither(true);\n    c32.drawPaint(paint);\n    canvas->scale(12, 12);\n    canvas->drawBitmap(bm32, 0, 0);\n    paint.setBlendMode(SkBlendMode::kPlus);\n    canvas->drawBitmap(bm32, 0, 11, &paint);\n    canvas->drawBitmap(bm32, 0, 11, &paint);\n    canvas->drawBitmap(bm32, 0, 11, &paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "76d4d4a7931a48495e4d5f54e073be53",
    "file": "SkPaint_Reference",
    "name": "Dither_2"
},
    "Paint_Draw_Looper_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkLayerDrawLooper::LayerInfo info;\n    info.fPaintBits = (SkLayerDrawLooper::BitFlags) SkLayerDrawLooper::kColorFilter_Bit;\n    info.fColorMode = SkBlendMode::kSrc;\n    SkLayerDrawLooper::Builder looperBuilder;\n    SkPaint* loopPaint = looperBuilder.addLayer(info);\n    loopPaint->setColor(SK_ColorRED);\n    info.fOffset.set(20, 20);\n    loopPaint = looperBuilder.addLayer(info);\n    loopPaint->setColor(SK_ColorBLUE);\n    SkPaint paint;\n    paint.setDrawLooper(looperBuilder.detach());\n    canvas->drawCircle(50, 50, 50, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "84ec12a36e50df5ac565cc7a75ffbe9f",
    "file": "SkPaint_Reference",
    "name": "Draw_Looper_Methods"
},
    "Paint_Fake_Bold": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(40);\n    canvas->drawString(\"OjYy_-\", 10, 35, paint);\n    paint.setFakeBoldText(true);\n    canvas->drawString(\"OjYy_-\", 10, 75, paint);\n    // create a custom fake bold by varying the stroke width\n    paint.setFakeBoldText(false);\n    paint.setStyle(SkPaint::kStrokeAndFill_Style);\n    paint.setStrokeWidth(40.f / 48);\n    canvas->drawString(\"OjYy_-\", 10, 115, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "e811f4829a2daaaeaad3795504a7e02a",
    "file": "SkPaint_Reference",
    "name": "Fake_Bold"
},
    "Paint_Filter_Quality_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->scale(.2f, .2f);\n    for (SkFilterQuality q : { kNone_SkFilterQuality, kLow_SkFilterQuality,\n                               kMedium_SkFilterQuality, kHigh_SkFilterQuality } ) {\n        paint.setFilterQuality(q);\n        canvas->drawImage(image.get(), 0, 0, &paint);\n        canvas->translate(550, 0);\n        if (kLow_SkFilterQuality == q) canvas->translate(-1100, 550);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "69369cff2f5b145a6f616092513266a0",
    "file": "SkPaint_Reference",
    "name": "Filter_Quality_Methods"
},
    "Paint_Image_Filter_Methods": {
    "code": "#include \"SkBlurImageFilter.h\"\n\nvoid draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(2);\n    SkRegion region;\n    region.op( 10, 10, 50, 50, SkRegion::kUnion_Op);\n    region.op( 10, 50, 90, 90, SkRegion::kUnion_Op);\n    paint.setImageFilter(SkBlurImageFilter::Make(5.0f, 5.0f, nullptr));\n    canvas->drawRegion(region, paint);\n    paint.setImageFilter(nullptr);\n    paint.setMaskFilter(SkMaskFilter::MakeBlur(kNormal_SkBlurStyle, 5));\n    canvas->translate(100, 100);\n    canvas->drawRegion(region, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "ece04ee3d3761e3425f37c8f06f054c1",
    "file": "SkPaint_Reference",
    "name": "Image_Filter_Methods"
},
    "Paint_Mask_Filter_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setMaskFilter(SkMaskFilter::MakeBlur(kSolid_SkBlurStyle, 3));\n    canvas->drawRect(SkRect::MakeXYWH(40, 40, 175, 175), paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "55d7b9d482ac8e17a6153f555a8adb8d",
    "file": "SkPaint_Reference",
    "name": "Mask_Filter_Methods"
},
    "Paint_Miter_Limit": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pts[] = {{ 10, 50 }, { 110, 80 }, { 10, 110 }};\n    SkVector v[] = { pts[0] - pts[1], pts[2] - pts[1] };\n    SkScalar angle1 = SkScalarATan2(v[0].fY, v[0].fX);\n    SkScalar angle2 = SkScalarATan2(v[1].fY, v[1].fX);\n    const SkScalar strokeWidth = 20;\n    SkScalar miterLimit = 1 / SkScalarSin((angle2 - angle1) / 2);\n    SkScalar miterLength = strokeWidth * miterLimit;\n    SkPath path;\n    path.moveTo(pts[0]);\n    path.lineTo(pts[1]);\n    path.lineTo(pts[2]);\n    SkPaint paint;  // set to default kMiter_Join\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeMiter(miterLimit);\n    paint.setStrokeWidth(strokeWidth);\n    canvas->drawPath(path, paint);\n    paint.setStrokeWidth(1);\n    canvas->drawLine(pts[1].fX - miterLength / 2, pts[1].fY + 50,\n                     pts[1].fX + miterLength / 2, pts[1].fY + 50, paint);\n    canvas->translate(200, 0);\n    miterLimit *= 0.99f;\n    paint.setStrokeMiter(miterLimit);\n    paint.setStrokeWidth(strokeWidth);\n    canvas->drawPath(path, paint);\n    paint.setStrokeWidth(1);\n    canvas->drawLine(pts[1].fX - miterLength / 2, pts[1].fY + 50,\n                     pts[1].fX + miterLength / 2, pts[1].fY + 50, paint);\n}\n",
    "width": 384,
    "height": 170,
    "hash": "5de2de0f00354e59074a9bb1a42d5a63",
    "file": "SkPaint_Reference",
    "name": "Miter_Limit"
},
    "Paint_Path_Effect_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(16);\n    SkScalar intervals[] = {30, 10};\n    paint.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 1));\n    canvas->drawRoundRect({20, 20, 120, 120}, 20, 20, paint);\n}\n",
    "width": 256,
    "height": 160,
    "hash": "8cf5684b187d60f09e11c4a48993ea39",
    "file": "SkPaint_Reference",
    "name": "Path_Effect_Methods"
},
    "Paint_Shader_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkPoint center = { 50, 50 };\n   SkScalar radius = 50;\n   const SkColor colors[] = { 0xFFFFFFFF, 0xFF000000 };\n   paint.setShader(SkGradientShader::MakeRadial(center, radius, colors,\n        nullptr, SK_ARRAY_COUNT(colors), SkShader::kClamp_TileMode));\n   for (SkScalar a : { 0.3f, 0.6f, 1.0f } ) {\n       paint.setAlpha((int) (a * 255));\n       canvas->drawCircle(center.fX, center.fY, radius, paint);\n       canvas->translate(70, 70);\n   }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "c015dc2010c15e1c00b4f7330232b0f7",
    "file": "SkPaint_Reference",
    "name": "Shader_Methods"
},
    "Paint_Shader_Methods_a": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkBitmap bitmap;\n   bitmap.setInfo(SkImageInfo::MakeA8(5, 1), 5);  // bitmap only contains alpha\n   uint8_t pixels[5] = { 0x22, 0x55, 0x88, 0xBB, 0xFF };\n   bitmap.setPixels(pixels);\n   paint.setShader(SkShader::MakeBitmapShader(bitmap,\n            SkShader::kMirror_TileMode, SkShader::kMirror_TileMode));\n   for (SkColor c : { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN } ) {\n       paint.setColor(c);  // all components in color affect shader\n       canvas->drawCircle(50, 50, 50, paint);\n       canvas->translate(70, 70);\n   }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "fe80fd80b98a20823db7fb9a077243c7",
    "file": "SkPaint_Reference",
    "name": "Shader_Methods_2"
},
    "Paint_Stroke_Width": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    for (bool antialias : { false, true }) {\n        paint.setAntiAlias(antialias);\n        for (int width = 0; width <= 4; ++width) {\n            SkScalar offset = antialias * 100 + width * 20;\n            paint.setStrokeWidth(width * 0.25f);\n            canvas->drawLine(10 + offset,  10, 20 + offset,  60, paint);\n            canvas->drawLine(10 + offset, 110, 60 + offset, 160, paint);\n        }\n    }\n}\n",
    "width": 256,
    "height": 170,
    "hash": "5112c7209a19e035c61cef33a624a652",
    "file": "SkPaint_Reference",
    "name": "Stroke_Width"
},
    "Paint_Text_Encoding": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    const char hello8[] = \"Hello\" \"\\xE2\" \"\\x98\" \"\\xBA\";\n    const uint16_t hello16[] = { 'H', 'e', 'l', 'l', 'o', 0x263A };\n    const uint32_t hello32[] = { 'H', 'e', 'l', 'l', 'o', 0x263A };\n    paint.setTextSize(24);\n    canvas->drawText(hello8, sizeof(hello8) - 1, 10, 30, paint);\n    paint.setTextEncoding(SkTextEncoding::kUTF16);\n    canvas->drawText(hello16, sizeof(hello16), 10, 60, paint);\n    paint.setTextEncoding(SkTextEncoding::kUTF32);\n    canvas->drawText(hello32, sizeof(hello32), 10, 90, paint);\n    uint16_t glyphs[SK_ARRAY_COUNT(hello32)];\n    paint.textToGlyphs(hello32, sizeof(hello32), glyphs);\n    paint.setTextEncoding(SkTextEncoding::kGlyphID);\n    canvas->drawText(glyphs, sizeof(glyphs), 10, 120, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "767fa4e7b6300e16a419f9881f0f9d3d",
    "file": "SkPaint_Reference",
    "name": "Text_Encoding"
},
    "Paint_Text_Scale_X": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    paint.setTextScaleX(.8f);\n    canvas->drawString(\"narrow\", 10, 20, paint);\n    paint.setTextScaleX(1);\n    canvas->drawString(\"normal\", 10, 60, paint);\n    paint.setTextScaleX(1.2f);\n    canvas->drawString(\"wide\", 10, 100, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "d13d787c1e36f515319fc998411c1d91",
    "file": "SkPaint_Reference",
    "name": "Text_Scale_X"
},
    "Paint_Text_Size": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->drawString(\"12 point\", 10, 20, paint);\n    paint.setTextSize(24);\n    canvas->drawString(\"24 point\", 10, 60, paint);\n    paint.setTextSize(48);\n    canvas->drawString(\"48 point\", 10, 120, paint);\n}\n",
    "width": 256,
    "height": 135,
    "hash": "91c9a3e498bb9412e4522a95d076ed5f",
    "file": "SkPaint_Reference",
    "name": "Text_Size"
},
    "Paint_Text_Skew_X": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    paint.setTextSkewX(-.25f);\n    canvas->drawString(\"right-leaning\", 10, 100, paint);\n    paint.setTextSkewX(0);\n    canvas->drawString(\"normal\", 10, 60, paint);\n    paint.setTextSkewX(.25f);\n    canvas->drawString(\"left-leaning\", 10, 20, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "aff208b0aab265f273045b27e683c17c",
    "file": "SkPaint_Reference",
    "name": "Text_Skew_X"
},
    "Paint_Typeface_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTypeface(SkTypeface::MakeFromName(nullptr, SkFontStyle()));\n    paint.setAntiAlias(true);\n    paint.setTextSize(36);\n    canvas->drawString(\"A Big Hello!\", 10, 40, paint);\n    paint.setTypeface(nullptr);\n    paint.setFakeBoldText(true);\n    canvas->drawString(\"A Big Hello!\", 10, 80, paint);\n}\n",
    "width": 256,
    "height": 100,
    "hash": "1a7a5062725139760962582f599f1b97",
    "file": "SkPaint_Reference",
    "name": "Typeface_Methods"
},
    "Path_Arc": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect oval = {8, 8, 56, 56};\n    SkPaint ovalPaint;\n    ovalPaint.setAntiAlias(true);\n    SkPaint textPaint(ovalPaint);\n    ovalPaint.setStyle(SkPaint::kStroke_Style);\n    SkPaint arcPaint(ovalPaint);\n    arcPaint.setStrokeWidth(5);\n    arcPaint.setColor(SK_ColorBLUE);\n    canvas->translate(-64, 0);\n    for (char arcStyle = '1'; arcStyle <= '6'; ++arcStyle) {\n        '4' == arcStyle ? canvas->translate(-96, 55) : canvas->translate(64, 0);\n        canvas->drawText(&arcStyle, 1, 30, 36, textPaint);\n        canvas->drawOval(oval, ovalPaint);\n        SkPath path;\n        path.moveTo({56, 32});\n        switch (arcStyle) {\n            case '1':\n                path.arcTo(oval, 0, 90, false);\n                break;\n            case '2':\n                canvas->drawArc(oval, 0, 90, false, arcPaint);\n                continue;\n            case '3':\n                path.addArc(oval, 0, 90);\n                break;\n            case '4':\n                path.arcTo({56, 56}, {32, 56}, 24);\n                break;\n            case '5':\n                path.arcTo({24, 24}, 0, SkPath::kSmall_ArcSize, SkPath::kCW_Direction, {32, 56});\n                break;\n            case '6':\n                path.conicTo({56, 56}, {32, 56}, SK_ScalarRoot2Over2);\n                break;\n         }\n         canvas->drawPath(path, arcPaint);\n     }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "5acc77eba0cb4d00bbf3a8f4db0c0aee",
    "file": "SkPath_Reference",
    "name": "Arc"
},
    "Path_Cubic": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPoint cubicPts[] = {{20, 150}, {90, 10}, {160, 150}, {230, 10}};\n    SkColor colors[] = { 0xff88ff00, 0xff0088bb, 0xff6600cc, 0xffbb3377 };\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(colors); ++i) {\n        paint.setColor(0x7fffffff & colors[i]);\n        paint.setStrokeWidth(1);\n        for (unsigned j = 0; j < 3; ++j) {\n            canvas->drawLine(cubicPts[j], cubicPts[j + 1], paint);\n        }\n        SkPath path;\n        path.moveTo(cubicPts[0]);\n        path.cubicTo(cubicPts[1], cubicPts[2], cubicPts[3]);\n        paint.setStrokeWidth(3);\n        paint.setColor(colors[i]);\n        canvas->drawPath(path, paint);\n        cubicPts[1].fY += 30;\n        cubicPts[2].fX += 30;\n   }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "466445ed991d86de08587066392d654a",
    "file": "SkPath_Reference",
    "name": "Cubic"
},
    "Path_Overview": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    path.moveTo(124, 108);\n    path.lineTo(172, 24);\n    path.addCircle(50, 50, 30);\n    path.moveTo(36, 148);\n    path.quadTo(66, 188, 120, 136);\n    canvas->drawPath(path, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStrokeWidth(3);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 192,
    "hash": "93887af0c1dac49521972698cf04069c",
    "file": "SkPath_Overview",
    "name": "Path_Overview"
},
    "Path_Overview_Contour": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawString(\"1st contour\", 150, 100, paint);\n    canvas->drawString(\"2nd contour\", 130, 160, paint);\n    canvas->drawString(\"3rd contour\", 40, 30, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(124, 108);\n    path.lineTo(172, 24);\n    path.moveTo(36, 148);\n    path.quadTo(66, 188, 120, 136);\n    path.close();\n    path.conicTo(70, 20, 110, 40, 0.6f);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 192,
    "hash": "0374f2dcd7effeb1dd435205a6c2de6f",
    "file": "SkPath_Overview",
    "name": "Contour"
},
    "Path_Overview_Contour_Zero_Length": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(8);\n    paint.setStrokeCap(SkPaint::kRound_Cap);\n    SkPath path;\n    path.moveTo(36, 48);\n    path.lineTo(36, 48);\n    canvas->drawPath(path, paint);\n    path.reset();\n    paint.setStrokeCap(SkPaint::kSquare_Cap);\n    path.moveTo(56, 48);\n    path.close();\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "62848df605af6258653d9e16b27d8f7f",
    "file": "SkPath_Overview",
    "name": "Contour_Zero_Length"
},
    "Path_Overview_Contour_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(8);\n    SkPath path;\n    path.moveTo(36, 48);\n    path.quadTo(66, 88, 120, 36);\n    canvas->drawPath(path, paint);\n    path.close();\n    canvas->translate(0, 50);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 160,
    "hash": "7a1f39b12d2cd8b7f5b1190879259cb2",
    "file": "SkPath_Overview",
    "name": "Contour_2"
},
    "Path_Overview_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    path.moveTo(36, 48);\n    path.quadTo(66, 88, 120, 36);\n    canvas->drawPath(path, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStrokeWidth(8);\n    canvas->translate(0, 50);\n    canvas->drawPath(path, paint);\n    paint.setStyle(SkPaint::kStrokeAndFill_Style);\n    paint.setColor(SK_ColorRED);\n    canvas->translate(0, 50);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 192,
    "hash": "36a995442c081ee779ecab2962d36e69",
    "file": "SkPath_Overview",
    "name": "Path_Overview_2"
},
    "Path_Quad": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPoint quadPts[] = {{20, 90}, {120, 10}, {220, 90}};\n    canvas->drawLine(quadPts[0], quadPts[1], paint);\n    canvas->drawLine(quadPts[1], quadPts[2], paint);\n    SkPath path;\n    path.moveTo(quadPts[0]);\n    path.quadTo(quadPts[1], quadPts[2]);\n    paint.setStrokeWidth(3);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 110,
    "hash": "78ad51fa1cd33eb84a6f99061e56e067",
    "file": "SkPath_Reference",
    "name": "Quad"
},
    "Path_Quad_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPoint quadPts[] = {{20, 150}, {120, 10}, {220, 150}};\n    SkColor colors[] = { 0xff88ff00, 0xff0088bb, 0xff6600cc, 0xffbb3377 };\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(colors); ++i) {\n        paint.setColor(0x7fffffff & colors[i]);\n        paint.setStrokeWidth(1);\n        canvas->drawLine(quadPts[0], quadPts[1], paint);\n        canvas->drawLine(quadPts[1], quadPts[2], paint);\n        SkPath path;\n        path.moveTo(quadPts[0]);\n        path.quadTo(quadPts[1], quadPts[2]);\n        paint.setStrokeWidth(3);\n        paint.setColor(colors[i]);\n        canvas->drawPath(path, paint);\n        quadPts[1].fY += 30;\n   }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "4082f66a42df11bb20462b232b156bb6",
    "file": "SkPath_Reference",
    "name": "Quad_2"
},
    "SkAutoCanvasRestore_SkCanvas_star": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(64);\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            SkMatrix m = SkMatrix::MakeAll(sx, 1, 96,    0, sy, 64,   0, 0, 1);\n            canvas->concat(m);\n            canvas->drawString(\"R\", 0, 0, p);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "466ef576b88e29d7252422db7adeed1c",
    "file": "SkAutoCanvasRestore_Reference",
    "name": "SkAutoCanvasRestore::SkAutoCanvasRestore(SkCanvas* canvas, bool doSave)"
},
    "SkBitmap_allocN32Pixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRandom random;\n    SkBitmap bitmap;\n    bitmap.allocN32Pixels(64, 64);\n    bitmap.eraseColor(SK_ColorTRANSPARENT);\n    for (int y = 0; y < 256; y += 64) {\n        for (int x = 0; x < 256; x += 64) {\n            SkColor color = random.nextU();\n            uint32_t w = random.nextRangeU(4, 32);\n            uint32_t cx = random.nextRangeU(0, 64 - w);\n            uint32_t h = random.nextRangeU(4, 32);\n            uint32_t cy = random.nextRangeU(0, 64 - h);\n            bitmap.erase(color, SkIRect::MakeXYWH(cx, cy, w, h));\n            canvas->drawBitmap(bitmap, x, y);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "c717491f9251604724c9cbde7088ec20",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocN32Pixels"
},
    "SkBitmap_allocPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    SkImageInfo info = SkImageInfo::Make(256, 64, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    bitmap.allocPixels(info, info.width() * info.bytesPerPixel() + 64);\n    SkCanvas offscreen(bitmap);\n    offscreen.scale(.5f, .5f);\n    for (int y : { 0, 64, 128, 192 } ) {\n        offscreen.drawBitmap(source, 0, -y);\n        canvas->drawBitmap(bitmap, 0, y);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "555c0f62f96602a9dcd459badcd005e0",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocPixels"
},
    "SkBitmap_allocPixelsFlags": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixelsFlags(SkImageInfo::MakeN32(44, 16, kPremul_SkAlphaType),\n                            SkBitmap::kZeroPixels_AllocFlag);\n    SkCanvas offscreen(bitmap);\n    SkPaint paint;\n    offscreen.drawString(\"!@#$%\", 0, 12, paint);\n    canvas->scale(6, 6);\n    canvas->drawBitmap(bitmap, 0, 0);\n    canvas->drawBitmap(bitmap, 8, 8);\n}",
    "width": 256,
    "height": 128,
    "hash": "737e721c7d9e0f367d25521a1b823b9d",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocPixelsFlags"
},
    "SkBitmap_allocPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::Make(64, 64, kGray_8_SkColorType, kOpaque_SkAlphaType));\n    SkCanvas offscreen(bitmap);\n    offscreen.scale(.5f, .5f);\n    for (int y : { 0, 64, 128, 192 } ) {\n        offscreen.drawBitmap(source, -y, -y);\n        canvas->drawBitmap(bitmap, y, y);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "91f474a11a2112cd5c88c40a9015048d",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocPixels_2"
},
    "SkBitmap_allocPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t set1[5] = { 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 };\n    uint8_t set2[5] = { 0xAC, 0xA8, 0x89, 0x47, 0x87 };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::Make(5, 1, kGray_8_SkColorType, kOpaque_SkAlphaType), set1, 5);\n    canvas->scale(10, 50);\n    canvas->drawBitmap(bitmap, 0, 0);\n    bitmap.allocPixels();\n    bitmap.eraseColor(SK_ColorBLACK);\n    canvas->drawBitmap(bitmap, 8, 0);\n    bitmap.setPixels(set2);\n    canvas->drawBitmap(bitmap, 16, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "1219b38c788bf270fb20f8cd2d78cff8",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocPixels_3"
},
    "SkBitmap_allocPixels_4": {
    "code": "class TinyAllocator : public SkBitmap::Allocator {\npublic:\n    bool allocPixelRef(SkBitmap* bitmap) override {\n        const SkImageInfo& info = bitmap->info();\n        if (info.height() * info.minRowBytes() > sizeof(storage)) {\n            return false;\n        }\n        sk_sp<SkPixelRef> pr = sk_sp<SkPixelRef>(\n                new SkPixelRef(info.width(), info.height(), storage, info.minRowBytes()));\n        bitmap->setPixelRef(std::move(pr), 0, 0);\n        return true;\n    }\n    char storage[16];\n};\n\nvoid draw(SkCanvas* canvas) {\n   TinyAllocator tinyAllocator;\n   SkBitmap bitmap;\n   bitmap.setInfo(SkImageInfo::MakeN32(2, 2, kOpaque_SkAlphaType));\n   if (bitmap.tryAllocPixels(&tinyAllocator)) {\n       bitmap.eraseColor(0xff55aa33);\n       bitmap.erase(0xffaa3355, SkIRect::MakeXYWH(1, 1, 1, 1));\n       canvas->scale(16, 16);\n       canvas->drawBitmap(bitmap, 0, 0);\n   }\n}\n",
    "width": 256,
    "height": 32,
    "hash": "1b2800d23c9ea249b45c2c21a34b6d14",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocPixels_4"
},
    "SkBitmap_bounds": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(.5f, .5f);\n    SkIRect bounds = source.bounds();\n    for (int x : { 0, bounds.width() } ) {\n        for (int y : { 0, bounds.height() } ) {\n            canvas->drawBitmap(source, x, y);\n        }\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "3e9126152ff1cc592aef6facbcb5fc96",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::bounds()"
},
    "SkBitmap_erase": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32(2, 2, kPremul_SkAlphaType));\n    bitmap.erase(0x7fff7f3f, SkIRect::MakeWH(1, 1));\n    bitmap.erase(0x7f7f3fff, SkIRect::MakeXYWH(0, 1, 1, 1));\n    bitmap.erase(0x7f3fff7f, SkIRect::MakeXYWH(1, 0, 1, 1));\n    bitmap.erase(0x7f1fbf5f, SkIRect::MakeXYWH(1, 1, 1, 1));\n    canvas->scale(25, 25);\n    canvas->drawBitmap(bitmap, 0, 0);\n    canvas->drawBitmap(bitmap, .5f, .5f);\n}",
    "width": 256,
    "height": 70,
    "hash": "2c5c4230ccd2861a5d15b7cd2764ab6e",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::erase()"
},
    "SkBitmap_eraseARGB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32(1, 1, kPremul_SkAlphaType));\n    bitmap.eraseARGB(0x7f, 0xff, 0x7f, 0x3f);\n    canvas->scale(50, 50);\n    canvas->drawBitmap(bitmap, 0, 0);\n    canvas->drawBitmap(bitmap, .5f, .5f);\n}",
    "width": 256,
    "height": 80,
    "hash": "67277b0a1003f340473a35982533561c",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::eraseARGB"
},
    "SkBitmap_eraseColor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32(1, 1, kOpaque_SkAlphaType));\n    bitmap.eraseColor(SK_ColorRED);\n    canvas->scale(16, 16);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 20,
    "hash": "418928dbfffa9eb00c8225530f44baf5",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::eraseColor"
},
    "SkBitmap_extractAlpha": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap alpha, bitmap;\n    bitmap.allocN32Pixels(100, 100);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(0);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    offscreen.drawCircle(50, 50, 39, paint);\n    offscreen.flush();\n    bitmap.extractAlpha(&alpha);\n    paint.setColor(SK_ColorRED);\n    canvas->drawBitmap(bitmap, 0, 0, &paint);\n    canvas->drawBitmap(alpha, 100, 0, &paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "ab6577df079e6c70511cf2bfc6447b44",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::extractAlpha"
},
    "SkBitmap_extractAlpha_2": {
    "code": "void draw(SkCanvas* canvas) {\n    auto radiusToSigma = [](SkScalar radius) -> SkScalar {\n         static const SkScalar kBLUR_SIGMA_SCALE = 0.57735f;\n         return radius > 0 ? kBLUR_SIGMA_SCALE * radius + 0.5f : 0.0f;\n    };\n    SkBitmap alpha, bitmap;\n    bitmap.allocN32Pixels(100, 100);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(0);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    offscreen.drawCircle(50, 50, 39, paint);\n    offscreen.flush();\n    paint.setMaskFilter(SkMaskFilter::MakeBlur(kNormal_SkBlurStyle, radiusToSigma(25)));\n    SkIPoint offset;\n    bitmap.extractAlpha(&alpha, &paint, &offset);\n    paint.setColor(SK_ColorRED);\n    canvas->drawBitmap(bitmap, 0, -offset.fY, &paint);\n    canvas->drawBitmap(alpha, 100 + offset.fX, 0, &paint);\n}",
    "width": 256,
    "height": 160,
    "hash": "092739b4cd5d732a27c07ced8ef45f01",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::extractAlpha_2"
},
    "SkBitmap_extractAlpha_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap alpha, bitmap;\n    bitmap.allocN32Pixels(100, 100);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(0);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    offscreen.drawCircle(50, 50, 39, paint);\n    offscreen.flush();\n    paint.setMaskFilter(SkMaskFilter::MakeBlur(kOuter_SkBlurStyle, 3));\n    SkIPoint offset;\n    bitmap.extractAlpha(&alpha, &paint, nullptr, &offset);\n    paint.setColor(SK_ColorRED);\n    canvas->drawBitmap(bitmap, 0, -offset.fY, &paint);\n    canvas->drawBitmap(alpha, 100 + offset.fX, 0, &paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "cd7543fa8c9f3cede46dc2d72eb8c4bd",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::extractAlpha_3"
},
    "SkBitmap_getBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect bounds;\n    source.getBounds(&bounds);\n    bounds.offset(100, 100);\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    canvas->scale(.25f, .25f);\n    canvas->drawRect(bounds, paint);\n    canvas->drawBitmap(source, 40, 40);\n}",
    "width": 256,
    "height": 160,
    "hash": "2431ebc7e7d1e91e6d9daafd0f7a478f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getBounds"
},
    "SkBitmap_getBounds_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect bounds;\n    source.getBounds(&bounds);\n    bounds.inset(100, 100);\n    SkBitmap bitmap;\n    source.extractSubset(&bitmap, bounds);\n    canvas->scale(.5f, .5f);\n    canvas->drawBitmap(bitmap, 10, 10);\n}",
    "width": 256,
    "height": 256,
    "hash": "0c45da35172bc0a529b2faecddae62a2",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getBounds_2"
},
    "SkBitmap_installPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n   SkRandom random;\n   SkBitmap bitmap;\n   const int width = 8;\n   const int height = 8;\n   uint32_t pixels[width * height];\n   for (unsigned x = 0; x < width * height; ++x) {\n       pixels[x] = random.nextU();\n   }\n   SkImageInfo info = SkImageInfo::MakeN32(width, height, kUnpremul_SkAlphaType);\n   if (bitmap.installPixels(info, pixels, info.minRowBytes())) {\n       canvas->scale(32, 32);\n       canvas->drawBitmap(bitmap, 0, 0);\n   }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "a7e04447b2081010c50d7920e80a6bb2",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::installPixels_2"
},
    "SkBitmap_installPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t storage[][5] = {{ 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 },\n                            { 0xAC, 0xA8, 0x89, 0x47, 0x87 },\n                            { 0x4B, 0x25, 0x25, 0x25, 0x46 },\n                            { 0x90, 0x81, 0x25, 0x41, 0x33 },\n                            { 0x75, 0x55, 0x44, 0x20, 0x00 }};\n    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->scale(10, 10);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *pixmap.writable_addr8(2, 2) = 0xFF;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 10, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "6e2a8c9358b34aebd2ec586815fe9d3a",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::installPixels_3"
},
    "SkBitmap_notifyPixelsChanged": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::Make(1, 1, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));\n    bitmap.allocPixels();\n    bitmap.eraseColor(SK_ColorRED);\n    canvas->scale(16, 16);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *(SkPMColor*) bitmap.getPixels() = SkPreMultiplyColor(SK_ColorBLUE);\n    canvas->drawBitmap(bitmap, 2, 0);\n    bitmap.notifyPixelsChanged();\n    *(SkPMColor*) bitmap.getPixels() = SkPreMultiplyColor(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 4, 0);\n}",
    "width": 256,
    "height": 20,
    "hash": "8f463ed17b0ed4fb9c503a0ec71706f9",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::notifyPixelsChanged"
},
    "SkBitmap_readPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 256;\n    const int height = 64;\n    SkImageInfo srcInfo = SkImageInfo::MakeN32Premul(width, height);\n    SkColor  gradColors[] = { 0xFFAA3300, 0x7F881122 };\n    SkPoint  gradPoints[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,\n                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));\n    SkBitmap bitmap;\n    bitmap.allocPixels(srcInfo);\n    SkCanvas srcCanvas(bitmap);\n    srcCanvas.drawRect(SkRect::MakeWH(width, height), paint);\n    canvas->drawBitmap(bitmap, 0, 0);\n    SkImageInfo dstInfo = srcInfo.makeColorType(kARGB_4444_SkColorType);\n    std::vector<int16_t> dstPixels;\n    dstPixels.resize(height * width);\n    bitmap.readPixels(dstInfo, &dstPixels.front(), width * 2, 0, 0);\n    SkPixmap dstPixmap(dstInfo, &dstPixels.front(), width * 2);\n    bitmap.installPixels(dstPixmap);\n    canvas->drawBitmap(bitmap, 0, 64);\n}",
    "width": 256,
    "height": 128,
    "hash": "b2cbbbbcffb618865d8aae3bc04b2a62",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::readPixels"
},
    "SkBitmap_readPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    srcPixels.resize(source.height() * source.rowBytes());\n    for (int y = 0; y < 4; ++y) {\n        for (int x = 0; x < 4; ++x) {\n            SkPixmap pixmap(SkImageInfo::MakeN32Premul(source.width() / 4, source.height() / 4),\n                    &srcPixels.front() + x * source.height() * source.width() / 4 +\n                    y * source.width() / 4, source.rowBytes());\n            source.readPixels(pixmap, x * source.width() / 4, y * source.height() / 4);\n        }\n    }\n    canvas->scale(.5f, .5f);\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(source.width(), source.height()),\n                             &srcPixels.front(), source.rowBytes());\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "e9f70cbc9827097449a386ec7a8a8188",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::readPixels_2"
},
    "SkBitmap_readPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    srcPixels.resize(source.height() * source.width() * 8);\n    for (int i = 0;  i < 2; ++i) {\n    SkPixmap pixmap(SkImageInfo::Make(source.width() * 2, source.height(),\n                    i ? kRGBA_8888_SkColorType : kBGRA_8888_SkColorType, kPremul_SkAlphaType),\n                    &srcPixels.front() + i * source.width(), source.rowBytes() * 2);\n        source.readPixels(pixmap);\n    }\n    canvas->scale(.25f, .25f);\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(source.width() * 2, source.height()),\n                         &srcPixels.front(), source.rowBytes() * 2);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 128,
    "hash": "4590fbf052659d6e629fbfd827081ae5",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::readPixels_3"
},
    "SkBitmap_readyToDraw": {
    "code": "void draw(SkCanvas* canvas) {\n    if (source.readyToDraw()) {\n        canvas->drawBitmap(source, 10, 10);\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "e89c78ca992e2e789ed50944fe68f920",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::readyToDraw"
},
    "SkBitmap_setInfo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(44, 16, kOpaque_SkAlphaType));\n    bitmap.allocPixels();\n    bitmap.eraseColor(SK_ColorGREEN);\n    SkCanvas offscreen(bitmap);\n    SkPaint paint;\n    offscreen.drawString(\"!@#$%\", 0, 12, paint);\n    canvas->scale(6, 6);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 96,
    "hash": "599ab64d0aea005498176249bbfb64eb",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setInfo"
},
    "SkBitmap_setIsVolatile": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::Make(1, 1, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));\n    bitmap.allocPixels();\n    bitmap.eraseColor(SK_ColorRED);\n    canvas->scale(16, 16);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *(SkPMColor*) bitmap.getPixels() = SkPreMultiplyColor(SK_ColorBLUE);\n    canvas->drawBitmap(bitmap, 2, 0);\n    bitmap.setIsVolatile(true);\n    *(SkPMColor*) bitmap.getPixels() = SkPreMultiplyColor(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 4, 0);\n}",
    "width": 256,
    "height": 20,
    "hash": "e8627a4df659b896402f89a91326618f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setIsVolatile"
},
    "SkBitmap_setPixelRef": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::Make(source.width() - 5, source.height() - 5,\n                   kGray_8_SkColorType, kOpaque_SkAlphaType), source.rowBytes());\n    bitmap.setPixelRef(sk_ref_sp(source.pixelRef()), 5, 5);\n    canvas->drawBitmap(bitmap, 10, 10);\n}",
    "width": 256,
    "height": 140,
    "hash": "f98cc0451c6e77a8833d261c9a484c5f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setPixelRef"
},
    "SkBitmap_setPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t set1[5] = { 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 };\n    uint8_t set2[5] = { 0xAC, 0xA8, 0x89, 0x47, 0x87 };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::Make(5, 1, kGray_8_SkColorType, kOpaque_SkAlphaType), set1, 5);\n    canvas->scale(10, 50);\n    canvas->drawBitmap(bitmap, 0, 0);\n    bitmap.setPixels(set2);\n    canvas->drawBitmap(bitmap, 10, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "f0db16e06c9a1436917c8179f8c1718f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setPixels"
},
    "SkBitmap_tryAllocN32Pixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    if (bitmap.tryAllocN32Pixels(80, 80)) {\n        bitmap.eraseColor(SK_ColorTRANSPARENT);\n        bitmap.erase(0x7f3f7fff, SkIRect::MakeWH(50, 30));\n        bitmap.erase(0x3f7fff3f, SkIRect::MakeXYWH(20, 10, 50, 30));\n        bitmap.erase(0x5fff3f7f, SkIRect::MakeXYWH(40, 20, 50, 30));\n        canvas->drawBitmap(bitmap, 0, 0);\n        for (int x : { 0, 30, 60, 90 } ) {\n            canvas->drawBitmap(bitmap, x, 70);\n        }\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "a2b1e0910f37066f15ae56368775a6d8",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocN32Pixels"
},
    "SkBitmap_tryAllocPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    SkImageInfo info = SkImageInfo::Make(64, 256, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    if (bitmap.tryAllocPixels(info, 0)) {\n        SkCanvas offscreen(bitmap);\n        offscreen.scale(.5f, .5f);\n        for (int x : { 0, 64, 128, 192 } ) {\n            offscreen.drawBitmap(source, -x, 0);\n            canvas->drawBitmap(bitmap, x, 0);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "34479d5aa23ce9f5e334b0786c9edb22",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocPixels"
},
    "SkBitmap_tryAllocPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    if (bitmap.tryAllocPixels(SkImageInfo::Make(64, 64, kGray_8_SkColorType, kOpaque_SkAlphaType))) {\n        SkCanvas offscreen(bitmap);\n        offscreen.scale(.25f, .5f);\n        for (int y : { 0, 64, 128, 192 } ) {\n            offscreen.drawBitmap(source, -y, -y);\n            canvas->drawBitmap(bitmap, y, y);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "7ef3d043c4c5885649e591dd7dca92ff",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocPixels_2"
},
    "SkBitmap_tryAllocPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t set1[5] = { 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::Make(5, 1, kGray_8_SkColorType, kOpaque_SkAlphaType), set1, 5);\n    canvas->scale(10, 50);\n    canvas->drawBitmap(bitmap, 0, 0);\n    if (bitmap.tryAllocPixels()) {\n        bitmap.eraseColor(SK_ColorBLACK);\n        canvas->drawBitmap(bitmap, 8, 0);\n        bitmap.setPixels(set1);\n        canvas->drawBitmap(bitmap, 16, 0);\n    }\n}",
    "width": 256,
    "height": 50,
    "hash": "720e4c053fae9e929ab6518b47e49370",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocPixels_3"
},
    "SkBitmap_tryAllocPixels_4": {
    "code": "class LargePixelRef : public SkPixelRef {\npublic:\n    LargePixelRef(const SkImageInfo& info, char* storage, size_t rowBytes)\n        : SkPixelRef(info.width(), info.height(), storage, rowBytes) {\n    }\n    ~LargePixelRef() override {\n        delete[] (char* ) this->pixels();\n    }\n};\nclass LargeAllocator : public SkBitmap::Allocator {\npublic:\n    bool allocPixelRef(SkBitmap* bitmap) override {\n        const SkImageInfo& info = bitmap->info();\n        uint64_t rowBytes = info.minRowBytes64();\n        uint64_t size = info.height() * rowBytes;\n        char* addr = new char[size];\n        if (nullptr == addr) {\n            return false;\n        }\n        sk_sp<SkPixelRef> pr = sk_sp<SkPixelRef>(new LargePixelRef(info, addr, rowBytes));\n        if (!pr) {\n            return false;\n        }\n        bitmap->setPixelRef(std::move(pr), 0, 0);\n        return true;\n    }\n};\n\nvoid draw(SkCanvas* canvas) {\n   LargeAllocator largeAllocator;\n   SkBitmap bitmap;\n   int width = 100; // make this 20000\n   int height = 100; // and this 100000 to allocate 8 gigs on a 64-bit platform\n   bitmap.setInfo(SkImageInfo::MakeN32(width, height, kOpaque_SkAlphaType));\n   if (bitmap.tryAllocPixels(&largeAllocator)) {\n       bitmap.eraseColor(0xff55aa33);\n       canvas->drawBitmap(bitmap, 0, 0);\n   }\n}\n",
    "width": 256,
    "height": 100,
    "hash": "eb6f861ca1839146d26e40d56c2a001c",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocPixels_4"
},
    "SkBitmap_writePixels": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    int width = image->width();\n    int height = image->height();\n    srcPixels.resize(height * width  * 4);\n    SkPixmap pixmap(SkImageInfo::MakeN32Premul(width, height), (const void*) &srcPixels.front(),\n                    width * 4);\n    image->readPixels(pixmap, 0, 0);\n    canvas->scale(.5f, .5f);\n    width /= 4;\n    height /= 4;\n    for (int y = 0; y < 4; ++y) {\n        for (int x = 0; x < 4; ++x) {\n            SkBitmap bitmap;\n            bitmap.allocPixels(SkImageInfo::MakeN32Premul(width, height));\n            bitmap.writePixels(pixmap, -y * width, -x * height);\n            canvas->drawBitmap(bitmap, x * width, y * height);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "9b3133a6673d2514d166398adbe1f9f4",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::writePixels"
},
    "SkBitmap_writePixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(2, 2));\n    bitmap.eraseColor(SK_ColorGREEN);\n    SkPMColor color = 0xFF5599BB;\n    SkPixmap src(SkImageInfo::MakeN32Premul(1, 1), &color, 4);\n    bitmap.writePixels(src);\n    canvas->scale(40, 40);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 80,
    "hash": "faa5dfa466f6e16c07c124d971f32679",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::writePixels_2"
},
    "SkCanvas_PointMode": {
    "code": "void draw(SkCanvas* canvas) {\n  SkPaint paint;\n  paint.setStyle(SkPaint::kStroke_Style);\n  paint.setStrokeWidth(10);\n  SkPoint points[] = {{64, 32}, {96, 96}, {32, 96}};\n  canvas->drawPoints(SkCanvas::kPoints_PointMode, 3, points, paint);\n  canvas->translate(128, 0);\n  canvas->drawPoints(SkCanvas::kLines_PointMode, 3, points, paint);\n  canvas->translate(0, 128);\n  canvas->drawPoints(SkCanvas::kPolygon_PointMode, 3, points, paint);\n  SkPath path;\n  path.addPoly(points, 3, false);\n  canvas->translate(-128, 0);\n  canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "292b4b2008961b6f612434d3121fc4ce",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::PointMode"
},
    "SkCanvas_SaveLayerFlagsSet": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint redPaint, bluePaint, scalePaint;\n    redPaint.setColor(SK_ColorRED);\n    canvas->drawCircle(21, 21, 8, redPaint);\n    bluePaint.setColor(SK_ColorBLUE);\n    canvas->drawCircle(31, 21, 8, bluePaint);\n    SkMatrix matrix;\n    matrix.setScale(4, 4);\n    scalePaint.setAlpha(0x40);\n    scalePaint.setImageFilter(\n            SkImageFilter::MakeMatrixFilter(matrix, kNone_SkFilterQuality, nullptr));\n    SkCanvas::SaveLayerRec saveLayerRec(nullptr, &scalePaint,\n            SkCanvas::kInitWithPrevious_SaveLayerFlag);\n    canvas->saveLayer(saveLayerRec);\n    canvas->restore();\n}\n",
    "width": 256,
    "height": 160,
    "hash": "05db6a937225e8e31ae3481173d25dae",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SaveLayerFlagsSet"
},
    "SkCanvas_SaveLayerRec": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint redPaint, bluePaint;\n    redPaint.setAntiAlias(true);\n    redPaint.setColor(SK_ColorRED);\n    canvas->drawCircle(21, 21, 8, redPaint);\n    bluePaint.setColor(SK_ColorBLUE);\n    canvas->drawCircle(31, 21, 8, bluePaint);\n    SkMatrix matrix;\n    matrix.setScale(4, 4);\n    auto scaler = SkImageFilter::MakeMatrixFilter(matrix, kNone_SkFilterQuality, nullptr);\n    SkCanvas::SaveLayerRec saveLayerRec(nullptr, nullptr, scaler.get(), 0);\n    canvas->saveLayer(saveLayerRec);\n    canvas->drawCircle(125, 85, 8, redPaint);\n    canvas->restore();\n}\n",
    "width": 256,
    "height": 160,
    "hash": "ee8c0b120234e27364f8c9a786cf8f89",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SaveLayerRec"
},
    "SkCanvas_SrcRectConstraint": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap redBorder;\n    redBorder.allocPixels(SkImageInfo::MakeN32Premul(4, 4));\n    SkCanvas checkRed(redBorder);\n    checkRed.clear(SK_ColorRED);\n    uint32_t checkers[][2] = { { SK_ColorBLACK, SK_ColorWHITE },\n                               { SK_ColorWHITE, SK_ColorBLACK } };\n    checkRed.writePixels(\n            SkImageInfo::MakeN32Premul(2, 2), (void*) checkers, sizeof(checkers[0]), 1, 1);\n    canvas->scale(16, 16);\n    canvas->drawBitmap(redBorder, 0, 0, nullptr);\n    canvas->resetMatrix();\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(redBorder);\n    SkPaint lowPaint;\n    lowPaint.setFilterQuality(kLow_SkFilterQuality);\n    for (auto constraint : { SkCanvas::kStrict_SrcRectConstraint,\n                             SkCanvas::kFast_SrcRectConstraint } ) {\n        canvas->translate(80, 0);\n        canvas->drawImageRect(image.get(), SkRect::MakeLTRB(1, 1, 3, 3),\n                SkRect::MakeLTRB(16, 16, 48, 48), &lowPaint, constraint);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "5df49d1f4da37275a1f10ef7f1a749f0",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SrcRectConstraint"
},
    "SkCanvas_accessTopLayerPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    if (canvas->accessTopLayerPixels(nullptr, nullptr)) {\n         canvas->clear(SK_ColorRED);\n    } else {\n         canvas->clear(SK_ColorBLUE);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "38d0d6ca9bea146d31bcbec197856359",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::accessTopLayerPixels"
},
    "SkCanvas_accessTopLayerPixels_a": {
    "code": "void draw(SkCanvas* canvas) {\n  SkPaint paint;\n  paint.setTextSize(100);\n  canvas->drawString(\"ABC\", 20, 160, paint);\n  SkRect layerBounds = SkRect::MakeXYWH(32, 32, 192, 192);\n  canvas->saveLayerAlpha(&layerBounds, 128);\n  canvas->clear(SK_ColorWHITE);\n  canvas->drawString(\"DEF\", 20, 160, paint);\n  SkImageInfo imageInfo;\n  size_t rowBytes;\n  SkIPoint origin;\n  uint32_t* access = (uint32_t*) canvas->accessTopLayerPixels(&imageInfo, &rowBytes, &origin);\n  if (access) {\n    int h = imageInfo.height();\n    int v = imageInfo.width();\n    int rowWords = rowBytes / sizeof(uint32_t);\n    for (int y = 0; y < h; ++y) {\n        int newY = (y - h / 2) * 2 + h / 2;\n        if (newY < 0 || newY >= h) {\n            continue;\n        }\n        for (int x = 0; x < v; ++x) {\n            int newX = (x - v / 2) * 2 + v / 2;\n            if (newX < 0 || newX >= v) {\n                continue;\n            }\n            if (access[y * rowWords + x] == SK_ColorBLACK) {\n                access[newY * rowWords + newX] = SK_ColorGRAY;\n            }\n        }\n    }\n  }\n  canvas->restore();\n}\n",
    "width": 256,
    "height": 256,
    "hash": "a7ac9c21bbabcdeeca00f72a61cd0f3e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::accessTopLayerPixels_2"
},
    "SkCanvas_clear": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->save();\n    canvas->clipRect(SkRect::MakeWH(256, 128));\n    canvas->clear(SkColorSetARGB(0x80, 0xFF, 0x00, 0x00));\n    canvas->restore();\n    canvas->save();\n    canvas->clipRect(SkRect::MakeWH(150, 192));\n    canvas->clear(SkColorSetARGB(0x80, 0x00, 0xFF, 0x00));\n    canvas->restore();\n    canvas->clipRect(SkRect::MakeWH(75, 256));\n    canvas->clear(SkColorSetARGB(0x80, 0x00, 0x00, 0xFF));\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8c4499e322f10153dcd9b0b9806233b9",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clear()"
},
    "SkCanvas_clipPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    path.addRect({20, 30, 100, 110});\n    path.setFillType(SkPath::kInverseWinding_FillType);\n    canvas->save();\n    canvas->clipPath(path, SkClipOp::kDifference, false);\n    canvas->drawCircle(70, 100, 60, paint);\n    canvas->restore();\n    canvas->translate(100, 100);\n    path.setFillType(SkPath::kWinding_FillType);\n    canvas->clipPath(path, SkClipOp::kIntersect, false);\n    canvas->drawCircle(70, 100, 60, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "ee47ae6b813bfaa55e1a7b7c053ed60d",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipPath"
},
    "SkCanvas_clipPath_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    path.addRect({20, 15, 100, 95});\n    path.addRect({50, 65, 130, 135});\n    path.setFillType(SkPath::kWinding_FillType);\n    canvas->save();\n    canvas->clipPath(path, SkClipOp::kIntersect);\n    canvas->drawCircle(70, 85, 60, paint);\n    canvas->restore();\n    canvas->translate(100, 100);\n    path.setFillType(SkPath::kEvenOdd_FillType);\n    canvas->clipPath(path, SkClipOp::kIntersect);\n    canvas->drawCircle(70, 85, 60, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "7856755c1bf8431c286c734b353345ad",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipPath_2"
},
    "SkCanvas_clipPath_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    SkPoint poly[] = {{20, 20}, { 80, 20}, { 80,  80}, {40,  80},\n                      {40, 40}, {100, 40}, {100, 100}, {20, 100}};\n    path.addPoly(poly, SK_ARRAY_COUNT(poly), true);\n    path.setFillType(SkPath::kWinding_FillType);\n    canvas->save();\n    canvas->clipPath(path, SkClipOp::kIntersect);\n    canvas->drawCircle(50, 50, 45, paint);\n    canvas->restore();\n    canvas->translate(100, 100);\n    path.setFillType(SkPath::kEvenOdd_FillType);\n    canvas->clipPath(path, SkClipOp::kIntersect);\n    canvas->drawCircle(50, 50, 45, paint);\n}\n",
    "width": 256,
    "height": 212,
    "hash": "187a7ae77a8176e417181411988534b6",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipPath_3"
},
    "SkCanvas_clipRRect": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(SK_ColorWHITE);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(0x8055aaff);\n    SkRRect oval;\n    oval.setOval({10, 20, 90, 100});\n    canvas->clipRRect(oval, SkClipOp::kIntersect, true);\n    canvas->drawCircle(70, 100, 60, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "182ef48ab5e04ba3578496fda8d9fa36",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRRect"
},
    "SkCanvas_clipRRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(0x8055aaff);\n    auto oval = SkRRect::MakeOval({10, 20, 90, 100});\n    canvas->clipRRect(oval, SkClipOp::kIntersect);\n    canvas->drawCircle(70, 100, 60, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "ef6ae2eaae6761130ce38065d0364abd",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRRect_2"
},
    "SkCanvas_clipRRect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    auto oval = SkRRect::MakeRectXY({10, 20, 90, 100}, 9, 13);\n    canvas->clipRRect(oval, true);\n    canvas->drawCircle(70, 100, 60, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "f583114580b2176fe3e75b0994476a84",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRRect_3"
},
    "SkCanvas_clipRect": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->rotate(10);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    for (auto alias: { false, true } ) {\n        canvas->save();\n        canvas->clipRect(SkRect::MakeWH(90, 80), SkClipOp::kIntersect, alias);\n        canvas->drawCircle(100, 60, 60, paint);\n        canvas->restore();\n        canvas->translate(80, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "6a614faa0fbcf19958b5559c19b02d0f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRect"
},
    "SkCanvas_clipRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    for (SkClipOp op: { SkClipOp::kIntersect, SkClipOp::kDifference } ) {\n        canvas->save();\n        canvas->clipRect(SkRect::MakeWH(90, 120), op, false);\n        canvas->drawCircle(100, 100, 60, paint);\n        canvas->restore();\n        canvas->translate(80, 0);\n    }\n}\n",
    "width": 280,
    "height": 192,
    "hash": "13bbc5fa5597a6cd4d704b419dbc66d9",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRect_2"
},
    "SkCanvas_clipRect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(SK_ColorWHITE);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(0x8055aaff);\n    SkRect clipRect = { 0, 0, 87.4f, 87.4f };\n    for (auto alias: { false, true } ) {\n        canvas->save();\n        canvas->clipRect(clipRect, SkClipOp::kIntersect, alias);\n        canvas->drawCircle(67, 67, 60, paint);\n        canvas->restore();\n        canvas->save();\n        canvas->clipRect(clipRect, SkClipOp::kDifference, alias);\n        canvas->drawCircle(67, 67, 60, paint);\n        canvas->restore();\n        canvas->translate(120, 0);\n    }\n}\n",
    "width": 256,
    "height": 133,
    "hash": "1d4e0632c97e42692775d834fe10aa99",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRect_3"
},
    "SkCanvas_clipRegion": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkIRect iRect = {30, 40, 120, 130 };\n    SkRegion region(iRect);\n    canvas->rotate(10);\n    canvas->save();\n    canvas->clipRegion(region, SkClipOp::kIntersect);\n    canvas->drawCircle(50, 50, 45, paint);\n    canvas->restore();\n    canvas->translate(100, 100);\n    canvas->clipRect(SkRect::Make(iRect), SkClipOp::kIntersect);\n    canvas->drawCircle(50, 50, 45, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "7bb57c0e456c5fda2c2cca4abb68b19e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRegion"
},
    "SkCanvas_concat": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(80);\n    paint.setTextScaleX(.3);\n    SkMatrix matrix;\n    SkRect rect[2] = {{ 10, 20, 90, 110 }, { 40, 130, 140, 180 }};\n    matrix.setRectToRect(rect[0], rect[1], SkMatrix::kFill_ScaleToFit);\n    canvas->drawRect(rect[0], paint);\n    canvas->drawRect(rect[1], paint);\n    paint.setColor(SK_ColorWHITE);\n    canvas->drawString(\"Here\", rect[0].fLeft + 10, rect[0].fBottom - 10, paint);\n    canvas->concat(matrix);\n    canvas->drawString(\"There\", rect[0].fLeft + 10, rect[0].fBottom - 10, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8f6818b25a92a88638ad99b2dd293f61",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::concat()"
},
    "SkCanvas_destructor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(200, 200));\n    {\n        SkCanvas offscreen(bitmap);\n        SkPaint paint;\n        paint.setTextSize(100);\n        offscreen.drawString(\"ABC\", 20, 160, paint);\n        SkRect layerBounds = SkRect::MakeXYWH(32, 32, 192, 192);\n        offscreen.saveLayerAlpha(&layerBounds, 128);\n        offscreen.clear(SK_ColorWHITE);\n        offscreen.drawString(\"DEF\", 20, 160, paint);\n    }\n    canvas->drawBitmap(bitmap, 0, 0, nullptr);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "b7bc91ff16c9b9351b2a127f35394b82",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::~SkCanvas()"
},
    "SkCanvas_drawAnnotation": {
    "code": "void draw(SkCanvas* canvas) {\n    const char text[] = \"Click this link!\";\n    SkRect bounds;\n    SkPaint paint;\n    paint.setTextSize(40);\n    (void)paint.measureText(text, strlen(text), &bounds);\n    const char url[] = \"https://www.google.com/\";\n    sk_sp<SkData> urlData(SkData::MakeWithCString(url));\n    canvas->drawAnnotation(bounds, \"url_key\", urlData.get());\n}",
    "width": 256,
    "height": 1,
    "hash": "00b430bd80d740e19c6d020a940f56d5",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAnnotation"
},
    "SkCanvas_drawAnnotation_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const char text[] = \"Click this link!\";\n    SkRect bounds;\n    SkPaint paint;\n    paint.setTextSize(40);\n    (void)paint.measureText(text, strlen(text), &bounds);\n    const char url[] = \"https://www.google.com/\";\n    sk_sp<SkData> urlData(SkData::MakeWithCString(url));\n    canvas->drawAnnotation(bounds, \"url_key\", urlData.get());\n}",
    "width": 256,
    "height": 1,
    "hash": "00b430bd80d740e19c6d020a940f56d5",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAnnotation_2"
},
    "SkCanvas_drawArc": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRect oval = { 4, 4, 60, 60};\n    for (auto useCenter : { false, true } ) {\n        for (auto style : { SkPaint::kFill_Style, SkPaint::kStroke_Style } ) {\n            paint.setStyle(style);\n            for (auto degrees : { 45, 90, 180, 360} ) {\n                canvas->drawArc(oval, 0, degrees , useCenter, paint);\n                canvas->translate(64, 0);\n            }\n            canvas->translate(-256, 64);\n        }\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "11f0fbe7b30d776913c2e7c92c02ff57",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawArc"
},
    "SkCanvas_drawArc_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(4);\n    SkRect oval = { 4, 4, 60, 60};\n    float intervals[] = { 5, 5 };\n    paint.setPathEffect(SkDashPathEffect::Make(intervals, 2, 2.5f));\n    for (auto degrees : { 270, 360, 540, 720 } ) {\n        canvas->drawArc(oval, 0, degrees, false, paint);\n        canvas->translate(64, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "e91dbe45974489b8962c815017b7914f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawArc_2"
},
    "SkCanvas_drawAtlas": {
    "code": "void draw(SkCanvas* canvas) {\n  // SkBitmap source = mandrill;\n  SkRSXform xforms[] = { { .5f, 0, 0, 0 }, {0, .5f, 200, 100 } };\n  SkRect tex[] = { { 0, 0, 250, 250 }, { 0, 0, 250, 250 } };\n  SkColor colors[] = { 0x7f55aa00, 0x7f3333bf };\n  const SkImage* imagePtr = image.get();\n  canvas->drawAtlas(imagePtr, xforms, tex, colors, 2, SkBlendMode::kSrcOver, nullptr, nullptr);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "1df575f9b8132306ce0552a2554ed132",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAtlas"
},
    "SkCanvas_drawAtlas_2": {
    "code": "void draw(SkCanvas* canvas) {\n  // SkBitmap source = mandrill;\n  SkRSXform xforms[] = { { .5f, 0, 0, 0 }, {0, .5f, 200, 100 } };\n  SkRect tex[] = { { 0, 0, 250, 250 }, { 0, 0, 250, 250 } };\n  SkColor colors[] = { 0x7f55aa00, 0x7f3333bf };\n  SkPaint paint;\n  paint.setAlpha(127);\n  canvas->drawAtlas(image, xforms, tex, colors, 2, SkBlendMode::kPlus, nullptr, &paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "0e66a8f230a8d531bcef9f5ebdc5aac1",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAtlas_2"
},
    "SkCanvas_drawAtlas_3": {
    "code": "void draw(SkCanvas* canvas) {\n  // sk_sp<SkImage> image = mandrill;\n  SkRSXform xforms[] = { { .5f, 0, 0, 0 }, {0, .5f, 200, 100 } };\n  SkRect tex[] = { { 0, 0, 250, 250 }, { 0, 0, 250, 250 } };\n  const SkImage* imagePtr = image.get();\n  canvas->drawAtlas(imagePtr, xforms, tex, 2, nullptr, nullptr);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8dc0d0fdeab20bbc21cac6874ddbefcd",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAtlas_3"
},
    "SkCanvas_drawAtlas_4": {
    "code": "void draw(SkCanvas* canvas) {\n  // sk_sp<SkImage> image = mandrill;\n  SkRSXform xforms[] = { { 1, 0, 0, 0 }, {0, 1, 300, 100 } };\n  SkRect tex[] = { { 0, 0, 200, 200 }, { 200, 0, 400, 200 } };\n  canvas->drawAtlas(image, xforms, tex, 2, nullptr, nullptr);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "c093c2b14bd3e6171ede7cd4049d9b57",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAtlas_4"
},
    "SkCanvas_drawBitmap": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t pixels[][8] = { { 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00},\n                            { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00},\n                            { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},\n                            { 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF},\n                            { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n                            { 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00},\n                            { 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00},\n                            { 0xFF, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeA8(8, 8),\n            (void*) pixels, sizeof(pixels[0]));\n    SkPaint paint;\n    canvas->scale(4, 4);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xFF007F00} ) {\n        paint.setColor(color);\n        canvas->drawBitmap(bitmap, 0, 0, &paint);\n        canvas->translate(12, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "4a521be1f850058541e136a808c65e78",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmap"
},
    "SkCanvas_drawBitmapLattice": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect center = { 20, 10, 50, 40 };\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(60, 60));\n    SkCanvas bitCanvas(bitmap);\n    SkPaint paint;\n    SkColor gray = 0xFF000000;\n    int left = 0;\n    for (auto right: { center.fLeft, center.fRight, bitmap.width() } ) {\n        int top = 0;\n        for (auto bottom: { center.fTop, center.fBottom, bitmap.height() } ) {\n            paint.setColor(gray);\n            bitCanvas.drawIRect(SkIRect::MakeLTRB(left, top, right, bottom), paint);\n            gray += 0x001f1f1f;\n            top = bottom;\n        }\n        left = right;\n    }\n    const int xDivs[] = { center.fLeft, center.fRight };\n    const int yDivs[] = { center.fTop, center.fBottom };\n    SkCanvas::Lattice::RectType fillTypes[3][3];\n    memset(fillTypes, 0, sizeof(fillTypes));\n    fillTypes[1][1] = SkCanvas::Lattice::kTransparent;\n    SkColor dummy[9];  // temporary pending bug fix\n    SkCanvas::Lattice lattice = { xDivs, yDivs, fillTypes[0], SK_ARRAY_COUNT(xDivs),\n         SK_ARRAY_COUNT(yDivs), nullptr, dummy };\n    for (auto dest: { 20, 30, 40, 60, 90 } ) {\n        canvas->drawBitmapLattice(bitmap, lattice, SkRect::MakeWH(dest, 110 - dest), nullptr);\n        canvas->translate(dest + 4, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "c5bfa944e17ba4a4400dc799f032069c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmapLattice"
},
    "SkCanvas_drawBitmapNine": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect center = { 20, 10, 50, 40 };\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(60, 60));\n    SkCanvas bitCanvas(bitmap);\n    SkPaint paint;\n    SkColor gray = 0xFF000000;\n    int left = 0;\n    for (auto right: { center.fLeft, center.fRight, bitmap.width() } ) {\n        int top = 0;\n        for (auto bottom: { center.fTop, center.fBottom, bitmap.height() } ) {\n            paint.setColor(gray);\n            bitCanvas.drawIRect(SkIRect::MakeLTRB(left, top, right, bottom), paint);\n            gray += 0x001f1f1f;\n            top = bottom;\n        }\n        left = right;\n    }\n    for (auto dest: { 20, 30, 40, 60, 90 } ) {\n        canvas->drawBitmapNine(bitmap, center, SkRect::MakeWH(dest, 110 - dest), nullptr);\n        canvas->translate(dest + 4, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "e99e7be0d8f67dfacbecf85df585433d",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmapNine"
},
    "SkCanvas_drawBitmapRect": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t pixels[][8] = { { 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00},\n                            { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00},\n                            { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},\n                            { 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF},\n                            { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n                            { 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00},\n                            { 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00},\n                            { 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeA8(8, 8),\n            (void*) pixels, sizeof(pixels[0]));\n    SkPaint paint;\n    paint.setMaskFilter(SkMaskFilter::MakeBlur(kSolid_SkBlurStyle, 6));\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xFF007F00} ) {\n        paint.setColor(color);\n        canvas->drawBitmapRect(bitmap, SkRect::MakeWH(8, 8), SkRect::MakeWH(32, 32), &paint);\n        canvas->translate(48, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "7d04932f2a259cc70d6e45cd25a6feb6",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmapRect"
},
    "SkCanvas_drawBitmapRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t pixels[][8] = { { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00},\n                            { 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00},\n                            { 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0xFF},\n                            { 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0xFF},\n                            { 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF},\n                            { 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF},\n                            { 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00},\n                            { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeA8(8, 8),\n            (void*) pixels, sizeof(pixels[0]));\n    SkPaint paint;\n    paint.setFilterQuality(kHigh_SkFilterQuality);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xFF007F00, 0xFF7f007f} ) {\n        paint.setColor(color);\n        canvas->drawBitmapRect(bitmap, SkIRect::MakeWH(8, 8), SkRect::MakeWH(32, 32), &paint);\n        canvas->translate(48.25f, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "0a3c6d2459566e58cee7d4910655ee21",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmapRect_2"
},
    "SkCanvas_drawBitmapRect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t pixels[][2] = { { 0x00000000, 0x55550000},\n                             { 0xAAAA0000, 0xFFFF0000} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(2, 2),\n            (void*) pixels, sizeof(pixels[0]));\n    SkPaint paint;\n    canvas->scale(4, 4);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN } ) {\n        paint.setColorFilter(SkColorFilter::MakeModeFilter(color, SkBlendMode::kPlus));\n        canvas->drawBitmapRect(bitmap, SkRect::MakeWH(8, 8), &paint);\n        canvas->translate(8, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "bdbeac3c97f60a63987b1cc8e1f1e91e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmapRect_3"
},
    "SkCanvas_drawCircle": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawCircle(128, 128, 90, paint);\n    paint.setColor(SK_ColorWHITE);\n    canvas->drawCircle(86, 86, 20, paint);\n    canvas->drawCircle(160, 76, 20, paint);\n    canvas->drawCircle(140, 150, 35, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "841229e25ca9dfb68bd0dc4dfff356eb",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawCircle"
},
    "SkCanvas_drawCircle_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawCircle(128, 128, 90, paint);\n    paint.setColor(SK_ColorWHITE);\n    canvas->drawCircle({86, 86}, 20, paint);\n    canvas->drawCircle({160, 76}, 20, paint);\n    canvas->drawCircle({140, 150}, 35, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "9303ffae45ddd0b0a1f93d816a1762f4",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawCircle_2"
},
    "SkCanvas_drawColor": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawColor(SK_ColorRED);\n    canvas->clipRect(SkRect::MakeWH(150, 150));\n    canvas->drawColor(SkColorSetARGB(0x80, 0x00, 0xFF, 0x00), SkBlendMode::kPlus);\n    canvas->clipRect(SkRect::MakeWH(75, 75));\n    canvas->drawColor(SkColorSetARGB(0x80, 0x00, 0x00, 0xFF), SkBlendMode::kPlus);\n}",
    "width": 256,
    "height": 256,
    "hash": "9cf94fead1e6b17d836c704b4eac269a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawColor"
},
    "SkCanvas_drawDRRect": {
    "code": "void draw(SkCanvas* canvas) {\n   SkRRect outer = SkRRect::MakeRect({20, 40, 210, 200});\n   SkRRect inner = SkRRect::MakeOval({60, 70, 170, 160});\n   SkPaint paint;\n   canvas->drawDRRect(outer, inner, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "02e33141f13da2f19aef7feb7117b541",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawDRRect"
},
    "SkCanvas_drawDRRect_a": {
    "code": "void draw(SkCanvas* canvas) {\n   SkRRect outer = SkRRect::MakeRect({20, 40, 210, 200});\n   SkRRect inner = SkRRect::MakeRectXY({60, 70, 170, 160}, 10, 10);\n   SkPaint paint;\n   paint.setAntiAlias(true);\n   paint.setStyle(SkPaint::kStroke_Style);\n   paint.setStrokeWidth(20);\n   paint.setStrokeJoin(SkPaint::kRound_Join);\n   canvas->drawDRRect(outer, inner, paint);\n   paint.setStrokeWidth(1);\n   paint.setColor(SK_ColorWHITE);\n   canvas->drawDRRect(outer, inner, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "30823cb4edf884d330285ea161664931",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawDRRect_2"
},
    "SkCanvas_drawDrawable": {
    "code": "struct MyDrawable : public SkDrawable {\n    SkRect onGetBounds() override { return SkRect::MakeWH(50, 100);  }\n    void onDraw(SkCanvas* canvas) override {\n       SkPath path;\n       path.conicTo(10, 90, 50, 90, 0.9f);\n       SkPaint paint;\n       paint.setColor(SK_ColorBLUE);\n       canvas->drawRect(path.getBounds(), paint);\n       paint.setAntiAlias(true);\n       paint.setColor(SK_ColorWHITE);\n       canvas->drawPath(path, paint);\n    }\n};\n\nvoid draw(SkCanvas* canvas) {\n    sk_sp<SkDrawable> drawable(new MyDrawable);\n  SkMatrix matrix;\n  matrix.setTranslate(10, 10);\n  canvas->drawDrawable(drawable.get(), &matrix);\n}\n",
    "width": 256,
    "height": 100,
    "hash": "3a4dfcd08838866b5cfc0d82489195ba",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawDrawable"
},
    "SkCanvas_drawDrawable_2": {
    "code": "struct MyDrawable : public SkDrawable {\n    SkRect onGetBounds() override { return SkRect::MakeWH(50, 100);  }\n    void onDraw(SkCanvas* canvas) override {\n       SkPath path;\n       path.conicTo(10, 90, 50, 90, 0.9f);\n       SkPaint paint;\n       paint.setColor(SK_ColorBLUE);\n       canvas->drawRect(path.getBounds(), paint);\n       paint.setAntiAlias(true);\n       paint.setColor(SK_ColorWHITE);\n       canvas->drawPath(path, paint);\n    }\n};\n\nvoid draw(SkCanvas* canvas) {\n    sk_sp<SkDrawable> drawable(new MyDrawable);\n  canvas->drawDrawable(drawable.get(), 10, 10);\n}\n",
    "width": 256,
    "height": 100,
    "hash": "1bdc07ad3b154c89b771722c2fcaee3f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawDrawable_2"
},
    "SkCanvas_drawIRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 64, 48, 192, 160 };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    paint.setStrokeJoin(SkPaint::kRound_Join);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorYELLOW, SK_ColorMAGENTA } ) {\n        paint.setColor(color);\n        canvas->drawIRect(rect, paint);\n        canvas->rotate(30, 128, 128);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "d3d8ca584134560750b1efa4a4c6e138",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawIRect"
},
    "SkCanvas_drawImage": {
    "code": "void draw(SkCanvas* canvas) {\n   // sk_sp<SkImage> image;\n   SkImage* imagePtr = image.get();\n   canvas->drawImage(imagePtr, 0, 0);\n   SkPaint paint;\n   canvas->drawImage(imagePtr, 80, 0, &paint);\n   paint.setAlpha(0x80);\n   canvas->drawImage(imagePtr, 160, 0, &paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "185746dc0faa6f1df30c4afe098646ff",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImage"
},
    "SkCanvas_drawImageLattice": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect center = { 20, 10, 50, 40 };\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(60, 60));\n    SkCanvas bitCanvas(bitmap);\n    SkPaint paint;\n    SkColor gray = 0xFF000000;\n    int left = 0;\n    for (auto right: { center.fLeft, center.fRight, bitmap.width() } ) {\n        int top = 0;\n        for (auto bottom: { center.fTop, center.fBottom, bitmap.height() } ) {\n            paint.setColor(gray);\n            bitCanvas.drawIRect(SkIRect::MakeLTRB(left, top, right, bottom), paint);\n            gray += 0x001f1f1f;\n            top = bottom;\n        }\n        left = right;\n    }\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkImage* imagePtr = image.get();\n    for (auto dest: { 20, 30, 40, 60, 90 } ) {\n        canvas->drawImageNine(imagePtr, center, SkRect::MakeWH(dest, dest), nullptr);\n        canvas->translate(dest + 4, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "4f153cf1d0dbe1a95acf5badeec14dae",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageLattice"
},
    "SkCanvas_drawImageNine": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect center = { 20, 10, 50, 40 };\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(60, 60));\n    SkCanvas bitCanvas(bitmap);\n    SkPaint paint;\n    SkColor gray = 0xFF000000;\n    int left = 0;\n    for (auto right: { center.fLeft, center.fRight, bitmap.width() } ) {\n        int top = 0;\n        for (auto bottom: { center.fTop, center.fBottom, bitmap.height() } ) {\n            paint.setColor(gray);\n            bitCanvas.drawIRect(SkIRect::MakeLTRB(left, top, right, bottom), paint);\n            gray += 0x001f1f1f;\n            top = bottom;\n        }\n        left = right;\n    }\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkImage* imagePtr = image.get();\n    for (auto dest: { 20, 30, 40, 60, 90 } ) {\n        canvas->drawImageNine(imagePtr, center, SkRect::MakeWH(dest, dest), nullptr);\n        canvas->translate(dest + 4, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "4f153cf1d0dbe1a95acf5badeec14dae",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageNine"
},
    "SkCanvas_drawImageNine_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect center = { 20, 10, 50, 40 };\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(60, 60));\n    SkCanvas bitCanvas(bitmap);\n    SkPaint paint;\n    SkColor gray = 0xFF000000;\n    int left = 0;\n    for (auto right: { center.fLeft, center.fRight, bitmap.width() } ) {\n        int top = 0;\n        for (auto bottom: { center.fTop, center.fBottom, bitmap.height() } ) {\n            paint.setColor(gray);\n            bitCanvas.drawIRect(SkIRect::MakeLTRB(left, top, right, bottom), paint);\n            gray += 0x001f1f1f;\n            top = bottom;\n        }\n        left = right;\n    }\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    for (auto dest: { 20, 30, 40, 60, 90 } ) {\n        canvas->drawImageNine(image, center, SkRect::MakeWH(dest, 110 - dest), nullptr);\n        canvas->translate(dest + 4, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "d597d9af8d17fd93e634dd12017058e2",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageNine_2"
},
    "SkCanvas_drawImageRect": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t pixels[][4] = {\n            { 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000 },\n            { 0xFFFF0000, 0xFF000000, 0xFFFFFFFF, 0xFFFF0000 },\n            { 0xFFFF0000, 0xFFFFFFFF, 0xFF000000, 0xFFFF0000 },\n            { 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000 } };\n    SkBitmap redBorder;\n    redBorder.installPixels(SkImageInfo::MakeN32Premul(4, 4),\n            (void*) pixels, sizeof(pixels[0]));\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(redBorder);\n    SkPaint lowPaint;\n    for (auto constraint : {\n            SkCanvas::kFast_SrcRectConstraint,\n            SkCanvas::kStrict_SrcRectConstraint,\n            SkCanvas::kFast_SrcRectConstraint } ) {\n        canvas->drawImageRect(image.get(), SkRect::MakeLTRB(1, 1, 3, 3),\n                SkRect::MakeLTRB(16, 16, 48, 48), &lowPaint, constraint);\n        lowPaint.setFilterQuality(kLow_SkFilterQuality);\n        canvas->translate(80, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "bfd18e9cac896cdf94c9f154ccf94be8",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect"
},
    "SkCanvas_drawImageRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    // sk_sp<SkImage> image;\n    for (auto i : { 1, 2, 4, 8 } ) {\n        canvas->drawImageRect(image.get(), SkIRect::MakeLTRB(0, 0, 100, 100),\n                SkRect::MakeXYWH(i * 20, i * 20, i * 20, i * 20), nullptr);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "7f92cd5c9b9f4b1ac3cd933b08037bfe",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect_2"
},
    "SkCanvas_drawImageRect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    // sk_sp<SkImage> image;\n    for (auto i : { 20, 40, 80, 160 } ) {\n        canvas->drawImageRect(image.get(), SkRect::MakeXYWH(i, i, i, i), nullptr);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "3cf8fb639fef99993cafc064d550c739",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect_3"
},
    "SkCanvas_drawImageRect_4": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t pixels[][2] = { { SK_ColorBLACK, SK_ColorWHITE },\n                             { SK_ColorWHITE, SK_ColorBLACK } };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(2, 2),\n            (void*) pixels, sizeof(pixels[0]));\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkPaint paint;\n    canvas->scale(4, 4);\n    for (auto alpha : { 50, 100, 150, 255 } ) {\n        paint.setAlpha(alpha);\n        canvas->drawImageRect(image, SkRect::MakeWH(2, 2), SkRect::MakeWH(8, 8), &paint);\n        canvas->translate(8, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "d4b35a9d24c32c042bd1f529b8de3c0d",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect_4"
},
    "SkCanvas_drawImageRect_5": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t pixels[][2] = { { 0x00000000, 0x55555555},\n                             { 0xAAAAAAAA, 0xFFFFFFFF} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(2, 2),\n            (void*) pixels, sizeof(pixels[0]));\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkPaint paint;\n    canvas->scale(4, 4);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN } ) {\n        paint.setColorFilter(SkColorFilter::MakeModeFilter(color, SkBlendMode::kPlus));\n        canvas->drawImageRect(image, SkIRect::MakeWH(2, 2), SkRect::MakeWH(8, 8), &paint);\n        canvas->translate(8, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "d307e7e1237f39fb54d80723e5449857",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect_5"
},
    "SkCanvas_drawImageRect_6": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t pixels[][2] = { { 0x00000000, 0x55550000},\n                             { 0xAAAA0000, 0xFFFF0000} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(2, 2),\n            (void*) pixels, sizeof(pixels[0]));\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkPaint paint;\n    canvas->scale(4, 4);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN } ) {\n        paint.setColorFilter(SkColorFilter::MakeModeFilter(color, SkBlendMode::kPlus));\n        canvas->drawImageRect(image, SkRect::MakeWH(8, 8), &paint);\n        canvas->translate(8, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "3a47ef94cb70144455f80333d8653e6c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect_6"
},
    "SkCanvas_drawImage_2": {
    "code": "void draw(SkCanvas* canvas) {\n   // sk_sp<SkImage> image;\n   canvas->drawImage(image, 0, 0);\n   SkPaint paint;\n   canvas->drawImage(image, 80, 0, &paint);\n   paint.setAlpha(0x80);\n   canvas->drawImage(image, 160, 0, &paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "a4e877e891b1be5faa2b7fd07f673a10",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImage_2"
},
    "SkCanvas_drawLine": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(0xFF9a67be);\n    paint.setStrokeWidth(20);\n    canvas->skew(1, 0);\n    canvas->drawLine(32, 96, 32, 160, paint);\n    canvas->skew(-2, 0);\n    canvas->drawLine(288, 96, 288, 160, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "d10ee4a265f278d02afe11ad889b293b",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawLine"
},
    "SkCanvas_drawLine_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(0xFF9a67be);\n    paint.setStrokeWidth(20);\n    canvas->skew(1, 0);\n    canvas->drawLine({32, 96}, {32, 160}, paint);\n    canvas->skew(-2, 0);\n    canvas->drawLine({288, 96}, {288, 160}, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "f8525816cb596dde1a3855446792c8e0",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawLine_2"
},
    "SkCanvas_drawOval": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(0xFF3f5f9f);\n    SkColor  kColor1 = SkColorSetARGB(0xff, 0xff, 0x7f, 0);\n    SkColor  g1Colors[] = { kColor1, SkColorSetA(kColor1, 0x20) };\n    SkPoint  g1Points[] = { { 0, 0 }, { 0, 100 } };\n    SkScalar pos[] = { 0.2f, 1.0f };\n    SkRect bounds = SkRect::MakeWH(80, 70);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setShader(SkGradientShader::MakeLinear(g1Points, g1Colors, pos, SK_ARRAY_COUNT(g1Colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawOval(bounds , paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8b6b86f8a022811cd29a9c6ab771df12",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawOval"
},
    "SkCanvas_drawPaint": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor     colors[] = { SK_ColorRED, SK_ColorGREEN, SK_ColorBLUE };\n    SkScalar    pos[] = { 0, SK_Scalar1/2, SK_Scalar1 };\n    SkPaint     paint;\n    paint.setShader(SkGradientShader::MakeSweep(256, 256, colors, pos, SK_ARRAY_COUNT(colors)));\n    canvas->drawPaint(paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "1cd076b9b1a7c976cdca72b93c4f42dd",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPaint"
},
    "SkCanvas_drawPatch": {
    "code": "void draw(SkCanvas* canvas) {\n    // SkBitmap source = cmbkygk;\n    SkPaint paint;\n    paint.setFilterQuality(kLow_SkFilterQuality);\n    paint.setAntiAlias(true);\n    SkPoint cubics[] = { { 3, 1 },    { 4, 2 }, { 5, 1 },    { 7, 3 },\n                      /* { 7, 3 }, */ { 6, 4 }, { 7, 5 },    { 5, 7 },\n                      /* { 5, 7 }, */ { 4, 6 }, { 3, 7 },    { 1, 5 },\n                      /* { 1, 5 }, */ { 2, 4 }, { 1, 3 }, /* { 3, 1 } */ };\n    SkColor colors[] = { 0xbfff0000, 0xbf0000ff, 0xbfff00ff, 0xbf00ffff };\n    SkPoint texCoords[] = { { -30, -30 }, { 162, -30}, { 162, 162}, { -30, 162} };\n    paint.setShader(SkShader::MakeBitmapShader(source, SkShader::kClamp_TileMode,\n                                                       SkShader::kClamp_TileMode, nullptr));\n    canvas->scale(15, 15);\n    for (auto blend : { SkBlendMode::kSrcOver, SkBlendMode::kModulate, SkBlendMode::kXor } ) {\n        canvas->drawPatch(cubics, colors, texCoords, blend, paint);\n        canvas->translate(4, 4);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "accb545d67984ced168f5be6ab824795",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPatch"
},
    "SkCanvas_drawPatch_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint cubics[] = { { 3, 1 },    { 4, 2 }, { 5, 1 },    { 7, 3 },\n                      /* { 7, 3 }, */ { 6, 4 }, { 7, 5 },    { 5, 7 },\n                      /* { 5, 7 }, */ { 4, 6 }, { 3, 7 },    { 1, 5 },\n                      /* { 1, 5 }, */ { 2, 4 }, { 1, 3 }, /* { 3, 1 } */ };\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE, SK_ColorYELLOW, SK_ColorCYAN };\n    canvas->scale(30, 30);\n    canvas->drawPatch(cubics, colors, nullptr, paint);\n    SkPoint text[] = { {3,0.9f}, {4,2.5f}, {5,0.9f}, {7.5f,3.2f}, {5.5f,4.2f},\n            {7.5f,5.2f}, {5,7.5f}, {4,5.9f}, {3,7.5f}, {0.5f,5.2f}, {2.5f,4.2f},\n            {0.5f,3.2f} };\n    paint.setTextSize(18.f / 30);\n    for (int i = 0; i< 10; ++i) {\n       char digit = '0' + i;\n       canvas->drawText(&digit, 1, text[i].fX, text[i].fY, paint);\n    }\n    canvas->drawString(\"10\", text[10].fX, text[10].fY, paint);\n    canvas->drawString(\"11\", text[11].fX, text[11].fY, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, 12, cubics, paint);\n    canvas->drawLine(cubics[11].fX, cubics[11].fY, cubics[0].fX, cubics[0].fY, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "4e8b7409531c9211a2afcf632005a38c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPatch_2"
},
    "SkCanvas_drawPatch_2_a": {
    "code": "void draw(SkCanvas* canvas) {\n    // SkBitmap source = checkerboard;\n    SkPaint paint;\n    paint.setFilterQuality(kLow_SkFilterQuality);\n    paint.setAntiAlias(true);\n    SkPoint cubics[] = { { 3, 1 },    { 4, 2 }, { 5, 1 },    { 7, 3 },\n                      /* { 7, 3 }, */ { 6, 4 }, { 7, 5 },    { 5, 7 },\n                      /* { 5, 7 }, */ { 4, 6 }, { 3, 7 },    { 1, 5 },\n                      /* { 1, 5 }, */ { 2, 4 }, { 1, 3 }, /* { 3, 1 } */ };\n    SkPoint texCoords[] = { { 0, 0 }, { 0, 62}, { 62, 62}, { 62, 0 } };\n    paint.setShader(SkShader::MakeBitmapShader(source, SkShader::kClamp_TileMode,\n                                                       SkShader::kClamp_TileMode, nullptr));\n    canvas->scale(30, 30);\n    canvas->drawPatch(cubics, nullptr, texCoords, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "3412c2a16cb529af0e04878d264451f2",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPatch_2_2"
},
    "SkCanvas_drawPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(20, 20);\n    path.quadTo(60, 20, 60, 60);\n    path.close();\n    path.moveTo(60, 20);\n    path.quadTo(60, 60, 20, 60);\n    SkPaint paint;\n    paint.setStrokeWidth(10);\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (auto join: { SkPaint::kBevel_Join, SkPaint::kRound_Join, SkPaint::kMiter_Join } ) {\n        paint.setStrokeJoin(join);\n        for (auto cap: { SkPaint::kButt_Cap, SkPaint::kSquare_Cap, SkPaint::kRound_Cap  } ) {\n            paint.setStrokeCap(cap);\n            canvas->drawPath(path, paint);\n            canvas->translate(80, 0);\n        }\n        canvas->translate(-240, 60);\n    }\n    paint.setStyle(SkPaint::kFill_Style);\n    for (auto fill : { SkPath::kWinding_FillType,\n                       SkPath::kEvenOdd_FillType,\n                       SkPath::kInverseWinding_FillType } ) {\n        path.setFillType(fill);\n        canvas->save();\n        canvas->clipRect({0, 10, 80, 70});\n        canvas->drawPath(path, paint);\n        canvas->restore();\n        canvas->translate(80, 0);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "fe2294131f422b8d6752f6a880f98ad9",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPath"
},
    "SkCanvas_drawPicture": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* recordingCanvas = recorder.beginRecording(50, 50);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xff007f00 } ) {\n        SkPaint paint;\n        paint.setColor(color);\n        recordingCanvas->drawRect({10, 10, 30, 40}, paint);\n        recordingCanvas->translate(10, 10);\n        recordingCanvas->scale(1.2f, 1.4f);\n    }\n    sk_sp<SkPicture> playback = recorder.finishRecordingAsPicture();\n    canvas->drawPicture(playback);\n    canvas->scale(2, 2);\n    canvas->translate(50, 0);\n    canvas->drawPicture(playback);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "83918a23fcffd47f59a1ef662c85a24c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPicture"
},
    "SkCanvas_drawPicture_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* recordingCanvas = recorder.beginRecording(50, 50);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xff007f00 } ) {\n        SkPaint paint;\n        paint.setColor(color);\n        recordingCanvas->drawRect({10, 10, 30, 40}, paint);\n        recordingCanvas->translate(10, 10);\n        recordingCanvas->scale(1.2f, 1.4f);\n    }\n    sk_sp<SkPicture> playback = recorder.finishRecordingAsPicture();\n    canvas->drawPicture(playback);\n    canvas->scale(2, 2);\n    canvas->translate(50, 0);\n    canvas->drawPicture(playback);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "83918a23fcffd47f59a1ef662c85a24c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPicture_2"
},
    "SkCanvas_drawPicture_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPictureRecorder recorder;\n    SkCanvas* recordingCanvas = recorder.beginRecording(50, 50);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xff007f00 } ) {\n        paint.setColor(color);\n        recordingCanvas->drawRect({10, 10, 30, 40}, paint);\n        recordingCanvas->translate(10, 10);\n        recordingCanvas->scale(1.2f, 1.4f);\n    }\n    sk_sp<SkPicture> playback = recorder.finishRecordingAsPicture();\n    const SkPicture* playbackPtr = playback.get();\n    SkMatrix matrix;\n    matrix.reset();\n    for (auto alpha : { 70, 140, 210 } ) {\n    paint.setAlpha(alpha);\n    canvas->drawPicture(playbackPtr, &matrix, &paint);\n    matrix.preTranslate(70, 70);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "759e4e5bac680838added8f70884dcdc",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPicture_3"
},
    "SkCanvas_drawPicture_4": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPictureRecorder recorder;\n    SkCanvas* recordingCanvas = recorder.beginRecording(50, 50);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xff007f00 } ) {\n        paint.setColor(color);\n        recordingCanvas->drawRect({10, 10, 30, 40}, paint);\n        recordingCanvas->translate(10, 10);\n        recordingCanvas->scale(1.2f, 1.4f);\n    }\n    sk_sp<SkPicture> playback = recorder.finishRecordingAsPicture();\n    SkMatrix matrix;\n    matrix.reset();\n    for (auto alpha : { 70, 140, 210 } ) {\n    paint.setAlpha(alpha);\n    canvas->drawPicture(playback, &matrix, &paint);\n    matrix.preTranslate(70, 70);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "c4ff59439dd2fc871925d4eeb0c84ca1",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPicture_4"
},
    "SkCanvas_drawPoint": {
    "code": "void draw(SkCanvas* canvas) {\n  SkPaint paint;\n  paint.setAntiAlias(true);\n  paint.setColor(0x80349a45);\n  paint.setStyle(SkPaint::kStroke_Style);\n  paint.setStrokeWidth(100);\n  paint.setStrokeCap(SkPaint::kRound_Cap);\n  canvas->scale(1, 1.2f);\n  canvas->drawPoint(64, 96, paint);\n  canvas->scale(.6f, .8f);\n  paint.setColor(SK_ColorWHITE);\n  canvas->drawPoint(106, 120, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "3476b553e7b547b604a3f6969f02d933",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPoint"
},
    "SkCanvas_drawPoint_2": {
    "code": "void draw(SkCanvas* canvas) {\n  SkPaint paint;\n  paint.setAntiAlias(true);\n  paint.setColor(0x80349a45);\n  paint.setStyle(SkPaint::kStroke_Style);\n  paint.setStrokeWidth(100);\n  paint.setStrokeCap(SkPaint::kSquare_Cap);\n  canvas->scale(1, 1.2f);\n  canvas->drawPoint({64, 96}, paint);\n  canvas->scale(.6f, .8f);\n  paint.setColor(SK_ColorWHITE);\n  canvas->drawPoint(106, 120, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "1a0a839061c69d870acca2bcfbdf1a41",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPoint_2"
},
    "SkCanvas_drawPoints": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    paint.setColor(0x80349a45);\n    const SkPoint points[] = {{32, 16}, {48, 48}, {16, 32}};\n    const SkPaint::Join join[] = { SkPaint::kRound_Join,\n                                   SkPaint::kMiter_Join,\n                                   SkPaint::kBevel_Join };\n    int joinIndex = 0;\n    SkPath path;\n    path.addPoly(points, 3, false);\n    for (const auto cap : { SkPaint::kRound_Cap, SkPaint::kSquare_Cap, SkPaint::kButt_Cap } ) {\n        paint.setStrokeCap(cap);\n        paint.setStrokeJoin(join[joinIndex++]);\n        for (const auto mode : { SkCanvas::kPoints_PointMode,\n                                 SkCanvas::kLines_PointMode,\n                                 SkCanvas::kPolygon_PointMode } ) {\n            canvas->drawPoints(mode, 3, points, paint);\n            canvas->translate(64, 0);\n        }\n        canvas->drawPath(path, paint);\n        canvas->translate(-192, 64);\n    }\n}\n",
    "width": 256,
    "height": 200,
    "hash": "635d54b4716e226e93dfbc21ad40e77d",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPoints"
},
    "SkCanvas_drawPosText": {
    "code": "void draw(SkCanvas* canvas) {\n  const char hello[] = \"HeLLo!\";\n  const SkPoint pos[] = { {40, 100}, {82, 95}, {115, 110}, {130, 95}, {145, 85},\n    {172, 100} };\n  SkPaint paint;\n  paint.setTextSize(60);\n  canvas->drawPosText(hello, strlen(hello), pos, paint);\n}\n",
    "width": 256,
    "height": 120,
    "hash": "bf0b2402533a23b6392e0676b7a8414c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPosText"
},
    "SkCanvas_drawPosTextH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkScalar xpos[] = { 20, 40, 80, 160 };\n    SkPaint paint;\n    canvas->drawPosTextH(\"XXXX\", 4, xpos, 20, paint);\n}\n",
    "width": 256,
    "height": 40,
    "hash": "95c6a7ef82993a8d2add676080e9438a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPosTextH"
},
    "SkCanvas_drawRRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRect outer = {30, 40, 210, 220};\n    SkRect radii = {30, 50, 70, 90 };\n    SkRRect rRect;\n    rRect.setNinePatch(outer, radii.fLeft, radii.fTop, radii.fRight, radii.fBottom);\n    canvas->drawRRect(rRect, paint);\n    paint.setColor(SK_ColorWHITE);\n    canvas->drawLine(outer.fLeft + radii.fLeft, outer.fTop,\n                     outer.fLeft + radii.fLeft, outer.fBottom, paint);\n    canvas->drawLine(outer.fRight - radii.fRight, outer.fTop,\n                     outer.fRight - radii.fRight, outer.fBottom, paint);\n    canvas->drawLine(outer.fLeft,  outer.fTop + radii.fTop,\n                     outer.fRight, outer.fTop + radii.fTop, paint);\n    canvas->drawLine(outer.fLeft,  outer.fBottom - radii.fBottom,\n                     outer.fRight, outer.fBottom - radii.fBottom, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "90fed1bb11efb43aada94113338c63d8",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawRRect"
},
    "SkCanvas_drawRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint rectPts[] = { {64, 48}, {192, 160} };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    paint.setStrokeJoin(SkPaint::kRound_Join);\n    SkMatrix rotator;\n    rotator.setRotate(30, 128, 128);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorYELLOW, SK_ColorMAGENTA } ) {\n        paint.setColor(color);\n        SkRect rect;\n        rect.set(rectPts[0], rectPts[1]);\n        canvas->drawRect(rect, paint);\n        rotator.mapPoints(rectPts, 2);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "871b0da9b4a23de11ae7a772ce14aed3",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawRect"
},
    "SkCanvas_drawRegion": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    region.op( 10, 10, 50, 50, SkRegion::kUnion_Op);\n    region.op( 10, 50, 90, 90, SkRegion::kUnion_Op);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    paint.setStrokeJoin(SkPaint::kRound_Join);\n    canvas->drawRegion(region, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "80309e0deca0f8add616cec7bec634ca",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawRegion"
},
    "SkCanvas_drawRoundRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkVector radii[] = { {0, 20}, {10, 10}, {10, 20}, {10, 40} };\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeJoin(SkPaint::kRound_Join);\n    paint.setAntiAlias(true);\n    for (auto style : { SkPaint::kStroke_Style, SkPaint::kFill_Style  } ) {\n        paint.setStyle(style );\n        for (size_t i = 0; i < SK_ARRAY_COUNT(radii); ++i) {\n           canvas->drawRoundRect({10, 10, 60, 40}, radii[i].fX, radii[i].fY, paint);\n           canvas->translate(0, 60);\n        }\n        canvas->translate(80, -240);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "199fe818c09026c114e165bff166a39f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawRoundRect"
},
    "SkCanvas_drawString": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->drawString(\"a small hello\", 20, 20, paint);\n}",
    "width": 256,
    "height": 48,
    "hash": "85442cf8d0bce6b5a777853bc36a4dc4",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawString"
},
    "SkCanvas_drawString_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkString string(\"a small hello\");\n    canvas->drawString(string, 20, 20, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "435178c09feb3bfec5e35d983609a013",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawString_2"
},
    "SkCanvas_drawText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    float textSizes[] = { 12, 18, 24, 36 };\n    for (auto size: textSizes ) {\n        paint.setTextSize(size);\n        canvas->drawText(\"Aa\", 2, 10, 20, paint);\n        canvas->translate(0, size * 2);\n    }\n    paint.reset();\n    paint.setAntiAlias(true);\n    float yPos = 20;\n    for (auto size: textSizes ) {\n        float scale = size / 12.f;\n        canvas->resetMatrix();\n        canvas->translate(100, 0);\n        canvas->scale(scale, scale);\n        canvas->drawText(\"Aa\", 2, 10 / scale, yPos / scale, paint);\n        yPos += size * 2;\n    }\n}\n",
    "width": 256,
    "height": 200,
    "hash": "55f5e59350622c5e2834d1c85789f732",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawText"
},
    "SkCanvas_drawTextBlob": {
    "code": "void draw(SkCanvas* canvas) {\n    SkTextBlobBuilder textBlobBuilder;\n    const char bunny[] = \"/(^x^)\\\\\";\n    const int len = sizeof(bunny) - 1;\n    uint16_t glyphs[len];\n    SkPaint paint;\n    paint.textToGlyphs(bunny, len, glyphs);\n    paint.setTextEncoding(SkTextEncoding::kGlyphID);\n    SkFont font;\n    int runs[] = { 3, 1, 3 };\n    SkPoint textPos = { 20, 100 };\n    int glyphIndex = 0;\n    for (auto runLen : runs) {\n        font.setSize(1 == runLen ? 20 : 50);\n        const SkTextBlobBuilder::RunBuffer& run =\n                textBlobBuilder.allocRun(font, runLen, textPos.fX, textPos.fY);\n        memcpy(run.glyphs, &glyphs[glyphIndex], sizeof(glyphs[0]) * runLen);\n        paint.setTextSize(1 == runLen ? 20 : 50);\n        textPos.fX += paint.measureText(&glyphs[glyphIndex], sizeof(glyphs[0]) * runLen, nullptr);\n        glyphIndex += runLen;\n    }\n    sk_sp<const SkTextBlob> blob = textBlobBuilder.make();\n    paint.reset();\n    canvas->drawTextBlob(blob.get(), 0, 0, paint);\n}\n",
    "width": 256,
    "height": 120,
    "hash": "005502b502c1282cb8d306d6c8d998fb",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawTextBlob"
},
    "SkCanvas_drawTextBlob_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkTextBlobBuilder textBlobBuilder;\n    SkFont font;\n    font.setSize(50);\n    const SkTextBlobBuilder::RunBuffer& run =\n            textBlobBuilder.allocRun(font, 1, 20, 100);\n    run.glyphs[0] = 20;\n    sk_sp<const SkTextBlob> blob = textBlobBuilder.make();\n    SkPaint paint;\n    paint.setTextSize(10);\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawTextBlob(blob.get(), 0, 0, paint);\n}\n",
    "width": 256,
    "height": 120,
    "hash": "1cae21e7b63b24de3eca0bbd9be1936b",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawTextBlob_2"
},
    "SkCanvas_drawTextRSXform": {
    "code": "void draw(SkCanvas* canvas) {\n    const int iterations = 26;\n    SkRSXform transforms[iterations];\n    char alphabet[iterations];\n    SkScalar angle = 0;\n    SkScalar scale = 1;\n    for (size_t i = 0; i < SK_ARRAY_COUNT(transforms); ++i) {\n        const SkScalar s = SkScalarSin(angle) * scale;\n        const SkScalar c = SkScalarCos(angle) * scale;\n        transforms[i] = SkRSXform::Make(-c, -s, -s * 16, c * 16);\n        angle += .45;\n        scale += .2;\n        alphabet[i] = 'A' + i;\n    }\n    SkPaint paint;\n    canvas->translate(110, 138);\n    canvas->drawTextRSXform(alphabet, sizeof(alphabet), transforms, nullptr, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "935c8f8b9782d297a73d7186f6ef7945",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawTextRSXform"
},
    "SkCanvas_drawVertices": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPoint points[] = { { 0, 0 }, { 250, 0 }, { 100, 100 }, { 0, 250 } };\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE, SK_ColorYELLOW, SK_ColorCYAN };\n    auto vertices = SkVertices::MakeCopy(SkVertices::kTriangleFan_VertexMode,\n            SK_ARRAY_COUNT(points), points, nullptr, colors);\n    canvas->drawVertices(vertices.get(), SkBlendMode::kSrc, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "f48b22eaad1bb7adcc3faaa321754af6",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawVertices"
},
    "SkCanvas_drawVertices_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPoint points[] = { { 0, 0 }, { 250, 0 }, { 100, 100 }, { 0, 250 } };\n    SkPoint texs[] = { { 0, 0 }, { 0, 250 }, { 250, 250 }, { 250, 0 } };\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE, SK_ColorYELLOW, SK_ColorCYAN };\n    paint.setShader(SkGradientShader::MakeLinear(points, colors, nullptr, 4,\n            SkShader::kClamp_TileMode));\n    auto vertices = SkVertices::MakeCopy(SkVertices::kTriangleFan_VertexMode,\n            SK_ARRAY_COUNT(points), points, texs, colors);\n    canvas->drawVertices(vertices, SkBlendMode::kDarken, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "e8bdae9bea3227758989028424fcac3d",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawVertices_2"
},
    "SkCanvas_getGrContext": {
    "code": "void draw(SkCanvas* canvas) {\n    if (canvas->getGrContext()) {\n         canvas->clear(SK_ColorRED);\n    } else {\n         canvas->clear(SK_ColorBLUE);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "c4ea949e5fa5a0630dcb6b0204bd498f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getGrContext"
},
    "SkCanvas_readPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(SK_ColorBLUE);\n    SkPaint paint;\n    canvas->drawCircle(32, 32, 28, paint);\n    SkImageInfo info = SkImageInfo::Make(64, 64, kBGRA_8888_SkColorType, kPremul_SkAlphaType);\n    sk_sp<SkData> data(SkData::MakeUninitialized(info.minRowBytes() * info.height()));\n    sk_bzero(data->writable_data(), info.minRowBytes() * info.height());\n    for (int x : { 32, -32 } ) {\n        for (int y : { 32, -32 } ) {\n            canvas->readPixels(info, data->writable_data(), info.minRowBytes(), x, y);\n        }\n    }\n    sk_sp<SkImage> image = SkImage::MakeRasterData(info, data, info.minRowBytes());\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 64,
    "height": 64,
    "hash": "102d014d7f753db2a9b9ee08893aaf11",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::readPixels"
},
    "SkCanvas_resetMatrix": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->scale(4, 6);\n    canvas->drawString(\"truth\", 2, 10, paint);\n    canvas->resetMatrix();\n    canvas->scale(2.8f, 6);\n    canvas->drawString(\"consequences\", 2, 20, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "412afffdf4682baa503a4e2e99201967",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::resetMatrix"
},
    "SkCanvas_rotate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->translate(128, 128);\n    canvas->drawCircle(0, 0, 60, paint);\n    canvas->save();\n    canvas->rotate(10 * 360 / 60);   // 10 minutes of 60 scaled to 360 degrees\n    canvas->drawLine(0, 0, 0, -50, paint);\n    canvas->restore();\n    canvas->rotate((5 + 10.f/60) * 360 / 12); // 5 and 10/60 hours of 12 scaled to 360 degrees\n    canvas->drawLine(0, 0, 0, -30, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "963789ac8498d4e505748ab3b15cdaa5",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::rotate()"
},
    "SkCanvas_rotate_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(96);\n    canvas->drawString(\"A1\", 130, 100, paint);\n    canvas->rotate(180, 130, 100);\n    canvas->drawString(\"A1\", 130, 100, paint);\n}\n",
    "width": 256,
    "height": 192,
    "hash": "bcf5baea1c66a957d5ffd7b54bbbfeff",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::rotate_2"
},
    "SkCanvas_save": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRect rect = { 0, 0, 25, 25 };\n    canvas->drawRect(rect, paint);\n    canvas->save();\n    canvas->translate(50, 50);\n    canvas->drawRect(rect, paint);\n    canvas->restore();\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect(rect, paint);\n}\n",
    "width": 256,
    "height": 100,
    "hash": "e477dce358a9ba3b0aa1bf33b8a376de",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::save()"
},
    "SkCanvas_saveLayer": {
    "code": "#include \"SkBlurImageFilter.h\"\n\nvoid draw(SkCanvas* canvas) {\n    SkPaint paint, blur;\n    blur.setImageFilter(SkBlurImageFilter::Make(3, 3, nullptr));\n    canvas->saveLayer(nullptr, &blur);\n    SkRect rect = { 25, 25, 50, 50};\n    canvas->drawRect(rect, paint);\n    canvas->translate(50, 50);\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect(rect, paint);\n    canvas->restore();\n}\n",
    "width": 256,
    "height": 128,
    "hash": "42318b18d403e17e07a541652da91ee2",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::saveLayer"
},
    "SkCanvas_saveLayerAlpha": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorRED);\n    canvas->drawCircle(50, 50, 50, paint);\n    canvas->saveLayerAlpha(nullptr, 128);\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawCircle(100, 50, 50, paint);\n    paint.setColor(SK_ColorGREEN);\n    paint.setAlpha(128);\n    canvas->drawCircle(75, 90, 50, paint);\n    canvas->restore();\n}",
    "width": 256,
    "height": 256,
    "hash": "8ab88d86fb438856cc48d6e2f08a6e24",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::saveLayerAlpha"
},
    "SkCanvas_saveLayerPreserveLCDTextRequests": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setLCDRenderText(true);\n    paint.setTextSize(20);\n    for (auto preserve : { false, true } ) {\n        preserve ? canvas->saveLayerPreserveLCDTextRequests(nullptr, nullptr)\n                 : canvas->saveLayer(nullptr, nullptr);\n        SkPaint p;\n        p.setColor(SK_ColorWHITE);\n        // Comment out the next line to draw on a non-opaque background.\n        canvas->drawRect(SkRect::MakeLTRB(25, 40, 200, 70), p);\n        canvas->drawString(\"Hamburgefons\", 30, 60, paint);\n        p.setColor(0xFFCCCCCC);\n        canvas->drawRect(SkRect::MakeLTRB(25, 70, 200, 100), p);\n        canvas->drawString(\"Hamburgefons\", 30, 90, paint);\n        canvas->restore();\n        canvas->translate(0, 80);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "8460bf8b013f46c67e0bd96e13451aff",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::saveLayerPreserveLCDTextRequests"
},
    "SkCanvas_saveLayer_2": {
    "code": "#include \"SkBlurImageFilter.h\"\n\nvoid draw(SkCanvas* canvas) {\n    SkPaint paint, blur;\n    blur.setImageFilter(SkBlurImageFilter::Make(3, 3, nullptr));\n    canvas->saveLayer(SkRect::MakeWH(90, 90), &blur);\n    SkRect rect = { 25, 25, 50, 50};\n    canvas->drawRect(rect, paint);\n    canvas->translate(50, 50);\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect(rect, paint);\n    canvas->restore();\n}\n",
    "width": 256,
    "height": 128,
    "hash": "a17aec3aa4909527be039e26a7eda694",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::saveLayer_2"
},
    "SkCanvas_saveLayer_3": {
    "code": "void draw(SkCanvas* canvas) {\n    // sk_sp<SkImage> image = GetResourceAsImage(\"images/mandrill_256.png\");\n    canvas->drawImage(image, 0, 0, nullptr);\n    SkCanvas::SaveLayerRec rec;\n    SkPaint paint;\n    paint.setBlendMode(SkBlendMode::kPlus);\n    rec.fSaveLayerFlags = SkCanvas::kInitWithPrevious_SaveLayerFlag;\n    rec.fPaint = &paint;\n    canvas->saveLayer(rec);\n    paint.setBlendMode(SkBlendMode::kClear);\n    canvas->drawCircle(128, 128, 96, paint);\n    canvas->restore();\n}",
    "width": 256,
    "height": 256,
    "hash": "7d3751e82d1b6ec328ffa3d6f48ca831",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::saveLayer_3"
},
    "SkCanvas_scale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRect rect = { 10, 20, 60, 120 };\n    canvas->translate(20, 20);\n    canvas->drawRect(rect, paint);\n    canvas->scale(2, .5f);\n    paint.setColor(SK_ColorGRAY);\n    canvas->drawRect(rect, paint);\n}\n",
    "width": 256,
    "height": 160,
    "hash": "7d0d801ef13c6c6da51e840c22ac15b0",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::scale()"
},
    "SkCanvas_setMatrix": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->scale(4, 6);\n    canvas->drawString(\"truth\", 2, 10, paint);\n    SkMatrix matrix;\n    matrix.setScale(2.8f, 6);\n    canvas->setMatrix(matrix);\n    canvas->drawString(\"consequences\", 2, 20, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "24b9cf7e6f9a08394e1e07413bd8733a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::setMatrix"
},
    "SkCanvas_skew": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    canvas->translate(30, 130);\n    canvas->save();\n    canvas->skew(-.5, 0);\n    canvas->drawString(\"A1\", 0, 0, paint);\n    canvas->restore();\n    canvas->save();\n    canvas->skew(0, .5);\n    paint.setColor(SK_ColorRED);\n    canvas->drawString(\"A1\", 0, 0, paint);\n    canvas->restore();\n    canvas->skew(-.5, .5);\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawString(\"A1\", 0, 0, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "2e2acc21d7774df7e0940a30ad2ca99e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::skew()"
},
    "SkCanvas_translate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint filledPaint;\n    SkPaint outlinePaint;\n    outlinePaint.setStyle(SkPaint::kStroke_Style);\n    outlinePaint.setColor(SK_ColorBLUE);\n    canvas->save();\n    canvas->translate(50, 50);\n    canvas->drawCircle(28, 28, 15, outlinePaint);  // blue center: (50+28, 50+28)\n    canvas->scale(2, 1/2.f);\n    canvas->drawCircle(28, 28, 15, filledPaint);   // black center: (50+(28*2), 50+(28/2))\n    canvas->restore();\n    filledPaint.setColor(SK_ColorGRAY);\n    outlinePaint.setColor(SK_ColorRED);\n    canvas->scale(2, 1/2.f);\n    canvas->drawCircle(28, 28, 15, outlinePaint);  // red center: (28*2, 28/2)\n    canvas->translate(50, 50);\n    canvas->drawCircle(28, 28, 15, filledPaint);   // gray center: ((50+28)*2, (50+28)/2)\n}\n",
    "width": 256,
    "height": 128,
    "hash": "eb93d5fa66a5f7a10f4f9210494d7222",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::translate()"
},
    "SkCanvas_writePixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo imageInfo = SkImageInfo::MakeN32(256, 1, kPremul_SkAlphaType);\n    for (int y = 0; y < 256; ++y) {\n        uint32_t pixels[256];\n        for (int x = 0; x < 256; ++x) {\n            pixels[x] = SkColorSetARGB(x, x + y, x, x - y);\n        }\n        canvas->writePixels(imageInfo, &pixels, sizeof(pixels), 0, y);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "29b98ebf58aa9fd1edfaabf9f4490b3a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::writePixels"
},
    "SkCanvas_writePixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo imageInfo = SkImageInfo::MakeN32Premul(2, 2);\n    SkBitmap bitmap;\n    bitmap.setInfo(imageInfo);\n    uint32_t pixels[4];\n    bitmap.setPixels(pixels);\n    for (int y = 0; y < 256; y += 2) {\n        for (int x = 0; x < 256;  x += 2) {\n            pixels[0] = SkColorSetRGB(x, y, x | y);\n            pixels[1] = SkColorSetRGB(x ^ y, y, x);\n            pixels[2] = SkColorSetRGB(x, x & y, y);\n            pixels[3] = SkColorSetRGB(~x, ~y, x);\n            canvas->writePixels(bitmap, x, y);\n        }\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8b128e067881f9251357653692fa28da",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::writePixels_2"
},
    "SkColorGetA": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(SK_ColorRED);\n    for (int alpha = 255; alpha >= 0; alpha -= 17) {\n        paint.setAlpha(alpha);\n        canvas->drawRect({5, 5, 100, 20}, paint);\n        SkAlpha alphaInPaint = SkColorGetA(paint.getColor());\n        canvas->drawString(std::to_string(alphaInPaint).c_str(), 110, 18, paint);\n        canvas->translate(0, 15);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "896ce0316b489608a95af5439ca2aab1",
    "file": "SkColor_Reference",
    "name": "SkColorGetA"
},
    "SkColorGetB": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawBitmap(source, 0, 0);\n    SkPaint bgPaint;\n    bgPaint.setColor(0xafffffff);\n    canvas->drawRect({20, 50, 80, 70}, bgPaint);\n    uint8_t blue = SkColorGetB(source.getColor(168, 170));\n    canvas->drawString(std::to_string(blue).c_str(), 40, 65, SkPaint());\n    canvas->drawLine(80, 70, 168, 170, SkPaint());\n}",
    "width": 256,
    "height": 256,
    "hash": "9ee27675284faea375611dc88123a2c5",
    "file": "SkColor_Reference",
    "name": "SkColorGetB"
},
    "SkColorGetG": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawBitmap(source, 0, 0);\n    SkPaint bgPaint;\n    bgPaint.setColor(0xafffffff);\n    canvas->drawRect({20, 50, 80, 70}, bgPaint);\n    uint8_t green = SkColorGetG(source.getColor(57, 192));\n    canvas->drawString(std::to_string(green).c_str(), 40, 65, SkPaint());\n    canvas->drawLine(80, 70, 57, 192, SkPaint());\n}",
    "width": 256,
    "height": 256,
    "hash": "535d38b2c019299d915170f7b03d5fea",
    "file": "SkColor_Reference",
    "name": "SkColorGetG"
},
    "SkColorGetR": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawBitmap(source, 0, 0);\n    SkPaint bgPaint;\n    bgPaint.setColor(0xafffffff);\n    canvas->drawRect({20, 50, 80, 70}, bgPaint);\n    uint8_t red = SkColorGetR(source.getColor(226, 128));\n    canvas->drawString(std::to_string(red).c_str(), 40, 65, SkPaint());\n    canvas->drawLine(80, 70, 226, 128, SkPaint());\n}",
    "width": 256,
    "height": 256,
    "hash": "d6da38577f189eaa6d9df75f6c3ed252",
    "file": "SkColor_Reference",
    "name": "SkColorGetR"
},
    "SkColorSetA": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawBitmap(source, 0, 0);\n    for (int y = 0; y < 256; y += 16) {\n       for (int x = 0; x < 256; x += 16) {\n         SkColor color = source.getColor(x + 8, y + 8);\n         SkPaint paint;\n         paint.setColor(SkColorSetA(color, x + y));\n         canvas->drawRect(SkRect::MakeXYWH(x, y, 16, 16), paint);\n      }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "18f6f376f771f5ffa56d5e5b2ebd20fb",
    "file": "SkColor_Reference",
    "name": "SkColorSetA"
},
    "SkColorSetARGB": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawColor(SK_ColorRED);\n    canvas->clipRect(SkRect::MakeWH(150, 150));\n    canvas->drawColor(SkColorSetARGB(0x80, 0x00, 0xFF, 0x00));\n    canvas->clipRect(SkRect::MakeWH(75, 75));\n    canvas->drawColor(SkColorSetARGB(0x80, 0x00, 0x00, 0xFF));\n}",
    "width": 256,
    "height": 256,
    "hash": "35888f0869e01a6e03b5b93bba563734",
    "file": "SkColor_Reference",
    "name": "SkColorSetARGB"
},
    "SkColorSetRGB": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawColor(SK_ColorRED);\n    canvas->clipRect(SkRect::MakeWH(150, 150));\n    canvas->drawColor(SkColorSetRGB(0x00, 0xFF, 0x00));\n    canvas->clipRect(SkRect::MakeWH(75, 75));\n    canvas->drawColor(SkColorSetRGB(0x00, 0x00, 0xFF));\n}",
    "width": 256,
    "height": 256,
    "hash": "dad12dd912197cd5edd789ac0801bf8a",
    "file": "SkColor_Reference",
    "name": "SkColorSetRGB"
},
    "SkColorToHSV": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawBitmap(source, 0, 0);\n    for (int y = 0; y < 256; ++y) {\n       for (int x = 0; x < 256; ++x) {\n         SkScalar hsv[3];\n         SkColorToHSV(source.getColor(x, y), hsv);\n         hsv[1] = 1 - hsv[1];\n         SkPaint paint;\n         paint.setColor(SkHSVToColor(hsv));\n         canvas->drawRect(SkRect::MakeXYWH(x, y, 1, 1), paint);\n      }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "1e0370f12c8aab5b84f9e824074f1e5a",
    "file": "SkColor_Reference",
    "name": "SkColorToHSV"
},
    "SkColorTypeBytesPerPixel": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = { \"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                             \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\" };\n    SkPaint paint;\n    paint.setTypeface(SkTypeface::MakeFromName(\"monospace\", SkFontStyle()));\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    int y = 15;\n    canvas->drawString(\"    colorType  bytes\", 10, y, paint);\n    for (SkColorType colorType : {\n    kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType,\n    kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType,\n    kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType,\n    kGray_8_SkColorType, kRGBA_F16_SkColorType\n                                 } ) {\n        int result = SkColorTypeBytesPerPixel(colorType);\n        SkString string;\n        string.printf(\"%13s %4d\", colors[(int) colorType], result);\n        canvas->drawString(string, 10, y += 14, paint);\n    }\n}",
    "width": 256,
    "height": 192,
    "hash": "09ef49d07cb7005ba3e34d5ea53896f5",
    "file": "SkImageInfo_Reference",
    "name": "SkColorTypeBytesPerPixel"
},
    "SkColorTypeIsAlwaysOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = { \"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                             \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\" };\n    SkPaint paint;\n    paint.setTypeface(SkTypeface::MakeFromName(\"monospace\", SkFontStyle()));\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    int y = 15;\n    canvas->drawString(\"    colorType  bytes\", 10, y, paint);\n    for (SkColorType colorType : {\n    kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType,\n    kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType,\n    kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType,\n    kGray_8_SkColorType, kRGBA_F16_SkColorType\n                                 } ) {\n        bool result = SkColorTypeIsAlwaysOpaque(colorType);\n        SkString string;\n        string.printf(\"%13s %6s\", colors[(int) colorType], result ? \"true\" : \"false\");\n        canvas->drawString(string, 10, y += 14, paint);\n    }\n}",
    "width": 256,
    "height": 192,
    "hash": "9b3eb5aaa0dfea9feee54e7650fa5446",
    "file": "SkImageInfo_Reference",
    "name": "SkColorTypeIsAlwaysOpaque"
},
    "SkColorTypeValidateAlphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = { \"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                             \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\" };\n    const char* alphas[] = {\"Unknown \", \"Opaque  \", \"Premul  \", \"Unpremul\"};\n    SkAlphaType alphaTypes[] = { kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType,\n    kUnpremul_SkAlphaType\n                               };\n    SkPaint paint;\n    paint.setTypeface(SkTypeface::MakeFromName(\"monospace\", SkFontStyle()));\n    paint.setAntiAlias(true);\n    paint.setTextSize(10);\n    int y = 15;\n    canvas->drawString(\"   colorType   alphaType  canonical\", 10, y, paint);\n    for (SkColorType colorType : {\n    kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType,\n    kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType,\n    kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType,\n    kGray_8_SkColorType, kRGBA_F16_SkColorType\n                                 } ) {\n        for (SkAlphaType alphaType : alphaTypes) {\n            SkAlphaType canonicalAlphaType  = kUnknown_SkAlphaType;\n            bool result = SkColorTypeValidateAlphaType(colorType, alphaType, &canonicalAlphaType);\n            SkString string;\n            string.printf(\"%13s %10s %10s\", colors[(int) colorType], alphas[(int) alphaType],\n                     result ? alphas[(int) canonicalAlphaType] : \"------  \");\n            canvas->drawString(string, 10, y += 14, paint);\n        }\n    }\n}",
    "width": 256,
    "height": 640,
    "hash": "befac1c29ed21507d367e4d824383a04",
    "file": "SkImageInfo_Reference",
    "name": "SkColorTypeValidateAlphaType"
},
    "SkDynamicMemoryWStream_bytesWritten": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::bytesWritten"
},
    "SkDynamicMemoryWStream_copyTo": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::copyTo"
},
    "SkDynamicMemoryWStream_copyToAndReset": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::copyToAndReset"
},
    "SkDynamicMemoryWStream_destructor": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::~SkDynamicMemoryWStream()"
},
    "SkDynamicMemoryWStream_detachAsData": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::detachAsData"
},
    "SkDynamicMemoryWStream_detachAsStream": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::detachAsStream"
},
    "SkDynamicMemoryWStream_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::SkDynamicMemoryWStream()"
},
    "SkDynamicMemoryWStream_padToAlign4": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::padToAlign4"
},
    "SkDynamicMemoryWStream_read": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::read()"
},
    "SkDynamicMemoryWStream_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::reset()"
},
    "SkDynamicMemoryWStream_write": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::write()"
},
    "SkDynamicMemoryWStream_writeToAndReset": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::writeToAndReset"
},
    "SkDynamicMemoryWStream_writeToStream": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkDynamicMemoryWStream_Reference",
    "name": "SkDynamicMemoryWStream::writeToStream"
},
    "SkFILEStream_Make": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::Make"
},
    "SkFILEStream_close": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::close()"
},
    "SkFILEStream_copy_const": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::SkFILEStream(const char path[] = nullptr)"
},
    "SkFILEStream_copy_star": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::SkFILEStream(FILE* file)"
},
    "SkFILEStream_destructor": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::~SkFILEStream()"
},
    "SkFILEStream_duplicate": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::duplicate()"
},
    "SkFILEStream_fork": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::fork()"
},
    "SkFILEStream_getLength": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::getLength"
},
    "SkFILEStream_getPosition": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::getPosition"
},
    "SkFILEStream_isAtEnd": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::isAtEnd"
},
    "SkFILEStream_isValid": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::isValid"
},
    "SkFILEStream_move": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::move()"
},
    "SkFILEStream_read": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::read()"
},
    "SkFILEStream_rewind": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::rewind()"
},
    "SkFILEStream_seek": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEStream_Reference",
    "name": "SkFILEStream::seek()"
},
    "SkFILEWStream_bytesWritten": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEWStream_Reference",
    "name": "SkFILEWStream::bytesWritten"
},
    "SkFILEWStream_copy_const": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEWStream_Reference",
    "name": "SkFILEWStream::SkFILEWStream(const char path[])"
},
    "SkFILEWStream_destructor": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEWStream_Reference",
    "name": "SkFILEWStream::~SkFILEWStream()"
},
    "SkFILEWStream_flush": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEWStream_Reference",
    "name": "SkFILEWStream::flush()"
},
    "SkFILEWStream_fsync": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEWStream_Reference",
    "name": "SkFILEWStream::fsync()"
},
    "SkFILEWStream_isValid": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEWStream_Reference",
    "name": "SkFILEWStream::isValid"
},
    "SkFILEWStream_write": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFILEWStream_Reference",
    "name": "SkFILEWStream::write()"
},
    "SkFont_Edging": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::Edging"
},
    "SkFont_SkTypeface_SkScalar": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::SkFont(sk_sp<SkTypeface> typeface, SkScalar size)"
},
    "SkFont_SkTypeface_SkScalar_SkScalar_SkScalar": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::SkFont(sk_sp<SkTypeface> typeface, SkScalar size, SkScalar scaleX, SkScalar skewX)"
},
    "SkFont_breakText": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::breakText"
},
    "SkFont_containsText": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::containsText"
},
    "SkFont_countText": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::countText"
},
    "SkFont_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::SkFont()"
},
    "SkFont_equal1_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::operator==(const SkFont& font) const"
},
    "SkFont_getEdging": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::getEdging"
},
    "SkFont_getHinting": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::getHinting"
},
    "SkFont_getMetrics": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::getMetrics"
},
    "SkFont_getPath": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::getPath"
},
    "SkFont_getPaths": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::getPaths"
},
    "SkFont_getScaleX": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::getScaleX"
},
    "SkFont_getSize": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::getSize"
},
    "SkFont_getSkewX": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::getSkewX"
},
    "SkFont_getSpacing": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::getSpacing"
},
    "SkFont_getTypeface": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::getTypeface"
},
    "SkFont_isEmbeddedBitmaps": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::isEmbeddedBitmaps"
},
    "SkFont_isEmbolden": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::isEmbolden"
},
    "SkFont_isForceAutoHinting": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::isForceAutoHinting"
},
    "SkFont_isLinearMetrics": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::isLinearMetrics"
},
    "SkFont_isSubpixel": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::isSubpixel"
},
    "SkFont_makeWithSize": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::makeWithSize"
},
    "SkFont_measureText": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::measureText"
},
    "SkFont_refTypeface": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::refTypeface"
},
    "SkFont_setEdging": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::setEdging"
},
    "SkFont_setEmbeddedBitmaps": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::setEmbeddedBitmaps"
},
    "SkFont_setEmbolden": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::setEmbolden"
},
    "SkFont_setForceAutoHinting": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::setForceAutoHinting"
},
    "SkFont_setHinting": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::setHinting"
},
    "SkFont_setLinearMetrics": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::setLinearMetrics"
},
    "SkFont_setScaleX": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::setScaleX"
},
    "SkFont_setSize": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::setSize"
},
    "SkFont_setSkewX": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::setSkewX"
},
    "SkFont_setSubpixel": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::setSubpixel"
},
    "SkFont_setTypeface": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::setTypeface"
},
    "SkFont_textToGlyphs": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::textToGlyphs"
},
    "SkFont_unicharToGlyph": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkFont_Reference",
    "name": "SkFont::unicharToGlyph"
},
    "SkHSVToColor": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawBitmap(source, 0, 0);\n    for (int y = 0; y < 256; ++y) {\n       for (int x = 0; x < 256; ++x) {\n         SkColor color = source.getColor(x, y);\n         SkScalar hsv[3];\n         SkColorToHSV(color, hsv);\n         hsv[0] = hsv[0] + 90 >= 360 ? hsv[0] - 270 : hsv[0] + 90;\n         SkPaint paint;\n         paint.setColor(SkHSVToColor(x + y, hsv));\n         canvas->drawRect(SkRect::MakeXYWH(x, y, 1, 1), paint);\n      }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "311a59931ac340b90f202cd6ac399a0a",
    "file": "SkColor_Reference",
    "name": "SkHSVToColor"
},
    "SkHSVToColor_2": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawBitmap(source, 0, 0);\n    for (int y = 0; y < 256; ++y) {\n       for (int x = 0; x < 256; ++x) {\n         SkColor color = source.getColor(x, y);\n         SkScalar hsv[3];\n         SkColorToHSV(color, hsv);\n         hsv[0] = hsv[0] + 90 >= 360 ? hsv[0] - 270 : hsv[0] + 90;\n         SkPaint paint;\n         paint.setColor(SkHSVToColor(hsv));\n         canvas->drawRect(SkRect::MakeXYWH(x, y, 1, 1), paint);\n      }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "d355a17547908cdbc2c38720974b5d11",
    "file": "SkColor_Reference",
    "name": "SkHSVToColor_2"
},
    "SkIPoint_add_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto draw_lines = [=](const SkIPoint pts[], size_t count, SkPaint& paint) -> void {\n        for (size_t i = 0; i < count - 1; ++i) {\n            SkPoint p0, p1;\n            p0.iset(pts[i]);\n            p1.iset(pts[i + 1]);\n            canvas->drawLine(p0, p1, paint);\n        }\n    };\n    SkIPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 } };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->scale(30, 15);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n    SkIPoint mod = {4, 1};\n    for (auto& point : points) {\n        point = point + mod;\n        mod.fX -= 1;\n        mod.fY += 1;\n    }\n    paint.setColor(SK_ColorRED);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "63f4cba971c6d8434595906f865b5a29",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator+(const SkIPoint& a, const SkIVector& b)"
},
    "SkIPoint_addto_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto draw_lines = [=](const SkIPoint pts[], size_t count, SkPaint& paint) -> void {\n        for (size_t i = 0; i < count - 1; ++i) {\n            SkPoint p0, p1;\n            p0.iset(pts[i]);\n            p1.iset(pts[i + 1]);\n            canvas->drawLine(p0, p1, paint);\n        }\n    };\n    SkIPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 } };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->scale(30, 15);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n    points[1] += {1, 1};\n    points[2] += {-1, -1};\n    paint.setColor(SK_ColorRED);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "4eb2d95c9e9a66f05296e345bb68bd51",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator+=(const SkIVector& v)"
},
    "SkIPoint_subtract_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto draw_lines = [=](const SkIPoint pts[], size_t count, SkPaint& paint) -> void {\n        for (size_t i = 0; i < count - 1; ++i) {\n            SkPoint p0, p1;\n            p0.iset(pts[i]);\n            p1.iset(pts[i + 1]);\n            canvas->drawLine(p0, p1, paint);\n        }\n    };\n    SkIPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 } };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->scale(30, 15);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n    points[1] += points[0] - points[3];\n    points[2] -= points[1] - points[0];\n    paint.setColor(SK_ColorRED);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "e626e26bf557857b824aa7d03f723e0f",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator-(const SkIPoint& a, const SkIPoint& b)"
},
    "SkIPoint_subtractfrom_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto draw_lines = [=](const SkIPoint pts[], size_t count, SkPaint& paint) -> void {\n        for (size_t i = 0; i < count - 1; ++i) {\n            SkPoint p0, p1;\n            p0.iset(pts[i]);\n            p1.iset(pts[i + 1]);\n            canvas->drawLine(p0, p1, paint);\n        }\n    };\n    SkIPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 } };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->scale(30, 15);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n    points[1] -= {1, 1};\n    points[2] -= {-1, -1};\n    paint.setColor(SK_ColorRED);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "a01e533dc7ab34ed728dc4e7a5f1f0ee",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator-=(const SkIVector& v)"
},
    "SkImageInfo_Make": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t storage[][5] = {{ 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 },\n                            { 0xAC, 0xA8, 0x89, 0xA7, 0x87 },\n                            { 0x9B, 0xB5, 0xE5, 0x95, 0x46 },\n                            { 0x90, 0x81, 0xC5, 0x71, 0x33 },\n                            { 0x75, 0x55, 0x44, 0x40, 0x30 }};\n    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->scale(8, 8);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 48,
    "hash": "9f47f9c2a99473f5b1113db48096d586",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::Make"
},
    "SkImageInfo_MakeA8": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t pixels[][8] = { { 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00},\n                            { 0x00, 0x7f, 0xff, 0x3f, 0x3f, 0x7f, 0x3f, 0x00},\n                            { 0x3f, 0xff, 0x7f, 0x00, 0x7f, 0xff, 0x7f, 0x00},\n                            { 0x00, 0x3f, 0x00, 0x00, 0x3f, 0x7f, 0x3f, 0x00},\n                            { 0x3f, 0x7f, 0x7f, 0x3f, 0x00, 0x00, 0x00, 0x00},\n                            { 0x7f, 0xff, 0xff, 0x7f, 0x00, 0x3f, 0x7f, 0x3f},\n                            { 0x7f, 0xff, 0xff, 0x7f, 0x00, 0x7f, 0xff, 0x7f},\n                            { 0x3f, 0x7f, 0x7f, 0x3f, 0x00, 0x3f, 0x7f, 0x3f} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeA8(8, 8),\n            (void*) pixels, sizeof(pixels[0]));\n    SkPaint paint;\n    canvas->scale(4, 4);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xFF007F00} ) {\n        paint.setColor(color);\n        canvas->drawBitmap(bitmap, 0, 0, &paint);\n        canvas->translate(12, 0);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "547388991687b8e10d482d8b1c82777d",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeA8"
},
    "SkImageInfo_MakeN32": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32(16, 16, kPremul_SkAlphaType));\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorWHITE);\n    SkPaint paint;\n    offscreen.drawString(\"g\", 0, 10, paint);\n    canvas->scale(8, 8);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 128,
    "hash": "78cea0c4cac205b61ad6f6c982cbd888",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeN32"
},
    "SkImageInfo_MakeN32Premul": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(18, 18));\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorWHITE);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(15);\n    offscreen.drawString(\"\\xF0\\x9F\\x98\\xB8\", 1, 15, paint);\n    canvas->scale(6, 6);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 128,
    "hash": "525650a67e19fdd8ca9f72b7eda65174",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeN32Premul"
},
    "SkImageInfo_MakeN32Premul_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul({18, 18}));\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorWHITE);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(15);\n    offscreen.drawString(\"\\xF0\\x9F\\x98\\xB9\", 1, 15, paint);\n    canvas->scale(6, 6);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 128,
    "hash": "b9026d7f39029756bd7cab9542c64f4e",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeN32Premul_2"
},
    "SkImageInfo_MakeS32": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 256;\n    const int height = 32;\n    SkImageInfo info = SkImageInfo::MakeN32Premul(width, height);\n    SkColor  gradColors[] = { 0xFFAA0055, 0xFF11CC88 };\n    SkPoint  gradPoints[] = { { 0, 0 }, { width, 0 } };\n    SkPaint gradPaint;\n    gradPaint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,\n                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32(width, height, kPremul_SkAlphaType));\n    SkCanvas offScreen(bitmap);\n    offScreen.drawRect(SkRect::MakeWH(width, height), gradPaint);\n    canvas->drawBitmap(bitmap, 0, 0);\n    bitmap.allocPixels(SkImageInfo::MakeS32(width, height, kPremul_SkAlphaType));\n    SkCanvas sRGBOffscreen(bitmap);\n    sRGBOffscreen.drawRect(SkRect::MakeWH(width, height), gradPaint);\n    canvas->drawBitmap(bitmap, 0, 48);\n    SkBitmap noColorSpaceBitmap;\n    noColorSpaceBitmap.setInfo(SkImageInfo::MakeN32(width, height, kPremul_SkAlphaType));\n    noColorSpaceBitmap.setPixels(bitmap.getAddr(0, 0));\n    canvas->drawBitmap(noColorSpaceBitmap, 0, 96);\n}",
    "width": 256,
    "height": 128,
    "hash": "de418ccb42471d1589508ef3955f8c53",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeS32"
},
    "SkImageInfo_MakeUnknown": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info;  // default constructor\n    SkString string;\n    string.printf(\"SkImageInfo() %c= SkImageInfo::MakeUnknown(0, 0)\",\n                  info == SkImageInfo::MakeUnknown(0, 0) ? '=' : '!');\n    SkPaint paint;\n    canvas->drawString(string, 0, 12, paint);\n}",
    "width": 384,
    "height": 32,
    "hash": "75f13a78b28b08c72baf32b7d868de1c",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeUnknown"
},
    "SkImageInfo_MakeUnknown_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info;  // default constructor\n    SkString string;\n    string.printf(\"SkImageInfo() %c= SkImageInfo::MakeUnknown()\",\n                  info == SkImageInfo::MakeUnknown() ? '=' : '!');\n    SkPaint paint;\n    canvas->drawString(string, 0, 12, paint);\n}",
    "width": 384,
    "height": 32,
    "hash": "a1af7696ae0cdd6f379546dd1f211b7a",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeUnknown_2"
},
    "SkImageInfo_bounds": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(.5f, .5f);\n    SkImageInfo imageInfo = source.info();\n    SkIRect bounds = imageInfo.bounds();\n    for (int x : { 0, bounds.width() } ) {\n        for (int y : { 0, bounds.height() } ) {\n            canvas->drawBitmap(source, x, y);\n        }\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "a818be8945cd0c18f99ffe53e90afa48",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::bounds()"
},
    "SkImageInfo_computeByteSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(2, 2);\n    const size_t size = info.computeByteSize(100000);\n    SkAutoTMalloc<SkPMColor> storage(size);\n    SkPMColor* pixels = storage.get();\n    SkBitmap bitmap;\n    bitmap.setInfo(info);\n    bitmap.setPixels(pixels);\n    bitmap.eraseColor(SK_ColorRED);\n    canvas->scale(50, 50);\n    canvas->rotate(8);\n    canvas->drawBitmap(bitmap, 2, 0);\n}",
    "width": 256,
    "height": 130,
    "hash": "9def507d2295f7051effd0c83bb04436",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::computeByteSize"
},
    "SkImageInfo_computeMinByteSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(2, 2);\n    const size_t size = info.computeMinByteSize();\n    SkAutoTMalloc<SkPMColor> storage(size);\n    SkPMColor* pixels = storage.get();\n    SkBitmap bitmap;\n    bitmap.setInfo(info);\n    bitmap.setPixels(pixels);\n    bitmap.eraseColor(SK_ColorRED);\n    canvas->scale(50, 50);\n    canvas->rotate(8);\n    canvas->drawBitmap(bitmap, 2, 0);\n}",
    "width": 256,
    "height": 130,
    "hash": "fc18640fdde437cb35338aed7c68d399",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::computeMinByteSize"
},
    "SkImageInfo_computeOffset": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t pixels[][12] = { { 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00},\n                             { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00},\n                             { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},\n                             { 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF},\n                             { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n                             { 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00},\n                             { 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00},\n                             { 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00} };\n    SkImageInfo imageInfo = SkImageInfo::MakeA8(8, 8);\n    SkBitmap bitmap;\n    bitmap.installPixels(imageInfo, (void*) pixels, sizeof(pixels[0]));\n    SkPaint paint;\n    paint.setColor(SK_ColorRED);\n    canvas->drawBitmapRect(bitmap, SkRect::MakeWH(8, 8), SkRect::MakeWH(32, 32), &paint);\n    size_t offset = imageInfo.computeOffset(2, 3, sizeof(pixels[0]));\n    pixels[0][offset] = 0x7F;\n    offset = imageInfo.computeOffset(5, 3, sizeof(pixels[0]));\n    pixels[0][offset] = 0x7F;\n    bitmap.installPixels(imageInfo, (void*) pixels, sizeof(pixels[0]));\n    canvas->drawBitmapRect(bitmap, SkRect::MakeWH(8, 8), SkRect::MakeWH(128, 128), &paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "818e4e1191e39d2a642902cbf253b399",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::computeOffset"
},
    "SkImageInfo_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo imageInfo;\n    size_t rowBytes;\n    SkIPoint origin;\n    (void) canvas->accessTopLayerPixels(&imageInfo, &rowBytes, &origin);\n    const char* alphaType[] = { \"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\" };\n    SkString string;\n    string.printf(\"k%s_SkAlphaType\", alphaType[(int) imageInfo.alphaType()]);\n    SkPaint paint;\n    canvas->drawString(string, 20, 20, paint);\n}",
    "width": 256,
    "height": 32,
    "hash": "f206f698e7a8db3d84334c26b1a702dc",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::SkImageInfo()"
},
    "SkImageInfo_gammaCloseToSRGB": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 256;\n    const int height = 64;\n    auto drawLabel = [=](const char* what, bool closeToSRGB) -> void {\n        SkString string;\n        string.printf(\"%s gamma is %s\" \"close to sRGB\", what, closeToSRGB ? \"\" : \"not \");\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        canvas->drawString(string, 20, 56, paint);\n    };\n    SkColor  gradColors[] = { 0xFFFF7F00, 0xFF00FF7F,  0xFF0000FF, 0xFF7F7FFF };\n    SkPoint  gradPoints[] = { { 0, 0 }, { width, 0 }, { width * 2, 0 }, { width * 3, 0 } };\n    SkPaint gradPaint;\n    gradPaint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,\n                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));\n    canvas->drawRect(SkRect::MakeWH(width, height), gradPaint);\n    drawLabel(\"canvas\", canvas->imageInfo().gammaCloseToSRGB());\n    SkBitmap bitmap;\n    SkImageInfo offscreenInfo = SkImageInfo::MakeS32(width, height, kPremul_SkAlphaType);\n    bitmap.allocPixels(offscreenInfo);\n    SkCanvas sRGBOffscreen(bitmap);\n    sRGBOffscreen.drawRect(SkRect::MakeWH(width, height), gradPaint);\n    canvas->translate(0, 80);\n    canvas->drawBitmap(bitmap, 0, 0);\n    drawLabel(\"offscreen\", offscreenInfo.gammaCloseToSRGB());\n}",
    "width": 256,
    "height": 144,
    "hash": "22df72732e898a11773fbfe07388a546",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::gammaCloseToSRGB"
},
    "SkImageInfo_height": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->translate(10, 20);\n    canvas->drawBitmap(source, 0, 0);\n    SkImageInfo imageInfo = source.info();\n    SkPaint paint;\n    canvas->drawLine(imageInfo.width() + 10, 0, imageInfo.width() + 10, imageInfo.height(), paint);\n    canvas->drawString(\"height\", imageInfo.width() + 15, imageInfo.height() / 2, paint);\n}",
    "width": 256,
    "height": 96,
    "hash": "72c35baaeddca1d912edf93d19429c8e",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::height()"
},
    "SkImageInfo_makeAlphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 256;\n    const int height = 128;\n    SkColor pixels[height][width];\n    for (int y = 0; y < height; ++y) {\n        for (int x = 0; x < width; ++x) {\n            int red = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarSin((x * 4 + y) * 0.03f)));\n            int blue = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarCos((x * 3 + y) * 0.04f)));\n            int green = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarSin((x * 2 + y) * 0.05f)));\n            int alpha = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarCos((x * 1 + y) * 0.006f)));\n            pixels[y][x] =\n                SkColorSetARGB(alpha, red * alpha / 255, green * alpha / 255, blue * alpha / 255);\n        }\n    }\n    SkBitmap bitmap;\n    SkImageInfo info = SkImageInfo::Make(width, height, kBGRA_8888_SkColorType, kPremul_SkAlphaType);\n    bitmap.installPixels(info, (void*) pixels, sizeof(SkColor) * width);\n    canvas->drawBitmap(source, 0, 0);\n    canvas->drawBitmap(bitmap, 0, 0);\n    SkImageInfo unpremulInfo = info.makeAlphaType(kUnpremul_SkAlphaType);\n    bitmap.installPixels(unpremulInfo, (void*) pixels, sizeof(SkColor) * width);\n    canvas->drawBitmap(bitmap, 0, 128);\n}",
    "width": 256,
    "height": 256,
    "hash": "e72db006f1bea26feceaef8727ff9818",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::makeAlphaType"
},
    "SkImageInfo_makeColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 256;\n    const int height = 64;\n    auto drawLabel = [=](const char* what, bool closeToSRGB) -> void {\n        SkString string;\n        string.printf(\"%s gamma is %s\" \"close to sRGB\", what, closeToSRGB ? \"\" : \"not \");\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        canvas->drawString(string, 20, 56, paint);\n    };\n    SkColor  gradColors[] = { 0xFFFF7F00, 0xFF00FF7F,  0xFF0000FF, 0xFF7F7FFF };\n    SkPoint  gradPoints[] = { { 0, 0 }, { width, 0 }, { width * 2, 0 }, { width * 3, 0 } };\n    SkPaint gradPaint;\n    gradPaint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,\n            SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));\n    canvas->drawRect(SkRect::MakeWH(width, height), gradPaint);\n    drawLabel(\"canvas\", canvas->imageInfo().gammaCloseToSRGB());\n    SkBitmap bitmap;\n    SkImageInfo offscreenInfo = SkImageInfo::MakeS32(width, height, kPremul_SkAlphaType);\n    bitmap.allocPixels(offscreenInfo);\n    SkCanvas sRGBOffscreen(bitmap);\n    sRGBOffscreen.drawRect(SkRect::MakeWH(width, height), gradPaint);\n    canvas->translate(0, 80);\n    canvas->drawBitmap(bitmap, 0, 0);\n    drawLabel(\"offscreen\", offscreenInfo.gammaCloseToSRGB());\n    SkImageInfo linearGamma =\n            offscreenInfo.makeColorSpace(offscreenInfo.colorSpace()->makeLinearGamma());\n    bitmap.allocPixels(linearGamma);\n    SkCanvas lgOffscreen(bitmap);\n    lgOffscreen.drawRect(SkRect::MakeWH(width, height), gradPaint);\n    canvas->translate(0, 80);\n    canvas->drawBitmap(bitmap, 0, 0);\n    drawLabel(\"linear\", linearGamma.gammaCloseToSRGB());\n}",
    "width": 256,
    "height": 224,
    "hash": "fe3c5a755d3dde29bba058a583f18901",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::makeColorSpace"
},
    "SkImageInfo_makeColorType": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 256;\n    const int height = 128;\n    SkColor pixels[height][width];\n    for (int y = 0; y < height; ++y) {\n        for (int x = 0; x < width; ++x) {\n            int red = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarSin((x * 4 + y) * 0.03f)));\n            int blue = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarCos((x * 3 + y) * 0.04f)));\n            int green = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarSin((x * 2 + y) * 0.05f)));\n            int alpha = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarCos((x * 1 + y) * 0.006f)));\n            pixels[y][x] =\n                SkColorSetARGB(alpha, red * alpha / 255, green * alpha / 255, blue * alpha / 255);\n        }\n    }\n    SkBitmap bitmap;\n    SkImageInfo info = SkImageInfo::Make(width, height, kBGRA_8888_SkColorType, kPremul_SkAlphaType);\n    bitmap.installPixels(info, (void*) pixels, sizeof(SkColor) * width);\n    canvas->drawBitmap(source, 0, 0);\n    canvas->drawBitmap(bitmap, 0, 0);\n    SkImageInfo rgbaInfo = info.makeColorType(kRGBA_8888_SkColorType);\n    bitmap.installPixels(rgbaInfo, (void*) pixels, sizeof(SkColor) * width);\n    canvas->drawBitmap(bitmap, 0, 128);\n}",
    "width": 256,
    "height": 256,
    "hash": "3ac267b08b12dc83c95f91d8dd5d70ee",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::makeColorType"
},
    "SkImageInfo_makeWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo canvasImageInfo = canvas->imageInfo();\n    SkRect canvasBounds = SkRect::Make(canvasImageInfo.bounds());\n    canvas->drawBitmapRect(source, source.bounds(), canvasBounds, nullptr);\n    SkImageInfo insetImageInfo =\n              canvasImageInfo.makeWH(canvasBounds.width() / 2, canvasBounds.height() / 2);\n    SkBitmap inset;\n    inset.allocPixels(insetImageInfo);\n    SkCanvas offscreen(inset);\n    offscreen.drawBitmapRect(source, source.bounds(), SkRect::Make(inset.bounds()), nullptr);\n    canvas->drawBitmap(inset, canvasBounds.width() / 4, canvasBounds.height() / 4);\n}",
    "width": 256,
    "height": 144,
    "hash": "cd203a3f9c5fb68272f21f302dd54fbc",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::makeWH"
},
    "SkImageInfo_width": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->translate(10, 10);\n    canvas->drawBitmap(source, 0, 0);\n    SkImageInfo imageInfo = source.info();\n    canvas->translate(0, imageInfo.height());\n    SkPaint paint;\n    canvas->drawLine(0, 10, imageInfo.width(), 10, paint);\n    canvas->drawString(\"width\", imageInfo.width() / 2 - 15, 25, paint);\n}",
    "width": 256,
    "height": 96,
    "hash": "e2491817695290d0218be77f091b8460",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::width()"
},
    "SkImage_MakeBackendTextureFromSkImage": {
    "code": "static sk_sp<SkImage> create_gpu_image(GrContext* grContext) {\n    const SkImageInfo info = SkImageInfo::MakeN32(20, 20, kOpaque_SkAlphaType);\n    auto surface(SkSurface::MakeRenderTarget(grContext, SkBudgeted::kNo, info));\n    SkCanvas* canvas = surface->getCanvas();\n    canvas->clear(SK_ColorWHITE);\n    SkPaint paint;\n    paint.setColor(SK_ColorBLACK);\n    canvas->drawRect(SkRect::MakeXYWH(5, 5, 10, 10), paint);\n    return surface->makeImageSnapshot();\n}\n\nvoid draw(SkCanvas* canvas) {\n    GrContext* grContext = canvas->getGrContext();\n    if (!grContext) {\n        return;\n    }\n    sk_sp<SkImage> backEndImage = create_gpu_image(grContext);\n    canvas->drawImage(backEndImage, 0, 0);\n    GrBackendTexture texture;\n    SkImage::BackendTextureReleaseProc proc;\n    if (!SkImage::MakeBackendTextureFromSkImage(grContext, std::move(backEndImage),\n            &texture, &proc)) {\n        return;\n    }\n    sk_sp<SkImage> i2 = SkImage::MakeFromTexture(grContext, texture, kTopLeft_GrSurfaceOrigin,\n            kN32_SkColorType, kOpaque_SkAlphaType, nullptr);\n    canvas->drawImage(i2, 30, 30);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "06aeb3cf63ffccf7b49fe556e5def351",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeBackendTextureFromSkImage"
},
    "SkImage_MakeCrossContextFromEncoded": {
    "code": "void draw(SkCanvas* canvas) {\n    GrContext* context = canvas->getGrContext();\n    sk_sp<SkData> encodedData = image->encodeToData(SkEncodedImageFormat::kJPEG, 100);\n    sk_sp<SkImage> image = SkImage::MakeCrossContextFromEncoded(context,\n                                                                encodedData, false, nullptr);\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "069c7b116479e3ca46f953f07dcbdd36",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeCrossContextFromEncoded"
},
    "SkImage_MakeCrossContextFromPixmap": {
    "code": "void draw(SkCanvas* canvas) {\n    GrContext* context = canvas->getGrContext();\n    SkPixmap pixmap;\n    if (source.peekPixels(&pixmap)) {\n        sk_sp<SkImage> image = SkImage::MakeCrossContextFromPixmap(context, pixmap,\n                                                                   false, nullptr);\n        canvas->drawImage(image, 0, 0);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "45bca8747b8f49b5be34b520897ef048",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeCrossContextFromPixmap"
},
    "SkImage_MakeFromAdoptedTexture": {
    "code": "void draw(SkCanvas* canvas) {\n    if (!canvas->getGrContext()) {\n        return;\n    }\n    canvas->scale(.5f, .5f);\n    canvas->clear(0x7f3f5f7f);\n    int x = 0, y = 0;\n    for (auto origin : { kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin } ) {\n        for (auto alpha : { kOpaque_SkAlphaType, kPremul_SkAlphaType, kUnpremul_SkAlphaType } ) {\n            sk_sp<SkImage> image = SkImage::MakeFromAdoptedTexture(canvas->getGrContext(),\n                                                                   backEndTexture, origin,\n                                                                   kRGBA_8888_SkColorType, alpha);\n            canvas->drawImage(image, x, y);\n            x += 160;\n        }\n        x -= 160 * 3;\n        y += 256;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "b034517e39394b7543f06ec885e36d7d",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromAdoptedTexture"
},
    "SkImage_MakeFromBitmap": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t storage[][5] = {{ 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 },\n                            { 0xAC, 0xA8, 0x89, 0xA7, 0x87 },\n                            { 0x9B, 0xB5, 0xE5, 0x95, 0x46 },\n                            { 0x90, 0x81, 0xC5, 0x71, 0x33 },\n                            { 0x75, 0x55, 0x44, 0x40, 0x30 }};\n    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    sk_sp<SkImage> image1 = SkImage::MakeFromBitmap(bitmap);\n    bitmap.setImmutable();\n    sk_sp<SkImage> image2 = SkImage::MakeFromBitmap(bitmap);\n    *pixmap.writable_addr8(2, 2) = 0x00;\n    canvas->scale(10, 10);\n    canvas->drawImage(image1, 0, 0);\n    canvas->drawImage(image2, 10, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "cf2cf53321e4e6a77c2841bfbc0ef707",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromBitmap"
},
    "SkImage_MakeFromEncoded": {
    "code": "void draw(SkCanvas* canvas) {\n    int x = 0;\n    for (int quality : { 100, 50, 10, 1} ) {\n        sk_sp<SkData> encodedData = image->encodeToData(SkEncodedImageFormat::kJPEG, quality);\n        sk_sp<SkImage> image = SkImage::MakeFromEncoded(encodedData);\n        canvas->drawImage(image, x, 0);\n        x += 64;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "894f732ed6409b1f392bc5481421d0e9",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromEncoded"
},
    "SkImage_MakeFromGenerator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    recorder.beginRecording(100, 100)->drawColor(SK_ColorRED);\n    auto picture = recorder.finishRecordingAsPicture();\n    auto gen = SkImageGenerator::MakeFromPicture({100, 100}, picture, nullptr, nullptr,\n                                                 SkImage::BitDepth::kU8, SkColorSpace::MakeSRGB());\n    sk_sp<SkImage> image = SkImage::MakeFromGenerator(std::move(gen));\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 256,
    "height": 128,
    "hash": "c2fec0746f88ca34d7dce59dd9bdef9e",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromGenerator"
},
    "SkImage_MakeFromPicture": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPictureRecorder recorder;\n    SkCanvas* recordingCanvas = recorder.beginRecording(50, 50);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xff007f00 } ) {\n        paint.setColor(color);\n        recordingCanvas->drawRect({10, 10, 30, 40}, paint);\n        recordingCanvas->translate(10, 10);\n        recordingCanvas->scale(1.2f, 1.4f);\n    }\n    sk_sp<SkPicture> playback = recorder.finishRecordingAsPicture();\n    int x = 0, y = 0;\n    for (auto alpha : { 70, 140, 210 } ) {\n        paint.setAlpha(alpha);\n        auto srgbColorSpace = SkColorSpace::MakeSRGB();\n        sk_sp<SkImage> image = SkImage::MakeFromPicture(playback, {50, 50}, nullptr, &paint,\n                                                        SkImage::BitDepth::kU8, srgbColorSpace);\n        canvas->drawImage(image, x, y);\n        x += 70; y += 70;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "4aa2879b9e44dfd6648995326d2c4dcf",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromPicture"
},
    "SkImage_MakeFromTexture": {
    "code": "void draw(SkCanvas* canvas) {\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n       return;\n    }\n    canvas->scale(.25f, .25f);\n    int x = 0;\n    for (auto origin : { kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin } ) {\n        sk_sp<SkImage> image = SkImage::MakeFromTexture(context, backEndTexture,\n               origin, kRGBA_8888_SkColorType, kOpaque_SkAlphaType, nullptr);\n        canvas->drawImage(image, x, 0);\n    x += 512;\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "94e9296c53bad074bf2a48ff885dac13",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromTexture"
},
    "SkImage_MakeFromTexture_2": {
    "code": "void draw(SkCanvas* canvas) {\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n       return;\n    }\n    auto debugster = [](SkImage::ReleaseContext releaseContext) -> void {\n     // broken\n     //   *((int *) releaseContext) += 128;\n    };\n    int x = 0;\n    for (auto origin : { kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin } ) {\n        sk_sp<SkImage> image = SkImage::MakeFromTexture(context, backEndTexture,\n               origin, kRGBA_8888_SkColorType, kOpaque_SkAlphaType, nullptr, debugster, &x);\n        canvas->drawImage(image, x, 0);\n        x += 128;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "f40e1ebba6b067714062b81877b22fa1",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromTexture_2"
},
    "SkImage_MakeRasterCopy": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t storage[][5] = {{ 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 },\n                            { 0xAC, 0xA8, 0x89, 0xA7, 0x87 },\n                            { 0x9B, 0xB5, 0xE5, 0x95, 0x46 },\n                            { 0x90, 0x81, 0xC5, 0x71, 0x33 },\n                            { 0x75, 0x55, 0x44, 0x40, 0x30 }};\n    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    sk_sp<SkImage> image = SkImage::MakeRasterCopy(pixmap);\n    *pixmap.writable_addr8(2, 2) = 0x00;\n    canvas->scale(10, 10);\n    canvas->drawBitmap(bitmap, 0, 0);\n    canvas->drawImage(image, 10, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "513afec5795a9504ebf6af5373d16b6b",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeRasterCopy"
},
    "SkImage_MakeRasterData": {
    "code": "void draw(SkCanvas* canvas) {\n    size_t rowBytes = image->width() * SkColorTypeBytesPerPixel(kRGBA_8888_SkColorType);\n    sk_sp<SkData> data = SkData::MakeUninitialized(rowBytes * image->height());\n    SkImageInfo dstInfo = SkImageInfo::MakeN32(image->width(), image->height(),\n                                               kPremul_SkAlphaType);\n    image->readPixels(dstInfo, data->writable_data(), rowBytes, 0, 0, SkImage::kAllow_CachingHint);\n    sk_sp<SkImage> raw = SkImage::MakeRasterData(dstInfo.makeColorType(kRGBA_8888_SkColorType),\n                                                 data, rowBytes);\n    canvas->drawImage(image, 0, 0);\n    canvas->drawImage(raw.get(), 128, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "22e7ce79ab2fe94252d23319f2258127",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeRasterData"
},
    "SkImage_alphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphaTypeStr[] = { \"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\" };\n    SkAlphaType alphaType = image->alphaType();\n    canvas->drawImage(image, 16, 0);\n    canvas->drawString(alphaTypeStr[(int) alphaType], 20, image->height() + 20, SkPaint());\n}",
    "width": 256,
    "height": 96,
    "hash": "1b9f1f05026ceb14ccb6926a13cdaa83",
    "file": "SkImage_Reference",
    "name": "SkImage::alphaType"
},
    "SkImage_bounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect bounds = image->bounds();\n    for (int x : { 0, bounds.width() } ) {\n        for (int y : { 0, bounds.height() } ) {\n            canvas->drawImage(image, x, y);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "c204b38b3fc08914b0a634aa4eaec894",
    "file": "SkImage_Reference",
    "name": "SkImage::bounds()"
},
    "SkImage_colorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap;\n    source.peekPixels(&pixmap);\n    canvas->scale(.25f, .25f);\n    int y = 0;\n    for (auto gamma : { SkColorSpace::kLinear_RenderTargetGamma,\n                        SkColorSpace::kSRGB_RenderTargetGamma } ) {\n        int x = 0;\n        sk_sp<SkColorSpace> colorSpace = SkColorSpace::MakeRGB(gamma, SkColorSpace::kSRGB_Gamut);\n        for (int index = 0; index < 2; ++index) {\n            pixmap.setColorSpace(colorSpace);\n            sk_sp<SkImage> image = SkImage::MakeRasterCopy(pixmap);\n            canvas->drawImage(image, x, y);\n            colorSpace = image->colorSpace()->makeColorSpin();\n            x += 512;\n        }\n        y += 512;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "4468d573f42af6f5e234be10a5453bb2",
    "file": "SkImage_Reference",
    "name": "SkImage::colorSpace"
},
    "SkImage_colorType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = { \"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                             \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\" };\n    SkColorType colorType = image->colorType();\n    canvas->drawImage(image, 16, 0);\n    canvas->drawString(colors[(int) colorType], 20, image->height() + 20, SkPaint());\n}",
    "width": 256,
    "height": 96,
    "hash": "50396fad4a128f58e400ca00fe09711f",
    "file": "SkImage_Reference",
    "name": "SkImage::colorType"
},
    "SkImage_encodeToData": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(4, 4);\n    SkIRect subset = {0, 0, 16, 64};\n    int x = 0;\n    for (int quality : { 0, 10, 50, 100 } ) {\n        sk_sp<SkData> data(image->encodeToData(SkEncodedImageFormat::kJPEG, quality));\n        sk_sp<SkImage> filtered = SkImage::MakeFromEncoded(data, &subset);\n        canvas->drawImage(filtered, x, 0);\n        x += 16;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "7a3bf8851bb7160e4e49c48f8c09639d",
    "file": "SkImage_Reference",
    "name": "SkImage::encodeToData"
},
    "SkImage_encodeToData_2": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(4, 4);\n    SkIRect subset = {136, 32, 200, 96};\n    sk_sp<SkData> data(image->encodeToData());\n    sk_sp<SkImage> eye = SkImage::MakeFromEncoded(data, &subset);\n    canvas->drawImage(eye, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "30cee813f6aa476b0a9c8a24283e53a3",
    "file": "SkImage_Reference",
    "name": "SkImage::encodeToData_2"
},
    "SkImage_getBackendTexture": {
    "code": "void draw(SkCanvas* canvas) {\n    GrContext* grContext = canvas->getGrContext();\n    if (!grContext) {\n        canvas->drawString(\"GPU only!\", 20, 40, SkPaint());\n        return;\n    }\n    sk_sp<SkImage> imageFromBackend = SkImage::MakeFromAdoptedTexture(grContext, backEndTexture,\n            kBottomLeft_GrSurfaceOrigin, kRGBA_8888_SkColorType, kOpaque_SkAlphaType);\n    GrBackendTexture textureFromImage = imageFromBackend->getBackendTexture(false);\n    if (!textureFromImage.isValid()) {\n        return;\n    }\n    sk_sp<SkImage> imageFromTexture = SkImage::MakeFromAdoptedTexture(grContext, textureFromImage,\n            kTopLeft_GrSurfaceOrigin, kRGBA_8888_SkColorType, kOpaque_SkAlphaType);\n    canvas->drawImage(imageFromTexture, 0, 0);\n    canvas->drawImage(imageFromBackend, 128, 128);\n}",
    "width": 256,
    "height": 256,
    "hash": "d093aad721261f421c4bef4a296aab48",
    "file": "SkImage_Reference",
    "name": "SkImage::getBackendTexture"
},
    "SkImage_height": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->translate(10, 10);\n    canvas->drawImage(image, 0, 0);\n    canvas->translate(image->width(), 0);\n    SkPaint paint;\n    canvas->drawLine(10, 0, 10, image->height(), paint);\n    canvas->drawString(\"height\", 34, image->height() / 2, paint);\n}",
    "width": 256,
    "height": 96,
    "hash": "a4f53a0b6ac85e7bc3887245b728530d",
    "file": "SkImage_Reference",
    "name": "SkImage::height()"
},
    "SkImage_isLazyGenerated": {
    "code": "class TestImageGenerator : public SkImageGenerator {\npublic:\n    TestImageGenerator() : SkImageGenerator(SkImageInfo::MakeN32Premul(10, 10)) {}\n    ~TestImageGenerator() override {}\nprotected:\n    bool onGetPixels(const SkImageInfo& info, void* pixelPtr, size_t rowBytes,\n                     const Options& options) override {\n        SkPMColor* pixels = static_cast<SkPMColor*>(pixelPtr);\n        for (int y = 0; y < info.height(); ++y) {\n            for (int x = 0; x < info.width(); ++x) {\n                pixels[y * info.width() + x] = 0xff223344 + y * 0x000C0811;\n            }\n        }\n        return true;\n    }\n};\n\nvoid draw(SkCanvas* canvas) {\n    auto gen = std::unique_ptr<TestImageGenerator>(new TestImageGenerator());\n    sk_sp<SkImage> image(SkImage::MakeFromGenerator(std::move(gen)));\n    SkString lazy(image->isLazyGenerated() ? \"is lazy\" : \"not lazy\");\n    canvas->scale(8, 8);\n    canvas->drawImage(image, 0, 0, nullptr);\n    SkPaint paint;\n    paint.setTextSize(4);\n    canvas->drawString(lazy, 2, 5, paint);\n}\n",
    "width": 256,
    "height": 80,
    "hash": "a8b8bd4bfe968e2c63085f867665227f",
    "file": "SkImage_Reference",
    "name": "SkImage::isLazyGenerated"
},
    "SkImage_isLazyGenerated_a": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {\n        if (nullptr == image) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        canvas->drawImage(image, 0, 0);\n        canvas->drawString(label, 30, image->height() / 4, paint);\n        canvas->drawString(\n                image->isLazyGenerated() ? \"is lazily generated\" : \"not lazily generated\",\n                20, image->height() * 3 / 4, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kRGBA_8888_SkColorType,\n                                kOpaque_SkAlphaType, nullptr));\n    drawImage(image, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, \"backEndTexture\");\n}\n",
    "width": 256,
    "height": 256,
    "hash": "f031c2a53f6a57833dc0127e674553da",
    "file": "SkImage_Reference",
    "name": "SkImage::isLazyGenerated_2"
},
    "SkImage_isTextureBacked": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {\n        if (nullptr == image) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        canvas->drawImage(image, 0, 0);\n        canvas->drawString(label, 30, image->height() / 4, paint);\n        canvas->drawString(image->isTextureBacked() ? \"is GPU texture\" : \"not GPU texture\",\n                           20, image->height() * 3 / 4, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kRGBA_8888_SkColorType,\n                                kOpaque_SkAlphaType, nullptr));\n    drawImage(image, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, \"backEndTexture\");\n}",
    "width": 256,
    "height": 256,
    "hash": "9cf5c62a3d2243e6577ae563f360ea9d",
    "file": "SkImage_Reference",
    "name": "SkImage::isTextureBacked"
},
    "SkImage_isValid": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {\n        if (nullptr == image) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        canvas->drawImage(image, 0, 0);\n        canvas->drawString(label, image->width() / 2, image->height() / 4, paint);\n        if (canvas->getGrContext()) {\n            canvas->drawString(image->isValid(canvas->getGrContext()) ? \"is valid on GPU\" :\n                    \"not valid on GPU\", 20, image->height() * 5 / 8, paint);\n        }\n        canvas->drawString(image->isValid(nullptr) ? \"is valid on CPU\" :\n                \"not valid on CPU\", 20, image->height() * 7 / 8, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kRGBA_8888_SkColorType,\n                                kOpaque_SkAlphaType, nullptr));\n    drawImage(image, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, \"backEndTexture\");\n}",
    "width": 256,
    "height": 256,
    "hash": "afc62f38aebc56af8e425297ec67dd37",
    "file": "SkImage_Reference",
    "name": "SkImage::isValid"
},
    "SkImage_makeColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkColorSpace> normalColorSpace = SkColorSpace::MakeRGB(\n             SkColorSpace::kSRGB_RenderTargetGamma, SkColorSpace::kSRGB_Gamut);\n    sk_sp<SkColorSpace> wackyColorSpace = normalColorSpace->makeColorSpin();\n    for (auto colorSpace : { normalColorSpace, wackyColorSpace  } ) {\n        sk_sp<SkImage> colorSpaced = image->makeColorSpace(colorSpace);\n        canvas->drawImage(colorSpaced, 0, 0);\n        canvas->translate(128, 0);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "dbf5f75c1275a3013672f896767140fb",
    "file": "SkImage_Reference",
    "name": "SkImage::makeColorSpace"
},
    "SkImage_makeNonTextureImage": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {\n        if (nullptr == image) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        sk_sp<SkImage> nonTexture(image->makeNonTextureImage());\n        canvas->drawImage(nonTexture, 0, 0);\n        canvas->drawString(label, 20, nonTexture->height() / 4, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kRGBA_8888_SkColorType,\n                                kOpaque_SkAlphaType, nullptr));\n    drawImage(image, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, \"backEndTexture\");\n}",
    "width": 256,
    "height": 256,
    "hash": "ecdbaff44a02c310ef672b7d393c6dea",
    "file": "SkImage_Reference",
    "name": "SkImage::makeNonTextureImage"
},
    "SkImage_makeRasterImage": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {\n        if (nullptr == image) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        sk_sp<SkImage> raster(image->makeRasterImage());\n        canvas->drawImage(raster, 0, 0);\n        canvas->drawString(label, 20, raster->height() / 4, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kRGBA_8888_SkColorType,\n                                kOpaque_SkAlphaType, nullptr));\n    drawImage(image, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, \"backEndTexture\");\n}",
    "width": 256,
    "height": 256,
    "hash": "aed5f399915d40bb5d133ab586e5bac3",
    "file": "SkImage_Reference",
    "name": "SkImage::makeRasterImage"
},
    "SkImage_makeShader": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setRotate(45);\n    SkPaint paint;\n    paint.setShader(image->makeShader(SkShader::kRepeat_TileMode, SkShader::kMirror_TileMode,\n                                      &matrix));\n    canvas->drawPaint(paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "1c6de6fe72b00b5be970f5f718363449",
    "file": "SkImage_Reference",
    "name": "SkImage::makeShader"
},
    "SkImage_makeShader_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setRotate(45);\n    matrix.postTranslate(125, 30);\n    SkPaint paint;\n    paint.setShader(image->makeShader(&matrix));\n    canvas->drawPaint(paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "10172fca71b9dbdcade772513ffeb27e",
    "file": "SkImage_Reference",
    "name": "SkImage::makeShader_2"
},
    "SkImage_makeSubset": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(.5f, .5f);\n    const int width = 64;\n    const int height = 64;\n    for (int y = 0; y < 512; y += height ) {\n        for (int x = 0; x < 512; x += width ) {\n            sk_sp<SkImage> subset(image->makeSubset({x, y, x + width, y + height}));\n            canvas->drawImage(subset, x * 3 / 2, y * 3 / 2);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "889e495ce3e3b3bacc96e8230932331c",
    "file": "SkImage_Reference",
    "name": "SkImage::makeSubset"
},
    "SkImage_makeTextureImage": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, GrContext* context, const char* label) -> void {\n        if (nullptr == image || nullptr == context) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        sk_sp<SkImage> texture(image->makeTextureImage(context, nullptr));\n        canvas->drawImage(texture, 0, 0);\n        canvas->drawString(label, 20, texture->height() / 4, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    GrContext* context = canvas->getGrContext();\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(context, backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kRGBA_8888_SkColorType,\n                                kOpaque_SkAlphaType, nullptr));\n    drawImage(image, context, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, context, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, context, \"backEndTexture\");\n}",
    "width": 256,
    "height": 256,
    "hash": "eeec9e07e604b44d0208899a2fe5bef5",
    "file": "SkImage_Reference",
    "name": "SkImage::makeTextureImage"
},
    "SkImage_makeWithFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkImageFilter> shadowFilter = SkDropShadowImageFilter::Make(\n                -10.0f * frame, 5.0f * frame, 3.0f, 3.0f, SK_ColorBLUE,\n                SkDropShadowImageFilter::kDrawShadowAndForeground_ShadowMode,\n                nullptr);\n    sk_sp<SkImageFilter> offsetFilter = SkOffsetImageFilter::Make(40, 40, shadowFilter, nullptr);\n    SkIRect subset = image->bounds();\n    SkIRect clipBounds = image->bounds();\n    clipBounds.outset(60, 60);\n    SkIRect outSubset;\n    SkIPoint offset;\n    sk_sp<SkImage> filtered(image->makeWithFilter(offsetFilter.get(), subset, clipBounds,\n                            &outSubset, &offset));\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawLine(0, 0, offset.fX, offset.fY, paint);\n    canvas->translate(offset.fX, offset.fY);\n    canvas->drawImage(filtered, 0, 0);\n    canvas->drawRect(SkRect::Make(outSubset), paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "85a76163138a2720ac003691d6363938",
    "file": "SkImage_Reference",
    "name": "SkImage::makeWithFilter"
},
    "SkImage_readPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(.5f, .5f);\n    const int width = 32;\n    const int height = 32;\n    std::vector<int32_t> dstPixels;\n    dstPixels.resize(height * width * 4);\n    SkImageInfo info = SkImageInfo::MakeN32Premul(width, height);\n    for (int y = 0; y < 512; y += height ) {\n        for (int x = 0; x < 512; x += width ) {\n            if (image->readPixels(info, &dstPixels.front(), width * 4, x, y)) {\n                SkPixmap dstPixmap(info, &dstPixels.front(), width * 4);\n                SkBitmap bitmap;\n                bitmap.installPixels(dstPixmap);\n                canvas->drawBitmap(bitmap, 0, 0);\n            }\n            canvas->translate(48, 0);\n        }\n        canvas->translate(-16 * 48, 48);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "8aa8ca63dff4641dfc6ea8a3c555d59c",
    "file": "SkImage_Reference",
    "name": "SkImage::readPixels"
},
    "SkImage_readPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    int rowBytes = image->width() * 4;\n    int quarterWidth = image->width() / 4;\n    int quarterHeight = image->height() / 4;\n    srcPixels.resize(image->height() * rowBytes);\n    for (int y = 0; y < 4; ++y) {\n        for (int x = 0; x < 4; ++x) {\n            SkPixmap pixmap(SkImageInfo::MakeN32Premul(quarterWidth, quarterHeight),\n                    &srcPixels.front() + x * image->height() * quarterWidth +\n                    y * quarterWidth, rowBytes);\n            image->readPixels(pixmap, x * quarterWidth, y * quarterHeight);\n        }\n    }\n    canvas->scale(.5f, .5f);\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(image->width(), image->height()),\n                             &srcPixels.front(), rowBytes);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "b77a73c4baa63a4a8e2a4fdd96144d0b",
    "file": "SkImage_Reference",
    "name": "SkImage::readPixels_2"
},
    "SkImage_refColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap;\n    source.peekPixels(&pixmap);\n    canvas->scale(.25f, .25f);\n    int y = 0;\n    for (auto gamma : { SkColorSpace::kLinear_RenderTargetGamma,\n                        SkColorSpace::kSRGB_RenderTargetGamma } ) {\n        int x = 0;\n        sk_sp<SkColorSpace> colorSpace = SkColorSpace::MakeRGB(gamma, SkColorSpace::kSRGB_Gamut);\n        for (int index = 0; index < 2; ++index) {\n            pixmap.setColorSpace(colorSpace);\n            sk_sp<SkImage> image = SkImage::MakeRasterCopy(pixmap);\n            canvas->drawImage(image, x, y);\n            colorSpace = image->refColorSpace()->makeColorSpin();\n            x += 512;\n        }\n        y += 512;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "59b2078ebfbda8736a57c0486ae33332",
    "file": "SkImage_Reference",
    "name": "SkImage::refColorSpace"
},
    "SkImage_refEncodedData": {
    "code": "void draw(SkCanvas* canvas) {\n    struct {\n        const char* name;\n        sk_sp<SkImage> image;\n    } tests[] = { { \"image\", image }, { \"bitmap\", SkImage::MakeFromBitmap(source) },\n          { \"texture\", SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                            kTopLeft_GrSurfaceOrigin, kRGBA_8888_SkColorType,\n                            kOpaque_SkAlphaType, nullptr) } };\n    SkString string;\n    SkPaint paint;\n    for (const auto& test : tests ) {\n        if (!test.image) {\n            string.printf(\"no %s\", test.name);\n        } else {\n            string.printf(\"%s\" \"encoded %s\", test.image->refEncodedData() ? \"\" : \"no \", test.name);\n        }\n        canvas->drawString(string, 10, 20, paint);\n        canvas->translate(0, 20);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "80856fe921ce36f8d5a32d8672bccbfc",
    "file": "SkImage_Reference",
    "name": "SkImage::refEncodedData"
},
    "SkImage_scalePixels": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    int quarterWidth = image->width() / 16;\n    int rowBytes = quarterWidth * 4;\n    int quarterHeight = image->height() / 16;\n    srcPixels.resize(quarterHeight * rowBytes);\n    SkPixmap pixmap(SkImageInfo::MakeN32Premul(quarterWidth, quarterHeight),\n                    &srcPixels.front(), rowBytes);\n    canvas->scale(4, 4);\n    SkFilterQuality qualities[] = { kNone_SkFilterQuality, kLow_SkFilterQuality,\n                     kMedium_SkFilterQuality, kHigh_SkFilterQuality };\n    for (unsigned index = 0; index < SK_ARRAY_COUNT(qualities); ++index) {\n        image->scalePixels(pixmap, qualities[index]);\n        sk_sp<SkImage> filtered = SkImage::MakeFromRaster(pixmap, nullptr, nullptr);\n        canvas->drawImage(filtered, 16 * index, 0);\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "5949c9a63610cae30019e5b1899ee38f",
    "file": "SkImage_Reference",
    "name": "SkImage::scalePixels"
},
    "SkImage_uniqueID": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkImage> subset = image->makeSubset({10, 20, 90, 100});\n    canvas->drawImage(image, 0, 0);\n    canvas->drawImage(subset, 128, 0);\n    SkPaint paint;\n    SkString s;\n    s.printf(\"original id: %d\", image->uniqueID());\n    canvas->drawString(s, 20, image->height() + 20, paint);\n    s.printf(\"subset id: %d\", subset->uniqueID());\n    canvas->drawString(s, 148, subset->height() + 20, paint);\n}",
    "width": 256,
    "height": 156,
    "hash": "d70194c9c51e700335f95de91846d023",
    "file": "SkImage_Reference",
    "name": "SkImage::uniqueID"
},
    "SkImage_width": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->translate(10, 10);\n    canvas->drawImage(image, 0, 0);\n    canvas->translate(0, image->height());\n    SkPaint paint;\n    canvas->drawLine(0, 10, image->width(), 10, paint);\n    canvas->drawString(\"width\", image->width() / 2 - 15, 25, paint);\n}",
    "width": 256,
    "height": 96,
    "hash": "9aec65fc252ffc9982fa8867433eca18",
    "file": "SkImage_Reference",
    "name": "SkImage::width()"
},
    "SkMatrix_Concat": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix, matrix2;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix2.setPolyToPoly(perspect, bitmapBounds, 4);\n    SkMatrix concat = SkMatrix::Concat(matrix, matrix2);\n    canvas->concat(concat);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "6b4562c7052da94f3d5b2412dca41946",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::Concat"
},
    "SkMatrix_MakeAll": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(64);\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            SkMatrix m = SkMatrix::MakeAll(sx, 1, 128,    0, sy, 128,   0, 0, 1);\n            canvas->concat(m);\n            canvas->drawString(\"K\", 0, 0, p);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "6bad83b64de9266e323c29d550e04188",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::MakeAll"
},
    "SkMatrix_MakeScale": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->concat(SkMatrix::MakeScale(4, 3));\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "7ff17718111df6d6f95381d8a8f1b389",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::MakeScale"
},
    "SkMatrix_MakeScale_2": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->concat(SkMatrix::MakeScale(4));\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "2956aeb50fa862cdb13995e1e56a4bc8",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::MakeScale_2"
},
    "SkMatrix_MakeTrans": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix = SkMatrix::MakeTrans(64, 48);\n    for (int i = 0; i < 4; ++i) {\n        canvas->drawBitmap(source, 0, 0);\n        canvas->concat(matrix);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "b2479df0d9cf296ff64ac31e36684557",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::MakeTrans"
},
    "SkMatrix_ScaleToFit": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* labels[] = { \"Fill\", \"Start\", \"Center\", \"End\" };\n    SkRect rects[] = {{5, 5, 59, 59}, {5, 74, 59, 108}, {10, 123, 44, 172}, {10, 187, 54, 231}};\n    SkRect bounds;\n    source.getBounds(&bounds);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    for (auto fit : { SkMatrix::kFill_ScaleToFit, SkMatrix::kStart_ScaleToFit,\n                      SkMatrix::kCenter_ScaleToFit, SkMatrix::kEnd_ScaleToFit } ) {\n        for (auto rect : rects ) {\n            canvas->drawRect(rect, paint);\n            SkMatrix matrix;\n            if (!matrix.setRectToRect(bounds, rect, fit)) {\n                continue;\n            }\n            SkAutoCanvasRestore acr(canvas, true);\n            canvas->concat(matrix);\n            canvas->drawBitmap(source, 0, 0);\n        }\n        canvas->drawString(labels[fit], 10, 255, paint);\n        canvas->translate(64, 0);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "17c3070b31b700ea8f52e48af9a66b6e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::ScaleToFit"
},
    "SkMatrix_fixedStepInX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    const SkPoint center = { 128, 128 };\n    matrix.setScale(20, 25, center.fX, center.fY);\n    matrix.postRotate(75, center.fX, center.fY);\n    {\n       SkAutoCanvasRestore acr(canvas, true);\n       canvas->concat(matrix);\n       canvas->drawBitmap(source, 0, 0);\n    }\n    if (matrix.isFixedStepInX()) {\n       SkPaint paint;\n       paint.setAntiAlias(true);\n       SkVector step = matrix.fixedStepInX(128);\n       SkVector end = center + step;\n       canvas->drawLine(center, end, paint);\n       SkVector arrow = { step.fX + step.fY, step.fY - step.fX};\n       arrow = arrow * .25f;\n       canvas->drawLine(end, end - arrow, paint);\n       canvas->drawLine(end, {end.fX + arrow.fY, end.fY - arrow.fX}, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "fad6b92b21b1e1deeae61978cec2d232",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::fixedStepInX"
},
    "SkMatrix_getMinMaxScales": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setAll(1, 0, 0,  0, 1, 0,   0, 0, 0);\n    if (matrix.invert(&matrix)) {\n        SkScalar factor[2] = {2, 2};\n        bool result = matrix.getMinMaxScales(factor);\n        SkDebugf(\"matrix.getMinMaxScales() %s %g %g\\n\",\n                result ? \"true\" : \"false\", factor[0], factor[1]);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "13adba0ecf5f82247cf051b4fa4d8a9c",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getMinMaxScales"
},
    "SkMatrix_getPerspX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m;\n    m.setIdentity();\n    m.set(SkMatrix::kMPersp0, -0.004f);\n    SkAutoCanvasRestore autoRestore(canvas, true);\n    canvas->translate(22, 144);\n    SkPaint black;\n    black.setAntiAlias(true);\n    black.setTextSize(24);\n    SkPaint gray = black;\n    gray.setColor(0xFF9f9f9f);\n    SkString string;\n    string.appendScalar(m.getPerspX());\n    canvas->drawString(string, 0, -72, gray);\n    canvas->concat(m);\n    canvas->drawString(string, 0, 0, black);\n}",
    "width": 256,
    "height": 256,
    "hash": "a0f5bf4b55e8c33bfda29bf67e34306f",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getPerspX"
},
    "SkMatrix_getPerspY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m;\n    m.setIdentity();\n    m.set(SkMatrix::kMPersp1, -0.004f);\n    SkAutoCanvasRestore autoRestore(canvas, true);\n    canvas->translate(22, 144);\n    SkPaint black;\n    black.setAntiAlias(true);\n    black.setTextSize(24);\n    SkPaint gray = black;\n    gray.setColor(0xFF9f9f9f);\n    SkString string;\n    string.appendScalar(m.getPerspY());\n    canvas->drawString(string, 0, -72, gray);\n    canvas->concat(m);\n    canvas->drawString(string, 0, 0, black);\n}",
    "width": 256,
    "height": 256,
    "hash": "424a00a73675dbd99ad20feb0267442b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getPerspY"
},
    "SkMatrix_hasPerspective": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    canvas->concat(matrix);\n    SkString string;\n    string.printf(\"hasPerspective %s\", matrix.hasPerspective() ? \"true\" : \"false\");\n    canvas->drawBitmap(source, 0, 0);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(48);\n    canvas->drawString(string, 0, source.bounds().height() + 48, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "688123908c733169bbbfaf11f41ecff6",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::hasPerspective"
},
    "SkMatrix_invert": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkPoint src[] = { { 10, 120}, {120, 120}, {120, 10}, {  10, 10} };\n    const SkPoint dst[] = { {150, 120}, {200, 100}, {240, 30}, { 130, 40} };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    matrix.setPolyToPoly(src, dst, 4);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, 4, src, paint);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, 4, dst, paint);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStrokeWidth(3);\n    paint.setStrokeCap(SkPaint::kRound_Cap);\n    canvas->drawPoints(SkCanvas::kPoints_PointMode, 4, dst, paint);\n    if (matrix.invert(&matrix)) {\n        canvas->concat(matrix);\n        canvas->drawPoints(SkCanvas::kPoints_PointMode, 4, dst, paint);\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "0e03cd9f154603ed4b21ca56d69dae44",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::invert()"
},
    "SkMatrix_isSimilarity": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    SkMatrix m;\n    int below = 175;\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            m.setAll(sx, 1, 128,    1, sy, 32,   0, 0, 1);\n            bool isSimilarity = m.isSimilarity();\n            SkString str;\n            str.printf(\"sx: %g sy: %g sim: %s\", sx, sy, isSimilarity ? \"true\" : \"false\");\n            {\n                SkAutoCanvasRestore autoRestore(canvas, true);\n                canvas->concat(m);\n                canvas->drawString(str, 0, 0, p);\n            }\n            if (!isSimilarity) {\n                canvas->drawString(str, 40, below, p);\n                below += 20;\n            }\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "8b37f4ae7fec1756433c0f984175fb14",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isSimilarity"
},
    "SkMatrix_mapHomogeneousPoints": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint3 src[] = {{3, 3, 1}, {8, 2, 2}, {5, 0, 4}, {0, 1, 3},\n                      {3, 7, 1}, {8, 6, 2}, {5, 4, 4}, {0, 5, 3}};\n    int lines[] = { 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 };\n    constexpr int count = SK_ARRAY_COUNT(src);\n    auto debugster = [=](SkPoint3 src[]) -> void {\n    for (size_t i = 0; i < SK_ARRAY_COUNT(lines); i += 2) {\n        const SkPoint3& s = src[lines[i]];\n        const SkPoint3& e = src[lines[i + 1]];\n        SkPaint paint;\n        paint.setARGB(77, 23, 99, 154);\n        canvas->drawLine(s.fX / s.fZ, s.fY / s.fZ, e.fX / e.fZ, e.fY / e.fZ, paint);\n    }\n    };\n    canvas->save();\n    canvas->translate(5, 5);\n    canvas->scale(15, 15);\n    debugster(src);\n    canvas->restore();\n    canvas->translate(128, 128);\n    SkMatrix matrix;\n    matrix.setAll(15, 0, 0, 0, 15, 0, -0.08, 0.04, 1);\n    matrix.mapHomogeneousPoints(src, src, count);\n    debugster(src);\n}",
    "width": 256,
    "height": 256,
    "hash": "d56f93e4bc763c7ba4914321ed07a8b5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapHomogeneousPoints"
},
    "SkMatrix_mapPoints": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.reset();\n    const int count = 4;\n    SkPoint src[count];\n    matrix.mapRectToQuad(src, {40, 70, 180, 220} );\n    SkPaint paint;\n    paint.setARGB(77, 23, 99, 154);\n    for (int i = 0; i < 5; ++i) {\n        SkPoint dst[count];\n        matrix.mapPoints(dst, src, count);\n        canvas->drawPoints(SkCanvas::kPolygon_PointMode, count, dst, paint);\n        matrix.preRotate(35, 128, 128);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "f99dcb00296d0c56b6c0e178e94b3534",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapPoints"
},
    "SkMatrix_mapPoints_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setRotate(35, 128, 128);\n    const int count = 4;\n    SkPoint pts[count];\n    matrix.mapRectToQuad(pts, {40, 70, 180, 220} );\n    SkPaint paint;\n    paint.setARGB(77, 23, 99, 154);\n    for (int i = 0; i < 5; ++i) {\n        canvas->drawPoints(SkCanvas::kPolygon_PointMode, count, pts, paint);\n        matrix.mapPoints(pts, count);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "428ca171ae3bd0d3f992458ac598b97b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapPoints_2"
},
    "SkMatrix_mapRadius": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    const SkPoint center = {108, 93};\n    matrix.setScale(2, .5f, center.fX, center.fY);\n    matrix.postRotate(45, center.fX, center.fY);\n    const SkScalar circleRadius = 50;\n    SkScalar mappedRadius = matrix.mapRadius(circleRadius);\n    SkVector minorAxis, majorAxis;\n    matrix.mapVector(0, circleRadius, &minorAxis);\n    matrix.mapVector(circleRadius, 0, &majorAxis);\n    SkString mappedArea;\n    mappedArea.printf(\"area = %g\", mappedRadius * mappedRadius);\n    canvas->drawString(mappedArea, 145, 250, paint);\n    canvas->drawString(\"mappedRadius\", center.fX + mappedRadius + 3, center.fY, paint);\n    paint.setColor(SK_ColorRED);\n    SkString axArea;\n    axArea.printf(\"area = %g\", majorAxis.length() * minorAxis.length());\n    paint.setStyle(SkPaint::kFill_Style);\n    canvas->drawString(axArea, 15, 250, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRect({10, 200, 10 + majorAxis.length(), 200 + minorAxis.length()}, paint);\n    paint.setColor(SK_ColorBLACK);\n    canvas->drawLine(center.fX, center.fY, center.fX + mappedRadius, center.fY, paint);\n    canvas->drawLine(center.fX, center.fY, center.fX, center.fY + mappedRadius, paint);\n    canvas->drawRect({140, 180, 140 + mappedRadius, 180 + mappedRadius}, paint);\n    canvas->concat(matrix);\n    canvas->drawCircle(center.fX, center.fY, circleRadius, paint);\n    paint.setColor(SK_ColorRED);\n    canvas->drawLine(center.fX, center.fY, center.fX + circleRadius, center.fY, paint);\n    canvas->drawLine(center.fX, center.fY, center.fX, center.fY + circleRadius, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "6d6f2082fcf59d9f02bfb1758b87db69",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapRadius"
},
    "SkMatrix_mapRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    matrix.setRotate(45, 128, 128);\n    SkRect rotatedBounds, bounds = {40, 50, 190, 200};\n    matrix.mapRect(&rotatedBounds, bounds );\n    paint.setColor(SK_ColorGRAY);\n    canvas->drawRect(rotatedBounds, paint);\n    canvas->concat(matrix);\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect(bounds, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "dbcf928b035a31ca69c99392e2e2cca9",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapRect"
},
    "SkMatrix_mapRectScaleTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkMatrix matrix;\n    SkRect rect = {100, 50, 150, 180};\n    matrix.setScale(2, .5f, rect.centerX(), rect.centerY());\n    SkRect rotated;\n    matrix.mapRectScaleTranslate(&rotated, rect);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect(rotated, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "62bc26989c2b4c2a54d516596a71dd97",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapRectScaleTranslate"
},
    "SkMatrix_mapRectToQuad": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    matrix.setRotate(60, 128, 128);\n    SkRect rect = {50, 50, 150, 150};\n    SkPoint pts[4];\n    matrix.mapRectToQuad(pts, rect);\n    for (int i = 0; i < 4; ++i) {\n        canvas->drawCircle(pts[i].fX, pts[i].fY, 3, paint);\n    }\n    canvas->concat(matrix);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 192,
    "hash": "c69cd2a590b5733c3cbc92cb9ceed3f5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapRectToQuad"
},
    "SkMatrix_mapRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    matrix.setRotate(45, 128, 128);\n    SkRect bounds = {40, 50, 190, 200};\n    matrix.mapRect(&bounds);\n    paint.setColor(SK_ColorGRAY);\n    canvas->drawRect(bounds, paint);\n    canvas->concat(matrix);\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect({40, 50, 190, 200}, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "5fafd0bd23d1ed37425b970b4a3c6cc9",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapRect_2"
},
    "SkMatrix_mapRect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect{110, 50, 180, 100};\n    SkMatrix matrix;\n    matrix.setRotate(50, 28, 28);\n    SkRect mapped = matrix.mapRect(rect);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRect(rect, paint);\n    canvas->drawRect(mapped, paint);\n    canvas->concat(matrix);\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "3b7b1f884437ab450f986234e4aec27f",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapRect_3"
},
    "SkMatrix_mapVector": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGREEN);\n    paint.setAntiAlias(true);\n    paint.setTextSize(48);\n    SkMatrix matrix;\n    matrix.setRotate(90);\n    SkVector offset = { 7, 7 };\n    for (int i = 0; i < 4; ++i) {\n        paint.setImageFilter(SkDropShadowImageFilter::Make(offset.fX, offset.fY, 3, 3,\n              SK_ColorBLUE, SkDropShadowImageFilter::kDrawShadowAndForeground_ShadowMode, nullptr));\n        matrix.mapVector(offset.fX, offset.fY, &offset);\n        canvas->translate(0, 60);\n        canvas->drawString(\"Text\", 50, 0, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "aed143fc6cd0bce4ed029b98d1e61f2d",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapVector"
},
    "SkMatrix_mapVector_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGREEN);\n    paint.setAntiAlias(true);\n    paint.setTextSize(48);\n    SkMatrix matrix;\n    matrix.setRotate(90);\n    SkVector offset = { 7, 7 };\n    for (int i = 0; i < 4; ++i) {\n        paint.setImageFilter(SkDropShadowImageFilter::Make(offset.fX, offset.fY, 3, 3,\n              SK_ColorBLUE, SkDropShadowImageFilter::kDrawShadowAndForeground_ShadowMode, nullptr));\n        offset = matrix.mapVector(offset.fX, offset.fY);\n        canvas->translate(0, 60);\n        canvas->drawString(\"Text\", 50, 0, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "8bf1518db3f369696cd3065b541a8bd7",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapVector_2"
},
    "SkMatrix_mapVectors": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkMatrix matrix;\n    matrix.reset();\n    const SkVector radii[] = {{8, 4}, {9, 1}, {6, 2}, {7, 3}};\n    for (int i = 0; i < 4; ++i) {\n        SkVector rScaled[4];\n        matrix.preScale(1.5f, 2.f);\n        matrix.mapVectors(rScaled, radii, SK_ARRAY_COUNT(radii));\n        SkRRect rrect;\n        rrect.setRectRadii({20, 20, 180, 70}, rScaled);\n        canvas->drawRRect(rrect, paint);\n        canvas->translate(0, 60);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "918a9778c3d7d5cb306692784399f6dc",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapVectors"
},
    "SkMatrix_mapVectors_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkMatrix matrix;\n    matrix.setScale(2, 3);\n    SkVector radii[] = {{7, 7}, {3, 3}, {2, 2}, {4, 0}};\n    for (int i = 0; i < 4; ++i) {\n        SkRRect rrect;\n        rrect.setRectRadii({20, 20, 180, 70}, radii);\n        canvas->drawRRect(rrect, paint);\n        canvas->translate(0, 60);\n        matrix.mapVectors(radii, SK_ARRAY_COUNT(radii));\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "5754501a00a1323e76353fb53153e939",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapVectors_2"
},
    "SkMatrix_mapXY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    matrix.setRotate(60, 128, 128);\n    SkPoint lines[] = {{50, 50}, {150, 50}, {150, 150}};\n    for (size_t i = 0; i < SK_ARRAY_COUNT(lines); ++i) {\n        SkPoint pt;\n        matrix.mapXY(lines[i].fX, lines[i].fY, &pt);\n        canvas->drawCircle(pt.fX, pt.fY, 3, paint);\n    }\n    canvas->concat(matrix);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(lines), lines, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "9e50185d502dc6903783679a84106089",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapXY"
},
    "SkMatrix_mapXY_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {30, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStrokeWidth(3);\n    for (int x : { 0, source.width() } ) {\n        for (int y : { 0, source.height() } ) {\n            canvas->drawPoint(matrix.mapXY(x, y), paint);\n        }\n    }\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "b1ead09c67a177ab8eace12b061610a7",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapXY_2"
},
    "SkMatrix_postConcat": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postConcat(matrix);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "e4226c55d9bdbc119264bd372b2b9835",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postConcat"
},
    "SkMatrix_postIDiv": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postIDiv(1, 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "e6ad0bd2999613d9e4758b661d45070c",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postIDiv"
},
    "SkMatrix_postRotate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postRotate(45, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "e09194ee48a81e7b375ade473d340f0d",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postRotate"
},
    "SkMatrix_postRotate_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postRotate(45);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "52e4c53e26971af5576b30de60fa70c2",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postRotate_2"
},
    "SkMatrix_postScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postScale(.75f, 1.5f, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "ed3aa18ba0ea95c85cc49aa3829fe384",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postScale"
},
    "SkMatrix_postScale_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postScale(.75f, 1.5f);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "1931017698766a67d3a26423453b8095",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postScale_2"
},
    "SkMatrix_postSkew": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postSkew(.5f, 0, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "8c34ae3a2b7e2742bb969819737365ec",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postSkew"
},
    "SkMatrix_postSkew_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postSkew(.5f, 0);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "3aa2603225dff72ac53dd359f897f494",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postSkew_2"
},
    "SkMatrix_postTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    for (int i = 0; i < 2; ++i ) {\n        SkMatrix matrix;\n        i == 0 ? matrix.reset(): matrix.setRotate(25, rect.centerX(), 320);\n        {\n            SkAutoCanvasRestore acr(canvas, true);\n            canvas->concat(matrix);\n            paint.setColor(SK_ColorGRAY);\n            canvas->drawRect(rect, paint);\n        }\n        paint.setColor(SK_ColorRED);\n        for (int j = 0; j < 2; ++j ) {\n            SkAutoCanvasRestore acr(canvas, true);\n            matrix.postTranslate(40, 40);\n            canvas->concat(matrix);\n            canvas->drawCircle(0, 0, 3, paint);\n        }\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "f5144ef4bd7cea294fad2f756ed335af",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postTranslate"
},
    "SkMatrix_preConcat": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix, matrix2;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix2.setPolyToPoly(perspect, bitmapBounds, 4);\n    matrix.preConcat(matrix2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "b07e62298e7b0ab5683db199faffceb2",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preConcat"
},
    "SkMatrix_preRotate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preRotate(45, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "a70bb18d67c06a20ab514e7a47924e5a",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preRotate"
},
    "SkMatrix_preRotate_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preRotate(45);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "5acd49bd931c79a808dd6c7cc0e92f72",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preRotate_2"
},
    "SkMatrix_preScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preScale(.75f, 1.5f, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "2531f8d1e05d7b6dc22f3efcd2fb84e4",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preScale"
},
    "SkMatrix_preScale_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preScale(.75f, 1.5f);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "3edbdea8e43d06086abf33ec4a9b415b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preScale_2"
},
    "SkMatrix_preSkew": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preSkew(.5f, 0, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "199a18ad61d702664ce6df1d7037aa48",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preSkew"
},
    "SkMatrix_preSkew_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preSkew(.5f, 0);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "e100c543869fe8fd516ba69de79444ba",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preSkew_2"
},
    "SkMatrix_preTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    for (int i = 0; i < 2; ++i ) {\n        SkMatrix matrix;\n        i == 0 ? matrix.reset(): matrix.setRotate(25, rect.centerX(), 320);\n        {\n            SkAutoCanvasRestore acr(canvas, true);\n            canvas->concat(matrix);\n            paint.setColor(SK_ColorGRAY);\n            canvas->drawRect(rect, paint);\n        }\n        paint.setColor(SK_ColorRED);\n        for (int j = 0; j < 2; ++j ) {\n            SkAutoCanvasRestore acr(canvas, true);\n            matrix.preTranslate(40, 40);\n            canvas->concat(matrix);\n            canvas->drawCircle(0, 0, 3, paint);\n        }\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "f75a9b629aa6c51ed888f8799b5ba5f7",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preTranslate"
},
    "SkMatrix_preservesRightAngles": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    SkMatrix m;\n    int pos = 0;\n    for (SkScalar sx : { 1, 2 } ) {\n        for (SkScalar kx : { 0, 1 } ) {\n            m.setAll(sx, kx, 16,    0, 1, 32,   0, 0, 1);\n            bool isSimilarity = m.isSimilarity();\n            bool preservesRightAngles = m.preservesRightAngles();\n            SkString str;\n            str.printf(\"sx: %g kx: %g %s %s\", sx, kx, isSimilarity ? \"sim\" : \"\",\n                        preservesRightAngles ? \"right\" : \"\");\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            canvas->concat(m);\n            canvas->drawString(str, 0, pos, p);\n            pos += 20;\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "b9becf0dc24a9f00726e24a81fb72f16",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preservesRightAngles"
},
    "SkMatrix_set9": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m;\n    SkScalar buffer[9] = {4, 0, 3,    0, 5, 4,     0, 0, 1};\n    m.set9(buffer);\n    canvas->concat(m);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "ec5de0d23e5fe28ba7628625d1402e85",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::set9"
},
    "SkMatrix_setAll": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(64);\n    SkMatrix m;\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            m.setAll(sx, 1, 128,    0, sy, 64,   0, 0, 1);\n            canvas->concat(m);\n            canvas->drawString(\"K\", 0, 0, p);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "95ccfc2a89ce593e6b7a9f992a844bc0",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setAll"
},
    "SkMatrix_setConcat": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix, matrix2;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix2.setPolyToPoly(perspect, bitmapBounds, 4);\n    matrix.setConcat(matrix, matrix2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "0381a10ac69bdefdf9d15b47cbb9fefe",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setConcat"
},
    "SkMatrix_setPerspX": {
    "code": "void draw(SkCanvas* canvas) {\n    for (SkScalar perspX : { -.003f, 0.f, .003f, .012f } ) {\n        SkMatrix matrix;\n        matrix.setIdentity();\n        matrix.setPerspX(perspX);\n        canvas->save();\n        canvas->concat(matrix);\n        canvas->drawBitmap(source, 0, 0);\n        canvas->restore();\n        canvas->translate(64, 64);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "830a9e4e4bb93d25afd83b2fea63929e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setPerspX"
},
    "SkMatrix_setPerspY": {
    "code": "void draw(SkCanvas* canvas) {\n    for (SkScalar perspX : { -.003f, 0.f, .003f, .012f } ) {\n        SkMatrix matrix;\n        matrix.setIdentity();\n        matrix.setPerspY(perspX);\n        canvas->save();\n        canvas->concat(matrix);\n        canvas->drawBitmap(source, 0, 0);\n        canvas->restore();\n        canvas->translate(64, 64);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "aeb258b7922c1a11b698b00f562182ec",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setPerspY"
},
    "SkMatrix_setPolyToPoly": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkPoint src[] = { { 0, 0}, {30,   0}, {30, -30}, { 0, -30} };\n    const SkPoint dst[] = { {50, 0}, {80, -10}, {90, -30}, {60, -40} };\n    SkPaint blackPaint;\n    blackPaint.setAntiAlias(true);\n    blackPaint.setTextSize(42);\n    SkPaint redPaint = blackPaint;\n    redPaint.setColor(SK_ColorRED);\n    for (int count : { 1, 2, 3, 4 } ) {\n        canvas->translate(35, 55);\n        for (int index = 0; index < count; ++index) {\n            canvas->drawCircle(src[index], 3, blackPaint);\n            canvas->drawCircle(dst[index], 3, blackPaint);\n            if (index > 0) {\n                canvas->drawLine(src[index], src[index - 1], blackPaint);\n                canvas->drawLine(dst[index], dst[index - 1], blackPaint);\n            }\n        }\n        SkMatrix matrix;\n        matrix.setPolyToPoly(src, dst, count);\n        canvas->drawString(\"A\", src[0].fX, src[0].fY, redPaint);\n        SkAutoCanvasRestore acr(canvas, true);\n        canvas->concat(matrix);\n        canvas->drawString(\"A\", src[0].fX, src[0].fY, redPaint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "c851d1313e8909aaea4f0591699fdb7b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setPolyToPoly"
},
    "SkMatrix_setRSXform": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    SkMatrix matrix;\n    matrix.setRSXform(SkRSXform::Make(.85f, .25f, rect.centerX(), rect.centerY()));\n    canvas->concat(matrix);\n    canvas->translate(-rect.centerX(), -rect.centerY());\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "c3f5faddca466f78278b32b88fd5f5eb",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setRSXform"
},
    "SkMatrix_setRotate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    SkMatrix matrix;\n    matrix.setRotate(25, rect.centerX(), rect.centerY());\n    canvas->concat(matrix);\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "8c28db3add9cd0177225088f6df6bbb5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setRotate"
},
    "SkMatrix_setRotate_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    SkMatrix matrix;\n    matrix.setRotate(25);\n    canvas->translate(rect.centerX(), rect.centerY());\n    canvas->concat(matrix);\n    canvas->translate(-rect.centerX(), -rect.centerY());\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "93efb9d191bf1b9710c173513e014d6c",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setRotate_2"
},
    "SkMatrix_setScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(64);\n    SkMatrix m;\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            m.setScale(sx, sy, 128, 64);\n            canvas->concat(m);\n            canvas->drawString(\"%\", 128, 64, p);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "4565a0792058178c88e0a129a87272d6",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setScale"
},
    "SkMatrix_setScaleX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 12, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setScaleX(3);\n    canvas->concat(matrix);\n    canvas->drawString(\"x scale\", 0, 48, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "a39dfed98c3c3c3a56be9ad59fe4e21e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setScaleX"
},
    "SkMatrix_setScaleY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 12, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setScaleY(3);\n    canvas->concat(matrix);\n    canvas->drawString(\"y scale\", 12, 48, paint);\n}",
    "width": 256,
    "height": 192,
    "hash": "f040c6dd85a02e94eaca00d5c2832604",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setScaleY"
},
    "SkMatrix_setScale_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(64);\n    SkMatrix m;\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            m.setScale(sx, sy);\n            m.postTranslate(128, 64);\n            canvas->concat(m);\n            canvas->drawString(\"@\", 0, 0, p);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "1579d0cc109c26e69f66f73abd35fb0e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setScale_2"
},
    "SkMatrix_setSinCos": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    SkMatrix matrix;\n    matrix.setSinCos(.25f, .85f, rect.centerX(), rect.centerY());\n    canvas->concat(matrix);\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "187e1d9228e2e4341ef820bd77b6fda9",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSinCos"
},
    "SkMatrix_setSinCos_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    SkMatrix matrix;\n    matrix.setSinCos(.25f, .85f);\n    matrix.postTranslate(rect.centerX(), rect.centerY());\n    canvas->concat(matrix);\n    canvas->translate(-rect.centerX(), -rect.centerY());\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "e37a94a53c959951b059fcd624639ef6",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSinCos_2"
},
    "SkMatrix_setSkew": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(48);\n    SkMatrix m;\n    for (SkScalar sx : { -1, 0, 1 } ) {\n        for (SkScalar sy : { -1, 0, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            m.setSkew(sx, sy, 96 + 64 * sx, 128 + 48 * sy);\n            canvas->concat(m);\n            canvas->drawString(\"K\", 96 + 64 * sx, 128 + 48 * sy, p);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "55e0431adc6c5b1987ebb8123cc10342",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSkew"
},
    "SkMatrix_setSkewX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 12, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setSkewX(-.7f);\n    canvas->concat(matrix);\n    canvas->drawString(\"x skew\", 36, 48, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "c7177a6fbc1545be95a5ebca87e0cd0d",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSkewX"
},
    "SkMatrix_setSkewY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 12, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setSkewY(.3f);\n    canvas->concat(matrix);\n    canvas->drawString(\"y skew\", 12, 48, paint);\n}",
    "width": 256,
    "height": 96,
    "hash": "b418d15df9829aefcc6aca93a37428bb",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSkewY"
},
    "SkMatrix_setSkew_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(48);\n    SkMatrix m;\n    for (SkScalar sx : { -1, 0, 1 } ) {\n        for (SkScalar sy : { -1, 0, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            m.setSkew(sx, sy);\n            m.postTranslate(96 + 64 * sx, 128 + 48 * sy);\n            canvas->concat(m);\n            canvas->drawString(\"K\", 0, 0, p);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "05be7844e9afdd7b9bfc31c5423a70a2",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSkew_2"
},
    "SkMatrix_setTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 8, 24, paint);\n    SkMatrix matrix;\n    matrix.setTranslate(96, 24);\n    canvas->concat(matrix);\n    canvas->drawString(\"translate\", 8, 24, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "63ca62985741b1bccb5e8b9cf734874e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setTranslate"
},
    "SkMatrix_setTranslateX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 8, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setTranslateX(96);\n    canvas->concat(matrix);\n    canvas->drawString(\"x translate\", 8, 24, paint);\n}",
    "width": 256,
    "height": 48,
    "hash": "a18bc2e3607ac3a8e438bcb61fb13130",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setTranslateX"
},
    "SkMatrix_setTranslateY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 8, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setTranslateY(24);\n    canvas->concat(matrix);\n    canvas->drawString(\"y translate\", 8, 24, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "34e3c70a72b836abf7f4858d35eecc98",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setTranslateY"
},
    "SkMatrix_setTranslate_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 8, 24, paint);\n    SkMatrix matrix;\n    matrix.setTranslate({96, 24});\n    canvas->concat(matrix);\n    canvas->drawString(\"translate\", 8, 24, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "ccfc734aff2ddea0b097c83f5621de5e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setTranslate_2"
},
    "SkMemoryStream_Make": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::Make"
},
    "SkMemoryStream_MakeCopy": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::MakeCopy"
},
    "SkMemoryStream_MakeDirect": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::MakeDirect"
},
    "SkMemoryStream_asData": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::asData"
},
    "SkMemoryStream_const_star": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::SkMemoryStream(const void* data, size_t length, bool copyData = false)"
},
    "SkMemoryStream_copy_": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::SkMemoryStream(size_t length)"
},
    "SkMemoryStream_copy_SkData": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::SkMemoryStream(sk_sp<SkData> data)"
},
    "SkMemoryStream_duplicate": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::duplicate()"
},
    "SkMemoryStream_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::SkMemoryStream()"
},
    "SkMemoryStream_fork": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::fork()"
},
    "SkMemoryStream_getAtPos": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::getAtPos"
},
    "SkMemoryStream_getLength": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::getLength"
},
    "SkMemoryStream_getMemoryBase": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::getMemoryBase"
},
    "SkMemoryStream_getPosition": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::getPosition"
},
    "SkMemoryStream_isAtEnd": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::isAtEnd"
},
    "SkMemoryStream_move": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::move()"
},
    "SkMemoryStream_peek": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::peek()"
},
    "SkMemoryStream_read": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::read()"
},
    "SkMemoryStream_rewind": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::rewind()"
},
    "SkMemoryStream_seek": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::seek()"
},
    "SkMemoryStream_setData": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::setData"
},
    "SkMemoryStream_setMemory": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::setMemory"
},
    "SkMemoryStream_skipToAlign4": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkMemoryStream_Reference",
    "name": "SkMemoryStream::skipToAlign4"
},
    "SkPaint": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    SkPath path;\n    path.moveTo(30, 30);\n    path.lineTo(30, 30);\n    path.moveTo(70, 30);\n    path.lineTo(90, 40);\n    for (SkPaint::Cap c : { SkPaint::kButt_Cap, SkPaint::kRound_Cap, SkPaint::kSquare_Cap } ) {\n        paint.setStrokeCap(c);\n        canvas->drawPath(path, paint);\n        canvas->translate(0, 70);\n    }\n}",
    "width": 256,
    "height": 200,
    "hash": "2bffb6384cc20077e632e7d01da045ca",
    "file": "SkPaint_Reference",
    "name": "SkPaint"
},
    "SkPaint_Join": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(10, 50);\n    path.quadTo(35, 110, 60, 210);\n    path.quadTo(105, 110, 130, 10);\n    SkPaint paint;  // set to default kMiter_Join\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    canvas->drawPath(path, paint);\n    canvas->translate(150, 0);\n    paint.setStrokeJoin(SkPaint::kBevel_Join);\n    canvas->drawPath(path, paint);\n    canvas->translate(150, 0);\n    paint.setStrokeJoin(SkPaint::kRound_Join);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 462,
    "height": 256,
    "hash": "3b1aebacc21c1836a52876b9b0b3905e",
    "file": "SkPaint_Reference",
    "name": "SkPaint::Join"
},
    "SkPaint_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    SkPath path;\n    path.moveTo(30, 20);\n    path.lineTo(40, 40);\n    path.conicTo(70, 20, 100, 20, .707f);\n    for (SkPaint::Join j : { SkPaint::kMiter_Join, SkPaint::kRound_Join, SkPaint::kBevel_Join } ) {\n        paint.setStrokeJoin(j);\n        canvas->drawPath(path, paint);\n        canvas->translate(0, 70);\n    }\n}",
    "width": 256,
    "height": 200,
    "hash": "917c44b504d3f9308571fd3835d90a0d",
    "file": "SkPaint_Reference",
    "name": "SkPaint_2"
},
    "SkPaint_breakText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(50);\n    const char str[] = \"Breakfast\";\n    const int count = sizeof(str) - 1;\n    canvas->drawText(str, count, 25, 50, paint);\n    SkScalar measuredWidth;\n    int partialBytes = paint.breakText(str, count, 100, &measuredWidth);\n    canvas->drawText(str, partialBytes, 25, 100, paint);\n    canvas->drawLine(25, 60, 25 + 100, 60, paint);\n    canvas->drawLine(25, 110, 25 + measuredWidth, 110, paint);\n}\n",
    "width": 280,
    "height": 128,
    "hash": "fd0033470ccbd5c7059670fdbf96cffc",
    "file": "SkPaint_Reference",
    "name": "SkPaint::breakText"
},
    "SkPaint_getFillPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint strokePaint;\n    strokePaint.setAntiAlias(true);\n    strokePaint.setStyle(SkPaint::kStroke_Style);\n    strokePaint.setStrokeWidth(.1f);\n    SkPath strokePath;\n    strokePath.moveTo(.08f, .08f);\n    strokePath.quadTo(.09f, .08f, .17f, .17f);\n    SkPath fillPath;\n    SkPaint outlinePaint(strokePaint);\n    outlinePaint.setStrokeWidth(2);\n    SkMatrix scale = SkMatrix::MakeScale(300, 300);\n    for (SkScalar precision : { 0.01f, .1f, 1.f, 10.f, 100.f } ) {\n        strokePaint.getFillPath(strokePath, &fillPath, nullptr, precision);\n        fillPath.transform(scale);\n        canvas->drawPath(fillPath, outlinePaint);\n        canvas->translate(60, 0);\n        if (1.f == precision) canvas->translate(-180, 100);\n    }\n    strokePath.transform(scale);\n    strokePaint.setStrokeWidth(30);\n    canvas->drawPath(strokePath, strokePaint);\n}\n",
    "width": 256,
    "height": 192,
    "hash": "cedd6233848198e1fca4d1e14816baaf",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFillPath"
},
    "SkPaint_getFillPath_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    SkPath strokePath;\n    strokePath.moveTo(20, 20);\n    strokePath.lineTo(100, 100);\n    canvas->drawPath(strokePath, paint);\n    SkPath fillPath;\n    paint.getFillPath(strokePath, &fillPath);\n    paint.setStrokeWidth(2);\n    canvas->translate(40, 0);\n    canvas->drawPath(fillPath, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "e6d8ca0cc17e0b475bd54dd995825468",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFillPath_2"
},
    "SkPaint_getFontMetrics": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    SkScalar lineHeight = paint.getFontMetrics(nullptr);\n    canvas->drawString(\"line 1\", 10, 40, paint);\n    canvas->drawString(\"line 2\", 10, 40 + lineHeight, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "59d9b8249afa1c2af6186711250ce240",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFontMetrics"
},
    "SkPaint_getPosTextPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(80);\n    SkPath path, path2;\n    SkPoint pos[] = {{20, 60}, {30, 70}, {40, 80}};\n    paint.getPosTextPath(\"ABC\", 3, pos, &path);\n    Simplify(path, &path);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 85,
    "hash": "7f27c93472aa99a7542fb3493076f072",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getPosTextPath"
},
    "SkPaint_getTextBlobIntercepts": {
    "code": "void draw(SkCanvas* canvas) {\n    SkFont font;\n    font.setSize(120);\n    SkPoint textPos = { 20, 110 };\n    int len = 3;\n    SkTextBlobBuilder textBlobBuilder;\n    const SkTextBlobBuilder::RunBuffer& run =\n            textBlobBuilder.allocRun(font, len, textPos.fX, textPos.fY);\n    run.glyphs[0] = 10;\n    run.glyphs[1] = 20;\n    run.glyphs[2] = 30;\n    sk_sp<const SkTextBlob> blob = textBlobBuilder.make();\n    SkPaint paint;\n    SkScalar bounds[] = { 116, 134 };\n    int count = paint.getTextBlobIntercepts(blob.get(), bounds, nullptr);\n    std::vector<SkScalar> intervals;\n    intervals.resize(count);\n    (void) paint.getTextBlobIntercepts(blob.get(), bounds, &intervals.front());\n    canvas->drawTextBlob(blob.get(), 0, 0, paint);\n    paint.setColor(0xFFFF7777);\n    SkScalar x = textPos.fX;\n    for (int i = 0; i < count; i+= 2) {\n        canvas->drawRect({x, bounds[0], intervals[i], bounds[1]}, paint);\n        x = intervals[i + 1];\n    }\n    canvas->drawRect({intervals[count - 1], bounds[0], 180, bounds[1]}, paint);\n}\n",
    "width": 256,
    "height": 143,
    "hash": "728ea9089f233a71a1062e364b8c73fa",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextBlobIntercepts"
},
    "SkPaint_getTextPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(80);\n    SkPath path, path2;\n    paint.getTextPath(\"ABC\", 3, 20, 80, &path);\n    path.offset(20, 20, &path2);\n    Op(path, path2, SkPathOp::kDifference_SkPathOp, &path);\n    path.addPath(path2);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "7c9e6a399f898d68026c1f0865e6f73e",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextPath"
},
    "SkPaint_getTextWidths": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(50);\n    const char str[] = \"abc\";\n    const int bytes = sizeof(str) - 1;\n    int count = paint.getTextWidths(str, bytes, nullptr);\n    std::vector<SkScalar> widths;\n    std::vector<SkRect> bounds;\n    widths.resize(count);\n    bounds.resize(count);\n    for (int loop = 0; loop < 2; ++loop) {\n        (void) paint.getTextWidths(str, count, &widths.front(), &bounds.front());\n        SkPoint loc = { 25, 50 };\n        canvas->drawText(str, bytes, loc.fX, loc.fY, paint);\n        paint.setStyle(SkPaint::kStroke_Style);\n        paint.setStrokeWidth(0);\n        SkScalar advanceY = loc.fY + 10;\n        for (int index = 0; index < count; ++index) {\n            bounds[index].offset(loc.fX, loc.fY);\n            canvas->drawRect(bounds[index], paint);\n            canvas->drawLine(loc.fX, advanceY, loc.fX + widths[index], advanceY, paint);\n            loc.fX += widths[index];\n            advanceY += 5;\n        }\n        canvas->translate(0, 80);\n        paint.setStrokeWidth(3);\n    }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "6b9e101f49e9c2c28755c5bdcef64dfb",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextWidths"
},
    "SkPaint_glyphsToUnichars": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    const char hello[] = \"Hello!\";\n    const int count = sizeof(hello) - 1;\n    SkGlyphID glyphs[count];\n    if (count != paint.textToGlyphs(hello, count, glyphs)) {\n        return;\n    }\n    SkUnichar unichars[count];\n    paint.glyphsToUnichars(glyphs, count, unichars);\n    paint.setTextEncoding(SkTextEncoding::kUTF32);\n    canvas->drawText(unichars, sizeof(unichars), 10, 30, paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "79c550ec6c34054ab60fbcd1b81adc03",
    "file": "SkPaint_Reference",
    "name": "SkPaint::glyphsToUnichars"
},
    "SkPaint_isLinearText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const char testStr[] = \"xxxx xxxx\";\n    for (auto linearText : { false, true } ) {\n        paint.setLinearText(linearText);\n        paint.setTextSize(24);\n        canvas->drawString(paint.isLinearText() ? \"linear\" : \"hinted\", 128, 30, paint);\n        for (SkScalar textSize = 8; textSize < 30; textSize *= 1.22f) {\n            paint.setTextSize(textSize);\n            canvas->translate(0, textSize);\n            canvas->drawString(testStr, 10, 0, paint);\n        }\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "2890ad644f980637837e6fcb386fb462",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isLinearText"
},
    "SkPaint_measureText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(50);\n    const char str[] = \"ay^jZ\";\n    const int count = sizeof(str) - 1;\n    canvas->drawText(str, count, 25, 50, paint);\n    SkRect bounds;\n    paint.measureText(str, count, &bounds);\n    canvas->translate(25, 50);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRect(bounds, paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "06084f609184470135a9cd9ebc5af149",
    "file": "SkPaint_Reference",
    "name": "SkPaint::measureText"
},
    "SkPaint_setAutohinted": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const char testStr[] = \"xxxx xxxx\";\n        for (auto forceAutoHinting : { false, true} ) {\n        paint.setAutohinted(forceAutoHinting);\n        paint.setTextSize(24);\n        canvas->drawString(paint.isAutohinted() ? \"auto-hinted\" : \"default\", 108, 30, paint);\n        for (SkScalar textSize = 8; textSize < 30; textSize *= 1.22f) {\n            paint.setTextSize(textSize);\n            canvas->translate(0, textSize);\n            canvas->drawString(testStr, 10, 0, paint);\n        }\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "4e185306d7de9390fe8445eed0139309",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setAutohinted"
},
    "SkPaint_setColorFilter": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   paint.setColorFilter(SkColorFilter::MakeModeFilter(SK_ColorLTGRAY, SkBlendMode::kSrcIn));\n   canvas->drawRect(SkRect::MakeWH(50, 50), paint);\n   paint.setColorFilter(nullptr);\n   canvas->translate(70, 0);\n   canvas->drawRect(SkRect::MakeWH(50, 50), paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "c7b786dc9b3501cd0eaba47494b6fa31",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setColorFilter"
},
    "SkPaint_setDrawLooper": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setDrawLooper(SkBlurDrawLooper::Make(0x7FFF0000, 4, -5, -10));\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    paint.setAntiAlias(true);\n    paint.setColor(0x7f0000ff);\n    canvas->drawCircle(70, 70, 50, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "bf10f838b330f0a3a3266d42ea68a638",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setDrawLooper"
},
    "SkPaint_setImageFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocN32Pixels(100, 100);\n    SkCanvas offscreen(bitmap);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(SK_ColorWHITE);\n    paint.setTextSize(96);\n    offscreen.clear(0);\n    offscreen.drawString(\"e\", 20, 70, paint);\n    paint.setImageFilter(\n           SkLightingImageFilter::MakePointLitDiffuse(SkPoint3::Make(80, 100, 10),\n           SK_ColorWHITE, 1, 2, nullptr, nullptr));\n    canvas->drawBitmap(bitmap, 0, 0, &paint);\n}\n",
    "width": 256,
    "height": 160,
    "hash": "6679d6e4ec632715ee03e68391bd7f9a",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setImageFilter"
},
    "SkPaint_setLinearText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const char testStr[] = \"abcd efgh\";\n    for (int textSize : { 12, 24 } ) {\n        paint.setTextSize(textSize);\n        for (auto linearText : { false, true } ) {\n            paint.setLinearText(linearText);\n            SkString width;\n            width.appendScalar(paint.measureText(testStr, SK_ARRAY_COUNT(testStr), nullptr));\n            canvas->translate(0, textSize + 4);\n            canvas->drawString(testStr, 10, 0, paint);\n            canvas->drawString(width, 128, 0, paint);\n        }\n     }\n  }\n",
    "width": 256,
    "height": 128,
    "hash": "c93bb912f3bddfb4d96d3ad70ada552b",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setLinearText"
},
    "SkPaint_setMaskFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    paint.setMaskFilter(SkMaskFilter::MakeBlur(kNormal_SkBlurStyle, 10));\n    canvas->drawRect(SkRect::MakeXYWH(40, 40, 175, 175), paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "a993831c40f3e134f809134e3b74e4a6",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setMaskFilter"
},
    "SkPaint_setPathEffect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setPathEffect(SkDiscretePathEffect::Make(3, 5));\n    canvas->drawRect(SkRect::MakeXYWH(40, 40, 175, 175), paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "52dd55074ca0b7d520d04e750ca2a0d7",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setPathEffect"
},
    "SkPaint_setShader": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorBLUE);\n    paint.setShader(SkShader::MakeColorShader(SK_ColorRED));\n    canvas->drawRect(SkRect::MakeWH(40, 40), paint);\n    paint.setShader(nullptr);\n    canvas->translate(50, 0);\n    canvas->drawRect(SkRect::MakeWH(40, 40), paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "77e64d5bae9b1ba037fd99252bb4aa58",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setShader"
},
    "SkPaint_setStyle": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(5);\n    SkRegion region;\n    region.op(140, 10, 160, 30, SkRegion::kUnion_Op);\n    region.op(170, 40, 190, 60, SkRegion::kUnion_Op);\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeA8(50, 50), 50);\n    uint8_t pixels[50][50];\n    for (int x = 0; x < 50; ++x) {\n        for (int y = 0; y < 50; ++y) {\n            pixels[y][x] = (x + y) % 5 ? 0xFF : 0x00;\n        }\n    }\n    bitmap.setPixels(pixels);\n    for (auto style : { SkPaint::kFill_Style,\n                        SkPaint::kStroke_Style,\n                        SkPaint::kStrokeAndFill_Style }) {\n        paint.setStyle(style);\n        canvas->drawLine(10, 10, 60, 60, paint);\n        canvas->drawRect({80, 10, 130, 60}, paint);\n        canvas->drawRegion(region, paint);\n        canvas->drawBitmap(bitmap, 200, 10, &paint);\n        canvas->translate(0, 80);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "c7bb6248e4735b8d1a32d02fba40d344",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setStyle"
},
    "SkPaint_setTypeface": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTypeface(SkTypeface::MakeFromName(\"monospace\", SkFontStyle()));\n    canvas->drawString(\"hamburgerfons\", 10, 30, paint);\n    paint.setTypeface(nullptr);\n    canvas->drawString(\"hamburgerfons\", 10, 50, paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "0e6fbb7773cd925b274552f4cd1abef2",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setTypeface"
},
    "SkPaint_textToGlyphs": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    const uint8_t utf8[] = { 0x24, 0xC2, 0xA2, 0xE2, 0x82, 0xAC, 0xC2, 0xA5, 0xC2, 0xA3 };\n    std::vector<SkGlyphID> glyphs;\n    int count = paint.textToGlyphs(utf8, sizeof(utf8), nullptr);\n    glyphs.resize(count);\n    (void) paint.textToGlyphs(utf8, sizeof(utf8), &glyphs.front());\n    paint.setTextEncoding(SkTextEncoding::kGlyphID);\n    paint.setTextSize(32);\n    canvas->drawText(&glyphs.front(), glyphs.size() * sizeof(SkGlyphID), 10, 40, paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "d11136d8a74f63009da2a7f550710823",
    "file": "SkPaint_Reference",
    "name": "SkPaint::textToGlyphs"
},
    "SkPath_AddPathMode": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, path2;\n    path.moveTo(20, 20);\n    path.lineTo(20, 40);\n    path.lineTo(40, 20);\n    path2.moveTo(60, 60);\n    path2.lineTo(80, 60);\n    path2.lineTo(80, 40);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 2; i++) {\n        for (auto addPathMode : { SkPath::kAppend_AddPathMode, SkPath::kExtend_AddPathMode } ) {\n            SkPath test(path);\n            test.addPath(path2, addPathMode);\n            canvas->drawPath(test, paint);\n            canvas->translate(100, 0);\n        }\n        canvas->translate(-200, 100);\n        path.close();\n    }\n}",
    "width": 256,
    "height": 180,
    "hash": "801b02e74c64aafdb734f2e5cf3e5ab0",
    "file": "SkPath_Reference",
    "name": "SkPath::AddPathMode"
},
    "SkPath_ArcSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (auto sweep: { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        for (auto arcSize : { SkPath::kSmall_ArcSize, SkPath::kLarge_ArcSize } ) {\n            SkPath path;\n            path.moveTo({120, 50});\n            path.arcTo(70, 40, 30, arcSize, sweep, 156, 100);\n            if (SkPath::kCCW_Direction == sweep && SkPath::kLarge_ArcSize == arcSize) {\n                paint.setColor(SK_ColorBLUE);\n                paint.setStrokeWidth(3);\n            }\n            canvas->drawPath(path, paint);\n         }\n    }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "8e40c546eecd9cc213200717240898ba",
    "file": "SkPath_Reference",
    "name": "SkPath::ArcSize"
},
    "SkPath_ConvertConicToQuads": {
    "code": "void draw(SkCanvas* canvas) {\n      SkPaint conicPaint;\n      conicPaint.setAntiAlias(true);\n      conicPaint.setStyle(SkPaint::kStroke_Style);\n      SkPaint quadPaint(conicPaint);\n      quadPaint.setColor(SK_ColorRED);\n      SkPoint conic[] = { {20, 170}, {80, 170}, {80, 230} };\n      for (auto weight : { .25f, .5f, .707f, .85f, 1.f } ) {\n          SkPoint quads[5];\n          SkPath::ConvertConicToQuads(conic[0], conic[1], conic[2], weight, quads, 1);\n          SkPath path;\n          path.moveTo(conic[0]);\n          path.conicTo(conic[1], conic[2], weight);\n          canvas->drawPath(path, conicPaint);\n          path.rewind();\n          path.moveTo(quads[0]);\n          path.quadTo(quads[1], quads[2]);\n          path.quadTo(quads[3], quads[4]);\n          canvas->drawPath(path, quadPaint);\n          canvas->translate(50, -50);\n      }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "3ba94448a4ba48f926e643baeb5b1016",
    "file": "SkPath_Reference",
    "name": "SkPath::ConvertConicToQuads"
},
    "SkPath_Convexity": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPoint quad[] = {{70, 70}, {20, 20}, {120, 20}, {120, 120}};\n    const char* labels[] = { \"unknown\", \"convex\", \"concave\" };\n    for (SkScalar x : { 40, 100 } ) {\n        SkPath path;\n        quad[0].fX = x;\n        path.addPoly(quad, SK_ARRAY_COUNT(quad), true);\n        canvas->drawPath(path, paint);\n        canvas->drawString(labels[(int) path.getConvexity()], 30, 100, paint);\n        canvas->translate(100, 100);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "ac49e8b810bd6ed5d84b4f5a3b40a0ec",
    "file": "SkPath_Reference",
    "name": "SkPath::Convexity"
},
    "SkPath_Direction": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkPoint arrow[] = { {40, -5}, {45, 0}, {40, 5} };\n    const SkRect rect = {10, 10, 90, 90};\n    SkPaint rectPaint;\n    rectPaint.setAntiAlias(true);\n    SkPaint textPaint(rectPaint);\n    rectPaint.setStyle(SkPaint::kStroke_Style);\n    SkPaint arrowPaint(rectPaint);\n    SkPath arrowPath;\n    arrowPath.addPoly(arrow, SK_ARRAY_COUNT(arrow), true);\n    arrowPaint.setPathEffect(SkPath1DPathEffect::Make(arrowPath, 320, 0,\n                             SkPath1DPathEffect::kRotate_Style));\n    for (auto direction : { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        canvas->drawRect(rect, rectPaint);\n        for (unsigned start : { 0, 1, 2, 3 } ) {\n           SkPath path;\n           path.addRect(rect, direction, start);\n           canvas->drawPath(path, arrowPaint);\n       }\n       canvas->drawString(SkPath::kCW_Direction == direction ? \"CW\" : \"CCW\",  rect.centerX(),\n            rect.centerY(), textPaint);\n       canvas->translate(120, 0);\n    }\n}\n",
    "width": 256,
    "height": 100,
    "hash": "4bbae00b40ed2cfcd0007921ad693a7b",
    "file": "SkPath_Reference",
    "name": "SkPath::Direction"
},
    "SkPath_FillType": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPath path;\n   path.addRect({10, 10, 30, 30}, SkPath::kCW_Direction);\n   path.addRect({20, 20, 40, 40}, SkPath::kCW_Direction);\n   path.addRect({10, 60, 30, 80}, SkPath::kCW_Direction);\n   path.addRect({20, 70, 40, 90}, SkPath::kCCW_Direction);\n   SkPaint strokePaint;\n   strokePaint.setStyle(SkPaint::kStroke_Style);\n   SkRect clipRect = {0, 0, 51, 100};\n   canvas->drawPath(path, strokePaint);\n   SkPaint fillPaint;\n   for (auto fillType : { SkPath::kWinding_FillType, SkPath::kEvenOdd_FillType,\n                      SkPath::kInverseWinding_FillType, SkPath::kInverseEvenOdd_FillType } ) {\n        canvas->translate(51, 0);\n        canvas->save();\n        canvas->clipRect(clipRect);\n        path.setFillType(fillType);\n        canvas->drawPath(path, fillPaint);\n        canvas->restore();\n    }\n}\n",
    "width": 256,
    "height": 100,
    "hash": "71fc6c069c377d808799f2453edabaf5",
    "file": "SkPath_Reference",
    "name": "SkPath::FillType"
},
    "SkPath_FillType_a": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPath path;\n   path.addRect({20, 10, 80, 70}, SkPath::kCW_Direction);\n   path.addRect({40, 30, 100, 90}, SkPath::kCW_Direction);\n   SkPaint strokePaint;\n   strokePaint.setStyle(SkPaint::kStroke_Style);\n   SkRect clipRect = {0, 0, 128, 128};\n   canvas->drawPath(path, strokePaint);\n   canvas->drawLine({0, 50}, {120, 50}, strokePaint);\n   SkPaint textPaint;\n   textPaint.setAntiAlias(true);\n   SkScalar textHPos[] = { 10, 30, 60, 90, 110 };\n   canvas->drawPosTextH(\"01210\", 5, textHPos, 48, textPaint);\n   textPaint.setTextSize(18);\n   canvas->translate(0, 128);\n   canvas->scale(.5f, .5f);\n   canvas->drawString(\"inverse\", 384, 150, textPaint);\n   SkPaint fillPaint;\n   for (auto fillType : { SkPath::kWinding_FillType, SkPath::kEvenOdd_FillType,\n                      SkPath::kInverseWinding_FillType, SkPath::kInverseEvenOdd_FillType } ) {\n        canvas->save();\n        canvas->clipRect(clipRect);\n        path.setFillType(fillType);\n        canvas->drawPath(path, fillPaint);\n        canvas->restore();\n        canvas->drawString(fillType & 1 ? \"even-odd\" : \"winding\", 64, 170, textPaint);\n        canvas->translate(128, 0);\n    }\n}\n",
    "width": 256,
    "height": 230,
    "hash": "d2c33dc791cd165dcc2423226ba5b095",
    "file": "SkPath_Reference",
    "name": "SkPath::FillType_2"
},
    "SkPath_Iter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(256);\n    SkPath asterisk, path;\n    paint.getTextPath(\"*\", 1, 50, 192, &asterisk);\n    SkPath::Iter iter(asterisk, true);\n    SkPoint start[4], pts[4];\n    iter.next(start);  // skip moveTo\n    iter.next(start);  // first quadTo\n    path.moveTo((start[0] + start[1]) * 0.5f);\n    while (SkPath::kClose_Verb != iter.next(pts)) {\n        path.quadTo(pts[0], (pts[0] + pts[1]) * 0.5f);\n    }\n    path.quadTo(start[0], (start[0] + start[1]) * 0.5f);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "2f53df9201769ab7e7c0e164a1334309",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter"
},
    "SkPath_addArc": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    for (auto start : { 0, 90, 135, 180, 270 } ) {\n        for (auto sweep : { -450.f, -180.f, -90.f, 90.f, 180.f, 360.1f } ) {\n            SkPath path;\n            path.addArc({10, 10, 35, 45}, start, sweep);\n            canvas->drawPath(path, paint);\n            canvas->translate(252 / 6, 0);\n        }\n        canvas->translate(-252, 255 / 5);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "9cf5122475624e4cf39f06c698f80b1a",
    "file": "SkPath_Reference",
    "name": "SkPath::addArc"
},
    "SkPath_addCircle": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    for (int size = 10; size < 300; size += 20) {\n        SkPath path;\n        path.addCircle(128, 128, size, SkPath::kCW_Direction);\n        canvas->drawPath(path, paint);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "bd5286cb9a5e5c32cd980f72b8f400fb",
    "file": "SkPath_Reference",
    "name": "SkPath::addCircle"
},
    "SkPath_addOval": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath oval;\n    oval.addOval({20, 20, 160, 80});\n    canvas->drawPath(oval, paint);\n}",
    "width": 256,
    "height": 120,
    "hash": "cac84cf68e63a453c2a8b64c91537704",
    "file": "SkPath_Reference",
    "name": "SkPath::addOval"
},
    "SkPath_addOval_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkPoint arrow[] = { {0, -5}, {10, 0}, {0, 5} };\n    const SkRect rect = {10, 10, 54, 54};\n    SkPaint ovalPaint;\n    ovalPaint.setAntiAlias(true);\n    SkPaint textPaint(ovalPaint);\n    ovalPaint.setStyle(SkPaint::kStroke_Style);\n    SkPaint arrowPaint(ovalPaint);\n    SkPath arrowPath;\n    arrowPath.addPoly(arrow, SK_ARRAY_COUNT(arrow), true);\n    arrowPaint.setPathEffect(SkPath1DPathEffect::Make(arrowPath, 176, 0,\n                             SkPath1DPathEffect::kRotate_Style));\n    for (auto direction : { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        for (unsigned start : { 0, 1, 2, 3 } ) {\n           SkPath path;\n           path.addOval(rect, direction, start);\n           canvas->drawPath(path, ovalPaint);\n           canvas->drawPath(path, arrowPaint);\n           canvas->drawText(&\"0123\"[start], 1, rect.centerX(), rect.centerY() + 5, textPaint);\n           canvas->translate(64, 0);\n       }\n       canvas->translate(-256, 72);\n       canvas->drawString(SkPath::kCW_Direction == direction ? \"clockwise\" : \"counterclockwise\",\n                          128, 0, textPaint);\n    }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "f1122d6fffddac0167e96fab4b9a862f",
    "file": "SkPath_Reference",
    "name": "SkPath::addOval_2"
},
    "SkPath_addPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    paint.setFakeBoldText(true);\n    SkPath dest, text;\n    paint.getTextPath(\"O\", 1, 50, 120, &text);\n    for (int i = 0; i < 3; i++) {\n        dest.addPath(text, i * 20, i * 20);\n    }\n    Simplify(dest, &dest);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(3);\n    canvas->drawPath(dest, paint);\n}",
    "width": 256,
    "height": 180,
    "hash": "c416bddfe286628974e1c7f0fd66f3f4",
    "file": "SkPath_Reference",
    "name": "SkPath::addPath"
},
    "SkPath_addPath_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath dest, path;\n    path.addOval({-80, 20, 0, 60}, SkPath::kCW_Direction, 1);\n    for (int i = 0; i < 2; i++) {\n        dest.addPath(path, SkPath::kExtend_AddPathMode);\n        dest.offset(100, 0);\n    }\n    canvas->drawPath(dest, paint);\n}",
    "width": 256,
    "height": 80,
    "hash": "84b2d1c0fc29f1b35e855b6fc6672f9e",
    "file": "SkPath_Reference",
    "name": "SkPath::addPath_2"
},
    "SkPath_addPath_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath dest, path;\n    path.addOval({20, 20, 200, 120}, SkPath::kCW_Direction, 1);\n    for (int i = 0; i < 6; i++) {\n        SkMatrix matrix;\n        matrix.reset();\n        matrix.setPerspX(i / 400.f);\n        dest.addPath(path, matrix);\n    }\n    canvas->drawPath(dest, paint);\n}",
    "width": 256,
    "height": 160,
    "hash": "3a90a91030f7289d5df0671d342dbbad",
    "file": "SkPath_Reference",
    "name": "SkPath::addPath_3"
},
    "SkPath_addPoly": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeCap(SkPaint::kRound_Cap);\n    const SkPoint points[] = {{20, 20}, {70, 20}, {40, 90}};\n    for (bool close : { false, true } ) {\n        SkPath path;\n        path.addPoly(points, SK_ARRAY_COUNT(points), close);\n        for (auto style : {SkPaint::kStroke_Style, SkPaint::kFill_Style,\n                SkPaint::kStrokeAndFill_Style} ) {\n            paint.setStyle(style);\n            canvas->drawPath(path, paint);\n            canvas->translate(85, 0);\n        }\n        canvas->translate(-255, 128);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "182b3999772f330f3b0b891b492634ae",
    "file": "SkPath_Reference",
    "name": "SkPath::addPoly"
},
    "SkPath_addPoly_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeCap(SkPaint::kRound_Cap);\n    for (bool close : { false, true } ) {\n        SkPath path;\n        path.addPoly({{20, 20}, {70, 20}, {40, 90}}, close);\n        for (auto style : {SkPaint::kStroke_Style, SkPaint::kFill_Style,\n                SkPaint::kStrokeAndFill_Style} ) {\n            paint.setStyle(style);\n            canvas->drawPath(path, paint);\n            canvas->translate(85, 0);\n        }\n        canvas->translate(-255, 128);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "1a6b69acad5ceafede3c5984ec6634cb",
    "file": "SkPath_Reference",
    "name": "SkPath::addPoly_2"
},
    "SkPath_addRRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRRect rrect;\n    SkVector radii[] = {{50, 50}, {0, 0}, {0, 0}, {50, 50}};\n    rrect.setRectRadii({10, 10, 110, 110}, radii);\n    SkPath path;\n    SkMatrix rotate90;\n    rotate90.setRotate(90, 128, 128);\n    for (int i = 0; i < 4; ++i) {\n        path.addRRect(rrect);\n        path.transform(rotate90);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "d9ecd58081b5bc77a157636fcb345dc6",
    "file": "SkPath_Reference",
    "name": "SkPath::addRRect"
},
    "SkPath_addRRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRRect rrect;\n    rrect.setRectXY({40, 40, 215, 215}, 50, 50);\n    SkPath path;\n    path.addRRect(rrect);\n    canvas->drawPath(path, paint);\n    for (int start = 0; start < 8; ++start) {\n        SkPath textPath;\n        textPath.addRRect(rrect, SkPath::kCW_Direction, start);\n        SkPathMeasure pathMeasure(textPath, false);\n        SkPoint position;\n        SkVector tangent;\n        if (!pathMeasure.getPosTan(0, &position, &tangent)) {\n            continue;\n        }\n        SkRSXform rsxForm = SkRSXform::Make(tangent.fX, tangent.fY,\n               position.fX + tangent.fY * 5, position.fY - tangent.fX * 5);\n        canvas->drawTextRSXform(&\"01234567\"[start], 1, &rsxForm, nullptr, paint);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "888edd4c4a91ca62ceb01bce8ab675b2",
    "file": "SkPath_Reference",
    "name": "SkPath::addRRect_2"
},
    "SkPath_addRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeCap(SkPaint::kSquare_Cap);\n    float intervals[] = { 5, 21.75f };\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 0));\n    SkPath path;\n    path.addRect({20, 20, 100, 100}, SkPath::kCW_Direction);\n    canvas->drawPath(path, paint);\n    path.rewind();\n    path.addRect({140, 20, 220, 100}, SkPath::kCCW_Direction);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "0f841e4eaebb613b5069800567917c2d",
    "file": "SkPath_Reference",
    "name": "SkPath::addRect"
},
    "SkPath_addRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkPoint arrow[] = { {5, -5}, {15, -5}, {20, 0}, {15, 5}, {5, 5}, {10, 0} };\n    const SkRect rect = {10, 10, 54, 54};\n    SkPaint rectPaint;\n    rectPaint.setAntiAlias(true);\n    rectPaint.setStyle(SkPaint::kStroke_Style);\n    SkPaint arrowPaint(rectPaint);\n    SkPath arrowPath;\n    arrowPath.addPoly(arrow, SK_ARRAY_COUNT(arrow), true);\n    arrowPaint.setPathEffect(SkPath1DPathEffect::Make(arrowPath, 176, 0,\n                             SkPath1DPathEffect::kRotate_Style));\n    for (auto direction : { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        for (unsigned start : { 0, 1, 2, 3 } ) {\n           SkPath path;\n           path.addRect(rect, direction, start);\n           canvas->drawPath(path, rectPaint);\n           canvas->drawPath(path, arrowPaint);\n           canvas->translate(64, 0);\n       }\n       canvas->translate(-256, 64);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "9202430b3f4f5275af8eec5cc9d7baa8",
    "file": "SkPath_Reference",
    "name": "SkPath::addRect_2"
},
    "SkPath_addRect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeCap(SkPaint::kSquare_Cap);\n    float intervals[] = { 5, 21.75f };\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 0));\n    for (auto direction : { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        SkPath path;\n        path.addRect(20, 20, 100, 100, direction);\n        canvas->drawPath(path, paint);\n        canvas->translate(128, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "3837827310e8b88b8c2e128ef9fbbd65",
    "file": "SkPath_Reference",
    "name": "SkPath::addRect_3"
},
    "SkPath_addRoundRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    for (auto xradius : { 0, 7, 13, 20 } ) {\n        for (auto yradius : { 0, 9, 18, 40 } ) {\n            SkPath path;\n            path.addRoundRect({10, 10, 36, 46}, xradius, yradius);\n            paint.setColor(path.isRect(nullptr) ? SK_ColorRED : path.isOval(nullptr) ?\n                           SK_ColorBLUE : path.isConvex() ? SK_ColorGRAY : SK_ColorGREEN);\n            canvas->drawPath(path, paint);\n            canvas->translate(64, 0);\n        }\n        canvas->translate(-256, 64);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "24736f685f265cf533f1700c042db353",
    "file": "SkPath_Reference",
    "name": "SkPath::addRoundRect"
},
    "SkPath_addRoundRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkScalar radii[] = { 80, 100, 0, 0, 40, 60, 0, 0 };\n    SkPath path;\n    SkMatrix rotate90;\n    rotate90.setRotate(90, 128, 128);\n    for (int i = 0; i < 4; ++i) {\n        path.addRoundRect({10, 10, 110, 110}, radii);\n        path.transform(rotate90);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "c43d70606b4ee464d2befbcf448c5e73",
    "file": "SkPath_Reference",
    "name": "SkPath::addRoundRect_2"
},
    "SkPath_arcTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath path;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(4);\n    path.moveTo(0, 0);\n    path.arcTo({20, 20, 120, 120}, -90, 90, false);\n    canvas->drawPath(path, paint);\n    path.rewind();\n    path.arcTo({120, 20, 220, 120}, -90, 90, false);\n    canvas->drawPath(path, paint);\n    path.rewind();\n    path.moveTo(0, 0);\n    path.arcTo({20, 120, 120, 220}, -90, 90, true);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 200,
    "hash": "5f02890edaa10cb5e1a4243a82b6a382",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo"
},
    "SkPath_arcTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint tangentPaint;\n    tangentPaint.setAntiAlias(true);\n    SkPaint textPaint(tangentPaint);\n    tangentPaint.setStyle(SkPaint::kStroke_Style);\n    tangentPaint.setColor(SK_ColorGRAY);\n    SkPaint arcPaint(tangentPaint);\n    arcPaint.setStrokeWidth(5);\n    arcPaint.setColor(SK_ColorBLUE);\n    SkPath path;\n    SkPoint pts[] = { {56, 20}, {200, 20}, {90, 190} };\n    SkScalar radius = 50;\n    path.moveTo(pts[0]);\n    path.arcTo(pts[1], pts[2], radius);\n    canvas->drawLine(pts[0], pts[1], tangentPaint);\n    canvas->drawLine(pts[1], pts[2], tangentPaint);\n    SkPoint lastPt;\n    (void) path.getLastPt(&lastPt);\n    SkVector radial = pts[2] - pts[1];\n    radial.setLength(radius);\n    SkPoint center = { lastPt.fX - radial.fY, lastPt.fY + radial.fX };\n    canvas->drawCircle(center, radius, tangentPaint);\n    canvas->drawLine(lastPt, center, tangentPaint);\n    radial = pts[1] - pts[0];\n    radial.setLength(radius);\n    SkPoint arcStart = { center.fX + radial.fY, center.fY - radial.fX };\n    canvas->drawLine(center, arcStart, tangentPaint);\n    canvas->drawPath(path, arcPaint);\n    canvas->drawString(\"(x0, y0)\", pts[0].fX - 5, pts[0].fY, textPaint);\n    canvas->drawString(\"(x1, y1)\", pts[1].fX + 5, pts[1].fY, textPaint);\n    canvas->drawString(\"(x2, y2)\", pts[2].fX, pts[2].fY + 15, textPaint);\n    canvas->drawString(\"radius\", center.fX + 15, center.fY + 25, textPaint);\n    canvas->drawString(\"radius\", center.fX - 3, center.fY - 16, textPaint);\n}\n",
    "width": 256,
    "height": 226,
    "hash": "386000684073fccabc224d7d6dc81cd9",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_2"
},
    "SkPath_arcTo_2_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint tangentPaint;\n    tangentPaint.setAntiAlias(true);\n    SkPaint textPaint(tangentPaint);\n    tangentPaint.setStyle(SkPaint::kStroke_Style);\n    tangentPaint.setColor(SK_ColorGRAY);\n    SkPaint arcPaint(tangentPaint);\n    arcPaint.setStrokeWidth(5);\n    arcPaint.setColor(SK_ColorBLUE);\n    SkPath path;\n    SkPoint pts[] = { {156, 20}, {200, 20}, {170, 50} };\n    SkScalar radius = 50;\n    path.moveTo(pts[0]);\n    path.arcTo(pts[1], pts[2], radius);\n    canvas->drawLine(pts[0], pts[1], tangentPaint);\n    canvas->drawLine(pts[1], pts[2], tangentPaint);\n    SkPoint lastPt;\n    (void) path.getLastPt(&lastPt);\n    SkVector radial = pts[2] - pts[1];\n    radial.setLength(radius);\n    SkPoint center = { lastPt.fX - radial.fY, lastPt.fY + radial.fX };\n    canvas->drawLine(lastPt, center, tangentPaint);\n    radial = pts[1] - pts[0];\n    radial.setLength(radius);\n    SkPoint arcStart = { center.fX + radial.fY, center.fY - radial.fX };\n    canvas->drawLine(center, arcStart, tangentPaint);\n    canvas->drawPath(path, arcPaint);\n    canvas->drawString(\"(x0, y0)\", pts[0].fX, pts[0].fY - 7, textPaint);\n    canvas->drawString(\"(x1, y1)\", pts[1].fX + 5, pts[1].fY, textPaint);\n    canvas->drawString(\"(x2, y2)\", pts[2].fX, pts[2].fY + 15, textPaint);\n    canvas->drawString(\"radius\", center.fX + 15, center.fY + 25, textPaint);\n    canvas->drawString(\"radius\", center.fX - 5, center.fY - 20, textPaint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "78f3c65fa900610bb52518989b547095",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_2_2"
},
    "SkPath_arcTo_4": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (auto sweep: { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        for (auto arcSize : { SkPath::kSmall_ArcSize, SkPath::kLarge_ArcSize } ) {\n            SkPath path;\n            path.moveTo({120, 50});\n            path.arcTo(70, 40, 30, arcSize, sweep, 120.1, 50);\n            if (SkPath::kCCW_Direction == sweep && SkPath::kLarge_ArcSize == arcSize) {\n                paint.setColor(SK_ColorBLUE);\n                paint.setStrokeWidth(3);\n            }\n            canvas->drawPath(path, paint);\n         }\n    }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "6b6ea44f659b27918f3a6fa621bf6173",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_4"
},
    "SkPath_arcTo_5": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath path;\n    const SkPoint starts[] = {{20, 20}, {120, 20}, {70, 60}};\n    for (auto start : starts) {\n        path.moveTo(start.fX, start.fY);\n        path.rArcTo(20, 20, 0, SkPath::kSmall_ArcSize, SkPath::kCCW_Direction, 60, 0);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 108,
    "hash": "3f76a1007416181a4848c1a87fc81dbd",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_5"
},
    "SkPath_close": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeCap(SkPaint::kRound_Cap);\n    SkPath path;\n    const SkPoint points[] = {{20, 20}, {70, 20}, {40, 90}};\n    path.addPoly(points, SK_ARRAY_COUNT(points), false);\n    for (int loop = 0; loop < 2; ++loop) {\n        for (auto style : {SkPaint::kStroke_Style, SkPaint::kFill_Style,\n                SkPaint::kStrokeAndFill_Style} ) {\n            paint.setStyle(style);\n            canvas->drawPath(path, paint);\n            canvas->translate(85, 0);\n        }\n        path.close();\n        canvas->translate(-255, 128);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "9235f6309271d6420fa5c45dc28664c5",
    "file": "SkPath_Reference",
    "name": "SkPath::close()"
},
    "SkPath_conicTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPoint conicPts[] = {{20, 150}, {120, 10}, {220, 150}};\n    canvas->drawLine(conicPts[0], conicPts[1], paint);\n    canvas->drawLine(conicPts[1], conicPts[2], paint);\n    SkColor colors[] = { 0xff88ff00, 0xff0088bb, 0xff6600cc, 0xffbb3377 };\n    paint.setStrokeWidth(3);\n    SkScalar weight = 0.5f;\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(colors); ++i) {\n        SkPath path;\n        path.moveTo(conicPts[0]);\n        path.conicTo(conicPts[1], conicPts[2], weight);\n        paint.setColor(colors[i]);\n        canvas->drawPath(path, paint);\n        weight += 0.25f;\n   }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "358d9b6060b528b0923c007420f09c13",
    "file": "SkPath_Reference",
    "name": "SkPath::conicTo"
},
    "SkPath_conicTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkRect oval = {0, 20, 120, 140};\n    SkPath path;\n    for (int i = 0; i < 4; ++i) {\n        path.moveTo(oval.centerX(), oval.fTop);\n        path.arcTo(oval, -90, 90 - 20 * i, false);\n        oval.inset(15, 15);\n    }\n    path.offset(100, 0);\n    SkScalar conicWeights[] = { 0.707107f, 0.819152f, 0.906308f, 0.965926f };\n    SkPoint conicPts[][3] = { { {40, 20}, {100, 20}, {100, 80} },\n                              { {40, 35}, {71.509f, 35}, {82.286f, 64.6091f} },\n                              { {40, 50}, {53.9892f, 50}, {62.981f, 60.7164f} },\n                              { {40, 65}, {44.0192f, 65}, {47.5f, 67.0096f} } };\n    for (int i = 0; i < 4; ++i) {\n         path.moveTo(conicPts[i][0]);\n         path.conicTo(conicPts[i][1], conicPts[i][2], conicWeights[i]);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "22d25e03b19d5bae92118877e462361b",
    "file": "SkPath_Reference",
    "name": "SkPath::conicTo_2"
},
    "SkPath_conservativelyContainsRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.addRoundRect({10, 20, 54, 120}, 10, 20);\n    SkRect tests[] = {\n      { 10, 40, 54, 80 },\n      { 25, 20, 39, 120 },\n      { 15, 25, 49, 115 },\n      { 13, 27, 51, 113 },\n    };\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(tests); ++i) {\n      SkPaint paint;\n      paint.setColor(SK_ColorRED);\n      canvas->drawPath(path, paint);\n      bool rectInPath = path.conservativelyContainsRect(tests[i]);\n      paint.setColor(rectInPath ? SK_ColorBLUE : SK_ColorBLACK);\n      canvas->drawRect(tests[i], paint);\n      canvas->translate(64, 0);\n    }\n}\n",
    "width": 256,
    "height": 140,
    "hash": "41638d13e40fa449ece354dde5fb1941",
    "file": "SkPath_Reference",
    "name": "SkPath::conservativelyContainsRect"
},
    "SkPath_contains": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkPaint paint;\n    paint.setTextSize(256);\n    paint.getTextPath(\"&\", 1, 30, 220, &path);\n    for (int y = 2; y < 256; y += 9) {\n       for (int x = 2; x < 256; x += 9) {\n           int coverage = 0;\n           for (int iy = -4; iy <= 4; iy += 2) {\n               for (int ix = -4; ix <= 4; ix += 2) {\n                   coverage += path.contains(x + ix, y + iy);\n               }\n           }\n           paint.setColor(SkColorSetARGB(0x5f, 0xff * coverage / 25, 0, 0xff * (25 - coverage) / 25));\n           canvas->drawCircle(x, y, 8, paint);\n       }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "c0216b3f7ebd80b9589ae5728f08fc80",
    "file": "SkPath_Reference",
    "name": "SkPath::contains()"
},
    "SkPath_cubicTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(0, -10);\n    for (int i = 0; i < 128; i += 16) {\n        SkScalar c = i * 0.5f;\n        path.cubicTo( 10 + c, -10 - i,  10 + i, -10 - c,  10 + i,       0);\n        path.cubicTo( 14 + i,  14 + c,  14 + c,  14 + i,       0,  14 + i);\n        path.cubicTo(-18 - c,  18 + i, -18 - i,  18 + c, -18 - i,       0);\n        path.cubicTo(-22 - i, -22 - c, -22 - c, -22 - i,       0, -22 - i);\n    }\n    path.offset(128, 128);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "3e476378e3e0550ab134bbaf61112d98",
    "file": "SkPath_Reference",
    "name": "SkPath::cubicTo"
},
    "SkPath_cubicTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPoint pts[] = { {20, 20}, {300, 80}, {-140, 90}, {220, 10} };\n    SkPath path;\n    path.moveTo(pts[0]);\n    path.cubicTo(pts[1], pts[2], pts[3]);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 84,
    "hash": "d38aaf12c6ff5b8d901a2201bcee5476",
    "file": "SkPath_Reference",
    "name": "SkPath::cubicTo_2"
},
    "SkPath_incReserve": {
    "code": "void draw(SkCanvas* canvas) {\n    auto addPoly = [](int sides, SkScalar size, SkPath* path) -> void {\n        path->moveTo(size, 0);\n        for (int i = 1; i < sides; i++) {\n            SkScalar c, s = SkScalarSinCos(SK_ScalarPI * 2 * i / sides, &c);\n            path->lineTo(c * size, s * size);\n        }\n        path->close();\n    };\n    SkPath path;\n    path.incReserve(3 + 4 + 5 + 6 + 7 + 8 + 9);\n    for (int sides = 3; sides < 10; ++sides) {\n       addPoly(sides, sides, &path);\n    }\n    SkMatrix matrix;\n    matrix.setScale(10, 10, -10, -10);\n    path.transform(matrix);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 192,
    "hash": "f2260f2a170a54aef5bafe5b91c121b3",
    "file": "SkPath_Reference",
    "name": "SkPath::incReserve"
},
    "SkPath_interpolate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path, path2;\n    path.moveTo(20, 20);\n    path.lineTo(40, 40);\n    path.lineTo(20, 40);\n    path.lineTo(40, 20);\n    path.close();\n    path2.addRect({20, 20, 40, 40});\n    for (SkScalar i = 0; i <= 1; i += 1.f / 6) {\n      SkPath interp;\n      path.interpolate(path2, i, &interp);\n      canvas->drawPath(interp, paint);\n      canvas->translate(30, 0);\n    }\n}\n",
    "width": 256,
    "height": 60,
    "hash": "404f11c5c9c9ca8a64822d484552a473",
    "file": "SkPath_Reference",
    "name": "SkPath::interpolate()"
},
    "SkPath_isConvex": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPoint quad[] = {{70, 70}, {20, 20}, {120, 20}, {120, 120}};\n    for (SkScalar x : { 40, 100 } ) {\n        SkPath path;\n        quad[0].fX = x;\n        path.addPoly(quad, SK_ARRAY_COUNT(quad), true);\n        path.setConvexity(SkPath::kConvex_Convexity);\n        canvas->drawPath(path, paint);\n        canvas->drawString(path.isConvex() ? \"convex\" : \"not convex\", 30, 100, paint);\n        canvas->translate(100, 100);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "d8be8b6e59de244e4cbf58ec9554557b",
    "file": "SkPath_Reference",
    "name": "SkPath::isConvex"
},
    "SkPath_isOval": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath path;\n    path.addOval({20, 20, 220, 220});\n    SkRect bounds;\n    if (path.isOval(&bounds)) {\n        paint.setColor(0xFF9FBFFF);\n        canvas->drawRect(bounds, paint);\n    }\n    paint.setColor(0x3f000000);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "a51256952b183ee0f7004f2c87cbbf5b",
    "file": "SkPath_Reference",
    "name": "SkPath::isOval"
},
    "SkPath_isRRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath path;\n    path.addRRect(SkRRect::MakeRectXY({20, 20, 220, 220}, 30, 50));\n    SkRRect rrect;\n    if (path.isRRect(&rrect)) {\n        const SkRect& bounds = rrect.rect();\n        paint.setColor(0xFF9FBFFF);\n        canvas->drawRect(bounds, paint);\n    }\n    paint.setColor(0x3f000000);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "2aa939b90d96aff436b145a96305132c",
    "file": "SkPath_Reference",
    "name": "SkPath::isRRect"
},
    "SkPath_lineTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(72);\n    canvas->drawString(\"#\", 120, 80, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(5);\n    SkPath path;\n    SkPoint hash[] = {{58, 28}, {43, 80}, {37, 45}, {85, 45}};\n    SkVector offsets[] = {{0, 0}, {17, 0}, {0, 0}, {-5, 17}};\n    unsigned o = 0;\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(hash); i += 2) {\n        for (unsigned j = 0; j < 2; o++, j++) {\n            path.moveTo(hash[i].fX + offsets[o].fX, hash[i].fY + offsets[o].fY);\n            path.lineTo(hash[i + 1].fX + offsets[o].fX, hash[i + 1].fY + offsets[o].fY);\n        }\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 100,
    "hash": "e311cdd451edacec33b50cc22a4dd5dc",
    "file": "SkPath_Reference",
    "name": "SkPath::lineTo"
},
    "SkPath_lineTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkVector oxo[] = {{25, 25}, {35, 35}, {25, 35}, {35, 25},\n                      {40, 20}, {40, 80}, {60, 20}, {60, 80},\n                      {20, 40}, {80, 40}, {20, 60}, {80, 60}};\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(oxo); i += 2) {\n        path.moveTo(oxo[i]);\n        path.lineTo(oxo[i + 1]);\n    }\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "41001546a7f7927d08e5a818bcc304f5",
    "file": "SkPath_Reference",
    "name": "SkPath::lineTo_2"
},
    "SkPath_moveTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 20, 20, 120, 80 };\n    SkPath path;\n    path.addRect(rect);\n    path.moveTo(rect.fLeft, rect.fTop);\n    path.lineTo(rect.fRight, rect.fBottom);\n    path.moveTo(rect.fLeft, rect.fBottom);\n    path.lineTo(rect.fRight, rect.fTop);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 140,
    "height": 100,
    "hash": "84101d341e934a535a41ad6cf42218ce",
    "file": "SkPath_Reference",
    "name": "SkPath::moveTo"
},
    "SkPath_moveTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint data[][3] = {{{30,40},{60,60},{90,30}}, {{30,120},{60,100},{90,120}},\n                         {{60,100},{60,40},{70,30}}, {{60,40},{50,20},{70,30}}};\n    SkPath path;\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(data); ++i) {\n        path.moveTo(data[i][0]);\n        path.lineTo(data[i][1]);\n        path.lineTo(data[i][2]);\n    }\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 128,
    "height": 128,
    "hash": "cb8d37990f6e7df3bcc85e7240c81274",
    "file": "SkPath_Reference",
    "name": "SkPath::moveTo_2"
},
    "SkPath_offset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath pattern;\n    pattern.moveTo(20, 20);\n    pattern.lineTo(20, 40);\n    pattern.lineTo(40, 20);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 10; i++) {\n        SkPath path;\n        pattern.offset(20 * i, 0, &path);\n        canvas->drawPath(path, paint);\n    }\n}",
    "width": 256,
    "height": 60,
    "hash": "1d1892196ba5bda257df4f3351abd084",
    "file": "SkPath_Reference",
    "name": "SkPath::offset()"
},
    "SkPath_offset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(20, 20);\n    path.lineTo(20, 40);\n    path.lineTo(40, 20);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 10; i++) {\n        canvas->drawPath(path, paint);\n        path.offset(20, 0);\n    }\n}",
    "width": 256,
    "height": 60,
    "hash": "5188d77585715db30bef228f2dfbcccd",
    "file": "SkPath_Reference",
    "name": "SkPath::offset_2"
},
    "SkPath_quadTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(0, -10);\n    for (int i = 0; i < 128; i += 16) {\n        path.quadTo( 10 + i, -10 - i,  10 + i,       0);\n        path.quadTo( 14 + i,  14 + i,       0,  14 + i);\n        path.quadTo(-18 - i,  18 + i, -18 - i,       0);\n        path.quadTo(-22 - i, -22 - i,       0, -22 - i);\n    }\n    path.offset(128, 128);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "60ee3eb747474f5781b0f0dd3a17a866",
    "file": "SkPath_Reference",
    "name": "SkPath::quadTo"
},
    "SkPath_quadTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setAntiAlias(true);\n    SkPath path;\n    SkPoint pts[] = {{128, 10}, {10, 214}, {236, 214}};\n    path.moveTo(pts[1]);\n    for (int i = 0; i < 3; ++i) {\n        path.quadTo(pts[i % 3],  pts[(i + 2) % 3]);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "82621c4df8da1e589d9e627494067826",
    "file": "SkPath_Reference",
    "name": "SkPath::quadTo_2"
},
    "SkPath_rArcTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath path;\n    const SkPoint starts[] = {{20, 20}, {120, 20}, {70, 60}};\n    for (auto start : starts) {\n        path.moveTo(start.fX, start.fY);\n        path.rArcTo(20, 20, 0, SkPath::kSmall_ArcSize, SkPath::kCCW_Direction, 60, 0);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 108,
    "hash": "3f76a1007416181a4848c1a87fc81dbd",
    "file": "SkPath_Reference",
    "name": "SkPath::rArcTo"
},
    "SkPath_rConicTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(20, 80);\n    path.rConicTo( 60,   0,  60,  60, 0.707107f);\n    path.rConicTo(  0, -60,  60, -60, 0.707107f);\n    path.rConicTo(-60,   0, -60, -60, 0.707107f);\n    path.rConicTo(  0,  60, -60,  60, 0.707107f);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 140,
    "hash": "3d52763e7c0e20c0b1d484a0afa622d2",
    "file": "SkPath_Reference",
    "name": "SkPath::rConicTo"
},
    "SkPath_rCubicTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(24, 108);\n    for (int i = 0; i < 16; i++) {\n       SkScalar sx, sy;\n       sx = SkScalarSinCos(i * SK_ScalarPI / 8, &sy);\n       path.rCubicTo(40 * sx, 4 * sy, 4 * sx, 40 * sy, 40 * sx, 40 * sy);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "19f0cfc7eeba8937fe19446ec0b5f932",
    "file": "SkPath_Reference",
    "name": "SkPath::rCubicTo"
},
    "SkPath_rLineTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(10, 98);\n    SkScalar x = 0, y = 0;\n    for (int i = 10; i < 100; i += 5) {\n        x += i * ((i & 2) - 1);\n        y += i * (((i + 1) & 2) - 1);\n        path.rLineTo(x, y);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "6e0be0766b8ca320da51640326e608b3",
    "file": "SkPath_Reference",
    "name": "SkPath::rLineTo"
},
    "SkPath_rMoveTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.addRect({20, 20, 80, 80}, SkPath::kCW_Direction, 2);\n    path.rMoveTo(25, 2);\n    SkVector arrow[] = {{0, -4}, {-20, 0}, {0, -3}, {-5, 5}, {5, 5}, {0, -3}, {20, 0}};\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(arrow); ++i) {\n        path.rLineTo(arrow[i].fX, arrow[i].fY);\n    }\n    SkPaint paint;\n    canvas->drawPath(path, paint);\n    SkPoint lastPt;\n    path.getLastPt(&lastPt);\n    canvas->drawString(\"start\", lastPt.fX, lastPt.fY, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "63e32dec4b2d8440b427f368bf8313a4",
    "file": "SkPath_Reference",
    "name": "SkPath::rMoveTo"
},
    "SkPath_rQuadTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    path.moveTo(128, 20);\n    path.rQuadTo(-6, 10, -7, 10);\n    for (int i = 1; i < 32; i += 4) {\n       path.rQuadTo(10 + i, 10 + i, 10 + i * 4, 10);\n       path.rQuadTo(-10 - i, 10 + i, -10 - (i + 2) * 4, 10);\n    }\n    path.quadTo(92, 220, 128, 215);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "1c1f4cdef1c572c9aa8fdf3e461191d0",
    "file": "SkPath_Reference",
    "name": "SkPath::rQuadTo"
},
    "SkPath_reverseAddPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(20, 20);\n    path.lineTo(20, 40);\n    path.lineTo(40, 20);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 2; i++) {\n        SkPath path2;\n        path2.moveTo(60, 60);\n        path2.lineTo(80, 60);\n        path2.lineTo(80, 40);\n        for (int j = 0; j < 2; j++) {\n            SkPath test(path);\n            test.reverseAddPath(path2);\n            canvas->drawPath(test, paint);\n            canvas->translate(100, 0);\n            path2.close();\n        }\n        canvas->translate(-200, 100);\n        path.close();\n    }\n}",
    "width": 256,
    "height": 200,
    "hash": "5e8513f073db09acde3ff616f6426e3d",
    "file": "SkPath_Reference",
    "name": "SkPath::reverseAddPath"
},
    "SkPath_setFillType": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.setFillType(SkPath::kInverseWinding_FillType);\n    SkPaint paint;\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "b4a91cd7f50b2a0a0d1bec6d0ac823d2",
    "file": "SkPath_Reference",
    "name": "SkPath::setFillType"
},
    "SkPath_setIsVolatile": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.setIsVolatile(true);\n    path.lineTo(40, 40);\n    canvas->drawPath(path, paint);\n    path.rewind();\n    path.moveTo(0, 40);\n    path.lineTo(40, 0);\n    canvas->drawPath(path, paint);\n}",
    "width": 50,
    "height": 50,
    "hash": "2049ff5141f0c80aac497618622b28af",
    "file": "SkPath_Reference",
    "name": "SkPath::setIsVolatile"
},
    "SkPath_setLastPt": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath path;\n    paint.getTextPath(\"@\", 1, 60, 100, &path);\n    path.setLastPt(20, 120);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "542c5afaea5f57baa11d0561dd402e18",
    "file": "SkPath_Reference",
    "name": "SkPath::setLastPt"
},
    "SkPath_setLastPt_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath path, path2;\n    paint.getTextPath(\"A\", 1, 60, 100, &path);\n    paint.getTextPath(\"Z\", 1, 60, 100, &path2);\n    SkPoint pt, pt2;\n    path.getLastPt(&pt);\n    path2.getLastPt(&pt2);\n    path.setLastPt(pt2);\n    path2.setLastPt(pt);\n    canvas->drawPath(path, paint);\n    canvas->drawPath(path2, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "6fa5e8f9513b3225e106778592e27e94",
    "file": "SkPath_Reference",
    "name": "SkPath::setLastPt_2"
},
    "SkPath_toggleInverseFillType": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkPaint paint;\n    paint.setColor(SK_ColorRED);\n    paint.setTextSize(80);\n    paint.getTextPath(\"ABC\", 3, 20, 80, &path);\n    canvas->drawPath(path, paint);\n    path.toggleInverseFillType();\n    paint.setColor(SK_ColorGREEN);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "400facce23d417bc5043c5f58404afbd",
    "file": "SkPath_Reference",
    "name": "SkPath::toggleInverseFillType"
},
    "SkPath_transform": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath pattern;\n    pattern.moveTo(100, 100);\n    pattern.lineTo(100, 20);\n    pattern.lineTo(20, 100);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 10; i++) {\n        SkPath path;\n        SkMatrix matrix;\n        matrix.setRotate(36 * i, 100, 100);\n        pattern.transform(matrix, &path);\n        canvas->drawPath(path, paint);\n    }\n}",
    "width": 256,
    "height": 200,
    "hash": "99761add116ce3b0730557224c1b0105",
    "file": "SkPath_Reference",
    "name": "SkPath::transform()"
},
    "SkPath_transform_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(100, 100);\n    path.quadTo(100, 20, 20, 100);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 10; i++) {\n        SkMatrix matrix;\n        matrix.setRotate(36, 100, 100);\n        path.transform(matrix);\n        canvas->drawPath(path, paint);\n    }\n}",
    "width": 256,
    "height": 200,
    "hash": "c40979a3b92a30cfb7bae36abcc1d805",
    "file": "SkPath_Reference",
    "name": "SkPath::transform_2"
},
    "SkPicture_AbortCallback": {
    "code": "class JustOneDraw : public SkPicture::AbortCallback {\npublic:\n    bool abort() override { return fCalls++ > 0; }\nprivate:\n    int fCalls = 0;\n};\n\nvoid draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* pictureCanvas = recorder.beginRecording({0, 0, 256, 256});\n    SkPaint paint;\n    pictureCanvas->drawRect(SkRect::MakeWH(200, 200), paint);\n    paint.setColor(SK_ColorWHITE);\n    pictureCanvas->drawRect(SkRect::MakeLTRB(20, 20, 180, 180), paint);\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    JustOneDraw callback;\n    picture->playback(canvas, &callback);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "56ed920dadbf2b2967ac45fb5a9bded6",
    "file": "SkPicture_Reference",
    "name": "SkPicture::AbortCallback"
},
    "SkPicture_MakeFromData": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* pictureCanvas = recorder.beginRecording({0, 0, 256, 256});\n    SkPaint paint;\n    pictureCanvas->drawRect(SkRect::MakeWH(200, 200), paint);\n    paint.setColor(SK_ColorWHITE);\n    pictureCanvas->drawRect(SkRect::MakeLTRB(20, 20, 180, 180), paint);\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    SkDynamicMemoryWStream writableStream;\n    picture->serialize(&writableStream);\n    sk_sp<SkData> readableData = writableStream.detachAsData();\n    sk_sp<SkPicture> copy = SkPicture::MakeFromData(readableData.get());\n    copy->playback(canvas);\n}",
    "width": 256,
    "height": 256,
    "hash": "58b44bf47d8816782066618700afdecb",
    "file": "SkPicture_Reference",
    "name": "SkPicture::MakeFromData"
},
    "SkPicture_MakeFromData_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* pictureCanvas = recorder.beginRecording({0, 0, 256, 256});\n    SkPaint paint;\n    pictureCanvas->drawRect(SkRect::MakeWH(200, 200), paint);\n    paint.setColor(SK_ColorWHITE);\n    pictureCanvas->drawRect(SkRect::MakeLTRB(20, 20, 180, 180), paint);\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    SkDynamicMemoryWStream writableStream;\n    picture->serialize(&writableStream);\n    sk_sp<SkData> readableData = writableStream.detachAsData();\n    sk_sp<SkPicture> copy = SkPicture::MakeFromData(readableData->data(), readableData->size());\n    copy->playback(canvas);\n}",
    "width": 256,
    "height": 256,
    "hash": "30b9f1b310187db6aff720a5d67591e2",
    "file": "SkPicture_Reference",
    "name": "SkPicture::MakeFromData_2"
},
    "SkPicture_MakeFromStream": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* pictureCanvas = recorder.beginRecording({0, 0, 256, 256});\n    SkPaint paint;\n    pictureCanvas->drawRect(SkRect::MakeWH(200, 200), paint);\n    paint.setColor(SK_ColorWHITE);\n    pictureCanvas->drawRect(SkRect::MakeLTRB(20, 20, 180, 180), paint);\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    SkDynamicMemoryWStream writableStream;\n    picture->serialize(&writableStream);\n    std::unique_ptr<SkStreamAsset> readableStream = writableStream.detachAsStream();\n    sk_sp<SkPicture> copy = SkPicture::MakeFromStream(readableStream.get());\n    copy->playback(canvas);\n}",
    "width": 256,
    "height": 256,
    "hash": "404fb42560a289c2004cad1caf3b96de",
    "file": "SkPicture_Reference",
    "name": "SkPicture::MakeFromStream"
},
    "SkPicture_MakePlaceholder": {
    "code": "class MyCanvas : public SkCanvas {\npublic:\n    MyCanvas(SkCanvas* c) : canvas(c) {}\n        void onDrawPicture(const SkPicture* picture, const SkMatrix* ,\n                               const SkPaint* ) override {\n        const SkRect rect = picture->cullRect();\n        SkPaint redPaint;\n        redPaint.setColor(SK_ColorRED);\n        canvas->drawRect(rect, redPaint);\n   }\n   SkCanvas* canvas;\n};\n\nvoid draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* pictureCanvas = recorder.beginRecording({0, 0, 256, 256});\n    sk_sp<SkPicture> placeholder = SkPicture::MakePlaceholder({10, 40, 80, 110});\n    pictureCanvas->drawPicture(placeholder);\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    MyCanvas myCanvas(canvas);\n    myCanvas.drawPicture(picture);\n}",
    "width": 256,
    "height": 256,
    "hash": "0d2cbf82f490ffb180e0b4531afa232c",
    "file": "SkPicture_Reference",
    "name": "SkPicture::MakePlaceholder"
},
    "SkPicture_approximateBytesUsed": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* pictureCanvas = recorder.beginRecording({0, 0, 256, 256});\n    SkPaint paint;\n    pictureCanvas->drawRect(SkRect::MakeWH(200, 200), paint);\n    paint.setColor(SK_ColorWHITE);\n    pictureCanvas->drawRect(SkRect::MakeLTRB(20, 20, 180, 180), paint);\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    picture->playback(canvas);\n    std::string opCount = \"approximate bytes used: \" + std::to_string(picture->approximateBytesUsed());\n    canvas->drawString(opCount.c_str(), 20, 220, SkPaint());\n}",
    "width": 256,
    "height": 256,
    "hash": "ececbda21218bd732394a305dba393a2",
    "file": "SkPicture_Reference",
    "name": "SkPicture::approximateBytesUsed"
},
    "SkPicture_approximateOpCount": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* pictureCanvas = recorder.beginRecording({0, 0, 256, 256});\n    SkPaint paint;\n    pictureCanvas->drawRect(SkRect::MakeWH(200, 200), paint);\n    paint.setColor(SK_ColorWHITE);\n    pictureCanvas->drawRect(SkRect::MakeLTRB(20, 20, 180, 180), paint);\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    picture->playback(canvas);\n    std::string opCount = \"approximate op count: \" + std::to_string(picture->approximateOpCount());\n    canvas->drawString(opCount.c_str(), 50, 220, SkPaint());\n}",
    "width": 256,
    "height": 256,
    "hash": "4b3d879118ef770d1f11a23c6493b2c4",
    "file": "SkPicture_Reference",
    "name": "SkPicture::approximateOpCount"
},
    "SkPicture_cullRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* pictureCanvas = recorder.beginRecording({64, 64, 192, 192});\n    SkPaint paint;\n    pictureCanvas->drawRect(SkRect::MakeWH(200, 200), paint);\n    paint.setColor(SK_ColorWHITE);\n    pictureCanvas->drawRect(SkRect::MakeLTRB(20, 20, 180, 180), paint);\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    picture->playback(canvas);\n    paint.setBlendMode(SkBlendMode::kModulate);\n    paint.setColor(0x40404040);\n    canvas->drawRect(picture->cullRect(), paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "15bb9a9596b40c5e2045f76e8c1dcf8e",
    "file": "SkPicture_Reference",
    "name": "SkPicture::cullRect"
},
    "SkPicture_playback": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* pictureCanvas = recorder.beginRecording({0, 0, 256, 256});\n    SkPaint paint;\n    pictureCanvas->drawRect(SkRect::MakeWH(200, 200), paint);\n    paint.setColor(SK_ColorWHITE);\n    pictureCanvas->drawRect(SkRect::MakeLTRB(20, 20, 180, 180), paint);\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    picture->playback(canvas);\n}",
    "width": 256,
    "height": 256,
    "hash": "6b0ffb03ba05f526b345dc65a1c73fe4",
    "file": "SkPicture_Reference",
    "name": "SkPicture::playback()"
},
    "SkPicture_serialize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* pictureCanvas = recorder.beginRecording({0, 0, 256, 256});\n    SkPaint paint;\n    pictureCanvas->drawRect(SkRect::MakeWH(200, 200), paint);\n    paint.setColor(SK_ColorWHITE);\n    pictureCanvas->drawRect(SkRect::MakeLTRB(20, 20, 180, 180), paint);\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    sk_sp<SkData> readableData = picture->serialize();\n    sk_sp<SkPicture> copy = SkPicture::MakeFromData(readableData->data(), readableData->size());\n    copy->playback(canvas);\n}",
    "width": 256,
    "height": 256,
    "hash": "dacdebe1355c884ebd3c2ea038cc7a20",
    "file": "SkPicture_Reference",
    "name": "SkPicture::serialize()"
},
    "SkPicture_serialize_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    SkCanvas* pictureCanvas = recorder.beginRecording({0, 0, 256, 256});\n    SkPaint paint;\n    pictureCanvas->drawRect(SkRect::MakeWH(200, 200), paint);\n    paint.setColor(SK_ColorWHITE);\n    pictureCanvas->drawRect(SkRect::MakeLTRB(20, 20, 180, 180), paint);\n    sk_sp<SkPicture> picture = recorder.finishRecordingAsPicture();\n    SkDynamicMemoryWStream writableStream;\n    picture->serialize(&writableStream);\n    sk_sp<SkData> readableData = writableStream.detachAsData();\n    sk_sp<SkPicture> copy = SkPicture::MakeFromData(readableData->data(), readableData->size());\n    copy->playback(canvas);\n}",
    "width": 256,
    "height": 256,
    "hash": "30b9f1b310187db6aff720a5d67591e2",
    "file": "SkPicture_Reference",
    "name": "SkPicture::serialize_2"
},
    "SkPixmap_erase": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t storage[2];\n    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);\n    SkPixmap pixmap(info, storage, info.minRowBytes());\n    pixmap.erase(SK_ColorBLUE, {0, 0, 1, 1});\n    pixmap.erase(SK_ColorRED, {0, 1, 1, 2});\n    SkBitmap bitmap;\n    canvas->scale(20, 20);\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "a0cdbafed4786788cc90681e7b294234",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::erase()"
},
    "SkPixmap_erase_2": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t storage[2];\n    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);\n    SkPixmap pixmap(info, storage, info.minRowBytes());\n    pixmap.erase(SK_ColorBLUE);\n    SkBitmap bitmap;\n    canvas->scale(20, 20);\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "838202e0d49cad2eb3eeb495834f6d63",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::erase_2"
},
    "SkPixmap_erase_3": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t storage[2];\n    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);\n    SkPixmap pixmap(info, storage, info.minRowBytes());\n    SkIRect topPixelBounds = {0, 0, 1, 1};\n    pixmap.erase({ 0.65f, 0.45f, 0.25f, 1 }, &topPixelBounds);\n    SkIRect bottomPixelBounds = {0, 1, 1, 2};\n    pixmap.erase({ 0.25f, 0.65f, 0.45f, 1 }, &bottomPixelBounds);\n    SkBitmap bitmap;\n    canvas->scale(20, 20);\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "f884f3f46a565f052a5e252ae2f36e9b",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::erase_3"
},
    "SkPixmap_extractSubset": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    pixels.resize(image->height() * image->width() * 4);\n    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,\n            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n    image->readPixels(pixmap, 0, 0);\n    SkPixmap inset;\n    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {\n        SkBitmap bitmap;\n        bitmap.installPixels(inset);\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "febdbfac6cf4cde69837643be2e1f6dd",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::extractSubset"
},
    "SkPixmap_readPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    const int width = 256;\n    const int height = 64;\n    pixels.resize(height * width * 4);\n    SkImageInfo srcInfo = SkImageInfo::MakeN32Premul(width, height);\n    SkPixmap srcPixmap(srcInfo, (const void*) &pixels.front(), width * 4);\n    SkColor  gradColors[] = { 0xFFAA3300, 0x7F881122 };\n    SkPoint  gradPoints[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,\n                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));\n    SkBitmap bitmap;\n    bitmap.installPixels(srcPixmap);\n    SkCanvas srcCanvas(bitmap);\n    srcCanvas.drawRect(SkRect::MakeWH(width, height), paint);\n    canvas->drawBitmap(bitmap, 0, 0);\n    std::vector<int32_t> dstPixels;\n    dstPixels.resize(height * width * 2);\n    SkImageInfo dstInfo = srcInfo.makeColorType(kARGB_4444_SkColorType);\n    srcPixmap.readPixels(dstInfo, &dstPixels.front(), width * 2);\n    SkPixmap dstPixmap(dstInfo, &dstPixels.front(), width * 2);\n    bitmap.installPixels(dstPixmap);\n    canvas->drawBitmap(bitmap, 0, 128);\n}",
    "width": 256,
    "height": 128,
    "hash": "df4e355c4845350daede833b4fd21ec1",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::readPixels"
},
    "SkPixmap_readPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());\n    std::vector<int32_t> srcPixels;\n    const int rowBytes = image->width() * 4;\n    srcPixels.resize(image->height() * rowBytes);\n    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);\n    image->readPixels(pixmap, 0, 0);\n    for (int offset : { 32, 64, 96 } ) {\n        std::vector<int32_t> dstPixels;\n        dstPixels.resize(image->height() * rowBytes);\n        pixmap.readPixels(info, &dstPixels.front(), rowBytes, offset, 0);\n        SkBitmap bitmap;\n        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);\n        bitmap.installPixels(dstmap);\n        canvas->translate(32, 32);\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "094ca0bd37588cc7be241bb387a3e17b",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::readPixels_2"
},
    "SkPixmap_readPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());\n    std::vector<int32_t> srcPixels;\n    const int rowBytes = image->width() * 4;\n    srcPixels.resize(image->height() * rowBytes);\n    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);\n    image->readPixels(pixmap, 0, 0);\n    for (int offset : { 32, 64, 96 } ) {\n        std::vector<int32_t> dstPixels;\n        dstPixels.resize(image->height() * rowBytes);\n        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);\n        pixmap.readPixels(dstmap, offset, 0);\n        SkBitmap bitmap;\n        bitmap.installPixels(dstmap);\n        canvas->translate(32, 32);\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "6ec7f7b2cc163cd29f627eef6d4b061c",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::readPixels_3"
},
    "SkPixmap_readPixels_4": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());\n    std::vector<int32_t> srcPixels;\n    const int rowBytes = image->width() * 4;\n    srcPixels.resize(image->height() * rowBytes);\n    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);\n    image->readPixels(pixmap, 0, 0);\n    for (int index = 0; index < 3; ++index ) {\n        std::vector<int32_t> dstPixels;\n        dstPixels.resize(image->height() * rowBytes);\n        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);\n        pixmap.readPixels(dstmap);\n        SkBitmap bitmap;\n        bitmap.installPixels(dstmap);\n        canvas->translate(32, 32);\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "e18549b5ee1039cb61b0bb38c2104fc9",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::readPixels_4"
},
    "SkPixmap_reset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    pixels.resize(image->height() * image->width() * 4);\n    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,\n            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n    image->readPixels(pixmap, 0, 0);\n    int x = 0;\n    for (auto colorType : { kRGBA_8888_SkColorType, kBGRA_8888_SkColorType } ) {\n        pixmap.reset(SkImageInfo::Make(image->width(), image->height(), colorType,\n                image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n        SkBitmap bitmap;\n        bitmap.installPixels(pixmap);\n        canvas->drawBitmap(bitmap, x, 0);\n        x += 128;\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "9a392b753167cfa849cebeefd5a6e07d",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::reset_2"
},
    "SkPixmap_scalePixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());\n    std::vector<int32_t> srcPixels;\n    int rowBytes = image->width() * 4;\n    srcPixels.resize(image->height() * rowBytes);\n    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);\n    image->readPixels(pixmap, 0, 0);\n    for (int offset : { 32, 64, 96 } ) {\n        info = SkImageInfo::MakeN32Premul(image->width() + offset, image->height());\n        rowBytes = info.width() * 4;\n        std::vector<int32_t> dstPixels;\n        dstPixels.resize(image->height() * rowBytes);\n        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);\n        pixmap.scalePixels(dstmap, kMedium_SkFilterQuality);\n        SkBitmap bitmap;\n        bitmap.installPixels(dstmap);\n        canvas->translate(32, 32);\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8e3c8a9c1d0d2e9b8bf66e24d274f792",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::scalePixels"
},
    "SkPixmap_writable_addr16": {
    "code": "void draw(SkCanvas* canvas) {\n    uint16_t storage[][5] = {{ 0xCABF, 0xDABE, 0xCA9D, 0xC96C, 0xA39B },\n                             { 0xACEE, 0xA87C, 0x893A, 0x4779, 0x8708 },\n                             { 0x4B7C, 0x255B, 0x2559, 0x2557, 0x4656 },\n                             { 0x9099, 0x8128, 0x2557, 0x4124, 0x3323 },\n                             { 0x7547, 0x5505, 0x4434, 0x2012, 0x0000 }};\n    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kARGB_4444_SkColorType, kPremul_SkAlphaType);\n    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->scale(10, 10);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *pixmap.writable_addr16(2, 2) = 0x000F;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 10, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "6da54774f6432b46b47ea9013c15f280",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr16"
},
    "SkPixmap_writable_addr32": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    pixels.resize(image->height() * image->width() * 4);\n    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,\n            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n    image->readPixels(pixmap, 0, 0);\n    for (int y = 0; y < pixmap.height() / 2; ++y) {\n        for (int x = 0; x < pixmap.width(); ++x) {\n            if ((x & 4) == (y & 4)) {\n                *pixmap.writable_addr32(x, y) =\n                        *pixmap.writable_addr32(pixmap.width() - x, pixmap.height() - y);\n            }\n        }\n    }\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 72,
    "hash": "086866243bf9e4c14c3b215a2aa69ad9",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr32"
},
    "SkPixmap_writable_addr64": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::Make(3, 3, kRGBA_F16_SkColorType, kPremul_SkAlphaType);\n    uint64_t storage[9];\n    SkPixmap pixmap(info, storage, 3 * sizeof(uint64_t));\n    SkColor4f c4 { 1, 0.45f, 0.25f, 0.65f };\n    pixmap.erase(c4);\n    SkBitmap bitmap;\n    canvas->scale(10, 10);\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *pixmap.writable_addr64(1, 1) |= 0x00ff000000000000LL;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 10, 0);\n}",
    "width": 256,
    "height": 40,
    "hash": "de14d8d30e4a7b6462103d0e0dd96b0b",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr64"
},
    "SkPixmap_writable_addr8": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t storage[][5] = {{ 0,   0,  64,   0,  0},\n                            { 0, 128, 255, 128,  0},\n                            {64, 255, 255, 255, 64},\n                            { 0, 128, 255, 128,  0},\n                            { 0,   0,  64,   0,  0}};\n    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kPremul_SkAlphaType);\n    SkPixmap pixmap(imageInfo, storage[0], 5);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->scale(10, 10);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *pixmap.writable_addr8(2, 2) = 0;\n//  bitmap.installPixels(pixmap);      // uncomment to fix on GPU\n    canvas->drawBitmap(bitmap, 10, 0);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "809284db136748208b3efc31cd89de29",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr8"
},
    "SkPixmap_writable_addrF16": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::Make(1, 2, kRGBA_F16_SkColorType, kPremul_SkAlphaType);\n    uint16_t storage[2][4];\n    SkPixmap pixmap(info, storage[0], sizeof(uint64_t));\n    SkIRect topPixelBounds = {0, 0, 1, 1};\n    pixmap.erase({ 0.65f, 0.45f, 0.25f, 1 }, &topPixelBounds);\n    SkIRect bottomPixelBounds = {0, 1, 1, 2};\n    pixmap.erase({ 0.25f, 0.65f, 0.45f, 1 }, &bottomPixelBounds);\n    SkBitmap bitmap;\n    canvas->scale(20, 20);\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n    uint16_t* pixel2 = pixmap.writable_addrF16(0, 1);\n    for (int i = 0; i < 4; ++i) {\n        pixel2[i] = storage[0][i];\n    }\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 4, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "7822d78f5cacf5c04267cbbc6c6d0b80",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addrF16"
},
    "SkPoint_CrossProduct": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkVector vectors[][2] = {{{50, 2}, {-14, 20}}, {{0, 50}, {-50, 0}}, {{-20, 25}, {25, -20}},\n                             {{-20, -24}, {-24, -20}}};\n    SkPoint center[] = {{32, 32}, {160, 32}, {32, 160}, {160, 160}};\n    paint.setStrokeWidth(2);\n    for (size_t i = 0; i < 4; ++i) {\n        paint.setColor(SK_ColorRED);\n        canvas->drawLine(center[i], center[i] + vectors[i][0], paint);\n        paint.setColor(SK_ColorBLUE);\n        canvas->drawLine(center[i], center[i] + vectors[i][1], paint);\n        SkString str;\n        SkScalar cross = SkPoint::CrossProduct(vectors[i][1], vectors[i][0]);\n        str.printf(\"cross = %g\", cross);\n        paint.setColor(cross >= 0 ? SK_ColorRED : SK_ColorBLUE);\n        canvas->drawString(str, center[i].fX, center[i].fY, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "8b8a4cd8a29d22bb9c5e63b70357bd65",
    "file": "SkPoint_Reference",
    "name": "SkPoint::CrossProduct"
},
    "SkPoint_Distance": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint lines[][2] = {{{-10, -10}, {90, 30}}, {{0, 0}, {150, 30}}, {{10, 25}, {120, 150}}};\n    const SkPoint origin = {30, 160};\n    for (auto line : lines) {\n        SkPoint a = origin + line[0];\n        const SkPoint& b = line[1];\n        canvas->drawLine(a, b, paint);\n        SkAutoCanvasRestore acr(canvas, true);\n        SkScalar angle = SkScalarATan2((b.fY - a.fY), b.fX - a.fX);\n        canvas->rotate(angle * 180 / SK_ScalarPI, a.fX, a.fY);\n        SkString distance(\"distance = \");\n        distance.appendScalar(SkPoint::Distance(a, b));\n        canvas->drawString(distance, a.fX + 25, a.fY - 4, paint);\n    }\n}",
    "width": 256,
    "height": 192,
    "hash": "9e0a2de2eb94dba4521d733e73f2bda5",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Distance"
},
    "SkPoint_DotProduct": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkVector vectors[][2] = {{{50, 2}, {-14, 20}}, {{0, 50}, {-50, 0}}, {{-20, 25}, {25, -20}},\n                             {{-20, -24}, {-24, -20}}};\n    SkPoint center[] = {{32, 32}, {160, 32}, {32, 160}, {160, 160}};\n    paint.setStrokeWidth(2);\n    for (size_t i = 0; i < 4; ++i) {\n        canvas->drawLine(center[i], center[i] + vectors[i][0], paint);\n        canvas->drawLine(center[i], center[i] + vectors[i][1], paint);\n        SkString str;\n        str.printf(\"dot = %g\", SkPoint::DotProduct(vectors[i][0], vectors[i][1]));\n        canvas->drawString(str, center[i].fX, center[i].fY, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "496db0131a003162faba7d7f98b30340",
    "file": "SkPoint_Reference",
    "name": "SkPoint::DotProduct"
},
    "SkPoint_Length": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 90, 30 }, { 120, 150 }, { 150, 30 }, { 210, 90 } };\n    const SkPoint origin = {30, 140};\n    for (auto point : points) {\n        canvas->drawLine(origin, point, paint);\n        SkAutoCanvasRestore acr(canvas, true);\n        SkScalar angle = SkScalarATan2((point.fY - origin.fY), point.fX - origin.fX);\n        canvas->rotate(angle * 180 / SK_ScalarPI, origin.fX, origin.fY);\n        SkString length(\"length = \");\n        length.appendScalar(SkPoint::Length(point.fX, point.fY));\n        canvas->drawString(length, origin.fX + 25, origin.fY - 4, paint);\n    }\n}",
    "width": 256,
    "height": 192,
    "hash": "c98773d8b4509969d78cb8121e4b77f6",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Length"
},
    "SkPoint_Normalize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint lines[][2] = { {{  30, 110 }, { 190,  30 }},\n                                 {{  30, 220 }, { 120, 140 }}};\n    for (auto line : lines) {\n        canvas->drawLine(line[0], line[1], paint);\n        SkVector vector = line[1] - line[0];\n        SkScalar priorLength = SkPoint::Normalize(&vector);\n        SkVector rotate90 = { -vector.fY, vector.fX };\n        rotate90 *= 10.f;\n        canvas->drawLine(line[0] - rotate90, line[0] + rotate90, paint);\n        canvas->drawLine(line[1] - rotate90, line[1] + rotate90, paint);\n        SkString length(\"length = \");\n        length.appendScalar(priorLength);\n        canvas->drawString(length, line[0].fX + 25, line[0].fY - 4, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "60a08f3ce75374fc815384616d114df7",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Normalize"
},
    "SkPoint_Offset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    SkPoint::Offset(points, SK_ARRAY_COUNT(points), { 1, 9 } );\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "f0f24726df78a5d797bcf311e694a0a3",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Offset"
},
    "SkPoint_Offset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    SkPoint::Offset(points, SK_ARRAY_COUNT(points), 1, 9);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "532849faa838de885b86d3ebffae3712",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Offset_2"
},
    "SkPoint_add_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    SkVector mod = {1, 1};\n    for (auto& point : points) {\n        point = point + mod;\n        mod.fX *= 1.1f;\n        mod.fY += .2f;\n    }\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "911a84253dfec4dabf94dbe3c71766f0",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator+(const SkPoint& a, const SkVector& b)"
},
    "SkPoint_addto_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    points[1] += {1, 1};\n    points[2] += {-1, -1};\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "8b4e79109e2381345258cb744881b20c",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator+=(const SkVector& v)"
},
    "SkPoint_cross": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkVector vectors[][2] = {{{50, 2}, {-14, 20}}, {{0, 50}, {-50, 0}}, {{-20, 25}, {25, -20}},\n                             {{-20, -24}, {-24, -20}}};\n    SkPoint center[] = {{32, 32}, {160, 32}, {32, 160}, {160, 160}};\n    paint.setStrokeWidth(2);\n    for (size_t i = 0; i < 4; ++i) {\n        paint.setColor(SK_ColorRED);\n        canvas->drawLine(center[i], center[i] + vectors[i][0], paint);\n        paint.setColor(SK_ColorBLUE);\n        canvas->drawLine(center[i], center[i] + vectors[i][1], paint);\n        SkString str;\n        SkScalar cross = vectors[i][0].cross(vectors[i][1]);\n        str.printf(\"cross = %g\", cross);\n        paint.setColor(cross >= 0 ? SK_ColorRED : SK_ColorBLUE);\n        canvas->drawString(str, center[i].fX, center[i].fY, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "0bc7b3997357e499817278b78bdfbf1d",
    "file": "SkPoint_Reference",
    "name": "SkPoint::cross()"
},
    "SkPoint_distanceToOrigin": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 60, -110 }, { 90, 10 }, { 120, -110 }, { 180, -50 } };\n    const SkPoint origin = {0, 0};\n    canvas->translate(30, 140);\n    for (auto point : points) {\n        canvas->drawLine(origin, point, paint);\n        SkAutoCanvasRestore acr(canvas, true);\n        SkScalar angle = SkScalarATan2((point.fY - origin.fY), point.fX - origin.fX);\n        canvas->rotate(angle * 180 / SK_ScalarPI, origin.fX, origin.fY);\n        SkString distance(\"distance = \");\n        distance.appendScalar(point.distanceToOrigin());\n        canvas->drawString(distance, origin.fX + 25, origin.fY - 4, paint);\n    }\n}",
    "width": 256,
    "height": 192,
    "hash": "812cf26d91b1cdcd2c6b9438a8172518",
    "file": "SkPoint_Reference",
    "name": "SkPoint::distanceToOrigin"
},
    "SkPoint_dot": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkVector vectors[][2] = {{{50, 2}, {-14, 20}}, {{0, 50}, {-50, 0}}, {{-20, 25}, {25, -20}},\n                             {{-20, -24}, {-24, -20}}};\n    SkPoint center[] = {{32, 32}, {160, 32}, {32, 160}, {160, 160}};\n    paint.setStrokeWidth(2);\n    for (size_t i = 0; i < 4; ++i) {\n        canvas->drawLine(center[i], center[i] + vectors[i][0], paint);\n        canvas->drawLine(center[i], center[i] + vectors[i][1], paint);\n        SkString str;\n        str.printf(\"dot = %g\", vectors[i][0].dot(vectors[i][1]));\n        canvas->drawString(str, center[i].fX, center[i].fY, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "56d01ccfedd71d3c504b09afa2875d38",
    "file": "SkPoint_Reference",
    "name": "SkPoint::dot()"
},
    "SkPoint_length": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 90, 30 }, { 120, 150 }, { 150, 30 }, { 210, 90 } };\n    const SkPoint origin = {30, 140};\n    for (auto point : points) {\n        canvas->drawLine(origin, point, paint);\n        SkAutoCanvasRestore acr(canvas, true);\n        SkScalar angle = SkScalarATan2((point.fY - origin.fY), point.fX - origin.fX);\n        canvas->rotate(angle * 180 / SK_ScalarPI, origin.fX, origin.fY);\n        SkString length(\"length = \");\n        length.appendScalar(point.length());\n        canvas->drawString(length, origin.fX + 25, origin.fY - 4, paint);\n    }\n}",
    "width": 256,
    "height": 192,
    "hash": "8363ab179447ee4b827679e20d3d81eb",
    "file": "SkPoint_Reference",
    "name": "SkPoint::length()"
},
    "SkPoint_multiply_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(15, 10);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    for (auto& point : points) {\n        point = point * 1.5f;\n    }\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "35b3bc675779de043706ae4817ee950c",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator*(SkScalar scale) const"
},
    "SkPoint_multiplyby_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(15, 10);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    for (auto& point : points) {\n        point *= 2;\n    }\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "3ce3db36235d80dbac4d39504cf756da",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator*=(SkScalar scale)"
},
    "SkPoint_normalize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint lines[][2] = { {{  30, 110 }, { 190,  30 }},\n                                 {{ 120, 140 }, {  30, 220 }}};\n    for (auto line : lines) {\n        canvas->drawLine(line[0], line[1], paint);\n        SkVector vector = line[1] - line[0];\n        if (vector.normalize()) {\n            SkVector rotate90 = { -vector.fY, vector.fX };\n            rotate90 *= 10.f;\n            canvas->drawLine(line[0] - rotate90, line[0] + rotate90, paint);\n            canvas->drawLine(line[1] - rotate90, line[1] + rotate90, paint);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "d84fce292d86c7d9ef37ae2d179c03c7",
    "file": "SkPoint_Reference",
    "name": "SkPoint::normalize()"
},
    "SkPoint_offset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    points[1].offset(1, 1);\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "02750ceaa874f956e6e6544ef6b858ee",
    "file": "SkPoint_Reference",
    "name": "SkPoint::offset()"
},
    "SkPoint_scale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint point = {40, -15}, scaled;\n    SkPoint origin = {30, 110};\n    for (auto scale : {1, 2, 3, 5}) {\n        paint.setStrokeWidth(scale * 5);\n        paint.setARGB(0x7f, 0x9f, 0xbf, 0x33 * scale);\n        point.scale(scale, &scaled);\n        canvas->drawLine(origin, origin + scaled, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "972e4e230806281adb928e068bcd8551",
    "file": "SkPoint_Reference",
    "name": "SkPoint::scale()"
},
    "SkPoint_scale_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint point = {40, -15};\n    SkPoint origin = {30, 110};\n    for (auto scale : {1, 2, 3, 5}) {\n        paint.setStrokeWidth(scale * 5);\n        paint.setARGB(0x7f, 0x9f, 0xbf, 0x33 * scale);\n        point.scale(scale);\n        canvas->drawLine(origin, origin + point, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "1060a4f27d8ef29519e6ac006ce90f2b",
    "file": "SkPoint_Reference",
    "name": "SkPoint::scale_2"
},
    "SkPoint_setLength": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 60, -110 }, { 90, 10 }, { 120, -110 }, { 180, -50 } };\n    const SkPoint origin = {0, 0};\n    canvas->translate(30, 140);\n    for (auto point : points) {\n        paint.setStrokeWidth(1);\n        paint.setColor(SK_ColorBLACK);\n        canvas->drawLine(origin, point, paint);\n        SkVector normal = point;\n        normal.setLength(100);\n        paint.setStrokeWidth(10);\n        paint.setColor(0x3f45bf12);\n        canvas->drawLine(origin, normal, paint);\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "cbe7db206ece825aa3b9b7c3256aeaf0",
    "file": "SkPoint_Reference",
    "name": "SkPoint::setLength"
},
    "SkPoint_setLength_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 60, -110 }, { 90, 10 }, { 120, -110 }, { 180, -50 } };\n    const SkPoint origin = {0, 0};\n    canvas->translate(30, 140);\n    for (auto point : points) {\n        paint.setStrokeWidth(1);\n        paint.setColor(SK_ColorBLACK);\n        canvas->drawLine(origin, point, paint);\n        SkVector normal;\n        normal.setLength(point.fX, point.fY, 100);\n        paint.setStrokeWidth(10);\n        paint.setColor(0x3fbf4512);\n        canvas->drawLine(origin, normal, paint);\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "3cc0662b6fbbee1fe3442a0acfece22c",
    "file": "SkPoint_Reference",
    "name": "SkPoint::setLength_2"
},
    "SkPoint_setNormalize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 60, -110 }, { 90, 10 }, { 120, -110 }, { 180, -50 } };\n    const SkPoint origin = {0, 0};\n    canvas->translate(30, 140);\n    for (auto point : points) {\n        paint.setStrokeWidth(1);\n        paint.setColor(SK_ColorBLACK);\n        canvas->drawLine(origin, point, paint);\n        SkVector normal;\n        normal.setNormalize(point.fX, point.fY);\n        normal *= 100;\n        paint.setStrokeWidth(10);\n        paint.setColor(0x3f4512bf);\n        canvas->drawLine(origin, normal, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "3e4f147d143a388802484bf0d26534c2",
    "file": "SkPoint_Reference",
    "name": "SkPoint::setNormalize"
},
    "SkPoint_subtract_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    points[1] += points[0] - points[2];\n    points[2] -= points[3] - points[5];\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "b6c4943ecd0b2dccf9d220b8944009e0",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator-(const SkPoint& a, const SkPoint& b)"
},
    "SkPoint_subtractfrom_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    points[1] -= {1, 1};\n    points[2] -= {-1, -1};\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "86c0399704d8dff4091bf87b8d87d40b",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator-=(const SkVector& v)"
},
    "SkPreMultiplyARGB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPMColor premultiplied = SkPreMultiplyARGB(160, 128, 160, 192);\n    canvas->drawString(\"Unpremultiplied:\", 20, 20, SkPaint());\n    canvas->drawString(\"alpha=160 red=128 green=160 blue=192\", 20, 40, SkPaint());\n    canvas->drawString(\"Premultiplied:\", 20, 80, SkPaint());\n    std::string str = \"alpha=\" + std::to_string(SkColorGetA(premultiplied));\n    str += \" red=\" + std::to_string(SkColorGetR(premultiplied));\n    str += \" green=\" + std::to_string(SkColorGetG(premultiplied));\n    str += \" blue=\" + std::to_string(SkColorGetB(premultiplied));\n    canvas->drawString(str.c_str(), 20, 100, SkPaint());\n}",
    "width": 300,
    "height": 128,
    "hash": "756345484fd48ca0ea7b6cec350f73b8",
    "file": "SkColor_Reference",
    "name": "SkPreMultiplyARGB"
},
    "SkPreMultiplyColor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor unpremultiplied = SkColorSetARGB(160, 128, 160, 192);\n    SkPMColor premultiplied = SkPreMultiplyColor(unpremultiplied);\n    canvas->drawString(\"Unpremultiplied:\", 20, 20, SkPaint());\n    std::string str = \"alpha=\" + std::to_string(SkColorGetA(unpremultiplied));\n    str += \" red=\" + std::to_string(SkColorGetR(unpremultiplied));\n    str += \" green=\" + std::to_string(SkColorGetG(unpremultiplied));\n    str += \" blue=\" + std::to_string(SkColorGetB(unpremultiplied));\n    canvas->drawString(str.c_str(), 20, 40, SkPaint());\n    canvas->drawString(\"Premultiplied:\", 20, 80, SkPaint());\n    str = \"alpha=\" + std::to_string(SkColorGetA(premultiplied));\n    str += \" red=\" + std::to_string(SkColorGetR(premultiplied));\n    str += \" green=\" + std::to_string(SkColorGetG(premultiplied));\n    str += \" blue=\" + std::to_string(SkColorGetB(premultiplied));\n    canvas->drawString(str.c_str(), 20, 100, SkPaint());\n}",
    "width": 300,
    "height": 128,
    "hash": "0bcc0f86a2aefc899f3500503dce6968",
    "file": "SkColor_Reference",
    "name": "SkPreMultiplyColor"
},
    "SkRGBToHSV": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawBitmap(source, 0, 0);\n    SkPaint bgPaint;\n    bgPaint.setColor(0xafffffff);\n    canvas->drawRect({20, 30, 110, 90}, bgPaint);\n    SkScalar hsv[3];\n    SkColor c = source.getColor(226, 128);\n    SkRGBToHSV(SkColorGetR(c), SkColorGetG(c), SkColorGetB(c), hsv);\n    canvas->drawString((\"h: \" + std::to_string(hsv[0]).substr(0, 6)).c_str(), 27, 45, SkPaint());\n    canvas->drawString((\"s: \" + std::to_string(hsv[1]).substr(0, 6)).c_str(), 27, 65, SkPaint());\n    canvas->drawString((\"v: \" + std::to_string(hsv[2]).substr(0, 6)).c_str(), 27, 85, SkPaint());\n    canvas->drawLine(110, 90, 226, 128, SkPaint());\n}",
    "width": 256,
    "height": 256,
    "hash": "4fb2da4a3d9b14ca4ac24eefb0f5126a",
    "file": "SkColor_Reference",
    "name": "SkRGBToHSV"
},
    "SkRRect_Corner": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRRect rrect;\n    SkVector corners[] = {{25, 17}, {17, 19}, {19, 15}, {15, 15}};\n    rrect.setRectRadii({30, 10, 100, 60}, corners);\n    canvas->drawRRect(rrect, paint);\n    paint.setColor(SK_ColorWHITE);\n    const SkRect r = rrect.getBounds();\n    canvas->drawLine(r.fLeft, r.fTop + rrect.radii(SkRRect::kUpperLeft_Corner).fY,\n                     r.fRight, r.fTop + rrect.radii(SkRRect::kUpperRight_Corner).fY, paint);\n    canvas->drawLine(r.fLeft, r.fBottom - rrect.radii(SkRRect::kLowerLeft_Corner).fY,\n                     r.fRight, r.fBottom - rrect.radii(SkRRect::kLowerRight_Corner).fY, paint);\n    canvas->drawLine(r.fLeft + rrect.radii(SkRRect::kUpperLeft_Corner).fX, r.fTop,\n                     r.fLeft + rrect.radii(SkRRect::kLowerLeft_Corner).fX, r.fBottom, paint);\n    canvas->drawLine(r.fRight - rrect.radii(SkRRect::kUpperRight_Corner).fX, r.fTop,\n                     r.fRight - rrect.radii(SkRRect::kLowerRight_Corner).fX, r.fBottom, paint);\n}",
    "width": 256,
    "height": 70,
    "hash": "9205393f30b156e1507e88aa27f1dd91",
    "file": "SkRRect_Reference",
    "name": "SkRRect::Corner"
},
    "SkRRect_MakeEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect = SkRRect::MakeEmpty();\n    SkRRect rrect2(rrect);\n    rrect2.inset(-20, -20);\n    SkPaint p;\n    p.setStyle(SkPaint::kStroke_Style);\n    p.setStrokeWidth(10);\n    std::string str(\"Type \");\n    str += SkRRect::kEmpty_Type == rrect2.type() ? \"=\" : \"!\"; \n    str += \"= SkRRect::kEmpty_Type\";\n    canvas->drawString(str.c_str(), 20, 80, SkPaint());\n    canvas->drawRRect(rrect2, p);\n}",
    "width": 256,
    "height": 90,
    "hash": "c6c6be3b3c137226adbb5b5af9203d27",
    "file": "SkRRect_Reference",
    "name": "SkRRect::MakeEmpty"
},
    "SkRRect_MakeOval": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRRect rrect = SkRRect::MakeOval({30, 10, 100, 60});\n    canvas->drawRRect(rrect, paint);\n    rrect.setRect(rrect.getBounds());\n    paint.setColor(SK_ColorBLUE);\n    paint.setBlendMode(SkBlendMode::kDifference);\n    canvas->drawRRect(rrect, paint);\n}",
    "width": 256,
    "height": 70,
    "hash": "0b99ee38fd154f769f6031242e02fa7a",
    "file": "SkRRect_Reference",
    "name": "SkRRect::MakeOval"
},
    "SkRRect_MakeRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});\n    canvas->drawRRect(rrect, paint);\n    rrect.setOval(rrect.getBounds());\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawRRect(rrect, paint);\n}",
    "width": 256,
    "height": 70,
    "hash": "5295b07fe4d2cdcd077979a9e19854d9",
    "file": "SkRRect_Reference",
    "name": "SkRRect::MakeRect"
},
    "SkRRect_MakeRectXY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 20, 20);\n    canvas->drawRRect(rrect, paint);\n    rrect.setRect(rrect.getBounds());\n    paint.setColor(SK_ColorBLUE);\n    paint.setBlendMode(SkBlendMode::kModulate);\n    canvas->drawRRect(rrect, paint);\n}",
    "width": 256,
    "height": 70,
    "hash": "2b24a1247637cbc94f8b3c77d37ed3e2",
    "file": "SkRRect_Reference",
    "name": "SkRRect::MakeRectXY"
},
    "SkRRect_Type": {
    "code": "void draw(SkCanvas* canvas) {\n    struct Radii { SkVector data[4]; };\n    auto drawRRectType = [=](const SkRect& rect, const Radii& radii) {\n        SkRRect rrect;\n        rrect.setRectRadii(rect, radii.data);\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        const char* typeStr[] = { \"empty\", \"rect\", \"oval\", \"simple\", \"nine patch\", \"complex\" };\n        canvas->drawString(typeStr[(int) rrect.type()], rect.centerX(), rect.bottom() + 20, paint);\n        paint.setStyle(SkPaint::kStroke_Style);       \n        canvas->drawRRect(rrect, paint);\n    };\n    drawRRectType({ 45,  30,  45,  30}, {{{ 5,  5}, { 5,  5}, { 5,  5}, { 5,  5}}});\n    drawRRectType({ 90,  10, 140,  30}, {{{ 0,  0}, { 0,  0}, { 0,  0}, { 0,  0}}});\n    drawRRectType({160,  10, 210,  30}, {{{25, 10}, {25, 10}, {25, 10}, {25, 10}}});\n    drawRRectType({ 20,  80,  70, 100}, {{{ 5,  5}, { 5,  5}, { 5,  5}, { 5,  5}}});\n    drawRRectType({ 90,  80, 140, 100}, {{{ 5,  5}, {10,  5}, {10,  5}, { 5,  5}}});\n    drawRRectType({160,  80, 210, 100}, {{{ 5,  5}, {10,  5}, { 5,  5}, { 5,  5}}});\n}",
    "width": 256,
    "height": 128,
    "hash": "a4233634c75b72fc7a2815ddb69bd669",
    "file": "SkRRect_Reference",
    "name": "SkRRect::Type"
},
    "SkRRect_contains": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect test = {10, 10, 110, 80};\n    SkRRect rrect = SkRRect::MakeRect(test);\n    SkRRect oval = SkRRect::MakeOval(test);\n    test.inset(10, 10);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawString(rrect.contains(test) ? \"contains\" : \"does not contain\", 55, 100, paint);\n    canvas->drawString(oval.contains(test) ? \"contains\" : \"does not contain\", 185, 100, paint);    \n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawRect(test, paint);\n    canvas->translate(120, 0);\n    canvas->drawRRect(oval, paint);\n    canvas->drawRect(test, paint);\n}",
    "width": 256,
    "height": 110,
    "hash": "0bb057140e4119234bdd2e8dd2f0fa19",
    "file": "SkRRect_Reference",
    "name": "SkRRect::contains()"
},
    "SkRRect_copy_const_SkRRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect = SkRRect::MakeRect({10, 10, 100, 50});\n    SkRRect rrect2(rrect);\n    rrect2.inset(20, 20);\n    SkPaint p;\n    p.setStyle(SkPaint::kStroke_Style);\n    p.setStrokeWidth(10);\n    canvas->drawRRect(rrect, p);\n    canvas->drawRRect(rrect2, p);\n}",
    "width": 256,
    "height": 60,
    "hash": "ad8f5d49edfcee60eddfe2a955b6c5f5",
    "file": "SkRRect_Reference",
    "name": "SkRRect::SkRRect(const SkRRect& rrect)"
},
    "SkRRect_copy_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect = SkRRect::MakeRect({40, 40, 100, 70});\n    SkRRect rrect2 = rrect;\n    rrect2.inset(-20, -20);\n    SkPaint p;\n    p.setStyle(SkPaint::kStroke_Style);\n    p.setStrokeWidth(10);\n    canvas->drawRRect(rrect, p);\n    canvas->drawRRect(rrect2, p);\n}",
    "width": 256,
    "height": 110,
    "hash": "52926c98c1cca00606d3ea99f23fea3d",
    "file": "SkRRect_Reference",
    "name": "SkRRect::operator=(const SkRRect& rrect)"
},
    "SkRRect_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect;\n    SkPaint p;\n    p.setStyle(SkPaint::kStroke_Style);\n    p.setStrokeWidth(10);\n    canvas->drawRRect(rrect, p);\n    rrect.setRect({10, 10, 100, 50});\n    canvas->drawRRect(rrect, p);\n}",
    "width": 256,
    "height": 60,
    "hash": "471e7aad0feaf9ec3a21757a317a64f5",
    "file": "SkRRect_Reference",
    "name": "SkRRect::SkRRect()"
},
    "SkRRect_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect1 = SkRRect::MakeRectXY({10, 20, 60, 220}, 50, 200);\n    SkRRect rrect2 = SkRRect::MakeRectXY(rrect1.rect(), 25, 100);\n    SkRRect rrect3 = SkRRect::MakeOval(rrect1.rect());\n    canvas->drawRRect(rrect1, SkPaint());\n    std::string str = \"rrect1 \" + std::string(rrect1 == rrect2 ? \"=\" : \"!\") + \"= rrect2\";\n    canvas->drawString(str.c_str(), 10, 240, SkPaint());\n    canvas->translate(70, 0);\n    canvas->drawRRect(rrect2, SkPaint());\n    canvas->translate(70, 0);\n    canvas->drawRRect(rrect3, SkPaint());\n    str = \"rrect2 \" + std::string(rrect2 == rrect3 ? \"=\" : \"!\") + \"= rrect3\";\n    canvas->drawString(str.c_str(), -20, 240, SkPaint());\n}",
    "width": 256,
    "height": 256,
    "hash": "df181af37f1d2b06f0f45af73df7b47d",
    "file": "SkRRect_Reference",
    "name": "SkRRect::operator==(const SkRRect& a, const SkRRect& b)"
},
    "SkRRect_getBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRRect rrect = SkRRect::MakeRectXY({20, 20, 220, 100}, 15, 15);\n    canvas->drawRRect(rrect, paint);\n    paint.setColor(SK_ColorWHITE);\n    rrect = SkRRect::MakeOval(rrect.getBounds());\n    canvas->drawRRect(rrect, paint);\n}",
    "width": 256,
    "height": 120,
    "hash": "4577e2dcb086b241bb43d8b89ee0b0dd",
    "file": "SkRRect_Reference",
    "name": "SkRRect::getBounds"
},
    "SkRRect_getSimpleRadii": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawDetails = [=](const SkRRect& rrect) {\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        paint.setTextSize(12);\n        canvas->drawRRect(rrect, paint);\n        SkVector corner = rrect.getSimpleRadii();\n        std::string label = \"corner: \" + std::to_string(corner.fX).substr(0, 3) + \", \" +\n                        std::to_string(corner.fY).substr(0, 3);\n        canvas->drawString(label.c_str(), 64, 90, paint);\n        canvas->translate(128, 0);\n    };\n    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});\n    drawDetails(rrect);\n    rrect.setRectXY(rrect.getBounds(), 5, 8);\n    drawDetails(rrect);\n}",
    "width": 256,
    "height": 100,
    "hash": "81345f7619a072bb2b0cf59810fe86d0",
    "file": "SkRRect_Reference",
    "name": "SkRRect::getSimpleRadii"
},
    "SkRRect_getType": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect = SkRRect::MakeRect({10, 10, 100, 50});\n    SkRRect rrect2(rrect);\n    rrect2.inset(20, 20);\n    SkPaint p;\n    p.setStyle(SkPaint::kStroke_Style);\n    p.setStrokeWidth(10);\n    std::string str(\"Type \");\n    str += SkRRect::kRect_Type == rrect2.getType() ? \"=\" : \"!\"; \n    str += \"= SkRRect::kRect_Type\";\n    canvas->drawString(str.c_str(), 20, 80, SkPaint());\n    canvas->drawRRect(rrect2, p);\n}",
    "width": 256,
    "height": 100,
    "hash": "ace8f4aebf90527d43e4b7291375c9ad",
    "file": "SkRRect_Reference",
    "name": "SkRRect::getType"
},
    "SkRRect_inset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);\n    for (int index = 0; index < 25; ++index) {\n       canvas->drawRRect(rrect, paint);\n       rrect.inset(-3, 3, &rrect);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "f02f0110d5605dac6d14dcb8d1d8cb6e",
    "file": "SkRRect_Reference",
    "name": "SkRRect::inset()"
},
    "SkRRect_inset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkRRect rrect = SkRRect::MakeRectXY({10, 20, 180, 220}, 50, 100);\n    for (int index = 0; index < 25; ++index) {\n       canvas->drawRRect(rrect, paint);\n       rrect.inset(3, 3);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "da61054322550a2d5ac15114da23bd23",
    "file": "SkRRect_Reference",
    "name": "SkRRect::inset_2"
},
    "SkRRect_isComplex": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(16);\n    SkVector radii[] = {{25, 30}, {40, 30}, {40, 30}, {20, 30}};\n    SkRRect rrect;\n    rrect.setRectRadii({30, 10, 100, 60}, radii);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isComplex() ? \"complex\" : \"not complex\", 64, 90, paint);\n    radii[0].fX = 20;\n    rrect.setRectRadii(rrect.getBounds(), radii);\n    canvas->translate(128, 0);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isComplex() ? \"complex\" : \"not complex\", 64, 90, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "b62c183dc435d1fc091111fb2f3c3f8e",
    "file": "SkRRect_Reference",
    "name": "SkRRect::isComplex"
},
    "SkRRect_isEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(16);\n    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 10, 5);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isEmpty() ? \"empty\" : \"not empty\", 64, 90, paint);\n    rrect.inset(40, 0);\n    canvas->translate(128, 0);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isEmpty() ? \"empty\" : \"not empty\", 64, 90, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "099d79ecfbdfb0a19c10deb7201859c3",
    "file": "SkRRect_Reference",
    "name": "SkRRect::isEmpty"
},
    "SkRRect_isNinePatch": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(16);\n    SkVector radii[] = {{20, 30}, {40, 30}, {40, 30}, {20, 30}};\n    SkRRect rrect;\n    rrect.setRectRadii({30, 10, 100, 60}, radii);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isNinePatch() ? \"9 patch\" : \"not 9 patch\", 64, 90, paint);\n    radii[0].fX = 35;\n    rrect.setRectRadii(rrect.getBounds(), radii);\n    canvas->translate(128, 0);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isNinePatch() ? \"9 patch\" : \"not 9 patch\", 64, 90, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "429f6dfd4cf6287df3c3c77fa7681c99",
    "file": "SkRRect_Reference",
    "name": "SkRRect::isNinePatch"
},
    "SkRRect_isOval": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(16);\n    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 40, 30);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isOval() ? \"oval\" : \"not oval\", 64, 90, paint);\n    rrect.setRectXY(rrect.getBounds(), 35, 25);\n    canvas->translate(128, 0);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isOval() ? \"oval\" : \"not oval\", 64, 90, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "4dfdb28d8343958425f2c1323fe8170d",
    "file": "SkRRect_Reference",
    "name": "SkRRect::isOval"
},
    "SkRRect_isRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(16);\n    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isRect() ? \"rect\" : \"not rect\", 64, 90, paint);\n    SkVector radii[] = {{10, 10}, {0, 0}, {0, 0}, {0, 0}};\n    rrect.setRectRadii(rrect.getBounds(), radii);\n    canvas->translate(128, 0);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isRect() ? \"rect\" : \"not rect\", 64, 90, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "bc931c9a6eb8ffe7ea8d3fb47e07a475",
    "file": "SkRRect_Reference",
    "name": "SkRRect::isRect"
},
    "SkRRect_isSimple": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(16);\n    SkVector radii[] = {{40, 30}, {40, 30}, {40, 30}, {40, 30}};\n    SkRRect rrect;\n    rrect.setRectRadii({30, 10, 100, 60}, radii);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isSimple() ? \"simple\" : \"not simple\", 64, 90, paint);\n    radii[0].fX = 35;\n    rrect.setRectRadii(rrect.getBounds(), radii);\n    canvas->translate(128, 0);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawString(rrect.isSimple() ? \"simple\" : \"not simple\", 64, 90, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "f6959ea422a7c6e98ddfad216a52c707",
    "file": "SkRRect_Reference",
    "name": "SkRRect::isSimple"
},
    "SkRRect_isValid": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect = SkRRect::MakeRect({10, 10, 110, 80});\n    SkRRect corrupt = rrect;\n    *((float*) &corrupt) = 120;\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawString(rrect.isValid() ? \"is valid\" : \"is corrupted\", 55, 100, paint);\n    canvas->drawString(corrupt.isValid() ? \"is valid\" : \"is corrupted\", 185, 100, paint);    \n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRRect(rrect, paint);\n    canvas->translate(120, 0);\n    canvas->drawRRect(corrupt, paint);\n}",
    "width": 256,
    "height": 110,
    "hash": "8cc1f21c98c0416f7724ad218f557a00",
    "file": "SkRRect_Reference",
    "name": "SkRRect::isValid"
},
    "SkRRect_makeOffset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);\n    for (int index = 0; index < 25; ++index) {\n       canvas->drawRRect(rrect, paint);\n       rrect = rrect.makeOffset(-3, 3);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "c433aa41eaf5e419e3349fb970a08151",
    "file": "SkRRect_Reference",
    "name": "SkRRect::makeOffset"
},
    "SkRRect_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect1 = SkRRect::MakeRectXY({10, 20, 60, 220}, 50, 100);\n    SkRRect rrect2 = SkRRect::MakeRectXY(rrect1.rect(), 50, 50);\n    SkRRect rrect3 = SkRRect::MakeOval(rrect1.rect());\n    canvas->drawRRect(rrect1, SkPaint());\n    std::string str = \"rrect1 \" + std::string(rrect1 == rrect2 ? \"=\" : \"!\") + \"= rrect2\";\n    canvas->drawString(str.c_str(), 10, 240, SkPaint());\n    canvas->translate(70, 0);\n    canvas->drawRRect(rrect2, SkPaint());\n    canvas->translate(70, 0);\n    canvas->drawRRect(rrect3, SkPaint());\n    str = \"rrect2 \" + std::string(rrect2 == rrect3 ? \"=\" : \"!\") + \"= rrect3\";\n    canvas->drawString(str.c_str(), -20, 240, SkPaint());\n}",
    "width": 256,
    "height": 256,
    "hash": "505e47b3e6474ebdecdc04c3c2af2c34",
    "file": "SkRRect_Reference",
    "name": "SkRRect::operator!=(const SkRRect& a, const SkRRect& b)"
},
    "SkRRect_offset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);\n    for (int index = 0; index < 25; ++index) {\n       canvas->drawRRect(rrect, paint);\n       rrect.offset(3, 3);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "a45cdd46ef2fe0df62d84d41713e82e2",
    "file": "SkRRect_Reference",
    "name": "SkRRect::offset()"
},
    "SkRRect_outset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);\n    for (int index = 0; index < 25; ++index) {\n       canvas->drawRRect(rrect, paint);\n       rrect.outset(-3, 3, &rrect);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "4d69b6d9c7726c47c42827d79fc7899c",
    "file": "SkRRect_Reference",
    "name": "SkRRect::outset()"
},
    "SkRRect_outset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);\n    for (int index = 0; index < 25; ++index) {\n       canvas->drawRRect(rrect, paint);\n       rrect.outset(3, 3);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "4391cced86653dcd0f84439a5c0bb3f2",
    "file": "SkRRect_Reference",
    "name": "SkRRect::outset_2"
},
    "SkRRect_readFromMemory": {
    "code": "void draw(SkCanvas* canvas) {\n    SkVector radii[] = {{5, 5},  {10, 10}, {15, 15}, {5, 5}};\n    SkRRect rrect;\n    rrect.setRectRadii({10, 10, 110, 80}, radii);\n    char storage[SkRRect::kSizeInMemory];\n    rrect.writeToMemory(storage);\n    SkRRect copy;\n    copy.readFromMemory(storage, sizeof(storage));\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawString(\"rrect\", 55, 100, paint);\n    canvas->drawString(\"copy\", 185, 100, paint);    \n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRRect(rrect, paint);\n    canvas->translate(120, 0);\n    canvas->drawRRect(copy, paint);\n}",
    "width": 256,
    "height": 110,
    "hash": "50969745cf2b23544362f4cff5592b75",
    "file": "SkRRect_Reference",
    "name": "SkRRect::readFromMemory"
},
    "SkRRect_setEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});\n    canvas->drawRRect(rrect, paint);\n    rrect.setEmpty();\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawRRect(rrect, paint);\n}",
    "width": 256,
    "height": 80,
    "hash": "44e9a9c2c5ef1af2a616086ff46a9037",
    "file": "SkRRect_Reference",
    "name": "SkRRect::setEmpty"
},
    "SkRRect_setNinePatch": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRRect rrect;\n    rrect.setNinePatch({30, 10, 100, 60}, 10, 20, 20, 10);\n    canvas->drawRRect(rrect, paint);\n    paint.setColor(SK_ColorWHITE);\n    const SkRect r = rrect.getBounds();\n    canvas->drawLine(r.fLeft, r.fTop + rrect.radii(SkRRect::kUpperLeft_Corner).fY,\n                     r.fRight, r.fTop + rrect.radii(SkRRect::kUpperRight_Corner).fY, paint);\n    canvas->drawLine(r.fLeft, r.fBottom - rrect.radii(SkRRect::kLowerLeft_Corner).fY,\n                     r.fRight, r.fBottom - rrect.radii(SkRRect::kLowerRight_Corner).fY, paint);\n    canvas->drawLine(r.fLeft + rrect.radii(SkRRect::kUpperLeft_Corner).fX, r.fTop,\n                     r.fLeft + rrect.radii(SkRRect::kLowerLeft_Corner).fX, r.fBottom, paint);\n    canvas->drawLine(r.fRight - rrect.radii(SkRRect::kUpperRight_Corner).fX, r.fTop,\n                     r.fRight - rrect.radii(SkRRect::kLowerRight_Corner).fX, r.fBottom, paint);\n}",
    "width": 256,
    "height": 70,
    "hash": "c4620df2eaba447b581688d3100053b1",
    "file": "SkRRect_Reference",
    "name": "SkRRect::setNinePatch"
},
    "SkRRect_setOval": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 20, 20);\n    canvas->drawRRect(rrect, paint);\n    rrect.setOval(rrect.getBounds());\n    paint.setColor(SK_ColorWHITE);\n    paint.setBlendMode(SkBlendMode::kExclusion);\n    canvas->drawRRect(rrect, paint);\n}",
    "width": 256,
    "height": 70,
    "hash": "cf418af29cbab6243ac16aacd1217ffe",
    "file": "SkRRect_Reference",
    "name": "SkRRect::setOval"
},
    "SkRRect_setRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});\n    canvas->drawRRect(rrect, paint);\n    rrect.setRect({60, 30, 120, 80});\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawRRect(rrect, paint);\n}",
    "width": 256,
    "height": 90,
    "hash": "3afc3ac9bebd1d7387822cc608571e82",
    "file": "SkRRect_Reference",
    "name": "SkRRect::setRect"
},
    "SkRRect_setRectRadii": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeCap(SkPaint::kSquare_Cap);\n    paint.setAntiAlias(true);\n    float intervals[] = { 5, 21.75f };\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 0));\n    SkPath path;\n    SkRRect rrect;\n    SkVector corners[] = {{15, 17}, {17, 19}, {19, 15}, {15, 15}};\n    rrect.setRectRadii({20, 20, 100, 100}, corners);\n    path.addRRect(rrect, SkPath::kCW_Direction);\n    canvas->drawPath(path, paint);\n    path.rewind();\n    path.addRRect(rrect, SkPath::kCCW_Direction, 1);\n    canvas->translate(120, 0);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "340d6c51efaa1f7f3d0dcaf8b0e90696",
    "file": "SkRRect_Reference",
    "name": "SkRRect::setRectRadii"
},
    "SkRRect_setRectXY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 20, 20);\n    canvas->drawRRect(rrect, paint);\n    rrect.setRectXY(rrect.getBounds(), 5, 5);\n    paint.setColor(SK_ColorWHITE);\n    paint.setBlendMode(SkBlendMode::kExclusion);\n    canvas->drawRRect(rrect, paint);\n}",
    "width": 256,
    "height": 70,
    "hash": "6ac569e40fb68c758319e85428b9ae95",
    "file": "SkRRect_Reference",
    "name": "SkRRect::setRectXY"
},
    "SkRRect_transform": {
    "code": "void draw(SkCanvas* canvas) {\n    SkVector radii[] = {{5, 5},  {10, 10}, {15, 15}, {5, 5}};\n    SkRRect rrect;\n    rrect.setRectRadii({10, 10, 110, 80}, radii);\n    SkRRect transformed;\n    SkMatrix matrix = SkMatrix::MakeRectToRect(rrect.rect(), {140, 30, 220, 80},\n                                               SkMatrix::kCenter_ScaleToFit);\n    bool success = rrect.transform(matrix, &transformed);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawString(\"rrect\", 55, 100, paint);\n    canvas->drawString(success ? \"transformed\" : \"transform failed\", 185, 100, paint);    \n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRRect(rrect, paint);\n    canvas->drawRRect(transformed, paint);\n}",
    "width": 256,
    "height": 110,
    "hash": "68a5d24f22e2d798608fce8a20e47fd0",
    "file": "SkRRect_Reference",
    "name": "SkRRect::transform()"
},
    "SkRRect_type": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect = SkRRect::MakeRect({10, 10, 100, 50});\n    SkRRect rrect2(rrect);\n    rrect2.inset(20, 20);\n    SkPaint p;\n    p.setStyle(SkPaint::kStroke_Style);\n    p.setStrokeWidth(10);\n    std::string str(\"Type \");\n    str += SkRRect::kEmpty_Type == rrect2.type() ? \"=\" : \"!\"; \n    str += \"= SkRRect::kEmpty_Type\";\n    canvas->drawString(str.c_str(), 20, 80, SkPaint());\n    canvas->drawRRect(rrect2, p);\n}",
    "width": 256,
    "height": 100,
    "hash": "1080805c8449406a4e26d694bc56d2dc",
    "file": "SkRRect_Reference",
    "name": "SkRRect::type()"
},
    "SkRRect_writeToMemory": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRRect rrect = SkRRect::MakeRect({10, 10, 110, 80});\n    char storage[SkRRect::kSizeInMemory];\n    rrect.writeToMemory(storage);\n    SkRRect copy;\n    copy.readFromMemory(storage, sizeof(storage));\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawString(\"rrect\", 55, 100, paint);\n    canvas->drawString(\"copy\", 185, 100, paint);    \n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRRect(rrect, paint);\n    canvas->translate(120, 0);\n    canvas->drawRRect(copy, paint);\n}",
    "width": 256,
    "height": 110,
    "hash": "d6f5a3d21727ddc15e10ef4d5103ff91",
    "file": "SkRRect_Reference",
    "name": "SkRRect::writeToMemory"
},
    "SkRegion_Op": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion operand({35, 35, 85, 85});\n    const char* labels[] = {\"difference\", \"intersect\", \"union\", \"xor\", \"reverse diff\", \"replace\"};\n    int index = 0;\n    SkPaint paint;\n    for (auto op : { SkRegion::kDifference_Op, SkRegion::kIntersect_Op, SkRegion::kUnion_Op,\n                     SkRegion::kXOR_Op, SkRegion::kReverseDifference_Op, SkRegion::kReplace_Op } ) {\n        SkRegion target({10, 10, 60, 60});\n        target.op(operand, op);\n        canvas->drawRegion(target, paint);\n        canvas->drawString(labels[index++], 40, 100, paint);\n        canvas->translate(80, 0);\n        if (SkRegion::kUnion_Op == op) {\n            canvas->translate(-240, 120);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "026dd8b180fe8e43f477fce43e9217b3",
    "file": "SkRegion_Reference",
    "name": "SkRegion::Op"
},
    "SkRegion_contains": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath xPath;\n    paint.getTextPath(\"X\", 1, 20, 110, &xPath);\n    SkRegion xRegion;\n    xRegion.setPath(xPath, SkRegion({0, 0, 256, 256}));\n    canvas->drawRegion(xRegion, paint);\n    for (int y = 0; y < 128; y += 8) {\n        for (int x = 0; x < 128; x += 8) {\n           paint.setColor(xRegion.contains(x, y) ? SK_ColorWHITE : SK_ColorRED);\n           canvas->drawPoint(x, y, paint);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "e3899c2715c332bfc7648d5f2b9eefc6",
    "file": "SkRegion_Reference",
    "name": "SkRegion::contains()"
},
    "SkRegion_contains_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath xPath;\n    paint.getTextPath(\"X\", 1, 20, 110, &xPath);\n    SkRegion xRegion;\n    SkIRect drawBounds = {0, 0, 128, 128};\n    xRegion.setPath(xPath, SkRegion(drawBounds));\n    xRegion.op(drawBounds, SkRegion::kReverseDifference_Op);\n    canvas->drawRegion(xRegion, paint);\n    SkIRect test = SkIRect::MakeXYWH(frame* 128, 64, 5, 5);\n    if (xRegion.contains(test)) {\n        paint.setColor(SK_ColorYELLOW);\n        canvas->drawRect(SkRect::Make(test), paint);\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "100b4cbd5dd7406804e40035833a433c",
    "file": "SkRegion_Reference",
    "name": "SkRegion::contains_2"
},
    "SkRegion_contains_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath xPath, testPath;\n    paint.getTextPath(\"X\", 1, 20, 110, &xPath);\n    paint.getTextPath(\"`\", 1, frame * 150 - 40, 150, &testPath);\n    SkRegion xRegion, testRegion;\n    SkIRect drawBounds = {0, 0, 128, 128};\n    xRegion.setPath(xPath, SkRegion(drawBounds));\n    testRegion.setPath(testPath, SkRegion(drawBounds));\n    xRegion.op(drawBounds, SkRegion::kReverseDifference_Op);\n    canvas->drawRegion(xRegion, paint);\n    if (xRegion.contains(testRegion)) {\n        paint.setColor(SK_ColorYELLOW);\n        canvas->drawRegion(testRegion, paint);\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "46de22da2f3e08a8d7f064634fc1c7b5",
    "file": "SkRegion_Reference",
    "name": "SkRegion::contains_3"
},
    "SkRegion_getBoundaryPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    region.setRect({10, 20, 90, 60});\n    region.op({30, 40, 60, 80}, SkRegion::kXOR_Op);\n    canvas->drawRegion(region, SkPaint());\n    SkPath path;\n    region.getBoundaryPath(&path);\n    path.offset(100, 0);\n    canvas->drawPath(path, SkPaint());\n}",
    "width": 256,
    "height": 100,
    "hash": "6631d36406efa3b3e27960c876421a7f",
    "file": "SkRegion_Reference",
    "name": "SkRegion::getBoundaryPath"
},
    "SkRegion_intersects": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath textPath;\n    paint.getTextPath(\"W\", 1, 20, 110, &textPath);\n    SkRegion region;\n    region.setPath(textPath, SkRegion({0, 0, 256, 256}));\n    canvas->drawRegion(region, SkPaint());\n    SkIRect iRect = SkIRect::MakeXYWH(frame * 160, 55, 10, 10);\n    paint.setColor(region.intersects(iRect) ? SK_ColorBLUE : SK_ColorRED);\n    canvas->drawRect(SkRect::Make(iRect), paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "42bde0ef8c2ee372751428cd6e21c1ca",
    "file": "SkRegion_Reference",
    "name": "SkRegion::intersects()"
},
    "SkRegion_intersects_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath hPath, dotPath;\n    paint.getTextPath(\"H\", 1, 40, 110, &hPath);\n    paint.getTextPath(\",\", 1, frame * 180, 95, &dotPath);\n    SkRegion hRegion, dotRegion;\n    hRegion.setPath(hPath, SkRegion({0, 0, 256, 256}));\n    dotRegion.setPath(dotPath, SkRegion({0, 0, 256, 256}));\n    canvas->drawRegion(hRegion, paint);\n    paint.setColor(hRegion.intersects(dotRegion) ? SK_ColorBLUE : SK_ColorRED);\n    canvas->drawRegion(dotRegion, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "4263d79ac0e7df02e90948fdde9fa965",
    "file": "SkRegion_Reference",
    "name": "SkRegion::intersects_2"
},
    "SkRegion_op": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath xPath;\n    paint.getTextPath(\"X\", 1, 20, 110, &xPath);\n    SkRegion xRegion;\n    SkIRect drawBounds = {0, 0, 128, 128};\n    xRegion.setPath(xPath, SkRegion(drawBounds));\n    xRegion.op(drawBounds, SkRegion::kReverseDifference_Op);\n    canvas->drawRegion(xRegion, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "1790b2e054c536a54601138365700ac3",
    "file": "SkRegion_Reference",
    "name": "SkRegion::op()"
},
    "SkRegion_op_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath xPath;\n    paint.getTextPath(\"X\", 1, 20, 110, &xPath);\n    SkRegion xRegion;\n    SkIRect drawBounds = {0, 0, 128, 128};\n    xRegion.setPath(xPath, SkRegion(drawBounds));\n    xRegion.op(drawBounds.fLeft + frame * drawBounds.width(), drawBounds.fTop,\n               drawBounds.fRight, drawBounds.fBottom, SkRegion::kReverseDifference_Op);\n    canvas->drawRegion(xRegion, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "2e3497890d523235f96680716c321098",
    "file": "SkRegion_Reference",
    "name": "SkRegion::op_2"
},
    "SkRegion_op_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath xPath, opPath;\n    paint.getTextPath(\"X\", 1, 20, 110, &xPath);\n    opPath.addCircle(64, 64, frame * 64);\n    SkRegion xRegion, opRegion;\n    SkIRect drawBounds = {0, 0, 128, 128};\n    opRegion.setPath(opPath, SkRegion(drawBounds));\n    xRegion.setPath(xPath, SkRegion(drawBounds));\n    xRegion.op(opRegion, SkRegion::kReverseDifference_Op);\n    canvas->drawRegion(xRegion, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "65f4eccea3514ed7e37b5067e15efddb",
    "file": "SkRegion_Reference",
    "name": "SkRegion::op_3"
},
    "SkRegion_op_4": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath xPath, opPath;\n    paint.getTextPath(\"X\", 1, 20, 110, &xPath);\n    opPath.addCircle(64, 64, frame * 64);\n    SkRegion xRegion, opRegion, rectRegion;\n    SkIRect drawBounds = {0, 0, 128, 128};\n    opRegion.setPath(opPath, SkRegion(drawBounds));\n    xRegion.setPath(xPath, SkRegion(drawBounds));\n    drawBounds.inset(frame * drawBounds.width() / 2, 0);    \n    rectRegion.op(drawBounds, opRegion, SkRegion::kIntersect_Op);\n    xRegion.op(rectRegion, SkRegion::kReverseDifference_Op);\n    canvas->drawRegion(xRegion, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "3f964be1e1fd2fbb977b655d3a928f0a",
    "file": "SkRegion_Reference",
    "name": "SkRegion::op_4"
},
    "SkRegion_op_5": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath xPath, opPath;\n    paint.getTextPath(\"X\", 1, 20, 110, &xPath);\n    opPath.addCircle(64, 64, frame * 64);\n    SkRegion xRegion, opRegion, rectRegion;\n    SkIRect drawBounds = {0, 0, 128, 128};\n    opRegion.setPath(opPath, SkRegion(drawBounds));\n    xRegion.setPath(xPath, SkRegion(drawBounds));\n    drawBounds.inset(frame * drawBounds.width() / 2, 0);    \n    rectRegion.op(opRegion, drawBounds, SkRegion::kUnion_Op);\n    xRegion.op(rectRegion, SkRegion::kReverseDifference_Op);\n    canvas->drawRegion(xRegion, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "e623208dd44f0b24499ac5f1593d1b39",
    "file": "SkRegion_Reference",
    "name": "SkRegion::op_5"
},
    "SkRegion_op_6": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath xPath, opPath;\n    paint.getTextPath(\"X\", 1, 20, 110, &xPath);\n    xPath.setFillType(SkPath::kInverseWinding_FillType);\n    opPath.addCircle(64, 64, frame * 64);\n    opPath.setFillType(SkPath::kInverseWinding_FillType);\n    SkRegion xRegion, opRegion, rectRegion;\n    SkIRect drawBounds = {0, 0, 128, 128};\n    opRegion.setPath(opPath, SkRegion(drawBounds));\n    xRegion.setPath(xPath, SkRegion(drawBounds));\n    drawBounds.inset(frame * drawBounds.width() / 2, 0);\n    rectRegion.setRect(drawBounds);    \n    rectRegion.op(xRegion, SkRegion::kIntersect_Op);\n    xRegion.op(rectRegion, opRegion, SkRegion::kReverseDifference_Op);\n    canvas->drawRegion(xRegion, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "13de1a6fcb2302a2a30278cb88d3e17d",
    "file": "SkRegion_Reference",
    "name": "SkRegion::op_6"
},
    "SkRegion_readFromMemory": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region({20, 20, 80, 80});\n    size_t size = region.writeToMemory(nullptr);\n    sk_sp<SkData> data = SkData::MakeUninitialized(size);\n    region.writeToMemory(data->writable_data());\n    SkRegion copy;\n    copy.readFromMemory(data->data(), data->size());\n    canvas->drawRegion(copy, SkPaint());\n}",
    "width": 256,
    "height": 100,
    "hash": "1ede346c430ef23df0eaaf0773dd6a15",
    "file": "SkRegion_Reference",
    "name": "SkRegion::readFromMemory"
},
    "SkRegion_setPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath textPath;\n    paint.getTextPath(\"Q\", 1, 0, 110, &textPath);\n    SkIRect clipRect = {20, 20, 100, 120};\n    SkRegion clipRegion(clipRect);\n    SkRegion region;\n    region.setPath(textPath, clipRegion);\n    canvas->drawRegion(region, SkPaint());\n    clipRect.offset(100, 0);\n    textPath.offset(100, 0);\n    canvas->clipRect(SkRect::Make(clipRect), false);\n    canvas->drawPath(textPath, SkPaint());\n}",
    "width": 256,
    "height": 120,
    "hash": "45b9ea2247b9ca7f10aa22ea29a426f4",
    "file": "SkRegion_Reference",
    "name": "SkRegion::setPath"
},
    "SkRegion_setRects": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rects[] = { {10, 10, 40, 40}, {20, 20, 50, 50}, {30, 30, 60, 60} };\n    SkRegion region;\n    region.setRects(rects, SK_ARRAY_COUNT(rects));\n    canvas->drawRegion(region, SkPaint());\n    region.setEmpty();\n    for (auto add : rects) {\n        region.op(add, SkRegion::kUnion_Op);\n    }\n    region.translate(100, 0);\n    canvas->drawRegion(region, SkPaint());\n}",
    "width": 256,
    "height": 70,
    "hash": "fc793a14ed76c096a68a755c963c1ee0",
    "file": "SkRegion_Reference",
    "name": "SkRegion::setRects"
},
    "SkRegion_translate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion test;\n    SkIRect rects[] = {{40, 20, 50, 30}, {70, 40, 80, 50}, { 60, 10, 70, 20}};\n    test.setRects(rects, SK_ARRAY_COUNT(rects));\n    SkPaint paint;\n    for (auto color :  { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN, SK_ColorMAGENTA } ) {\n        paint.setColor(color);\n        canvas->drawRegion(test, paint);\n        test.translate(10, 10);\n    }\n}",
    "width": 256,
    "height": 90,
    "hash": "4e5b9e53aa1b200fed3ee6596ca01f0e",
    "file": "SkRegion_Reference",
    "name": "SkRegion::translate()"
},
    "SkRegion_translate_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion test;\n    SkIRect rects[] = {{40, 20, 50, 30}, {70, 40, 80, 50}, { 60, 10, 70, 20}};\n    test.setRects(rects, SK_ARRAY_COUNT(rects));\n    SkPaint paint;\n    for (auto color :  { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN, SK_ColorMAGENTA } ) {\n        paint.setColor(color);\n        canvas->drawRegion(test, paint);\n        SkRegion second;\n        test.translate(10, test.getBounds().fBottom, &second);\n        test.op(second, SkRegion::kXOR_Op);\n        test.translate(30, 0);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "024200960eb52fee1f471514607e6001",
    "file": "SkRegion_Reference",
    "name": "SkRegion::translate_2"
},
    "SkRegion_writeToMemory": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath xPath;\n    paint.getTextPath(\"X\", 1, 20, 110, &xPath);\n    SkIRect drawBounds = {0, 0, 128, 128};\n    SkRegion xRegion;\n    xRegion.setPath(xPath, SkRegion(drawBounds));\n    size_t size = xRegion.writeToMemory(nullptr);\n    sk_sp<SkData> data = SkData::MakeUninitialized(size);\n    xRegion.writeToMemory(data->writable_data());\n    SkRegion copy;\n    copy.readFromMemory(data->data(), data->size());\n    canvas->drawRegion(copy, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "1419d2a8c22c355ab46240865d056ee5",
    "file": "SkRegion_Reference",
    "name": "SkRegion::writeToMemory"
},
    "SkStream_MakeFromFile": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::MakeFromFile"
},
    "SkStream_destructor": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::~SkStream()"
},
    "SkStream_duplicate": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::duplicate()"
},
    "SkStream_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::SkStream()"
},
    "SkStream_fork": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::fork()"
},
    "SkStream_getLength": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::getLength"
},
    "SkStream_getMemoryBase": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::getMemoryBase"
},
    "SkStream_getPosition": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::getPosition"
},
    "SkStream_hasLength": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::hasLength"
},
    "SkStream_hasPosition": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::hasPosition"
},
    "SkStream_isAtEnd": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::isAtEnd"
},
    "SkStream_move": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::move()"
},
    "SkStream_peek": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::peek()"
},
    "SkStream_read": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::read()"
},
    "SkStream_readBool": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::readBool"
},
    "SkStream_readPackedUInt": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::readPackedUInt"
},
    "SkStream_readS16": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::readS16"
},
    "SkStream_readS32": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::readS32"
},
    "SkStream_readS8": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::readS8"
},
    "SkStream_readScalar": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::readScalar"
},
    "SkStream_readU16": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::readU16"
},
    "SkStream_readU32": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::readU32"
},
    "SkStream_readU8": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::readU8"
},
    "SkStream_rewind": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::rewind()"
},
    "SkStream_seek": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::seek()"
},
    "SkStream_skip": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkStream_Reference",
    "name": "SkStream::skip()"
},
    "SkSurface_MakeFromBackendTexture": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    sk_sp<SkSurface> gpuSurface = SkSurface::MakeFromBackendTexture(context,\n            backEndTexture, kTopLeft_GrSurfaceOrigin, 0,\n            kRGBA_8888_SkColorType, nullptr, nullptr);\n    auto surfaceCanvas = gpuSurface->getCanvas();\n    surfaceCanvas->drawString(\"GPU rocks!\", 20, 40, paint);\n    sk_sp<SkImage> image(gpuSurface->makeImageSnapshot());\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "d3aec071998f871809f515e58abb1b0e",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeFromBackendTexture"
},
    "SkSurface_MakeFromBackendTextureAsRenderTarget": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    sk_sp<SkSurface> gpuSurface = SkSurface::MakeFromBackendTextureAsRenderTarget(\n            context, backEndTexture, kTopLeft_GrSurfaceOrigin, 0,\n            kRGBA_8888_SkColorType, nullptr, nullptr);\n    auto surfaceCanvas = gpuSurface->getCanvas();\n    surfaceCanvas->drawString(\"GPU rocks!\", 20, 40, paint);\n    sk_sp<SkImage> image(gpuSurface->makeImageSnapshot());\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "5e87093b9cbe95124ae14cbe77091eb7",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeFromBackendTextureAsRenderTarget"
},
    "SkSurface_MakeRenderTarget": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    SkImageInfo info = SkImageInfo::MakeN32(256, 64, kOpaque_SkAlphaType);\n    for (auto surfaceOrigin : { kTopLeft_GrSurfaceOrigin, kBottomLeft_GrSurfaceOrigin } ) {\n        auto gpuSurface(SkSurface::MakeRenderTarget(context, SkBudgeted::kNo, info, 0,\n               surfaceOrigin, nullptr));\n        auto surfaceCanvas = gpuSurface->getCanvas();\n        surfaceCanvas->clear(SK_ColorWHITE);\n        surfaceCanvas->drawString(\"GPU rocks!\", 20, 40, paint);\n        sk_sp<SkImage> image(gpuSurface->makeImageSnapshot());\n        canvas->drawImage(image, 0, 0);\n       canvas->translate(0, 128);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "67b6609471a3f1ed0f4b1657004cdecb",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRenderTarget"
},
    "SkSurface_MakeRenderTarget_2": {
    "code": "void draw(SkCanvas* canvas) {\n    auto test_draw = [](SkCanvas* surfaceCanvas) -> void {\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        paint.setLCDRenderText(true);\n        paint.setColor(0xFFBBBBBB);\n        surfaceCanvas->drawRect(SkRect::MakeWH(128, 64), paint);\n        paint.setColor(SK_ColorWHITE);\n        paint.setTextSize(32);\n        surfaceCanvas->drawString(\"Pest\", 0, 25, paint);\n    };\n    GrContext* context = canvas->getGrContext();\n    SkImageInfo info = SkImageInfo::MakeN32(128, 64, kOpaque_SkAlphaType);\n    int y = 0;\n    for (auto geometry : { kRGB_H_SkPixelGeometry, kBGR_H_SkPixelGeometry,\n                           kRGB_V_SkPixelGeometry, kBGR_V_SkPixelGeometry } ) {\n        SkSurfaceProps props(0, geometry);\n        sk_sp<SkSurface> surface = context ? SkSurface::MakeRenderTarget(\n                context, SkBudgeted::kNo, info, 0, &props) : SkSurface::MakeRaster(info, &props);\n        test_draw(surface->getCanvas());\n        surface->draw(canvas, 0, y, nullptr);\n        sk_sp<SkImage> image(surface->makeImageSnapshot());\n        SkAutoCanvasRestore acr(canvas, true);\n        canvas->scale(8, 8);\n        canvas->drawImage(image, 12, y / 8);\n        y += 64;\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "640321e8ecfb3f9329f3bc6e1f02485f",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRenderTarget_2"
},
    "SkSurface_MakeRenderTarget_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    SkImageInfo info = SkImageInfo::MakeN32(256, 64, kOpaque_SkAlphaType);\n    auto gpuSurface(SkSurface::MakeRenderTarget(context, SkBudgeted::kNo, info));\n    auto surfaceCanvas = gpuSurface->getCanvas();\n    surfaceCanvas->clear(SK_ColorWHITE);\n    surfaceCanvas->drawString(\"GPU rocks!\", 20, 40, paint);\n    sk_sp<SkImage> image(gpuSurface->makeImageSnapshot());\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "5c7629c15e9ac93f098335e72560fa2e",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRenderTarget_3"
},
    "SkSurface_characterize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    sk_sp<SkSurface> gpuSurface = SkSurface::MakeRenderTarget(\n            context, SkBudgeted::kYes, SkImageInfo::MakeN32Premul(64, 64));\n    SkSurfaceCharacterization characterization;\n    if (!gpuSurface->characterize(&characterization)) {\n         canvas->drawString(\"characterization unsupported\", 20, 40, paint);\n         return;\n    }\n    // start of threadable work\n    SkDeferredDisplayListRecorder recorder(characterization);\n    SkCanvas* subCanvas = recorder.getCanvas();\n    subCanvas->clear(SK_ColorGREEN);\n    std::unique_ptr<SkDeferredDisplayList> displayList = recorder.detach();\n    // end of threadable work\n    gpuSurface->draw(displayList.get());\n    sk_sp<SkImage> img = gpuSurface->makeImageSnapshot();\n    canvas->drawImage(std::move(img), 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "6de6f3ef699a72ff26da1b26b23a3316",
    "file": "SkSurface_Reference",
    "name": "SkSurface::characterize()"
},
    "SkSurface_draw": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> big(SkSurface::MakeRasterN32Premul(64, 64));\n    sk_sp<SkSurface> lil(big->makeSurface(SkImageInfo::MakeN32(32, 32, kPremul_SkAlphaType)));\n    big->getCanvas()->clear(SK_ColorRED);\n    lil->getCanvas()->clear(SK_ColorBLACK);\n    lil->draw(big->getCanvas(), 16, 16, nullptr);\n    SkPixmap pixmap;\n    if (big->peekPixels(&pixmap)) {\n        SkBitmap bigBits;\n        bigBits.installPixels(pixmap);\n        canvas->drawBitmap(bigBits, 0, 0);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "0de693f4d8dd898a60be8cfba23952be",
    "file": "SkSurface_Reference",
    "name": "SkSurface::draw()"
},
    "SkSurface_draw_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(16);\n    sk_sp<SkSurface> gpuSurface = SkSurface::MakeRasterN32Premul(64, 64);\n    SkSurfaceCharacterization characterization;\n    if (!gpuSurface->characterize(&characterization)) {\n         canvas->drawString(\"characterization unsupported\", 20, 40, paint);\n         return;\n    }\n    // start of threadable work\n    SkDeferredDisplayListRecorder recorder(characterization);\n    SkCanvas* subCanvas = recorder.getCanvas();\n    subCanvas->clear(SK_ColorGREEN);\n    std::unique_ptr<SkDeferredDisplayList> displayList = recorder.detach();\n    // end of threadable work\n    gpuSurface->draw(displayList.get());\n    sk_sp<SkImage> img = gpuSurface->makeImageSnapshot();\n    canvas->drawImage(std::move(img), 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "46d9bacf593deaaeabd74ff42f2571a0",
    "file": "SkSurface_Reference",
    "name": "SkSurface::draw_2"
},
    "SkSurface_getCanvas": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surface(SkSurface::MakeRasterN32Premul(64, 64));\n    SkCanvas* surfaceCanvas = surface->getCanvas();\n    surfaceCanvas->clear(SK_ColorBLUE);\n    SkPaint paint;\n    paint.setTextSize(40);\n    surfaceCanvas->drawString(\"\\xF0\\x9F\\x98\\x81\", 12, 45, paint);\n    surface->draw(canvas, 0, 0, nullptr);\n}",
    "width": 256,
    "height": 64,
    "hash": "33d0c5ad5a4810e533ae1010e29f8b75",
    "file": "SkSurface_Reference",
    "name": "SkSurface::getCanvas"
},
    "SkSurface_makeImageSnapshot": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> big(SkSurface::MakeRasterN32Premul(64, 64));\n    sk_sp<SkSurface> lil(big->makeSurface(SkImageInfo::MakeN32(32, 32, kPremul_SkAlphaType)));\n    big->getCanvas()->clear(SK_ColorRED);\n    lil->getCanvas()->clear(SK_ColorBLACK);\n    sk_sp<SkImage> early(big->makeImageSnapshot());\n    lil->draw(big->getCanvas(), 16, 16, nullptr);\n    sk_sp<SkImage> later(big->makeImageSnapshot());\n    canvas->drawImage(early, 0, 0);\n    canvas->drawImage(later, 128, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "46f1fa0d95e590a64bed0140407ce5f7",
    "file": "SkSurface_Reference",
    "name": "SkSurface::makeImageSnapshot"
},
    "SkSurface_makeImageSnapshot_2": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> big(SkSurface::MakeRasterN32Premul(64, 64));\n    sk_sp<SkSurface> lil(big->makeSurface(SkImageInfo::MakeN32(32, 32, kPremul_SkAlphaType)));\n    big->getCanvas()->clear(SK_ColorRED);\n    lil->getCanvas()->clear(SK_ColorBLACK);\n    sk_sp<SkImage> early(big->makeImageSnapshot());\n    lil->draw(big->getCanvas(), 16, 16, nullptr);\n    sk_sp<SkImage> later(big->makeImageSnapshot({0, 0, 16, 16}));\n    canvas->drawImage(early, 0, 0);\n    canvas->drawImage(later, 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "b18b8ab693b09eb70a1d22ab63790cc7",
    "file": "SkSurface_Reference",
    "name": "SkSurface::makeImageSnapshot_2"
},
    "SkSurface_makeSurface": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> big(SkSurface::MakeRasterN32Premul(64, 64));\n    sk_sp<SkSurface> lil(big->makeSurface(SkImageInfo::MakeN32(32, 32, kPremul_SkAlphaType)));\n    big->getCanvas()->clear(SK_ColorRED);\n    lil->getCanvas()->clear(SK_ColorBLACK);\n    SkPixmap pixmap;\n    if (big->peekPixels(&pixmap)) {\n        SkBitmap bigBits;\n        bigBits.installPixels(pixmap);\n        canvas->drawBitmap(bigBits, 0, 0);\n    }\n    if (lil->peekPixels(&pixmap)) {\n        SkBitmap lilBits;\n        lilBits.installPixels(pixmap);\n        canvas->drawBitmap(lilBits, 64, 64);\n    }\n}",
    "width": 256,
    "height": 96,
    "hash": "a9889b519a26896b900da0444e423c61",
    "file": "SkSurface_Reference",
    "name": "SkSurface::makeSurface"
},
    "SkSurface_peekPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    auto surfCanvas = surf->getCanvas();\n    surfCanvas->clear(SK_ColorRED);\n    SkPaint paint;\n    paint.setTextSize(40);\n    surfCanvas->drawString(\"&\", 16, 48, paint);\n    SkPixmap pixmap;\n    if (surf->peekPixels(&pixmap)) {\n        SkBitmap surfBits;\n        surfBits.installPixels(pixmap);\n        canvas->drawBitmap(surfBits, 0, 0);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "8c6184f22cfe068f021704cf92a147a1",
    "file": "SkSurface_Reference",
    "name": "SkSurface::peekPixels"
},
    "SkSurface_readPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    auto surfCanvas = surf->getCanvas();\n    surfCanvas->clear(SK_ColorRED);\n    SkPaint paint;\n    paint.setTextSize(40);\n    surfCanvas->drawString(\"&\", 0, 32, paint);\n    std::vector<SkPMColor> storage;\n    storage.resize(surf->width() * surf->height());\n    SkPixmap pixmap(SkImageInfo::MakeN32Premul(32, 32), &storage.front(),\n                    surf->width() * sizeof(storage[0]));\n    if (surf->readPixels(pixmap, 0, 0)) {\n        SkBitmap surfBits;\n        surfBits.installPixels(pixmap);\n        canvas->drawBitmap(surfBits, 0, 0);\n    }\n}",
    "width": 256,
    "height": 32,
    "hash": "9f454fb93bca6482598d198b4121f0a6",
    "file": "SkSurface_Reference",
    "name": "SkSurface::readPixels"
},
    "SkSurface_readPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    auto surfCanvas = surf->getCanvas();\n    surfCanvas->clear(SK_ColorRED);\n    SkPaint paint;\n    surfCanvas->drawOval({4, 8, 58, 54}, paint);\n    SkImageInfo info = SkImageInfo::Make(64, 64, kBGRA_8888_SkColorType, kPremul_SkAlphaType);\n    sk_sp<SkData> data(SkData::MakeUninitialized(info.minRowBytes() * info.height()));\n    sk_bzero(data->writable_data(), info.minRowBytes() * info.height());\n    for (int x : { 32, -32 } ) {\n        for (int y : { 32, -32 } ) {\n            surf->readPixels(info, data->writable_data(), info.minRowBytes(), x, y);\n        }\n    }\n    sk_sp<SkImage> image = SkImage::MakeRasterData(info, data, info.minRowBytes());\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "484d60dab5d846bf28c7a4d48892324a",
    "file": "SkSurface_Reference",
    "name": "SkSurface::readPixels_2"
},
    "SkSurface_readPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    auto surfCanvas = surf->getCanvas();\n    surfCanvas->clear(SK_ColorGREEN);\n    SkPaint paint;\n    surfCanvas->drawOval({2, 10, 58, 54}, paint);\n    SkImageInfo info = SkImageInfo::Make(64, 64, kBGRA_8888_SkColorType, kPremul_SkAlphaType);\n    SkBitmap bitmap;\n    bitmap.setInfo(info);\n    bitmap.allocPixels();\n    for (int x : { 32, -32 } ) {\n        for (int y : { 32, -32 } ) {\n            surf->readPixels(bitmap, x, y);\n        }\n    }\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "2d991a231e49d1de13eeb2ba9b440e01",
    "file": "SkSurface_Reference",
    "name": "SkSurface::readPixels_3"
},
    "SkSurface_writePixels": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    auto surfCanvas = surf->getCanvas();\n    surfCanvas->clear(SK_ColorRED);\n    SkPaint paint;\n    paint.setTextSize(40);\n    surfCanvas->drawString(\"&\", 16, 40, paint);\n    SkPixmap pixmap;\n    if (surf->peekPixels(&pixmap)) {\n        surf->writePixels(pixmap, 25, 25);\n        sk_sp<SkImage> image(surf->makeImageSnapshot());\n        canvas->drawImage(image, 0, 0);\n    }\n}",
    "width": 256,
    "height": 96,
    "hash": "760793bcf0ef193fa61ea03e6e8fc825",
    "file": "SkSurface_Reference",
    "name": "SkSurface::writePixels"
},
    "SkSurface_writePixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    auto surfCanvas = surf->getCanvas();\n    surfCanvas->clear(SK_ColorGREEN);\n    surf->writePixels(source, 25, 25);\n    sk_sp<SkImage> image(surf->makeImageSnapshot());\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 256,
    "height": 96,
    "hash": "d77790dd3bc9f678fa4f582347fb8fba",
    "file": "SkSurface_Reference",
    "name": "SkSurface::writePixels_2"
},
    "SkTextBlobBuilder_allocRun": {
    "code": "void draw(SkCanvas* canvas) {\n    SkTextBlobBuilder builder;\n    SkFont font;\n    SkPaint paint;\n    const SkTextBlobBuilder::RunBuffer& run = builder.allocRun(font, 5, 20, 20);\n    paint.textToGlyphs(\"hello\", 5, run.glyphs);\n    canvas->drawRect({20, 20, 30, 30}, paint);\n    canvas->drawTextBlob(builder.make(), 20, 20, paint);\n}",
    "width": 256,
    "height": 60,
    "hash": "f0e584aec20eaee7a5bfed62aa885eee",
    "file": "SkTextBlobBuilder_Reference",
    "name": "SkTextBlobBuilder::allocRun"
},
    "SkTextBlobBuilder_allocRunPos": {
    "code": "void draw(SkCanvas* canvas) {\n    SkTextBlobBuilder builder;\n    SkPaint paint;\n    SkFont font;\n    const SkTextBlobBuilder::RunBuffer& run = builder.allocRunPos(font, 5);\n    paint.textToGlyphs(\"hello\", 5, run.glyphs);\n    SkPoint positions[] = {{0, 0}, {10, 10}, {20, 20}, {40, 40}, {80, 80}};\n    memcpy(run.pos, positions, sizeof(positions));\n    canvas->drawTextBlob(builder.make(), 20, 20, paint);\n}",
    "width": 256,
    "height": 90,
    "hash": "da4fcb4a972b500996be9aff6c6c40e1",
    "file": "SkTextBlobBuilder_Reference",
    "name": "SkTextBlobBuilder::allocRunPos"
},
    "SkTextBlobBuilder_allocRunPosH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkTextBlobBuilder builder;\n    SkPaint paint;\n    SkFont font;\n    const SkTextBlobBuilder::RunBuffer& run = builder.allocRunPosH(font, 5, 20);\n    paint.textToGlyphs(\"hello\", 5, run.glyphs);\n    SkScalar positions[] = {0, 10, 20, 40, 80};\n    memcpy(run.pos, positions, sizeof(positions));\n    canvas->drawTextBlob(builder.make(), 20, 20, paint);\n}",
    "width": 256,
    "height": 60,
    "hash": "c77ac50f506106fdfef94d20bc1a6934",
    "file": "SkTextBlobBuilder_Reference",
    "name": "SkTextBlobBuilder::allocRunPosH"
},
    "SkTextBlob_Deserialize": {
    "code": "#include \"SkSerialProcs.h\"\n\nvoid draw(SkCanvas* canvas) {\n    SkFont blobFont;\n    blobFont.setSize(24);\n    sk_sp<SkTextBlob> blob = SkTextBlob::MakeFromText(\"Hello World!\", 12, blobFont);\n    sk_sp<SkData> data = blob->serialize(SkSerialProcs());\n    uint16_t glyphs[6];\n    SkPaint blobPaint;\n    blobPaint.textToGlyphs(\"Hacker\", 6, glyphs);\n    memcpy((char*)data->writable_data() + 0x54, glyphs, sizeof(glyphs));\n    sk_sp<SkTextBlob> copy = SkTextBlob::Deserialize(data->data(), data->size(), SkDeserialProcs());\n    canvas->drawTextBlob(copy, 20, 20, SkPaint());\n}",
    "width": 256,
    "height": 24,
    "hash": "68b6d0208eb0b4de67fc152381af7a58",
    "file": "SkTextBlob_Reference",
    "name": "SkTextBlob::Deserialize"
},
    "SkTextBlob_MakeFromString": {
    "code": "void draw(SkCanvas* canvas) {\n    SkFont font;\n    font.setSize(24);\n    SkPaint canvasPaint;\n    canvasPaint.setColor(SK_ColorBLUE); // respected\n    canvasPaint.setTextSize(2); // ignored\n    sk_sp<SkTextBlob> blob = SkTextBlob::MakeFromString(\"Hello World\", font);\n    canvas->drawTextBlob(blob, 20, 20, canvasPaint);\n}",
    "width": 256,
    "height": 24,
    "hash": "a5af182e793eed3f2bb3b0efc2cf4852",
    "file": "SkTextBlob_Reference",
    "name": "SkTextBlob::MakeFromString"
},
    "SkTextBlob_MakeFromText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkFont font;\n    font.setSize(24);\n    SkPaint canvasPaint;\n    canvasPaint.setColor(SK_ColorBLUE); // respected\n    canvasPaint.setTextSize(2); // ignored\n    sk_sp<SkTextBlob> blob = SkTextBlob::MakeFromText(\"Hello World\", 11, font);\n    canvas->drawTextBlob(blob, 20, 20, canvasPaint);\n}",
    "width": 256,
    "height": 24,
    "hash": "bec2252bc36dc8fd023015629d60c405",
    "file": "SkTextBlob_Reference",
    "name": "SkTextBlob::MakeFromText"
},
    "SkTextBlob_bounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkTextBlobBuilder textBlobBuilder;\n    const char bunny[] = \"/(^x^)\\\\\";\n    const int len = sizeof(bunny) - 1;\n    uint16_t glyphs[len];\n    SkPaint paint;\n    paint.textToGlyphs(bunny, len, glyphs);\n    paint.setTextEncoding(SkTextEncoding::kGlyphID);\n    SkFont font;\n    int runs[] = { 3, 1, 3 };\n    SkPoint textPos = { 20, 50 };\n    int glyphIndex = 0;\n    for (auto runLen : runs) {\n        font.setSize(1 == runLen ? 20 : 50);\n        paint.setTextSize(1 == runLen ? 20 : 50);\n        const SkTextBlobBuilder::RunBuffer& run =\n                textBlobBuilder.allocRun(font, runLen, textPos.fX, textPos.fY);\n        memcpy(run.glyphs, &glyphs[glyphIndex], sizeof(glyphs[0]) * runLen);\n        textPos.fX += paint.measureText(&glyphs[glyphIndex], sizeof(glyphs[0]) * runLen, nullptr);\n        glyphIndex += runLen;\n    }\n    sk_sp<const SkTextBlob> blob = textBlobBuilder.make();\n    canvas->drawTextBlob(blob.get(), 0, 0, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRect(blob->bounds(), paint);\n}",
    "width": 256,
    "height": 70,
    "hash": "fb8b2502bbe52d2029aecdf569dd9fdb",
    "file": "SkTextBlob_Reference",
    "name": "SkTextBlob::bounds()"
},
    "SkTextBlob_serialize": {
    "code": "#include \"SkSerialProcs.h\"\n\nvoid draw(SkCanvas* canvas) {\n    SkFont blobFont;\n    blobFont.setSize(24);\n    sk_sp<SkTextBlob> blob = SkTextBlob::MakeFromText(\"Hello World\", 11, blobFont);\n    char storage[2048];\n    size_t used = blob->serialize(SkSerialProcs(), storage, sizeof(storage));\n    sk_sp<SkTextBlob> copy = SkTextBlob::Deserialize(storage, used, SkDeserialProcs());\n    canvas->drawTextBlob(copy, 20, 20, SkPaint());\n    std::string usage = \"size=\" + std::to_string(sizeof(storage)) + \" used=\" + std::to_string(used);\n    canvas->drawString(usage.c_str(), 20, 40, SkPaint());\n}",
    "width": 256,
    "height": 64,
    "hash": "90ce8c327d407b1faac73baa2ebd0378",
    "file": "SkTextBlob_Reference",
    "name": "SkTextBlob::serialize()"
},
    "SkTextBlob_serialize_2": {
    "code": "#include \"SkSerialProcs.h\"\n\nvoid draw(SkCanvas* canvas) {\n    SkFont blobFont;\n    blobFont.setSize(24);\n    sk_sp<SkTextBlob> blob = SkTextBlob::MakeFromText(\"Hello World\", 11, blobFont);\n    sk_sp<SkData> data = blob->serialize(SkSerialProcs());\n    sk_sp<SkTextBlob> copy = SkTextBlob::Deserialize(data->data(), data->size(), SkDeserialProcs());\n    canvas->drawTextBlob(copy, 20, 20, SkPaint());\n}",
    "width": 256,
    "height": 24,
    "hash": "464201a828f7e94fc01cd57facfcd2f4",
    "file": "SkTextBlob_Reference",
    "name": "SkTextBlob::serialize_2"
},
    "SkTextBlob_uniqueID": {
    "code": "void draw(SkCanvas* canvas) {\n    for (int index = 0; index < 2; ++index) {\n        SkTextBlobBuilder textBlobBuilder;\n        const char bunny[] = \"/(^x^)\\\\\";\n        const int len = sizeof(bunny) - 1;\n        uint16_t glyphs[len];\n        SkPaint paint;\n        paint.textToGlyphs(bunny, len, glyphs);\n        paint.setTextEncoding(SkTextEncoding::kGlyphID);\n        paint.setTextScaleX(0.5);\n        SkFont font;\n        font.setScaleX(0.5);\n        int runs[] = { 3, 1, 3 };\n        SkPoint textPos = { 20, 50 };\n        int glyphIndex = 0;\n        for (auto runLen : runs) {\n            font.setSize(1 == runLen ? 20 : 50);\n            paint.setTextSize(1 == runLen ? 20 : 50);\n            const SkTextBlobBuilder::RunBuffer& run =\n                    textBlobBuilder.allocRun(font, runLen, textPos.fX, textPos.fY);\n            memcpy(run.glyphs, &glyphs[glyphIndex], sizeof(glyphs[0]) * runLen);\n            textPos.fX += paint.measureText(&glyphs[glyphIndex], sizeof(glyphs[0]) * runLen, nullptr);\n            glyphIndex += runLen;\n        }\n        sk_sp<const SkTextBlob> blob = textBlobBuilder.make();\n        paint.reset();\n        canvas->drawTextBlob(blob.get(), 0, 0, paint);\n        std::string id = \"unique ID:\" + std::to_string(blob->uniqueID());\n        canvas->drawString(id.c_str(), 30, blob->bounds().fBottom + 15, paint);\n        canvas->translate(blob->bounds().fRight + 10, 0);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "6e12cceca981ddabc0fc18c380543f34",
    "file": "SkTextBlob_Reference",
    "name": "SkTextBlob::uniqueID"
},
    "SkWStream_SizeOfPackedUInt": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::SizeOfPackedUInt"
},
    "SkWStream_bytesWritten": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::bytesWritten"
},
    "SkWStream_destructor": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::~SkWStream()"
},
    "SkWStream_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::SkWStream()"
},
    "SkWStream_flush": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::flush()"
},
    "SkWStream_newline": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::newline()"
},
    "SkWStream_write": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::write()"
},
    "SkWStream_write16": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::write16"
},
    "SkWStream_write32": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::write32"
},
    "SkWStream_write8": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::write8"
},
    "SkWStream_writeBigDecAsText": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::writeBigDecAsText"
},
    "SkWStream_writeBool": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::writeBool"
},
    "SkWStream_writeDecAsText": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::writeDecAsText"
},
    "SkWStream_writeHexAsText": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::writeHexAsText"
},
    "SkWStream_writePackedUInt": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::writePackedUInt"
},
    "SkWStream_writeScalar": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::writeScalar"
},
    "SkWStream_writeScalarAsText": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::writeScalarAsText"
},
    "SkWStream_writeStream": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::writeStream"
},
    "SkWStream_writeText": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkWStream_Reference",
    "name": "SkWStream::writeText"
}
    }
    var canvas
var context
var getFromWeb = true
var mouseDown = false
var scale = .6
var outset = 15
var columnWidth = 256
var maxHeight = 256
var lastLink = null
var lastLinkStr = null
var labelback = {}
var loadedImages = 0
var images = {}
var imagesLength = 0;

function recContains(rec, value) {
    if (!value.length)
        return 0
    var lc = value.toLowerCase()
    if (rec.name.toLowerCase().indexOf(lc) >= 0)
        return 1
    if (rec.code.toLowerCase().indexOf(lc) >= 0)
        return 2
    return 3
}

function setLink(recstr) {
    var under
    var link = recstr
    if (!link.startsWith("Sk")) {
        under = link.indexOf('_')
        link = link.substring(under + 1)
    }
    under = link.lastIndexOf('_')
    var len = link.length
    if (under == len - 2) {
        var letter = link[len - 1]
        if ('a' <= letter && letter <= 'z') {
            link = link.substr(0, len - 2)
        } else if ('0' <= letter && letter <= '9') {
            link = link.substr(0, len - 2)
        }
    }
    lastLinkStr = link
}

function showLink() {
    var link = lastLink.file + '#' + lastLinkStr
    context.save()
    context.font = "normal 16px Arial";
    labelback.w = Math.max(labelback.w, context.measureText(link).width + 8)
    context.beginPath()
    context.rect(labelback.x, labelback.y, labelback.w, labelback.h)
    context.fillStyle = "rgba(232,180,220, 1)"
    context.fill()
    context.fillStyle = "rgba(64,32,48, 1)"
    context.fillText(link, labelback.x + 4, labelback.y + 16)
    context.restore()
}

function imageIterator(callout, state) {
    var row = outset + 30
    var column = outset
    for (var recstr in pngs) {
        var rec = pngs[recstr]
        var contains = recContains(rec, input.value)
        if (3 == contains)
            continue;
        var height = rec.height < maxHeight ? rec.height : maxHeight
        if (callout(state, column, row, height, contains, recstr))
            break;
        row += height + outset
        if (row >= canvas.height / scale) {
            row = 0
            column += columnWidth + outset
            if (column >= canvas.width / scale) {
                break
            }
        }
    }
}

function handleMouseOver(event) {
    var callout = function(state, column, row, height, contains, recstr) {
        if (state.x >= column && state.x <= column + columnWidth &&
                state.y >= row && state.y <= row + height) {
            document.body.style.cursor = "pointer"
            lastLink = pngs[recstr]
            setLink(recstr)
            showLink()
            return true
        }
        return false
    }
    var state = {
        x: (event.clientX - 5) / scale,
        y: (event.clientY - 7) / scale
    }
    document.body.style.cursor = ""
    lastLink = null
    imageIterator(callout, state)
}

function handleMouseClick() {
    if (null != lastLink) {
        var link = 'https://skia.org/user/api/' + lastLink.file + '#' + lastLinkStr
        window.location = link
    }
}

function doKeyPress(evt) {
    idiv.style.height = 20
    input.focus()
}

function drawImage(hash, x, y, w, h, contains) {
    context.save()
    context.transform(scale, 0, 0, scale, 0, 0)
    context.save()
    context.beginPath()
    context.rect(x, y, w, h)
    context.clip()
    context.drawImage(images[hash], x, y)
    context.restore()
    context.beginPath()
    context.rect(x, y, w, h)
    context.strokeStyle = 1 == contains ? "red" : "black"
    context.stroke()
    context.restore()
}

function draw() {
    var callout = function(state, column, row, height, contains, recstr) {
        drawImage(pngs[recstr].hash, column, row, columnWidth, height, contains)
        return false
    }
    imageIterator(callout, null)
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function redraw() {
    context.strokeStyle = "white"
    context.beginPath()
    context.fillStyle = "white"
    context.rect(0, 30, canvas.width, canvas.height)
    context.fill()
    context.rect((256 + outset) * scale, 0, canvas.width, 30)
    context.fill()
    for (var image in images) {
        image.drawn = false
    }
    do {
        draw();
        if (loadedImages >= imagesLength)
            break;
        console.debug(" loadedImages:" + loadedImages + " imagesLength:" + imagesLength)
        await sleep(1000);
    } while (true)
}

function resize() {
    setSize()
    redraw()
}

function setSize() {
    canvas.width = window.innerWidth - 20
    canvas.height = window.innerHeight - 20
    labelback.x = 0
    labelback.y = canvas.height - 20
    labelback.w = 0
    labelback.h = 20
}

function loadImages() {
    for (var recstr in pngs) {
        var rec = pngs[recstr]
        var image = new Image()
        images[rec.hash] = image
        if (getFromWeb)
            image.src = 'https://fiddle.skia.org/i/'
        image.src += rec.hash + '_raster.png'
        image.onload = function () {
            loadedImages += 1
        }
        imagesLength += 1;
    }
}

function start() {
    loadImages()
    window.addEventListener('keypress', doKeyPress, true);
    window.addEventListener('keydown', doKeyPress, true);
    canvas = document.getElementById('canvas')
    context = canvas.getContext('2d')
    resize()
}

</script>
</head>

<body onLoad="start()" onresize="resize()">
<div style="height:0" id="idiv">
<input type="text" id="input" onkeypress="redraw()" onkeydown="redraw()"/>
</div>
<canvas id="canvas" width="750" height="500"
onmousedown="mouseDown = true"
onmouseup="mouseDown = false"
onmousemove="handleMouseOver(event)"
onclick="handleMouseClick()"
></canvas >
</body>
</html>

