<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title></title>

<script type="text/javascript">
    var text = {
        "Path_Conic_Weight": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* verbNames[] = { \"move\", \"line\", \"quad\", \"conic\", \"cubic\", \"close\", \"done\" };\n    const int pointCount[]  = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n    SkPath path;\n    path.conicTo(20, 30, 50, 60, 1);\n    SkPath::Iter iter(path, false);\n    SkPath::Verb verb;\n    do {\n       SkPoint points[4];\n       verb = iter.next(points);\n       SkDebugf(\"%s \", verbNames[(int) verb]);\n       for (int i = 0; i < pointCount[(int) verb]; ++i) {\n            SkDebugf(\"{%g, %g}, \", points[i].fX, points[i].fY);\n       }\n       if (SkPath::kConic_Verb == verb) {\n           SkDebugf(\"weight = %g\", iter.conicWeight());\n       }\n       SkDebugf(\"\\n\");\n    } while (SkPath::kDone_Verb != verb);\n}\n",
    "hash": "2aadded3d20dfef34d1c8abe28c7bc8d",
    "file": "SkPath_Reference",
    "name": "Weight",
        "stdout": "move {0, 0}, \\nquad {0, 0}, {20, 30}, {50, 60}, \\ndone \\n"
    },
        "Path_Conic_Weight_a": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* verbNames[] = { \"move\", \"line\", \"quad\", \"conic\", \"cubic\", \"close\", \"done\" };\n    const int pointCount[]  = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n    SkPath path;\n    path.arcTo(20, 0, 20, 20, 20);\n    SkPath::Iter iter(path, false);\n    SkPath::Verb verb;\n    do {\n       SkPoint points[4];\n       verb = iter.next(points);\n       SkDebugf(\"%s \", verbNames[(int) verb]);\n       for (int i = 0; i < pointCount[(int) verb]; ++i) {\n            SkDebugf(\"{%g, %g}, \", points[i].fX, points[i].fY);\n       }\n       if (SkPath::kConic_Verb == verb) {\n           SkDebugf(\"weight = %g\", iter.conicWeight());\n       }\n       SkDebugf(\"\\n\");\n    } while (SkPath::kDone_Verb != verb);\n}\n",
    "hash": "e88f554efacfa9f75f270fb1c0add5b4",
    "file": "SkPath_Reference",
    "name": "Weight_2",
        "stdout": "move {0, 0}, \\nconic {0, 0}, {20, 0}, {20, 20}, weight = 0.707107\\ndone \\n"
    },
        "Path_Conic_Weight_b": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* verbNames[] = { \"move\", \"line\", \"quad\", \"conic\", \"cubic\", \"close\", \"done\" };\n    const int pointCount[]  = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n    SkPath path;\n    path.conicTo(20, 0, 20, 20, SK_ScalarInfinity);\n    SkPath::Iter iter(path, false);\n    SkPath::Verb verb;\n    do {\n       SkPoint points[4];\n       verb = iter.next(points);\n       SkDebugf(\"%s \", verbNames[(int) verb]);\n       for (int i = 0; i < pointCount[(int) verb]; ++i) {\n            SkDebugf(\"{%g, %g}, \", points[i].fX, points[i].fY);\n       }\n       if (SkPath::kConic_Verb == verb) {\n           SkDebugf(\"weight = %g\", iter.conicWeight());\n       }\n       SkDebugf(\"\\n\");\n    } while (SkPath::kDone_Verb != verb);\n}\n",
    "hash": "6fb11419e99297fe2fe666c296117fb9",
    "file": "SkPath_Reference",
    "name": "Weight_3",
        "stdout": "move {0, 0}, \\nline {0, 0}, {20, 0}, \\nline {20, 0}, {20, 20}, \\ndone \\n"
    },
        "SkAutoCanvasRestore_restore": {
    "code": "void draw(SkCanvas* canvas) {\n    for (bool callRestore : { false, true } ) {\n        for (bool saveCanvas : {false, true} ) {\n            SkAutoCanvasRestore autoRestore(canvas, saveCanvas);\n            if (!saveCanvas) {\n                canvas->save();\n            }\n            SkDebugf(\"saveCanvas: %s  before restore: %d\\n\",\n                   saveCanvas ? \"true\" : \"false\", canvas->getSaveCount());\n            if (callRestore) autoRestore.restore();\n            SkDebugf(\"saveCanvas: %s  after restore: %d\\n\",\n                   saveCanvas ? \"true\" : \"false\", canvas->getSaveCount());\n        }\n    }\n    SkDebugf(\"final count: %d\\n\", canvas->getSaveCount());\n}",
    "hash": "9f459b218ec079c1ada23f4412968f9a",
    "file": "SkAutoCanvasRestore_Reference",
    "name": "SkAutoCanvasRestore::restore()",
        "stdout": "saveCanvas: false  before restore: 2\\nsaveCanvas: false  after restore: 2\\nsaveCanvas: true  before restore: 2\\nsaveCanvas: true  after restore: 2\\nsaveCanvas: false  before restore: 2\\nsaveCanvas: false  after restore: 1\\nsaveCanvas: true  before restore: 2\\nsaveCanvas: true  after restore: 1\\nfinal count: 1\\n"
    },
        "SkBitmap_ComputeIsOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::Make(2, 2, kN32_SkColorType, kPremul_SkAlphaType));\n    for (int index = 0; index < 2; ++index) {\n        bitmap.allocPixels();\n        bitmap.eraseColor(0x00000000);\n        SkDebugf(\"computeIsOpaque: %s\\n\", SkBitmap::ComputeIsOpaque(bitmap) ? \"true\" : \"false\");\n        bitmap.eraseColor(0xFFFFFFFF);\n        SkDebugf(\"computeIsOpaque: %s\\n\", SkBitmap::ComputeIsOpaque(bitmap) ? \"true\" : \"false\");\n        bitmap.setInfo(bitmap.info().makeAlphaType(kOpaque_SkAlphaType));\n    }\n}",
    "hash": "9df1baa17658fbd0c419780f26fd854f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::ComputeIsOpaque",
        "stdout": "computeIsOpaque: false\\ncomputeIsOpaque: true\\ncomputeIsOpaque: false\\ncomputeIsOpaque: true\\n"
    },
        "SkBitmap_HeapAllocator_allocPixelRef": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(16, 16, kPremul_SkAlphaType));\n    SkDebugf(\"pixel address = %p\\n\", bitmap.getPixels());\n    SkBitmap::HeapAllocator stdalloc;\n    if (!stdalloc.allocPixelRef(&bitmap)) {\n        SkDebugf(\"pixel allocation failed\\n\");\n    } else {\n        SkDebugf(\"pixel address = %p\\n\", bitmap.getPixels());\n    }\n}",
    "hash": "fe79a9c1ec350264eb9c7b2509dd3638",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::HeapAllocator::allocPixelRef",
        "stdout": "pixel address = (nil)\\npixel address = 0x560ddd0ac670\\n"
    },
        "SkBitmap_alphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);\n    SkDebugf(\"alpha type: k\" \"%s\" \"_SkAlphaType\\n\", alphas[pixmap.alphaType()]);\n}",
    "hash": "070b1a60232be499eb10c6ea62371804",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::alphaType",
        "stdout": "alpha type: kPremul_SkAlphaType\\n"
    },
        "SkBitmap_bytesPerPixel": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkImageInfo info = SkImageInfo::MakeA8(1, 1);\n    SkBitmap bitmap;\n    for (SkColorType colorType : { kUnknown_SkColorType,     kAlpha_8_SkColorType,\n                                   kRGB_565_SkColorType,     kARGB_4444_SkColorType, \n                                   kRGBA_8888_SkColorType,\n                                   kBGRA_8888_SkColorType,   kGray_8_SkColorType,\n                                   kRGBA_F16_SkColorType } ) {\n        bitmap.setInfo(info.makeColorType(colorType));\n        SkDebugf(\"color: k\" \"%s\" \"_SkColorType\" \"%*s\" \"bytesPerPixel: %d\\n\",\n                colors[colorType], 13 - strlen(colors[colorType]), \" \",\n                bitmap.bytesPerPixel());\n    }\n}",
    "hash": "4bfe28ea3f70f3bfd73d956e913c1a20",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::bytesPerPixel",
        "stdout": "color: kUnknown_SkColorType      bytesPerPixel: 0\\ncolor: kAlpha_8_SkColorType      bytesPerPixel: 1\\ncolor: kRGB_565_SkColorType      bytesPerPixel: 2\\ncolor: kARGB_4444_SkColorType    bytesPerPixel: 2\\ncolor: kRGBA_8888_SkColorType    bytesPerPixel: 4\\ncolor: kBGRA_8888_SkColorType    bytesPerPixel: 4\\ncolor: kGray_8_SkColorType       bytesPerPixel: 1\\ncolor: kRGBA_F16_SkColorType     bytesPerPixel: 8\\n"
    },
        "SkBitmap_colorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType, \n            SkColorSpace::MakeSRGBLinear()));\n    SkColorSpace* colorSpace = bitmap.colorSpace();\n    SkDebugf(\"gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\\n\",\n            colorSpace->gammaCloseToSRGB() ? \"true\" : \"false\",\n            colorSpace->gammaIsLinear() ? \"true\" : \"false\",\n            colorSpace->isSRGB() ? \"true\" : \"false\");\n}",
    "hash": "7ade8a1a21ea5197e565c86740b47b73",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::colorSpace",
        "stdout": "gammaCloseToSRGB: false  gammaIsLinear: true  isSRGB: false\\n"
    },
        "SkBitmap_colorType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeA8(16, 32));\n    SkDebugf(\"color type: k\" \"%s\" \"_SkColorType\\n\", colors[bitmap.colorType()]);\n}",
    "hash": "ceb77fab7326b57822a147b04aa0960e",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::colorType",
        "stdout": "color type: kAlpha_8_SkColorType\\n"
    },
        "SkBitmap_computeByteSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    for (int width : { 1, 1000, 1000000 } ) {\n        for (int height: { 1, 1000, 1000000 } ) {\n            SkImageInfo imageInfo = SkImageInfo::MakeN32(width, height, kPremul_SkAlphaType);\n            bitmap.setInfo(imageInfo, width * 5);\n            SkDebugf(\"width: %7d height: %7d computeByteSize: %13lld\\n\", width, height,\n                     bitmap.computeByteSize());\n        }\n    }\n}",
    "hash": "165c8f208829fc0908e8a50da60c0076",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::computeByteSize",
        "stdout": "width:       1 height:       1 computeByteSize:             4\\nwidth:       1 height:    1000 computeByteSize:          4999\\nwidth:       1 height: 1000000 computeByteSize:       4999999\\nwidth:    1000 height:       1 computeByteSize:          4000\\nwidth:    1000 height:    1000 computeByteSize:       4999000\\nwidth:    1000 height: 1000000 computeByteSize:    4999999000\\nwidth: 1000000 height:       1 computeByteSize:       4000000\\nwidth: 1000000 height:    1000 computeByteSize:    4999000000\\nwidth: 1000000 height: 1000000 computeByteSize: 4999999000000\\n"
    },
        "SkBitmap_copy_const_SkBitmap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original;\n    original.tryAllocPixels(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));\n    SkDebugf(\"original has pixels before copy: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n    SkBitmap copy(original);  \n    SkDebugf(\"original has pixels after copy: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n    SkDebugf(\"copy has pixels: %s\\n\", copy.getPixels() ? \"true\" : \"false\");\n}\n",
    "hash": "dbf46a0b60324ec611cc18d86772e7b9",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::SkBitmap(const SkBitmap& src)",
        "stdout": "original has pixels before copy: true\\noriginal has pixels after copy: true\\ncopy has pixels: true\\n"
    },
        "SkBitmap_copy_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original;\n    original.tryAllocPixels(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));\n    SkDebugf(\"original has pixels before copy: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n    SkBitmap copy = original;  \n    SkDebugf(\"original has pixels after copy: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n    SkDebugf(\"copy has pixels: %s\\n\", copy.getPixels() ? \"true\" : \"false\");\n}\n",
    "hash": "6366fa1b1b3df1bebbfa3ed1c5a43457",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::operator=(const SkBitmap& src)",
        "stdout": "original has pixels before copy: true\\noriginal has pixels after copy: true\\ncopy has pixels: true\\n"
    },
        "SkBitmap_dimensions": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(33, 55, kOpaque_SkAlphaType));\n    SkISize dimensions = bitmap.dimensions();\n    SkRect bounds;\n    bitmap.getBounds(&bounds);\n    SkRect dimensionsAsBounds = SkRect::Make(dimensions);\n    SkDebugf(\"dimensionsAsBounds %c= bounds\\n\", dimensionsAsBounds == bounds ? '=' : '!');\n}",
    "hash": "647056bcc12c27fb4413f212f33a2898",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::dimensions()",
        "stdout": "dimensionsAsBounds == bounds\\n"
    },
        "SkBitmap_drawsNothing": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    for (int w : { 0, 8 } ) {\n        for (bool allocate : { false, true} ) {\n            bitmap.setInfo(SkImageInfo::MakeA8(w, 8));\n            allocate ? bitmap.allocPixels() : (void) 0 ;\n            SkDebugf(\"empty:%s isNull:%s drawsNothing:%s\\n\", bitmap.empty() ? \"true \" : \"false\",\n                     bitmap.isNull() ? \"true \" : \"false\", bitmap.drawsNothing() ? \"true\" : \"false\");\n        }\n    }\n}",
    "hash": "daacf43394ce4045a362a48b5774deed",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::drawsNothing",
        "stdout": "empty:true  isNull:true  drawsNothing:true\\nempty:true  isNull:false drawsNothing:true\\nempty:false isNull:true  drawsNothing:true\\nempty:false isNull:false drawsNothing:false\\n"
    },
        "SkBitmap_empty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    for (int width : { 0, 2 } ) {\n        for (int height : { 0, 2 } ) {\n             bitmap.setInfo(SkImageInfo::MakeA8(width, height));\n             SkDebugf(\"width: %d height: %d empty: %s\\n\", width, height,\n                      bitmap.empty() ? \"true\" : \"false\");\n        }\n    }\n}",
    "hash": "a3762c2722b56ba55e42689c527f146c",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::empty()",
        "stdout": "width: 0 height: 0 empty: true\\nwidth: 0 height: 2 empty: true\\nwidth: 2 height: 0 empty: true\\nwidth: 2 height: 2 empty: false\\n"
    },
        "SkBitmap_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkBitmap bitmap;\n    for (int i = 0; i < 2; ++i) {\n       SkDebugf(\"width: %2d  height: %2d\", bitmap.width(), bitmap.height());\n       SkDebugf(\"  color: k%s_SkColorType\", colors[bitmap.colorType()]);\n       SkDebugf(\"  alpha: k%s_SkAlphaType\\n\", alphas[bitmap.alphaType()]);\n       bitmap.setInfo(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType),\n                      0);\n    }\n}\n",
    "hash": "6739d14ec0d6a373f2fcadc6b3077fd4",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::SkBitmap()",
        "stdout": "width:  0  height:  0  color: kUnknown_SkColorType  alpha: kUnknown_SkAlphaType\\nwidth: 25  height: 35  color: kRGBA_8888_SkColorType  alpha: kOpaque_SkAlphaType\\n"
    },
        "SkBitmap_extractSubset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect bounds, s;\n    source.getBounds(&bounds);\n    SkDebugf(\"bounds: %d, %d, %d, %d\\n\", bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    SkBitmap subset;\n    for (int left: { -100, 0, 100, 1000 } ) {\n         for (int right: { 0, 100, 1000 } ) {\n             SkIRect b = SkIRect::MakeLTRB(left, 100, right, 200);\n             bool success = source.extractSubset(&subset, b);\n             SkDebugf(\"subset: %4d, %4d, %4d, %4d  \", b.fLeft, b.fTop, b.fRight, b.fBottom);\n             SkDebugf(\"success; %s\", success ? \"true\" : \"false\");\n             if (success) {\n                 subset.getBounds(&s);  \n                 SkDebugf(\"  subset: %d, %d, %d, %d\", s.fLeft, s.fTop, s.fRight, s.fBottom);\n             }\n             SkDebugf(\"\\n\");\n         } \n    }\n}",
    "hash": "3ad80d8fcb13344612f361812658b696",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::extractSubset",
        "stdout": "bounds: 0, 0, 512, 512\\nsubset: -100,  100,    0,  200  success; false\\nsubset: -100,  100,  100,  200  success; true  subset: 0, 0, 100, 100\\nsubset: -100,  100, 1000,  200  success; true  subset: 0, 0, 512, 100\\nsubset:    0,  100,    0,  200  success; false\\nsubset:    0,  100,  100,  200  success; true  subset: 0, 0, 100, 100\\nsubset:    0,  100, 1000,  200  success; true  subset: 0, 0, 512, 100\\nsubset:  100,  100,    0,  200  success; false\\nsubset:  100,  100,  100,  200  success; false\\nsubset:  100,  100, 1000,  200  success; true  subset: 0, 0, 412, 100\\nsubset: 1000,  100,    0,  200  success; false\\nsubset: 1000,  100,  100,  200  success; false\\nsubset: 1000,  100, 1000,  200  success; false\\n"
    },
        "SkBitmap_getAddr": {
    "code": "void draw(SkCanvas* canvas) {\n    char* row0 = (char* ) source.getAddr(0, 0);\n    char* row1 = (char* ) source.getAddr(0, 1);\n    SkDebugf(\"addr interval %c= rowBytes\\n\", row1 - row0 == source.rowBytes() ? '=' : '!');\n}",
    "hash": "bd0e0adb48b16d75129092649eab1617",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getAddr",
        "stdout": "addr interval == rowBytes\\n"
    },
        "SkBitmap_getAddr16": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap16;\n    SkImageInfo dstInfo = SkImageInfo::Make(source.width(), source.height(), kARGB_4444_SkColorType, \n                     kPremul_SkAlphaType);\n    bitmap16.allocPixels(dstInfo);\n    if (source.readPixels(dstInfo, bitmap16.getPixels(), bitmap16.rowBytes(), 0, 0)) {\n        uint16_t* row0 = bitmap16.getAddr16(0, 0);\n        uint16_t* row1 = bitmap16.getAddr16(0, 1);\n        size_t interval = (row1 - row0) * bitmap16.bytesPerPixel();\n        SkDebugf(\"addr interval %c= rowBytes\\n\", interval == bitmap16.rowBytes() ? '=' : '!');\n    }\n}",
    "hash": "3d7e49d428c9a4812558b39cf505baa6",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getAddr16",
        "stdout": "addr interval == rowBytes\\n"
    },
        "SkBitmap_getAddr32": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t* row0 = source.getAddr32(0, 0);\n    uint32_t* row1 = source.getAddr32(0, 1);\n    size_t interval = (row1 - row0) * source.bytesPerPixel();\n    SkDebugf(\"addr interval %c= rowBytes\\n\", interval == source.rowBytes() ? '=' : '!');\n}",
    "hash": "837a2bcc9fb9ce617a3420956cefc64a",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getAddr32",
        "stdout": "addr interval == rowBytes\\n"
    },
        "SkBitmap_getAddr8": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    const int width = 8;\n    const int height = 8;\n    uint8_t pixels[height][width];\n    SkImageInfo info = SkImageInfo::Make(width, height, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    if (bitmap.installPixels(info, pixels, info.minRowBytes())) {\n        SkDebugf(\"&pixels[4][2] %c= bitmap.getAddr8(2, 4)\\n\",\n                  &pixels[4][2]  == bitmap.getAddr8(2, 4) ? '=' : '!');\n    }\n}",
    "hash": "cb9a08e8ff779b6a1cf8bb54f3883aaf",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getAddr8",
        "stdout": "\\u0026pixels[4][2] == bitmap.getAddr8(2, 4)\\n"
    },
        "SkBitmap_getColor": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    SkColor colors[][w] = {\n        0x00000000, 0x2a0e002a, 0x55380055, 0x7f7f007f,\n        0x2a000e2a, 0x551c1c55, 0x7f542a7f, 0xaaaa38aa,\n        0x55003855, 0x7f2a547f, 0xaa7171aa, 0xd4d48dd4,\n        0x7f007f7f, 0xaa38aaaa, 0xd48dd4d4, 0xffffffff, \n    };\n    SkDebugf(\"Premultiplied:\\n\");\n    for (int y = 0; y < h; ++y) {\n        SkDebugf(\"(0, %d) \", y);\n        for (int x = 0; x < w; ++x) {\n            SkDebugf(\"0x%08x%c\", colors[y][x], x == w - 1 ? '\\n' : ' ');\n        }\n    }\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), colors, w * 4);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    SkDebugf(\"Unpremultiplied:\\n\");\n    for (int y = 0; y < h; ++y) {\n        SkDebugf(\"(0, %d) \", y);\n        for (int x = 0; x < w; ++x) {\n            SkDebugf(\"0x%08x%c\", bitmap.getColor(x, y), x == w - 1 ? '\\n' : ' ');\n        }\n    }\n}",
    "hash": "2e49fa71dd4be95470248ea6eb35468b",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getColor",
        "stdout": "Premultiplied:\\n(0, 0) 0x00000000 0x2a0e002a 0x55380055 0x7f7f007f\\n(0, 1) 0x2a000e2a 0x551c1c55 0x7f542a7f 0xaaaa38aa\\n(0, 2) 0x55003855 0x7f2a547f 0xaa7171aa 0xd4d48dd4\\n(0, 3) 0x7f007f7f 0xaa38aaaa 0xd48dd4d4 0xffffffff\\nUnpremultiplied:\\n(0, 0) 0x00000000 0x2a5500ff 0x55a800ff 0x7fff00ff\\n(0, 1) 0x2a0055ff 0x555454ff 0x7fa954ff 0xaaff54ff\\n(0, 2) 0x5500a8ff 0x7f54a9ff 0xaaaaaaff 0xd4ffaaff\\n(0, 3) 0x7f00ffff 0xaa54ffff 0xd4aaffff 0xffffffff\\n"
    },
        "SkBitmap_getGenerationID": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    SkDebugf(\"empty id %u\\n\", bitmap.getGenerationID());\n    bitmap.allocPixels(SkImageInfo::MakeN32(64, 64, kOpaque_SkAlphaType));\n    SkDebugf(\"alloc id %u\\n\", bitmap.getGenerationID());\n    bitmap.eraseColor(SK_ColorRED);\n    SkDebugf(\"erase id %u\\n\", bitmap.getGenerationID());\n}",
    "hash": "db9dd91e0207c3941c09538555817b4b",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getGenerationID",
        "stdout": "empty id 0\\nalloc id 4\\nerase id 6\\n"
    },
        "SkBitmap_getPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(4, 4, kPremul_SkAlphaType));\n    bitmap.allocPixels();\n    bitmap.eraseColor(0x00000000);\n    void* baseAddr = bitmap.getPixels();\n    *(SkPMColor*)baseAddr = 0xFFFFFFFF;\n    SkDebugf(\"bitmap.getColor(0, 1) %c= 0x00000000\\n\",\n              bitmap.getColor(0, 1)  == 0x00000000 ? '=' : '!');\n    SkDebugf(\"bitmap.getColor(0, 0) %c= 0xFFFFFFFF\\n\",\n              bitmap.getColor(0, 0)  == 0xFFFFFFFF ? '=' : '!');\n}",
    "hash": "e006bb05cf74ec8d2b3d6adeb5dba11b",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getPixels",
        "stdout": "bitmap.getColor(0, 1) == 0x00000000\\nbitmap.getColor(0, 0) == 0xFFFFFFFF\\n"
    },
        "SkBitmap_getSubset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect bounds;\n    source.getBounds(&bounds);\n    bounds.inset(100, 100);\n    SkBitmap subset;\n    source.extractSubset(&subset, bounds);\n    SkIRect r = source.getSubset();\n    SkDebugf(\"source: %d, %d, %d, %d\\n\", r.fLeft, r.fTop, r.fRight, r.fBottom);\n    r = subset.getSubset();\n    SkDebugf(\"subset: %d, %d, %d, %d\\n\", r.fLeft, r.fTop, r.fRight, r.fBottom);\n}",
    "hash": "d6dd0b425aa550f21b938a18c2e1a981",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getSubset",
        "stdout": "source: 0, 0, 512, 512\\nsubset: 100, 100, 412, 412\\n"
    },
        "SkBitmap_height": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeA8(16, 32);\n    SkBitmap bitmap;\n    bitmap.setInfo(info);\n    SkDebugf(\"bitmap height: %d  info height: %d\\n\", bitmap.height(), info.height());\n}",
    "hash": "c79a196278c58b34cd5f551b0124ecc9",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::height()",
        "stdout": "bitmap height: 32  info height: 32\\n"
    },
        "SkBitmap_info": {
    "code": "void draw(SkCanvas* canvas) {\n    // SkBitmap source;  // pre-populated with soccer ball by fiddle.skia.org\n    const SkImageInfo& info = source.info();\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkDebugf(\"width: %d height: %d color: %s alpha: %s\\n\", info.width(), info.height(),\n                colors[info.colorType()], alphas[info.alphaType()]);\n}\n",
    "hash": "ec47c4dc23e2925ad565eaba55a91553",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::info()",
        "stdout": "width: 56 height: 56 color: BGRA_8888 alpha: Opaque\\n"
    },
        "SkBitmap_installPixels": {
    "code": "static void releaseProc(void* addr, void* ) {\n    SkDebugf(\"releaseProc called\\n\");\n    delete[] (uint32_t*) addr; \n}\n\nvoid draw(SkCanvas* canvas) {\n   SkBitmap bitmap;\n   void* pixels = new uint32_t[8 * 8];\n   SkImageInfo info = SkImageInfo::MakeN32(8, 8, kOpaque_SkAlphaType);\n   SkDebugf(\"before installPixels\\n\");\n   bool installed = bitmap.installPixels(info, pixels, 16, releaseProc, nullptr);\n   SkDebugf(\"install \" \"%s\" \"successful\\n\", installed ? \"\" : \"not \");\n}\n",
    "hash": "ff5b5c349efb5d929ff5dff07b7727e6",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::installPixels",
        "stdout": "before installPixels\\nreleaseProc called\\ninstall not successful\\n"
    },
        "SkBitmap_isImmutable": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original; \n    SkImageInfo info = SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType);\n    if (original.tryAllocPixels(info)) {\n        original.setImmutable();\n        SkBitmap copy;\n        original.extractSubset(&copy, {5, 10, 15, 20});  \n        SkDebugf(\"original is \" \"%s\" \"immutable\\n\", original.isImmutable() ? \"\" : \"not \");\n        SkDebugf(\"copy is \" \"%s\" \"immutable\\n\", copy.isImmutable() ? \"\" : \"not \");\n    }\n}",
    "hash": "cca4f94232e5e1fcee9a841b13df9d9c",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::isImmutable",
        "stdout": "original is immutable\\ncopy is immutable\\n"
    },
        "SkBitmap_isNull": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    SkDebugf(\"empty bitmap does %shave pixels\\n\", bitmap.isNull() ? \"not \" : \"\");\n    bitmap.setInfo(SkImageInfo::MakeA8(8, 8));\n    SkDebugf(\"bitmap with dimensions does %shave pixels\\n\", bitmap.isNull() ? \"not \" : \"\");\n    bitmap.allocPixels();\n    SkDebugf(\"allocated bitmap does %shave pixels\\n\", bitmap.isNull() ? \"not \" : \"\");\n}",
    "hash": "211ec89418011aa6e54aa2cc9567e003",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::isNull",
        "stdout": "empty bitmap does not have pixels\\nbitmap with dimensions does not have pixels\\nallocated bitmap does have pixels\\n"
    },
        "SkBitmap_isOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    const int height = 2;\n    const int width = 2;\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::Make(width, height, kN32_SkColorType, kPremul_SkAlphaType));\n    for (int index = 0; index < 2; ++index) {\n        bitmap.allocPixels();\n        bitmap.eraseColor(0x00000000);\n        SkDebugf(\"isOpaque: %s\\n\", bitmap.isOpaque() ? \"true\" : \"false\");\n        bitmap.eraseColor(0xFFFFFFFF);\n        SkDebugf(\"isOpaque: %s\\n\", bitmap.isOpaque() ? \"true\" : \"false\");\n        bitmap.setInfo(bitmap.info().makeAlphaType(kOpaque_SkAlphaType));\n    }\n}",
    "hash": "5e76b68bb46d54315eb0c12d83bd6949",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::isOpaque",
        "stdout": "isOpaque: false\\nisOpaque: false\\nisOpaque: true\\nisOpaque: true\\n"
    },
        "SkBitmap_isVolatile": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original; \n    SkImageInfo info = SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType);\n    if (original.tryAllocPixels(info)) {\n        original.setIsVolatile(true);\n        SkBitmap copy;\n        original.extractSubset(&copy, {5, 10, 15, 20});  \n        SkDebugf(\"original is \" \"%s\" \"volatile\\n\", original.isVolatile() ? \"\" : \"not \");\n        SkDebugf(\"copy is \" \"%s\" \"volatile\\n\", copy.isImmutable() ? \"\" : \"not \");\n    }\n}",
    "hash": "4f3e4d39cf34ea52fcd933dbafc46dfa",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::isVolatile",
        "stdout": "original is volatile\\ncopy is not volatile\\n"
    },
        "SkBitmap_move_SkBitmap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original;\n    original.tryAllocPixels(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));\n    SkDebugf(\"original has pixels before move: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n    SkBitmap copy(std::move(original));  \n    SkDebugf(\"original has pixels after move: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n    SkDebugf(\"copy has pixels: %s\\n\", copy.getPixels() ? \"true\" : \"false\");\n}\n",
    "hash": "8172a14e66cb763b7133f70dc4ff601e",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::SkBitmap(SkBitmap&& src)",
        "stdout": "original has pixels before move: true\\noriginal has pixels after move: false\\ncopy has pixels: true\\n"
    },
        "SkBitmap_move_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap original;\n    original.tryAllocPixels(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));\n    SkDebugf(\"original has pixels before move: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n    SkBitmap copy = std::move(original);  \n    SkDebugf(\"original has pixels after move: %s\\n\", original.getPixels() ? \"true\" : \"false\");\n    SkDebugf(\"copy has pixels: %s\\n\", copy.getPixels() ? \"true\" : \"false\");\n}\n",
    "hash": "5066583054077df5098bb1d2aa402149",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::operator=(SkBitmap&& src)",
        "stdout": "original has pixels before move: true\\noriginal has pixels after move: false\\ncopy has pixels: true\\n"
    },
        "SkBitmap_peekPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(6, 11));\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorWHITE);\n    SkPaint paint;\n    offscreen.drawString(\"?\", 0, 10, paint);\n    SkPixmap pixmap;\n    if (bitmap.peekPixels(&pixmap)) {\n        const SkPMColor* pixels = pixmap.addr32();\n        SkPMColor pmWhite = pixels[0];\n        for (int y = 0; y < bitmap.height(); ++y) {\n            for (int x = 0; x < bitmap.width(); ++x) {\n                SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n            }\n            SkDebugf(\"\\n\");\n        }\n    }\n}",
    "hash": "0cc2c6a0dffa61a88711534bd3d43b40",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::peekPixels",
        "stdout": "------\\n-xxx--\\nx---x-\\n----x-\\n---x--\\n--x---\\n--x---\\n------\\n--x---\\n--x---\\n------\\n"
    },
        "SkBitmap_pixelRef": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap subset;\n    source.extractSubset(&subset, SkIRect::MakeXYWH(32, 64, 128, 256));\n    SkDebugf(\"src ref %c= sub ref\\n\", source.pixelRef() == subset.pixelRef() ? '=' : '!');\n    SkDebugf(\"src pixels %c= sub pixels\\n\", source.getPixels() == subset.getPixels() ? '=' : '!');\n    SkDebugf(\"src addr %c= sub addr\\n\", source.getAddr(32, 64) == subset.getAddr(0, 0) ? '=' : '!');\n}",
    "hash": "5db2d30870a7cc45f28e22578d1880c3",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::pixelRef",
        "stdout": "src ref == sub ref\\nsrc pixels != sub pixels\\nsrc addr == sub addr\\n"
    },
        "SkBitmap_pixelRefOrigin": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap subset;\n    source.extractSubset(&subset, SkIRect::MakeXYWH(32, 64, 128, 256));\n    SkIPoint sourceOrigin = source.pixelRefOrigin();\n    SkIPoint subsetOrigin = subset.pixelRefOrigin();\n    SkDebugf(\"source origin: %d, %d\\n\", sourceOrigin.fX, sourceOrigin.fY);\n    SkDebugf(\"subset origin: %d, %d\\n\", subsetOrigin.fX, subsetOrigin.fY);\n}",
    "hash": "6d31686c6c0829c70f284ae716526d6a",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::pixelRefOrigin",
        "stdout": "source origin: 0, 0\\nsubset origin: 32, 64\\n"
    },
        "SkBitmap_pixmap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(10, 11));\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorWHITE);\n    SkPaint paint;\n    offscreen.drawString(\"&\", 0, 10, paint);\n    const SkPixmap& pixmap = bitmap.pixmap();\n    if (pixmap.addr()) {\n        SkPMColor pmWhite = *pixmap.addr32(0, 0);\n        for (int y = 0; y < pixmap.height(); ++y) {\n            for (int x = 0; x < pixmap.width(); ++x) {\n                SkDebugf(\"%c\", *pixmap.addr32(x, y) == pmWhite ? '-' : 'x');\n            }\n            SkDebugf(\"\\n\");\n        }\n    }\n}",
    "hash": "7f972d742dd78d2500034d8867e9ef2f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::pixmap()",
        "stdout": "----------\\n---xx-----\\n--x--x----\\n--x-------\\n--xx------\\n--x-x---x-\\n-x---x--x-\\n-x----xx--\\n-xx---x---\\n--xxxx-xx-\\n----------\\n"
    },
        "SkBitmap_refColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap1, bitmap2;\n    bitmap1.setInfo(SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType, \n            SkColorSpace::MakeSRGBLinear()));\n    bitmap2.setInfo(SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,\n            bitmap1.refColorSpace()));\n    SkColorSpace* colorSpace = bitmap2.colorSpace();\n    SkDebugf(\"gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\\n\",\n            colorSpace->gammaCloseToSRGB() ? \"true\" : \"false\",\n            colorSpace->gammaIsLinear() ? \"true\" : \"false\",\n            colorSpace->isSRGB() ? \"true\" : \"false\");\n}",
    "hash": "972e9bb22c1ce94bb97b2d106168280e",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::refColorSpace",
        "stdout": "gammaCloseToSRGB: false  gammaIsLinear: true  isSRGB: false\\n"
    },
        "SkBitmap_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap; \n    bitmap.setInfo(SkImageInfo::Make(1, 1, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));\n    bitmap.allocPixels();\n    SkDebugf(\"width:%d height:%d isNull:%s\\n\", bitmap.width(), bitmap.height(),\n             bitmap.isNull() ? \"true\" : \"false\");\n    bitmap.reset();\n    SkDebugf(\"width:%d height:%d isNull:%s\\n\", bitmap.width(), bitmap.height(),\n             bitmap.isNull() ? \"true\" : \"false\");\n}",
    "hash": "458f838acf38302abec477cec3102f0f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::reset()",
        "stdout": "width:1 height:1 isNull:false\\nwidth:0 height:0 isNull:true\\n"
    },
        "SkBitmap_rowBytes": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    for (int rowBytes : { 2, 8 } ) {\n        bool result = bitmap.setInfo(SkImageInfo::MakeA8(4, 4), rowBytes);\n        SkDebugf(\"setInfo returned:%s rowBytes:%d\\n\", result ? \"true \" : \"false\", bitmap.rowBytes());\n     }\n}",
    "hash": "a654fd0b73f424859ae6c95e03f55099",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::rowBytes",
        "stdout": "setInfo returned:false rowBytes:0\\nsetInfo returned:true  rowBytes:8\\n"
    },
        "SkBitmap_rowBytesAsPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    for (int rowBytes : { 4, 5, 6, 7, 8} ) {\n        bitmap.setInfo(SkImageInfo::MakeN32(1, 1, kPremul_SkAlphaType), rowBytes);\n        SkDebugf(\"rowBytes: %d rowBytesAsPixels: %d\\n\", rowBytes, bitmap.rowBytesAsPixels());\n    }\n}",
    "hash": "03a9e08082a23a98de17c3e24871d61a",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::rowBytesAsPixels",
        "stdout": "rowBytes: 4 rowBytesAsPixels: 1\\nrowBytes: 5 rowBytesAsPixels: 1\\nrowBytes: 6 rowBytesAsPixels: 1\\nrowBytes: 7 rowBytesAsPixels: 1\\nrowBytes: 8 rowBytesAsPixels: 2\\n"
    },
        "SkBitmap_setAlphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = { \"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                             \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\" };\n    const char* alphas[] = {\"Unknown \", \"Opaque  \", \"Premul  \", \"Unpremul\"}; \n    SkBitmap bitmap;\n    SkAlphaType alphaTypes[] = { kUnknown_SkAlphaType, kOpaque_SkAlphaType,\n                                 kPremul_SkAlphaType, kUnpremul_SkAlphaType };\n    SkDebugf(\"%88s\", \"Canonical    Unknown           Opaque            Premul            Unpremul\\n\");\n    for (SkColorType colorType : { kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType,\n                            kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kBGRA_8888_SkColorType, \n                            kGray_8_SkColorType, kRGBA_F16_SkColorType } ) {\n        for (SkAlphaType canonicalAlphaType : alphaTypes) {\n            SkColorTypeValidateAlphaType(colorType, kUnknown_SkAlphaType, &canonicalAlphaType );\n            SkDebugf(\"%10s %10s \", colors[(int) colorType], alphas[(int) canonicalAlphaType ]);\n            for (SkAlphaType alphaType : alphaTypes) {\n                bitmap.setInfo(SkImageInfo::Make(4, 4, colorType, canonicalAlphaType));\n                bool result = bitmap.setAlphaType(alphaType);\n                SkDebugf(\"%s %s    \", result ? \"true \" : \"false\", alphas[(int) bitmap.alphaType()]);\n            }\n            SkDebugf(\"\\n\");\n        }\n    }\n}\n",
    "hash": "9394975fa8a13204a5cc2e94f86737e5",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setAlphaType",
        "stdout": "Canonical    Unknown           Opaque            Premul            Unpremul\\n   Unknown   Unknown  true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n   Unknown   Unknown  true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n   Unknown   Unknown  true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n   Unknown   Unknown  true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n   Alpha_8   Unknown  true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n   Alpha_8   Opaque   false Opaque      true  Opaque      true  Premul      true  Premul      \\n   Alpha_8   Premul   false Premul      true  Opaque      true  Premul      true  Premul      \\n   Alpha_8   Unpremul false Premul      true  Opaque      true  Premul      true  Premul      \\n   RGB_565   Opaque   true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n   RGB_565   Opaque   true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n   RGB_565   Opaque   true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n   RGB_565   Opaque   true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n ARGB_4444   Unknown  true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n ARGB_4444   Opaque   false Opaque      true  Opaque      true  Premul      true  Unpremul    \\n ARGB_4444   Premul   false Premul      true  Opaque      true  Premul      true  Unpremul    \\n ARGB_4444   Unpremul false Unpremul    true  Opaque      true  Premul      true  Unpremul    \\n RGBA_8888   Unknown  true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n RGBA_8888   Opaque   false Opaque      true  Opaque      true  Premul      true  Unpremul    \\n RGBA_8888   Premul   false Premul      true  Opaque      true  Premul      true  Unpremul    \\n RGBA_8888   Unpremul false Unpremul    true  Opaque      true  Premul      true  Unpremul    \\n BGRA_8888   Unknown  true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n BGRA_8888   Opaque   false Opaque      true  Opaque      true  Premul      true  Unpremul    \\n BGRA_8888   Premul   false Premul      true  Opaque      true  Premul      true  Unpremul    \\n BGRA_8888   Unpremul false Unpremul    true  Opaque      true  Premul      true  Unpremul    \\n    Gray_8   Opaque   true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n    Gray_8   Opaque   true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n    Gray_8   Opaque   true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n    Gray_8   Opaque   true  Opaque      true  Opaque      true  Opaque      true  Opaque      \\n  RGBA_F16   Unknown  true  Unknown     true  Unknown     true  Unknown     true  Unknown     \\n  RGBA_F16   Opaque   false Opaque      true  Opaque      true  Premul      true  Unpremul    \\n  RGBA_F16   Premul   false Premul      true  Opaque      true  Premul      true  Unpremul    \\n  RGBA_F16   Unpremul false Unpremul    true  Opaque      true  Premul      true  Unpremul    \\n"
    },
        "SkBitmap_setImmutable": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(4, 4, kPremul_SkAlphaType));\n    bitmap.allocPixels();\n    SkCanvas offscreen(bitmap);\n    SkDebugf(\"draw white\\n\");\n    offscreen.clear(SK_ColorWHITE);\n    bitmap.setImmutable();\n    SkDebugf(\"draw black\\n\");\n    offscreen.clear(SK_ColorBLACK);\n}",
    "hash": "9210060d1f4ca46e1375496237902ef3",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setImmutable",
        "stdout": "draw white\\ndraw black\\n"
    },
        "SkBitmap_shiftPerPixel": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkImageInfo info = SkImageInfo::MakeA8(1, 1);\n    SkBitmap bitmap;\n    for (SkColorType colorType : { kUnknown_SkColorType,   kAlpha_8_SkColorType,\n                                   kRGB_565_SkColorType,   kARGB_4444_SkColorType, \n                                   kRGBA_8888_SkColorType, kBGRA_8888_SkColorType,\n                                   kGray_8_SkColorType,    kRGBA_F16_SkColorType } ) {\n        bitmap.setInfo(info.makeColorType(colorType));\n        SkDebugf(\"color: k\" \"%s\" \"_SkColorType\" \"%*s\" \"shiftPerPixel: %d\\n\",\n                colors[colorType], 10 - strlen(colors[colorType]), \" \",\n                bitmap.shiftPerPixel());\n    }\n}",
    "hash": "2c77d92f20b950154b9444d3b639b36c",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::shiftPerPixel",
        "stdout": "color: kUnknown_SkColorType   shiftPerPixel: 0\\ncolor: kAlpha_8_SkColorType   shiftPerPixel: 0\\ncolor: kRGB_565_SkColorType   shiftPerPixel: 1\\ncolor: kARGB_4444_SkColorType shiftPerPixel: 1\\ncolor: kRGBA_8888_SkColorType shiftPerPixel: 2\\ncolor: kBGRA_8888_SkColorType shiftPerPixel: 2\\ncolor: kGray_8_SkColorType    shiftPerPixel: 0\\ncolor: kRGBA_F16_SkColorType  shiftPerPixel: 3\\n"
    },
        "SkBitmap_swap": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkBitmap& b) -> void {\n        const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n        const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                                \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n        SkDebugf(\"%s width:%d height:%d colorType:k%s_SkColorType alphaType:k%s_SkAlphaType\\n\",\n                 prefix, b.width(), b.height(), colors[b.colorType()], alphas[b.alphaType()]);\n    };\n    SkBitmap one, two;\n    one.tryAllocPixels(SkImageInfo::Make(1, 1, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));\n    two.tryAllocPixels(SkImageInfo::Make(2, 2, kBGRA_8888_SkColorType, kPremul_SkAlphaType));\n    for (int index = 0; index < 2; ++index) {\n       debugster(\"one\", one);\n       debugster(\"two\", two);\n       one.swap(two);\n    }\n}\n",
    "hash": "274d02e5f33866b1a9a78423c5569e22",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::swap()",
        "stdout": "one width:1 height:1 colorType:kRGBA_8888_SkColorType alphaType:kOpaque_SkAlphaType\\ntwo width:2 height:2 colorType:kBGRA_8888_SkColorType alphaType:kPremul_SkAlphaType\\none width:2 height:2 colorType:kBGRA_8888_SkColorType alphaType:kPremul_SkAlphaType\\ntwo width:1 height:1 colorType:kRGBA_8888_SkColorType alphaType:kOpaque_SkAlphaType\\n"
    },
        "SkBitmap_toString": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    int width = 6;\n    int height = 11;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(width, height));\n    SkString string;\n    bitmap.toString(&string);\n    SkString match;\n    match.printf(\"(%d, %d)\", width, height);\n    int start = string.find(match.c_str());\n    if (start >= 0) {\n        SkString whStr(&string.c_str()[start], match.size());\n        SkDebugf(\"bitmap dimensions %s\\n\", whStr.c_str());\n    }\n}",
    "hash": "6018d98695245510839a318caabba9c9",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::toString",
        "stdout": "bitmap dimensions (6, 11)\\n"
    },
        "SkBitmap_tryAllocPixelsFlags": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    if (!bitmap.tryAllocPixelsFlags(SkImageInfo::MakeN32(10000, 10000, kOpaque_SkAlphaType), \n                                    SkBitmap::kZeroPixels_AllocFlag)) {\n        SkDebugf(\"bitmap allocation failed!\\n\");\n    } else {\n        SkDebugf(\"bitmap allocation succeeded!\\n\");\n    }\n}",
    "hash": "4fff5f5034ced615ad5a1d50c40aeff3",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocPixelsFlags",
        "stdout": "bitmap allocation succeeded!\\n"
    },
        "SkBitmap_width": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeA8(16, 32);\n    SkBitmap bitmap;\n    bitmap.setInfo(info);\n    SkDebugf(\"bitmap width: %d  info width: %d\\n\", bitmap.width(), info.width());\n}",
    "hash": "d06880c42f8bb3b4c3b67bd988046049",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::width()",
        "stdout": "bitmap width: 16  info width: 16\\n"
    },
        "SkCanvas_MakeRasterDirect": {
    "code": "void draw(SkCanvas* ) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(3, 3);  // device aligned, 32 bpp, Premultiplied\n    const size_t minRowBytes = info.minRowBytes();  // bytes used by one bitmap row\n    const size_t size = info.computeMinByteSize();  // bytes used by all rows\n    SkAutoTMalloc<SkPMColor> storage(size);  // allocate storage for pixels\n    SkPMColor* pixels = storage.get();  // get pointer to allocated storage\n    // create a SkCanvas backed by a raster device, and delete it when the\n    // function goes out of scope.\n    std::unique_ptr<SkCanvas> canvas = SkCanvas::MakeRasterDirect(info, pixels, minRowBytes);\n    canvas->clear(SK_ColorWHITE);  // white is Unpremultiplied, in ARGB order\n    canvas->flush();  // ensure that pixels are cleared\n    SkPMColor pmWhite = pixels[0];  // the Premultiplied format may vary\n    SkPaint paint;  // by default, draws black\n    canvas->drawPoint(1, 1, paint);  // draw in the center\n    canvas->flush();  // ensure that point was drawn\n    for (int y = 0; y < info.height(); ++y) {\n        for (int x = 0; x < info.width(); ++x) {\n            SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}\n",
    "hash": "525285073aae7e53eb8f454a398f880c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::MakeRasterDirect",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkCanvas_MakeRasterDirectN32": {
    "code": "void draw(SkCanvas* ) {\n    const int width = 3;\n    const int height = 3;\n    SkPMColor pixels[height][width];  // allocate a 3x3 Premultiplied bitmap on the stack\n    // create a SkCanvas backed by a raster device, and delete it when the\n    // function goes out of scope.\n    std::unique_ptr<SkCanvas> canvas = SkCanvas::MakeRasterDirectN32(\n            width,\n            height,\n            pixels[0],  // top-left of the bitmap\n            sizeof(pixels[0]));  // byte width of the each row\n    // write a premultiplied value for white into all pixels in the bitmap\n    canvas->clear(SK_ColorWHITE);\n    SkPMColor pmWhite = pixels[0][0];  // the Premultiplied format may vary\n    SkPaint paint;  // by default, draws black\n    canvas->drawPoint(1, 1, paint);  // draw in the center\n    canvas->flush();  // ensure that pixels is ready to be read\n    for (int y = 0; y < height; ++y) {\n        for (int x = 0; x < width; ++x) {\n            SkDebugf(\"%c\", pixels[y][x] == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}\n",
    "hash": "a9b116a7ebd1708237ce81ef532e9cb4",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::MakeRasterDirectN32",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkCanvas_SaveLayerRec_SaveLayerRec": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas::SaveLayerRec rec1;\n    rec1.fSaveLayerFlags = SkCanvas::kIsOpaque_SaveLayerFlag;\n    SkCanvas::SaveLayerRec rec2(nullptr, nullptr, SkCanvas::kIsOpaque_SaveLayerFlag);\n    SkDebugf(\"rec1 %c= rec2\\n\", rec1.fBounds == rec2.fBounds\n            && rec1.fPaint == rec2.fPaint\n            && rec1.fBackdrop == rec2.fBackdrop\n            && rec1.fSaveLayerFlags == rec2.fSaveLayerFlags ? '=' : '!');\n}",
    "hash": "ac7c834dce2eac6ef49c15e820e94003",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SaveLayerRec::SaveLayerRec",
        "stdout": "rec1 == rec2\\n"
    },
        "SkCanvas_SaveLayerRec_SaveLayerRec_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas::SaveLayerRec rec1;\n    SkCanvas::SaveLayerRec rec2(nullptr, nullptr);\n    SkDebugf(\"rec1 %c= rec2\\n\", rec1.fBounds == rec2.fBounds\n            && rec1.fPaint == rec2.fPaint\n            && rec1.fBackdrop == rec2.fBackdrop\n            && rec1.fSaveLayerFlags == rec2.fSaveLayerFlags ? '=' : '!');\n}",
    "hash": "027f920259888fc19591ea9a90d92873",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SaveLayerRec::SaveLayerRec_2",
        "stdout": "rec1 == rec2\\n"
    },
        "SkCanvas_SaveLayerRec_SaveLayerRec_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas::SaveLayerRec rec1;\n    SkCanvas::SaveLayerRec rec2(nullptr, nullptr, nullptr, 0);\n    SkDebugf(\"rec1 %c= rec2\\n\", rec1.fBounds == rec2.fBounds\n            && rec1.fPaint == rec2.fPaint\n            && rec1.fBackdrop == rec2.fBackdrop\n            && rec1.fSaveLayerFlags == rec2.fSaveLayerFlags ? '=' : '!');\n}",
    "hash": "9b7fa2fe855642ffff6538829db15328",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SaveLayerRec::SaveLayerRec_3",
        "stdout": "rec1 == rec2\\n"
    },
        "SkCanvas_accessTopRasterHandle": {
    "code": "static void DeleteCallback(void*, void* context) {\n    delete (char*) context;\n}\nclass CustomAllocator : public SkRasterHandleAllocator {\npublic:\n    bool allocHandle(const SkImageInfo& info, Rec* rec) override {\n        char* context = new char[4]{'s', 'k', 'i', 'a'};\n        rec->fReleaseProc = DeleteCallback;\n        rec->fReleaseCtx = context;\n        rec->fHandle = context;\n        rec->fPixels = context;\n        rec->fRowBytes = 4;\n        return true;\n    }\n    void updateHandle(Handle handle, const SkMatrix& ctm, const SkIRect& clip_bounds) override {\n        // apply canvas matrix and clip to custom environment\n    }\n};\n\nvoid draw(SkCanvas* canvas) {\n    const SkImageInfo info = SkImageInfo::MakeN32Premul(1, 1);\n    std::unique_ptr<SkCanvas> c2 =\n            SkRasterHandleAllocator::MakeCanvas(std::unique_ptr<CustomAllocator>(\n            new CustomAllocator()), info);\n    char* context = (char*) c2->accessTopRasterHandle();\n    SkDebugf(\"context = %.4s\\n\", context);\n}\n",
    "hash": "4486d0c0b22ad2931db130f42da4c80c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::accessTopRasterHandle",
        "stdout": "context = skia\\n"
    },
        "SkCanvas_const_SkBitmap_const_SkSurfaceProps": {
    "code": "void draw(SkCanvas* ) {\n    SkBitmap bitmap;\n    // create a bitmap 5 wide and 11 high\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(5, 11));\n    SkCanvas canvas(bitmap, SkSurfaceProps(0, kUnknown_SkPixelGeometry));\n    canvas.clear(SK_ColorWHITE);  // white is Unpremultiplied, in ARGB order\n    SkPixmap pixmap;  // provides guaranteed access to the drawn pixels\n    if (!canvas.peekPixels(&pixmap)) {\n        SkDebugf(\"peekPixels should never fail.\\n\");\n    }\n    const SkPMColor* pixels = pixmap.addr32();  // points to top-left of bitmap\n    SkPMColor pmWhite = pixels[0];  // the Premultiplied format may vary\n    SkPaint paint;  // by default, draws black, 12 point text\n    canvas.drawString(\"!\", 1, 10, paint);  // 1 char at baseline (1, 10)\n    for (int y = 0; y < bitmap.height(); ++y) {\n        for (int x = 0; x < bitmap.width(); ++x) {\n            SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}",
    "hash": "c26cfae4c42cb445240335cc12a50235",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SkCanvas(const SkBitmap& bitmap, const SkSurfaceProps& props)",
        "stdout": "-----\\n---x-\\n---x-\\n---x-\\n---x-\\n---x-\\n---x-\\n-----\\n---x-\\n---x-\\n-----\\n"
    },
        "SkCanvas_copy_const_SkBitmap": {
    "code": "void draw(SkCanvas* ) {\n    SkBitmap bitmap;\n    // create a bitmap 5 wide and 11 high\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(5, 11));\n    SkCanvas canvas(bitmap);\n    canvas.clear(SK_ColorWHITE);  // white is Unpremultiplied, in ARGB order\n    SkPixmap pixmap;  // provides guaranteed access to the drawn pixels\n    if (!canvas.peekPixels(&pixmap)) {\n        SkDebugf(\"peekPixels should never fail.\\n\");\n    }\n    const SkPMColor* pixels = pixmap.addr32();  // points to top-left of bitmap\n    SkPMColor pmWhite = pixels[0];  // the Premultiplied format may vary\n    SkPaint paint;  // by default, draws black, 12 point text\n    canvas.drawString(\"!\", 1, 10, paint);  // 1 char at baseline (1, 10)\n    for (int y = 0; y < bitmap.height(); ++y) {\n        for (int x = 0; x < bitmap.width(); ++x) {\n            SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}",
    "hash": "dd92db963af190e849894038f39b598a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SkCanvas(const SkBitmap& bitmap)",
        "stdout": "-----\\n---x-\\n---x-\\n---x-\\n---x-\\n---x-\\n---x-\\n-----\\n---x-\\n---x-\\n-----\\n"
    },
        "SkCanvas_empty_constructor": {
    "code": "// Returns true if either the canvas rotates the text by 90 degrees, or the paint does.\nstatic void check_for_up_and_down_text(const SkCanvas* canvas, const SkPaint& paint) {\n    bool paintHasVertical = paint.isVerticalText();\n    const SkMatrix& matrix = canvas->getTotalMatrix();\n    bool matrixIsVertical = matrix.preservesRightAngles() && !matrix.isScaleTranslate();\n    SkDebugf(\"paint draws text %s\\n\", paintHasVertical != matrixIsVertical ?\n            \"top to bottom\" : \"left to right\");\n}\nstatic void check_for_up_and_down_text(const SkPaint& paint) {\n    SkCanvas canvas;  // placeholder only, does not have an associated device\n    check_for_up_and_down_text(&canvas, paint);\n}\n\nvoid draw(SkCanvas* canvas) {\n    SkPaint paint;\n    check_for_up_and_down_text(paint);  // paint draws text left to right\n    paint.setVerticalText(true);\n    check_for_up_and_down_text(paint);  // paint draws text top to bottom\n    paint.setVerticalText(false);\n    canvas->rotate(90);\n    check_for_up_and_down_text(canvas, paint);  // paint draws text top to bottom\n}\n",
    "hash": "903451d6c93bf69e2833747a3e8cc8f7",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SkCanvas()",
        "stdout": "paint draws text left to right\\npaint draws text top to bottom\\npaint draws text top to bottom\\n"
    },
        "SkCanvas_getBaseLayerSize": {
    "code": "void draw(SkCanvas* ) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(20, 30));\n    SkCanvas canvas(bitmap, SkSurfaceProps(0, kUnknown_SkPixelGeometry));\n    canvas.clipRect(SkRect::MakeWH(10, 40));\n    SkIRect clipDeviceBounds = canvas.getDeviceClipBounds();\n    if (clipDeviceBounds.isEmpty()) {\n        SkDebugf(\"Empty clip bounds is unexpected!\\n\");\n    }\n    SkDebugf(\"clip=%d,%d\\n\", clipDeviceBounds.width(), clipDeviceBounds.height());\n    SkISize baseLayerSize = canvas.getBaseLayerSize();\n    SkDebugf(\"size=%d,%d\\n\", baseLayerSize.width(), baseLayerSize.height());\n}",
    "hash": "374e245d91cd729eca48fd20e631fdf3",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getBaseLayerSize",
        "stdout": "clip=10,30\\nsize=20,30\\n"
    },
        "SkCanvas_getDeviceClipBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas device(256, 256);\n    canvas = &device;\n    SkIRect bounds = canvas->getDeviceClipBounds();\n    SkDebugf(\"left:%d  top:%d  right:%d  bottom:%d\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    SkPoint clipPoints[]  = {{30, 130}, {120, 130}, {120, 230} }; \n    SkPath clipPath;\n    clipPath.addPoly(clipPoints, SK_ARRAY_COUNT(clipPoints), true);\n    canvas->save();\n    canvas->clipPath(clipPath);\n    bounds = canvas->getDeviceClipBounds();\n    SkDebugf(\"left:%d  top:%d  right:%d  bottom:%d\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    canvas->restore();\n    canvas->scale(1.f/2, 1.f/2);\n    canvas->clipPath(clipPath);\n    bounds = canvas->getDeviceClipBounds();\n    SkDebugf(\"left:%d  top:%d  right:%d  bottom:%d\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n}\n",
    "hash": "5f4c910afa4a5a61702e5119eab2cac9",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getDeviceClipBounds",
        "stdout": "left:0  top:0  right:256  bottom:256\\nleft:30  top:130  right:120  bottom:230\\nleft:15  top:65  right:60  bottom:115\\n"
    },
        "SkCanvas_getDeviceClipBounds_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect bounds;\n    SkDebugf(\"device bounds empty = %s\\n\", canvas->getDeviceClipBounds(&bounds)\n             ? \"false\" : \"true\");\n    SkPath path;\n    canvas->clipPath(path);\n    SkDebugf(\"device bounds empty = %s\\n\", canvas->getDeviceClipBounds(&bounds)\n             ? \"false\" : \"true\");\n}\n",
    "hash": "6abb99f849a1f0e33e1dedc00d1c4f7a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getDeviceClipBounds_2",
        "stdout": "device bounds empty = false\\ndevice bounds empty = true\\n"
    },
        "SkCanvas_getLocalClipBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas local(256, 256);\n    canvas = &local;\n    SkRect bounds = canvas->getLocalClipBounds();\n    SkDebugf(\"left:%g  top:%g  right:%g  bottom:%g\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    SkPoint clipPoints[]  = {{30, 130}, {120, 130}, {120, 230} }; \n    SkPath clipPath;\n    clipPath.addPoly(clipPoints, SK_ARRAY_COUNT(clipPoints), true);\n    canvas->clipPath(clipPath);\n    bounds = canvas->getLocalClipBounds();\n    SkDebugf(\"left:%g  top:%g  right:%g  bottom:%g\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    canvas->scale(2, 2);\n    bounds = canvas->getLocalClipBounds();\n    SkDebugf(\"left:%g  top:%g  right:%g  bottom:%g\\n\",\n            bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n}",
    "hash": "0b36ff64daf88c046b4ae6ed4ee64db9",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getLocalClipBounds",
        "stdout": "left:-1  top:-1  right:257  bottom:257\\nleft:29  top:129  right:121  bottom:231\\nleft:14.5  top:64.5  right:60.5  bottom:115.5\\n"
    },
        "SkCanvas_getLocalClipBounds_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas local(256, 256);\n    canvas = &local;\n    SkRect bounds;\n    SkDebugf(\"local bounds empty = %s\\n\", canvas->getLocalClipBounds(&bounds)\n             ? \"false\" : \"true\");\n    SkPath path;\n    canvas->clipPath(path);\n    SkDebugf(\"local bounds empty = %s\\n\", canvas->getLocalClipBounds(&bounds)\n             ? \"false\" : \"true\");\n}\n",
    "hash": "85496614e90c66b020f8a70db8d06f4a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getLocalClipBounds_2",
        "stdout": "local bounds empty = false\\nlocal bounds empty = true\\n"
    },
        "SkCanvas_getMetaData": {
    "code": "void draw(SkCanvas* ) {\n    const char* kHelloMetaData = \"HelloMetaData\";\n    SkCanvas canvas;\n    SkMetaData& metaData = canvas.getMetaData();\n    SkDebugf(\"before: %s\\n\", metaData.findString(kHelloMetaData));\n    metaData.setString(kHelloMetaData, \"Hello!\");\n    SkDebugf(\"during: %s\\n\", metaData.findString(kHelloMetaData));\n    metaData.removeString(kHelloMetaData);\n    SkDebugf(\"after: %s\\n\", metaData.findString(kHelloMetaData));\n}",
    "hash": "1598396056045e8d0c583b748293d652",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getMetaData",
        "stdout": "before: (null)\\nduring: Hello!\\nafter: (null)\\n"
    },
        "SkCanvas_getProps": {
    "code": "void draw(SkCanvas* ) {\n    SkBitmap bitmap;\n    SkCanvas canvas(bitmap, SkSurfaceProps(0, kRGB_V_SkPixelGeometry));\n    SkSurfaceProps surfaceProps(0, kUnknown_SkPixelGeometry);\n    SkDebugf(\"isRGB:%d\\n\", SkPixelGeometryIsRGB(surfaceProps.pixelGeometry()));\n    if (!canvas.getProps(&surfaceProps)) {\n        SkDebugf(\"getProps failed unexpectedly.\\n\");\n    }\n    SkDebugf(\"isRGB:%d\\n\", SkPixelGeometryIsRGB(surfaceProps.pixelGeometry()));\n}",
    "hash": "0fbf2dedc2619bbfbf173c9e3bc1a508",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getProps",
        "stdout": "isRGB:0\\nisRGB:1\\n"
    },
        "SkCanvas_getSaveCount": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas simple;\n    SkDebugf(\"depth = %d\\n\", simple.getSaveCount());\n    simple.save();\n    SkDebugf(\"depth = %d\\n\", simple.getSaveCount());\n    simple.restore();\n    SkDebugf(\"depth = %d\\n\", simple.getSaveCount());\n}\n",
    "hash": "005f2b207e078baac596681924fe591e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getSaveCount",
        "stdout": "depth = 1\\ndepth = 2\\ndepth = 1\\n"
    },
        "SkCanvas_getTotalMatrix": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"isIdentity %s\\n\", canvas->getTotalMatrix().isIdentity() ? \"true\" : \"false\");\n}",
    "hash": "c0d5fa544759704768f47cac91ae3832",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getTotalMatrix",
        "stdout": "isIdentity true\\n"
    },
        "SkCanvas_imageInfo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas emptyCanvas;\n    SkImageInfo canvasInfo = emptyCanvas.imageInfo();\n    SkImageInfo emptyInfo;\n    SkDebugf(\"emptyInfo %c= canvasInfo\\n\", emptyInfo == canvasInfo ? '=' : '!');\n}",
    "hash": "d93389d971f8084c4ccc7a66e4e157ee",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::imageInfo",
        "stdout": "emptyInfo == canvasInfo\\n"
    },
        "SkCanvas_int_int_const_SkSurfaceProps_star": {
    "code": "void draw(SkCanvas* ) {\n    SkCanvas canvas(10, 20);  // 10 units wide, 20 units high\n    canvas.clipRect(SkRect::MakeXYWH(30, 40, 5, 10));  // clip is outside canvas' device\n    SkDebugf(\"canvas %s empty\\n\", canvas.getDeviceClipBounds().isEmpty() ? \"is\" : \"is not\");\n}",
    "hash": "ce6a5ef2df447970b4453489d9d67930",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SkCanvas(int width, int height, const SkSurfaceProps* props = nullptr)",
        "stdout": "canvas is empty\\n"
    },
        "SkCanvas_isClipEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"clip is%s empty\\n\", canvas->isClipEmpty() ? \"\" : \" not\");\n    SkPath path;\n    canvas->clipPath(path);\n    SkDebugf(\"clip is%s empty\\n\", canvas->isClipEmpty() ? \"\" : \" not\");\n}\n",
    "hash": "f106f146a58c8604308d4d8d7086d2f5",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::isClipEmpty",
        "stdout": "clip is not empty\\nclip is empty\\n"
    },
        "SkCanvas_isClipRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"clip is%s rect\\n\", canvas->isClipRect() ? \"\" : \" not\");\n    canvas->clipRect({0, 0, 0, 0});\n    SkDebugf(\"clip is%s rect\\n\", canvas->isClipRect() ? \"\" : \" not\");\n}\n",
    "hash": "9894bfb476c78a8f6c8f49fbbca3d50d",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::isClipRect",
        "stdout": "clip is rect\\nclip is not rect\\n"
    },
        "SkCanvas_makeSurface": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surface = SkSurface::MakeRasterN32Premul(5, 6);\n    SkCanvas* smallCanvas = surface->getCanvas();\n    SkImageInfo imageInfo = SkImageInfo::MakeN32Premul(3, 4);\n    sk_sp<SkSurface> compatible = smallCanvas->makeSurface(imageInfo);\n    SkDebugf(\"compatible %c= nullptr\\n\", compatible == nullptr ? '=' : '!');\n    SkDebugf(\"size = %d, %d\\n\", compatible->width(), compatible->height());\n}",
    "hash": "1ce28351444b41ab2b8e3128a4b9b9c2",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::makeSurface",
        "stdout": "compatible != nullptr\\nsize = 3, 4\\n"
    },
        "SkCanvas_peekPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap;\n    if (canvas->peekPixels(&pixmap)) {\n        SkDebugf(\"width=%d height=%d\\n\", pixmap.bounds().width(), pixmap.bounds().height());\n    }\n}",
    "hash": "e9411d676d1fa13b46331abe9e14ad3e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::peekPixels",
        "stdout": "width=256 height=256\\n"
    },
        "SkCanvas_quickReject": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect testRect = {30, 30, 120, 129 }; \n    SkRect clipRect = {30, 130, 120, 230 }; \n    canvas->save();\n    canvas->clipRect(clipRect);\n    SkDebugf(\"quickReject %s\\n\", canvas->quickReject(testRect) ? \"true\" : \"false\");\n    canvas->restore();\n    canvas->rotate(10);\n    canvas->clipRect(clipRect);\n    SkDebugf(\"quickReject %s\\n\", canvas->quickReject(testRect) ? \"true\" : \"false\");\n}\n",
    "hash": "c15e39862d5f07b0fed44c71e86f7cc9",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::quickReject",
        "stdout": "quickReject true\\nquickReject false\\n"
    },
        "SkCanvas_quickReject_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint testPoints[] = {{30,  30}, {120,  30}, {120, 129} }; \n    SkPoint clipPoints[] = {{30, 130}, {120, 130}, {120, 230} }; \n    SkPath testPath, clipPath;\n    testPath.addPoly(testPoints, SK_ARRAY_COUNT(testPoints), true);\n    clipPath.addPoly(clipPoints, SK_ARRAY_COUNT(clipPoints), true);\n    canvas->save();\n    canvas->clipPath(clipPath);\n    SkDebugf(\"quickReject %s\\n\", canvas->quickReject(testPath) ? \"true\" : \"false\");\n    canvas->restore();\n    canvas->rotate(10);\n    canvas->clipPath(clipPath);\n    SkDebugf(\"quickReject %s\\n\", canvas->quickReject(testPath) ? \"true\" : \"false\");\n}\n",
    "hash": "64723a541c40073157abf2ca67907e15",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::quickReject_2",
        "stdout": "quickReject true\\nquickReject false\\n"
    },
        "SkCanvas_readPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(0x8055aaff);\n    uint32_t pixels[1] = { 0 };\n    SkPixmap pixmap(SkImageInfo::MakeN32Premul(1, 1), pixels, 4);\n    canvas->readPixels(pixmap, 0, 0);\n    SkDebugf(\"pixel = %08x\\n\", pixels[0]);\n}\n",
    "hash": "85f199032943b6483722c34a91c4e20f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::readPixels_2",
        "stdout": "pixel = 802b5580\\n"
    },
        "SkCanvas_readPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(0x8055aaff);\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(1, 1));\n    canvas->readPixels(bitmap, 0, 0);\n    SkDebugf(\"pixel = %08x\\n\", bitmap.getAddr32(0, 0)[0]);\n}\n",
    "hash": "af6dec8ef974aa67bf102f29915bcd6a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::readPixels_3",
        "stdout": "pixel = 802b5580\\n"
    },
        "SkCanvas_readPixels_a": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(0x8055aaff);\n    for (SkAlphaType alphaType : { kPremul_SkAlphaType, kUnpremul_SkAlphaType } ) {\n        uint32_t pixel = 0;\n        SkImageInfo info = SkImageInfo::Make(1, 1, kBGRA_8888_SkColorType, alphaType);\n        if (canvas->readPixels(info, &pixel, 4, 0, 0)) {\n            SkDebugf(\"pixel = %08x\\n\", pixel);\n        }\n    }\n}",
    "hash": "481e990e923a0ed34654f4361b94f096",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::readPixels_2",
        "stdout": "pixel = 802b5580\\npixel = 8056a9ff\\n"
    },
        "SkCanvas_restore": {
    "code": "void draw(SkCanvas* canvas) {\n    SkCanvas simple;\n    SkDebugf(\"depth = %d\\n\", simple.getSaveCount());\n    simple.restore();\n    SkDebugf(\"depth = %d\\n\", simple.getSaveCount());\n}\n",
    "hash": "e78471212a67f2f4fd39496e17a30d17",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::restore()",
        "stdout": "depth = 1\\ndepth = 1\\n"
    },
        "SkCanvas_restoreToCount": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"depth = %d\\n\", canvas->getSaveCount());\n    canvas->save();\n    canvas->save();\n    SkDebugf(\"depth = %d\\n\", canvas->getSaveCount());\n    canvas->restoreToCount(0);\n    SkDebugf(\"depth = %d\\n\", canvas->getSaveCount());\n}\n",
    "hash": "9ed0d56436e114c7097fd49eed1aea47",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::restoreToCount",
        "stdout": "depth = 1\\ndepth = 3\\ndepth = 1\\n"
    },
        "SkIPoint16_Make": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint16 pt1 = {45, 66};\n    SkIPoint16 pt2 = SkIPoint16::Make(45, 66);\n    SkDebugf(\"pt1.fX %c= pt2.fX\\n\", pt1.fX == pt2.fX ? '=' : '!');\n    SkDebugf(\"pt1.fY %c= pt2.fY\\n\", pt1.fY == pt2.fY ? '=' : '!');\n}",
    "hash": "d815ca04fbf22b5acec6f85b6351f362",
    "file": "SkIPoint16_Reference",
    "name": "SkIPoint16::Make",
        "stdout": "pt1.fX == pt2.fX\\npt1.fY == pt2.fY\\n"
    },
        "SkIPoint16_set": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint16 pt1, pt2 = { SK_MinS16, SK_MaxS16 };\n    pt1.set(SK_MinS16, SK_MaxS16);\n    SkDebugf(\"pt1.fX %c= pt2.fX\\n\", pt1.fX == pt2.fX ? '=' : '!');\n    SkDebugf(\"pt1.fY %c= pt2.fY\\n\", pt1.fY == pt2.fY ? '=' : '!');\n}",
    "hash": "abff78d3f2d97b1284ccb13d0c56b6c8",
    "file": "SkIPoint16_Reference",
    "name": "SkIPoint16::set()",
        "stdout": "pt1.fX == pt2.fX\\npt1.fY == pt2.fY\\n"
    },
        "SkIPoint16_x": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint16 pt1 = {45, 66};\n    SkDebugf(\"pt1.fX %c= pt1.x()\\n\", pt1.fX == pt1.x() ? '=' : '!');\n}",
    "hash": "f7fd3b3674f042869de3582ab793dbf7",
    "file": "SkIPoint16_Reference",
    "name": "SkIPoint16::x()",
        "stdout": "pt1.fX == pt1.x()\\n"
    },
        "SkIPoint16_y": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint16 pt1 = {45, 66};\n    SkDebugf(\"pt1.fY %c= pt1.y()\\n\", pt1.fY == pt1.y() ? '=' : '!');\n}",
    "hash": "3662cedaf1e9924a401f794902da3b1f",
    "file": "SkIPoint16_Reference",
    "name": "SkIPoint16::y()",
        "stdout": "pt1.fY == pt1.y()\\n"
    },
        "SkIPoint_Make": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint pt1 = {45, 66};\n    SkIPoint pt2 = SkIPoint::Make(45, 66);\n    SkDebugf(\"pt1 %c= pt2\\n\", pt1 == pt2 ? '=' : '!');\n}",
    "hash": "e5cf5159525bd3140f288a95fe641fae",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::Make",
        "stdout": "pt1 == pt2\\n"
    },
        "SkIPoint_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint test[] = { {0, -0}, {-1, -2}, {SK_MaxS32, -1}, {SK_NaN32, -1} };\n    for (const SkIPoint& pt : test) {\n        SkDebugf(\"pt: %d, %d  %c= pt\\n\", pt.fX, pt.fY, pt == pt ? '=' : '!');\n    }\n}",
    "hash": "37ffe2817d720f99e6c252332ce70460",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator==(const SkIPoint& a, const SkIPoint& b)",
        "stdout": "pt: 0, 0  == pt\\npt: -1, -2  == pt\\npt: 2147483647, -1  == pt\\npt: -2147483648, -1  == pt\\n"
    },
        "SkIPoint_equals": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint test[] = { {0, -0}, {-1, -2}, {SK_MaxS32, -1}, {SK_NaN32, -1} };\n    for (const SkIPoint& pt : test) {\n        SkDebugf(\"pt: %d, %d  %c= pt\\n\", pt.fX, pt.fY, pt.equals(pt.fX, pt.fY) ? '=' : '!');\n    }\n}",
    "hash": "64f575d36439d5b69aaed14ffeff1cc4",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::equals()",
        "stdout": "pt: 0, 0  == pt\\npt: -1, -2  == pt\\npt: 2147483647, -1  == pt\\npt: -2147483648, -1  == pt\\n"
    },
        "SkIPoint_isZero": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint pt = { 0, -0};\n    SkDebugf(\"pt.isZero() == %s\\n\", pt.isZero() ? \"true\" : \"false\");\n}",
    "hash": "658c1df611b4577cc7e0bb384e95737e",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::isZero",
        "stdout": "pt.isZero() == true\\n"
    },
        "SkIPoint_minus_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint test[] = { {0, -0}, {-1, -2},\n                       { SK_MaxS32, SK_MinS32 },\n                       { SK_NaN32, -SK_NaN32 } };\n    for (const SkIPoint& pt : test) {\n        SkIPoint negPt = -pt;\n        SkDebugf(\"pt: %d, %d  negate: %d, %d\\n\", pt.fX, pt.fY, negPt.fX, negPt.fY);\n    }\n}",
    "hash": "d283e8876366349aedd85b65cadb3706",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator-()_const",
        "stdout": "pt: 0, 0  negate: 0, 0\\npt: -1, -2  negate: 1, 2\\npt: 2147483647, -2147483647  negate: -2147483647, 2147483647\\npt: -2147483648, -2147483648  negate: -2147483648, -2147483648\\n"
    },
        "SkIPoint_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint test[] = { {0, -0}, {-1, -2}, {SK_MaxS32, -1}, {SK_NaN32, -1} };\n    for (const SkIPoint& pt : test) {\n        SkDebugf(\"pt: %d, %d  %c= pt\\n\", pt.fX, pt.fY, pt != pt ? '!' : '=');\n    }\n}",
    "hash": "dd89dc48dff69b53d99530b120f204bc",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator!=(const SkIPoint& a, const SkIPoint& b)",
        "stdout": "pt: 0, 0  == pt\\npt: -1, -2  == pt\\npt: 2147483647, -1  == pt\\npt: -2147483648, -1  == pt\\n"
    },
        "SkIPoint_set": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint pt1, pt2 = { SK_MinS32, SK_MaxS32 };\n    pt1.set(SK_MinS32, SK_MaxS32);\n    SkDebugf(\"pt1 %c= pt2\\n\", pt1 == pt2 ? '=' : '!');\n}",
    "hash": "165418b5718d79d8f1682a8a0ee32ba0",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::set()",
        "stdout": "pt1 == pt2\\n"
    },
        "SkIPoint_x": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint pt1 = {45, 66};\n    SkDebugf(\"pt1.fX %c= pt1.x()\\n\", pt1.fX == pt1.x() ? '=' : '!');\n}",
    "hash": "eed4185294f8a8216fc354e6ee6b2e3a",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::x()",
        "stdout": "pt1.fX == pt1.x()\\n"
    },
        "SkIPoint_y": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint pt1 = {45, 66};\n    SkDebugf(\"pt1.fY %c= pt1.y()\\n\", pt1.fY == pt1.y() ? '=' : '!');\n}",
    "hash": "35c41b8ba7cebf8c9a7a8494e610e14d",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::y()",
        "stdout": "pt1.fY == pt1.y()\\n"
    },
        "SkIRect_EmptyIRect": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkIRect& rect = SkIRect::EmptyIRect();\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "65e0b9b52e907902630577941fb3ed6d",
    "file": "SkIRect_Reference",
    "name": "SkIRect::EmptyIRect",
        "stdout": "rect: 0, 0, 0, 0\\n"
    },
        "SkIRect_Intersects": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"%s intersection\", SkIRect::Intersects({10, 40, 50, 80}, {30, 60, 70, 90}) ? \"\" : \"no \");\n}",
    "hash": "0c67cf8981389efc7108369fb9b7976b",
    "file": "SkIRect_Reference",
    "name": "SkIRect::Intersects",
        "stdout": "intersection"
    },
        "SkIRect_IntersectsNoEmptyCheck": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"%s intersection\", SkIRect::IntersectsNoEmptyCheck(\n            {10, 40, 50, 80}, {30, 60, 70, 90}) ? \"\" : \"no \");\n}",
    "hash": "dba234d15162fb5b26e1a96529ca6a2a",
    "file": "SkIRect_Reference",
    "name": "SkIRect::IntersectsNoEmptyCheck",
        "stdout": "intersection"
    },
        "SkIRect_MakeEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = SkIRect::MakeEmpty();\n    SkDebugf(\"MakeEmpty isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.offset(10, 10);\n    SkDebugf(\"offset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.inset(10, 10);\n    SkDebugf(\"inset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.outset(20, 20);\n    SkDebugf(\"outset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "0ade3971c1d2616564992e286966ec8a",
    "file": "SkIRect_Reference",
    "name": "SkIRect::MakeEmpty",
        "stdout": "MakeEmpty isEmpty: true\\noffset rect isEmpty: true\\ninset rect isEmpty: true\\noutset rect isEmpty: false\\n"
    },
        "SkIRect_MakeLTRB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = SkIRect::MakeLTRB(5, 35, 15, 25);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "ec1473b700c594f2df9749a12a06b89b",
    "file": "SkIRect_Reference",
    "name": "SkIRect::MakeLTRB",
        "stdout": "rect: 5, 35, 15, 25  isEmpty: true\\nrect: 5, 25, 15, 35  isEmpty: false\\n"
    },
        "SkIRect_MakeSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkSize size = {25.5f, 35.5f};\n    SkIRect rect = SkIRect::MakeSize(size.toRound());\n    SkDebugf(\"round width: %d  height: %d\\n\", rect.width(), rect.height());\n    rect = SkIRect::MakeSize(size.toFloor());\n    SkDebugf(\"floor width: %d  height: %d\\n\", rect.width(), rect.height());\n}",
    "hash": "c6586ff8d24869c780169b0d19c75df6",
    "file": "SkIRect_Reference",
    "name": "SkIRect::MakeSize",
        "stdout": "round width: 26  height: 36\\nfloor width: 25  height: 35\\n"
    },
        "SkIRect_MakeWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect1 = SkIRect::MakeWH(25, 35);\n    SkIRect rect2 = SkIRect::MakeSize({25, 35});\n    SkIRect rect3 = SkIRect::MakeXYWH(0, 0, 25, 35);\n    SkIRect rect4 = SkIRect::MakeLTRB(0, 0, 25, 35);\n    SkDebugf(\"all %s\" \"equal\\n\", rect1 == rect2 && rect2 == rect3 && rect3 == rect4 ?\n             \"\" : \"not \");\n}",
    "hash": "e36827a1a6ae2b1c26e7a8a08f325a07",
    "file": "SkIRect_Reference",
    "name": "SkIRect::MakeWH",
        "stdout": "all equal\\n"
    },
        "SkIRect_MakeXYWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = SkIRect::MakeXYWH(5, 35, -15, 25);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "598ee14350bd1d961cae6b36fa3df17e",
    "file": "SkIRect_Reference",
    "name": "SkIRect::MakeXYWH",
        "stdout": "rect: 5, 35, -10, 60  isEmpty: true\\nrect: -10, 35, 5, 60  isEmpty: false\\n"
    },
        "SkIRect_bottom": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fBottom: %d unsorted.bottom(): %d\\n\", unsorted.fBottom, unsorted.bottom());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fBottom: %d sorted.bottom(): %d\\n\", sorted.fBottom, sorted.bottom());\n}",
    "hash": "c32afebc296054a181621648a184b8e3",
    "file": "SkIRect_Reference",
    "name": "SkIRect::bottom()",
        "stdout": "unsorted.fBottom: 5 unsorted.bottom(): 5\\nsorted.fBottom: 25 sorted.bottom(): 25\\n"
    },
        "SkIRect_centerX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect tests[] = {{20, 30, 41, 51}, {-20, -30, -41, -51}, {-10, -10, 11, 11}};\n    for (auto rect : tests) {\n        SkDebugf(\"left: %3d right: %3d centerX: %3d \", rect.left(), rect.right(), rect.centerX());\n        SkDebugf(\"div2: %3d\\n\", (rect.left() + rect.right()) / 2);\n    }\n}",
    "hash": "549b840a9ceaaf7cb4e604f9f3d7108d",
    "file": "SkIRect_Reference",
    "name": "SkIRect::centerX",
        "stdout": "left:  20 right:  41 centerX:  30 div2:  30\\nleft: -20 right: -41 centerX: -31 div2: -30\\nleft: -10 right:  11 centerX:   0 div2:   0\\n"
    },
        "SkIRect_centerY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 0, 0, 2, 2 };\n    rect.offset(0x40000000, 0x40000000);\n    SkDebugf(\"left: %d right: %d centerX: %d \", rect.left(), rect.right(), rect.centerX());\n    SkDebugf(\"safe mid x: %d\\n\", rect.left() / 2 + rect.right() / 2);\n}",
    "hash": "687d833b042fb018f8948764e73a37b1",
    "file": "SkIRect_Reference",
    "name": "SkIRect::centerY",
        "stdout": "left: 1073741824 right: 1073741826 centerX: -1073741823 safe mid x: 1073741825\\n"
    },
        "SkIRect_contains": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkIPoint pts[] = { { 30, 50}, { 40, 50}, { 30, 60} };\n    for (auto pt : pts) {\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.contains(pt.x(), pt.y()) ? \"contains\" : \"does not contain\", pt.x(), pt.y());\n    }\n}",
    "hash": "a7958a4e0668f5cf805a8e78eb57f51d",
    "file": "SkIRect_Reference",
    "name": "SkIRect::contains()",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50)\\nrect: (30, 50, 40, 60) does not contain (40, 50)\\nrect: (30, 50, 40, 60) does not contain (30, 60)\\n"
    },
        "SkIRect_containsNoEmptyCheck": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        bool success = rect.containsNoEmptyCheck(\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 success ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "fef2a36bee224e92500199fa9d3cbb8b",
    "file": "SkIRect_Reference",
    "name": "SkIRect::containsNoEmptyCheck",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkIRect_containsNoEmptyCheck_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.containsNoEmptyCheck(contained) ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "8f91f58001d9c10420eb146fbc169af4",
    "file": "SkIRect_Reference",
    "name": "SkIRect::containsNoEmptyCheck_2",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkIRect_contains_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        bool success = rect.contains(\n                       contained.left(), contained.top(), contained.right(), contained.bottom());\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 success ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "eae55f284818d9965ec5834747d14a48",
    "file": "SkIRect_Reference",
    "name": "SkIRect::contains_2",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkIRect_contains_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%d, %d, %d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.contains(contained) ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "ee0185db622602b4eb19583c2f42c734",
    "file": "SkIRect_Reference",
    "name": "SkIRect::contains_3",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkIRect_contains_4": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 40, 60 };\n    SkRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        SkDebugf(\"rect: (%d, %d, %d, %d) %s (%g, %g, %g, %g)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.contains(contained) ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "acbd79ffb304f332e4b38ef18e19663e",
    "file": "SkIRect_Reference",
    "name": "SkIRect::contains_4",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkIRect_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect test = {0, 0, 2, 2};\n    SkIRect sorted = test.makeSorted();\n    SkDebugf(\"test %c= sorted\\n\", test == sorted ? '=' : '!');\n}",
    "hash": "bd8f028d9051062816c9116fea4237b2",
    "file": "SkIRect_Reference",
    "name": "SkIRect::operator==(const SkIRect& a, const SkIRect& b)",
        "stdout": "test == sorted\\n"
    },
        "SkIRect_height": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 20 };\n    SkDebugf(\"unsorted height: %d\\n\", unsorted.height());\n    SkIRect large = { 1, -2147483647, 2, 2147483644 };\n    SkDebugf(\"large height: %d\\n\", large.height());\n}",
    "hash": "0175bae87fafcd9433ae661574695586",
    "file": "SkIRect_Reference",
    "name": "SkIRect::height()",
        "stdout": "unsorted height: -5\\nlarge height: -5\\n"
    },
        "SkIRect_inset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 14, 50, 73 };\n    rect.inset(5, 13);\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "9debaded1aa8bdf5077a4de0b3015b8f",
    "file": "SkIRect_Reference",
    "name": "SkIRect::inset()",
        "stdout": "rect: 15, 27, 45, 60\\n"
    },
        "SkIRect_intersect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect leftRect =  { 10, 40, 50, 80 };\n    SkIRect rightRect = { 30, 60, 70, 90 };\n    SkDebugf(\"%s intersection: \", leftRect.intersect(rightRect) ? \"\" : \"no \");\n    SkDebugf(\"%d, %d, %d, %d\\n\", leftRect.left(), leftRect.top(), \n                                 leftRect.right(), leftRect.bottom());\n}",
    "hash": "2be1302480e54a767e25cbeed5d41b41",
    "file": "SkIRect_Reference",
    "name": "SkIRect::intersect()",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkIRect_intersectNoEmptyCheck": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect result;\n    bool intersected = result.intersectNoEmptyCheck({ 10, 40, 50, 80 }, { 30, 60, 70, 90 });\n    SkDebugf(\"intersection: %d, %d, %d, %d\\n\",\n             result.left(), result.top(), result.right(), result.bottom());\n}",
    "hash": "2b3e26ccba1cba3d961645f0824621ac",
    "file": "SkIRect_Reference",
    "name": "SkIRect::intersectNoEmptyCheck",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkIRect_intersect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect result;\n    bool intersected = result.intersect({ 10, 40, 50, 80 }, { 30, 60, 70, 90 });\n    SkDebugf(\"%s intersection: %d, %d, %d, %d\\n\", intersected ? \"\" : \"no \",\n             result.left(), result.top(), result.right(), result.bottom());\n}",
    "hash": "b2db0573aacf99ca52776c5522459d02",
    "file": "SkIRect_Reference",
    "name": "SkIRect::intersect_2",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkIRect_intersect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect leftRect =  { 10, 40, 50, 80 };\n    SkDebugf(\"%s intersection: \", leftRect.intersect(30, 60, 70, 90) ? \"\" : \"no \");\n    SkDebugf(\"%d, %d, %d, %d\\n\", leftRect.left(), leftRect.top(), \n                                 leftRect.right(), leftRect.bottom());\n}",
    "hash": "4e6f580a3906c08a5faee524f7e72334",
    "file": "SkIRect_Reference",
    "name": "SkIRect::intersect_3",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkIRect_is16Bit": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect tests[] = {{-32768, -32768, 32767, 32767}, {-32768, -32768, 32768, 32768}};\n    for (auto rect : tests) {\n        SkDebugf(\"{%d, %d, %d, %d} %s in 16 bits\\n\", rect.fLeft, rect.fTop, rect.fRight,\n                 rect.fBottom, rect.is16Bit() ? \"fits\" : \"does not fit\");\n}\n}",
    "hash": "103e8d463e68e87e0f8f9454a7d3441c",
    "file": "SkIRect_Reference",
    "name": "SkIRect::is16Bit",
        "stdout": "{-32768, -32768, 32767, 32767} fits in 16 bits\\n{-32768, -32768, 32768, 32768} does not fit in 16 bits\\n"
    },
        "SkIRect_isEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};\n    for (auto rect : tests) {\n        SkDebugf(\"rect: {%d, %d, %d, %d} is\" \"%s empty\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isEmpty() ? \"\" : \" not\");\n        rect.sort();\n        SkDebugf(\"sorted: {%d, %d, %d, %d} is\" \"%s empty\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isEmpty() ? \"\" : \" not\");\n    }\n}",
    "hash": "edaad064b6de249b7a7c768dfa000adc",
    "file": "SkIRect_Reference",
    "name": "SkIRect::isEmpty",
        "stdout": "rect: {20, 40, 10, 50} is empty\\nsorted: {10, 40, 20, 50} is not empty\\nrect: {20, 40, 20, 50} is empty\\nsorted: {20, 40, 20, 50} is empty\\n"
    },
        "SkIRect_join": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 20, 15, 25};\n    rect.join(50, 60, 55, 65);\n    SkDebugf(\"join: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "c00ef06289d21db70340e465690e0e08",
    "file": "SkIRect_Reference",
    "name": "SkIRect::join()",
        "stdout": "join: 10, 20, 55, 65\\n"
    },
        "SkIRect_join_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 20, 15, 25};\n    rect.join({50, 60, 55, 65});\n    SkDebugf(\"join: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "75fd81c1d3512e63890d085593018876",
    "file": "SkIRect_Reference",
    "name": "SkIRect::join_2",
        "stdout": "join: 10, 20, 55, 65\\n"
    },
        "SkIRect_left": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 5, 10, 25 };\n    SkDebugf(\"unsorted.fLeft: %d unsorted.left(): %d\\n\", unsorted.fLeft, unsorted.left());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fLeft: %d sorted.left(): %d\\n\", sorted.fLeft, sorted.left());\n}",
    "hash": "caf38ea4431bc246ba198f6a8c2b0f01",
    "file": "SkIRect_Reference",
    "name": "SkIRect::left()",
        "stdout": "unsorted.fLeft: 15 unsorted.left(): 15\\nsorted.fLeft: 10 sorted.left(): 10\\n"
    },
        "SkIRect_makeInset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeInset(15, 32);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "1db94b2c76e0a7a71856532335fa56b6",
    "file": "SkIRect_Reference",
    "name": "SkIRect::makeInset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: 25, 82, 5, 28  isEmpty: true\\n"
    },
        "SkIRect_makeOffset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeOffset(15, 32);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "737c747df07ddf392c05970440de0927",
    "file": "SkIRect_Reference",
    "name": "SkIRect::makeOffset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: 25, 82, 35, 92  isEmpty: false\\n"
    },
        "SkIRect_makeOutset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeOutset(15, 32);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "240e2953e3455c08f6d89255feff8416",
    "file": "SkIRect_Reference",
    "name": "SkIRect::makeOutset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: -5, 18, 35, 92  isEmpty: false\\n"
    },
        "SkIRect_makeSorted": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 20, 10 };\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    SkIRect sort = rect.makeSorted();\n    SkDebugf(\"sorted: %d, %d, %d, %d\\n\", sort.fLeft, sort.fTop, sort.fRight, sort.fBottom);\n}",
    "hash": "de89926c374aa16427916900b89a3441",
    "file": "SkIRect_Reference",
    "name": "SkIRect::makeSorted",
        "stdout": "rect: 30, 50, 20, 10\\nsorted: 20, 10, 30, 50\\n"
    },
        "SkIRect_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect test = {2, 2, 0, 0};\n    SkIRect sorted = test.makeSorted();\n    SkDebugf(\"test %c= sorted\\n\", test != sorted ? '!' : '=');\n}",
    "hash": "6c4acd8aa203f632b7d85cae672abf4d",
    "file": "SkIRect_Reference",
    "name": "SkIRect::operator!=(const SkIRect& a, const SkIRect& b)",
        "stdout": "test != sorted\\n"
    },
        "SkIRect_offset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 14, 50, 73 };\n    rect.offset(5, 13);\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "77e633b2174ffae923c038b303418b50",
    "file": "SkIRect_Reference",
    "name": "SkIRect::offset()",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkIRect_offsetTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 14, 50, 73 };\n    rect.offsetTo(15, 27);\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "a2734ff23b35653956a3002e5c29ff91",
    "file": "SkIRect_Reference",
    "name": "SkIRect::offsetTo",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkIRect_offset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 14, 50, 73 };\n    rect.offset({5, 13});\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "31a4c575499e76def651eb65994876f0",
    "file": "SkIRect_Reference",
    "name": "SkIRect::offset_2",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkIRect_outset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 10, 14, 50, 73 };\n    rect.outset(5, 13);\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "3fc62ca29428195f33a3a02b3eb74e4f",
    "file": "SkIRect_Reference",
    "name": "SkIRect::outset()",
        "stdout": "rect: 5, 1, 55, 86\\n"
    },
        "SkIRect_quickReject": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkIRect rect = {7, 11, 13, 17};\n    const int32_t* r = &rect.fLeft;\n    const SkIRect tests[] = { {13, 11, 15, 17}, { 7, 7, 13, 11 }, { 12, 16, 14, 18 } };\n    for (auto& test : tests) {\n      const int32_t* t = &test.fLeft;\n      SkDebugf(\"rect (%d, %d, %d, %d) test(%d, %d, %d, %d) quickReject %s; intersects %s\\n\",\n               r[0], r[1], r[2], r[3], t[0], t[1], t[2], t[3],\n               rect.quickReject(t[0], t[1], t[2], t[3]) ? \"true\" : \"false\", \n               SkIRect::Intersects(rect, test) ? \"true\" : \"false\");\n    }\n}",
    "hash": "f07146508efc516559d73853e6dadc78",
    "file": "SkIRect_Reference",
    "name": "SkIRect::quickReject",
        "stdout": "rect (7, 11, 13, 17) test(13, 11, 15, 17) quickReject true; intersects false\\nrect (7, 11, 13, 17) test(7, 7, 13, 11) quickReject true; intersects false\\nrect (7, 11, 13, 17) test(12, 16, 14, 18) quickReject false; intersects true\\n"
    },
        "SkIRect_right": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fRight: %d unsorted.right(): %d\\n\", unsorted.fRight, unsorted.right());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fRight: %d sorted.right(): %d\\n\", sorted.fRight, sorted.right());\n}",
    "hash": "97e210976f1ee0387b30c70635cf114f",
    "file": "SkIRect_Reference",
    "name": "SkIRect::right()",
        "stdout": "unsorted.fRight: 10 unsorted.right(): 10\\nsorted.fRight: 15 sorted.right(): 15\\n"
    },
        "SkIRect_set": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect1 = {3, 4, 1, 2};\n    SkDebugf(\"rect1: {%d, %d, %d, %d}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkIRect rect2;\n    rect2.set(3, 4, 1, 2);\n    SkDebugf(\"rect2: {%d, %d, %d, %d}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "1912c37076b7f3bf6aebfa167e971bec",
    "file": "SkIRect_Reference",
    "name": "SkIRect::set()",
        "stdout": "rect1: {3, 4, 1, 2}\\nrect2: {3, 4, 1, 2}\\n"
    },
        "SkIRect_setEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = {3, 4, 1, 2};\n    for (int i = 0; i < 2; ++i) {\n    SkDebugf(\"rect: {%d, %d, %d, %d} is %s\" \"empty\\n\", rect.fLeft, rect.fTop,\n             rect.fRight, rect.fBottom, rect.isEmpty() ? \"\" : \"not \");\n    rect.setEmpty();\n    }\n}",
    "hash": "94039c3cc9e911c8ab2993d56fd06210",
    "file": "SkIRect_Reference",
    "name": "SkIRect::setEmpty",
        "stdout": "rect: {3, 4, 1, 2} is empty\\nrect: {0, 0, 0, 0} is empty\\n"
    },
        "SkIRect_setLTRB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect1 = {3, 4, 1, 2};\n    SkDebugf(\"rect1: {%d, %d, %d, %d}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkIRect rect2;\n    rect2.setLTRB(3, 4, 1, 2);\n    SkDebugf(\"rect2: {%d, %d, %d, %d}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "ead6bdcf2ae77ec19a1c5a96f5b31af8",
    "file": "SkIRect_Reference",
    "name": "SkIRect::setLTRB",
        "stdout": "rect1: {3, 4, 1, 2}\\nrect2: {3, 4, 1, 2}\\n"
    },
        "SkIRect_setXYWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect;\n    rect.setXYWH(5, 35, -15, 25);\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %d, %d, %d, %d  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "0e1db8c86678c004e504f47641b44b17",
    "file": "SkIRect_Reference",
    "name": "SkIRect::setXYWH",
        "stdout": "rect: 5, 35, -10, 60  isEmpty: true\\nrect: -10, 35, 5, 60  isEmpty: false\\n"
    },
        "SkIRect_size": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkIRect& rect) -> void {\n        SkISize size = rect.size();\n        SkDebugf(\"%s \", prefix);\n        SkDebugf(\"rect: %d, %d, %d, %d  \", rect.left(), rect.top(), rect.right(), rect.bottom());\n        SkDebugf(\"size: %d, %d\\n\", size.width(), size.height());\n    };\n    SkIRect rect = {20, 30, 40, 50};\n    debugster(\"original\", rect);\n    rect.offset(20, 20);\n    debugster(\"  offset\", rect);\n    rect.outset(20, 20);\n    debugster(\"  outset\", rect);\n}",
    "hash": "8b3224641cb3053a7b8a5798b6cd1cf6",
    "file": "SkIRect_Reference",
    "name": "SkIRect::size()",
        "stdout": "original rect: 20, 30, 40, 50  size: 20, 20\\n  offset rect: 40, 50, 60, 70  size: 20, 20\\n  outset rect: 20, 30, 80, 90  size: 60, 60\\n"
    },
        "SkIRect_sort": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 30, 50, 20, 10 };\n    SkDebugf(\"rect: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    rect.sort();\n    SkDebugf(\"sorted: %d, %d, %d, %d\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "fa12547fcfd4c1aef3db1a1f6aae0fe4",
    "file": "SkIRect_Reference",
    "name": "SkIRect::sort()",
        "stdout": "rect: 30, 50, 20, 10\\nsorted: 20, 10, 30, 50\\n"
    },
        "SkIRect_top": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fTop: %d unsorted.top(): %d\\n\", unsorted.fTop, unsorted.top());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fTop: %d sorted.top(): %d\\n\", sorted.fTop, sorted.top());\n}",
    "hash": "cbec1ae6530e95943775450b1d11f19e",
    "file": "SkIRect_Reference",
    "name": "SkIRect::top()",
        "stdout": "unsorted.fTop: 25 unsorted.top(): 25\\nsorted.fTop: 5 sorted.top(): 5\\n"
    },
        "SkIRect_width": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted width: %d\\n\", unsorted.width());\n    SkIRect large = { -2147483647, 1, 2147483644, 2 };\n    SkDebugf(\"large width: %d\\n\", large.width());\n}",
    "hash": "4acfbe051805940210c8916a94794142",
    "file": "SkIRect_Reference",
    "name": "SkIRect::width()",
        "stdout": "unsorted width: -5\\nlarge width: -5\\n"
    },
        "SkIRect_x": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 5, 10, 25 };\n    SkDebugf(\"unsorted.fLeft: %d unsorted.x(): %d\\n\", unsorted.fLeft, unsorted.x());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fLeft: %d sorted.x(): %d\\n\", sorted.fLeft, sorted.x());\n}",
    "hash": "2a59cbfd1330a0db520d6ebb2b7c68c7",
    "file": "SkIRect_Reference",
    "name": "SkIRect::x()",
        "stdout": "unsorted.fLeft: 15 unsorted.x(): 15\\nsorted.fLeft: 10 sorted.x(): 10\\n"
    },
        "SkIRect_y": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fTop: %d unsorted.y(): %d\\n\", unsorted.fTop, unsorted.y());\n    SkIRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fTop: %d sorted.y(): %d\\n\", sorted.fTop, sorted.y());\n}",
    "hash": "6ea461e71f7fc80605818fbf493caa63",
    "file": "SkIRect_Reference",
    "name": "SkIRect::y()",
        "stdout": "unsorted.fTop: 25 unsorted.y(): 25\\nsorted.fTop: 5 sorted.y(): 5\\n"
    },
        "SkImage_MakeFromRaster": {
    "code": "static void releaseProc(const void* pixels, SkImage::ReleaseContext context) {\n     int* countPtr = static_cast<int*>(context);\n     *countPtr += 1;\n}\n\nvoid draw(SkCanvas* canvas) {\n    SkColor color = 0;\n    SkPixmap pixmap(SkImageInfo::MakeN32(1, 1, kPremul_SkAlphaType), &color, 4);\n    int releaseCount = 0;\n    sk_sp<SkImage> image(SkImage::MakeFromRaster(pixmap, releaseProc, &releaseCount));\n    SkDebugf(\"before reset: %d\\n\", releaseCount);\n    image.reset();\n    SkDebugf(\"after reset: %d\\n\", releaseCount);\n}\n",
    "hash": "275356b65d18c8868f4434137350cddc",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromRaster",
        "stdout": "before reset: 0\\nafter reset: 1\\n"
    },
        "SkImage_dimensions": {
    "code": "void draw(SkCanvas* canvas) {\n    SkISize dimensions = image->dimensions();\n    SkIRect bounds = image->bounds();\n    SkIRect dimensionsAsBounds = SkIRect::MakeSize(dimensions);\n    SkDebugf(\"dimensionsAsBounds %c= bounds\\n\", dimensionsAsBounds == bounds ? '=' : '!');\n}",
    "hash": "96b4bc43b3667df9ba9e2dafb770d33c",
    "file": "SkImage_Reference",
    "name": "SkImage::dimensions()",
        "stdout": "dimensionsAsBounds == bounds\\n"
    },
        "SkImage_isAlphaOnly": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t pmColors = 0;\n    sk_sp<SkImage> image = SkImage::MakeRasterCopy({SkImageInfo::MakeA8(1, 1), &pmColors, 1});\n    SkDebugf(\"alphaOnly = %s\\n\", image->isAlphaOnly() ? \"true\" : \"false\");\n}",
    "hash": "50762c73b8ea91959c5a7b68fbf1062d",
    "file": "SkImage_Reference",
    "name": "SkImage::isAlphaOnly",
        "stdout": "alphaOnly = true\\n"
    },
        "SkImage_isOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    auto check_isopaque = [](const SkImageInfo& imageInfo) -> void {\n        auto surface(SkSurface::MakeRaster(imageInfo));\n        auto image(surface->makeImageSnapshot());\n        SkDebugf(\"isOpaque = %s\\n\", image->isOpaque() ? \"true\" : \"false\");\n    };\n    check_isopaque(SkImageInfo::MakeN32Premul(5, 5));\n    check_isopaque(SkImageInfo::MakeN32(5, 5, kOpaque_SkAlphaType));\n}",
    "hash": "e3340460003b74ee286d625e68589d65",
    "file": "SkImage_Reference",
    "name": "SkImage::isOpaque",
        "stdout": "isOpaque = false\\nisOpaque = true\\n"
    },
        "SkImage_peekPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(12, 11));\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorWHITE);\n    SkPaint paint;\n    offscreen.drawString(\"%\", 1, 10, paint);\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkPixmap pixmap;\n    if (image->peekPixels(&pixmap)) {\n        const SkPMColor* pixels = pixmap.addr32();\n        SkPMColor pmWhite = pixels[0];\n        for (int y = 0; y < image->height(); ++y) {\n            for (int x = 0; x < image->width(); ++x) {\n                SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n            }\n            SkDebugf(\"\\n\");\n        }\n    }\n}",
    "hash": "900c0eab8dfdecd8301ed5be95887f8e",
    "file": "SkImage_Reference",
    "name": "SkImage::peekPixels",
        "stdout": "------------\\n--xx----x---\\n-x--x--x----\\n-x--x--x----\\n-x--x-x-----\\n--xx-xx-xx--\\n-----x-x--x-\\n----x--x--x-\\n----x--x--x-\\n---x----xx--\\n------------\\n"
    },
        "SkMatrix_I": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m1, m2, m3;\n    m1.reset();\n    m2.setIdentity();\n    m3 = SkMatrix::I();\n    SkDebugf(\"m1 %c= m2\\n\", m1 == m2 ? '=' : '!');\n    SkDebugf(\"m2 %c= m3\\n\", m1 == m2 ? '=' : '!');\n}",
    "hash": "d961d91020f19037204a8c3fd8cb1060",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::I",
        "stdout": "m1 == m2\\nm2 == m3\\n"
    },
        "SkMatrix_InvalidMatrix": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"scaleX %g\\n\", SkMatrix::InvalidMatrix().getScaleX());\n}",
    "hash": "af0b72360c1c7a25b4754bfa47011dd5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::InvalidMatrix",
        "stdout": "scaleX 3.40282e+38\\n"
    },
        "SkMatrix_MakeRectToRect": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkRect srcs[] = { {0, 0, 0, 0}, {1, 2, 3, 4} };\n    const SkRect dsts[] = { {0, 0, 0, 0}, {5, 6, 8, 9} };\n    for (auto src : srcs) {\n        for (auto dst : dsts) {\n             SkMatrix matrix = SkMatrix::MakeRectToRect(src, dst, SkMatrix::kFill_ScaleToFit);\n             SkDebugf(\"src: %g, %g, %g, %g  dst: %g, %g, %g, %g\\n\",\n                      src.fLeft, src.fTop, src.fRight, src.fBottom,\n                      dst.fLeft, dst.fTop, dst.fRight, dst.fBottom);\n             matrix.dump();\n        }\n    }\n}",
    "hash": "a1d6a6721b39350f81021f71a1b93208",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::MakeRectToRect",
        "stdout": "src: 0, 0, 0, 0  dst: 0, 0, 0, 0\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 0, 0, 0, 0  dst: 5, 6, 8, 9\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 1, 2, 3, 4  dst: 0, 0, 0, 0\\n[  0.0000   0.0000   0.0000][  0.0000   0.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 1, 2, 3, 4  dst: 5, 6, 8, 9\\n[  1.5000   0.0000   3.5000][  0.0000   1.5000   3.0000][  0.0000   0.0000   1.0000]\\n"
    },
        "SkMatrix_SetAffineIdentity": {
    "code": "void draw(SkCanvas* canvas) {\n    SkScalar affine[6];\n    SkMatrix::SetAffineIdentity(affine);\n    const char* names[] = { \"ScaleX\", \"SkewY\", \"SkewX\", \"ScaleY\", \"TransX\", \"TransY\" };\n    for (int i = 0; i < 6; ++i) {\n        SkDebugf(\"%s: %g \", names[i], affine[i]);\n    }\n    SkDebugf(\"\\n\");\n}",
    "hash": "e10adbd0bcc940c5d4d872db0e78e892",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::SetAffineIdentity",
        "stdout": "ScaleX: 1 SkewY: 0 SkewX: 0 ScaleY: 1 TransX: 0 TransY: 0 \\n"
    },
        "SkMatrix_TypeMask": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkMatrix& matrix) -> void {\n        SkString typeMask;\n        typeMask += SkMatrix::kIdentity_Mask == matrix.getType() ? \"kIdentity_Mask \" : \"\";\n        typeMask += SkMatrix::kTranslate_Mask & matrix.getType() ? \"kTranslate_Mask \" : \"\";\n        typeMask += SkMatrix::kScale_Mask & matrix.getType() ? \"kScale_Mask \" : \"\";\n        typeMask += SkMatrix::kAffine_Mask & matrix.getType() ? \"kAffine_Mask \" : \"\";\n        typeMask += SkMatrix::kPerspective_Mask & matrix.getType() ? \"kPerspective_Mask\" : \"\";\n        SkDebugf(\"after %s: %s\\n\", prefix, typeMask.c_str());\n    };\nSkMatrix matrix;\nmatrix.reset();\ndebugster(\"reset\", matrix);\nmatrix.postTranslate(1, 0);\ndebugster(\"postTranslate\", matrix);\nmatrix.postScale(2, 1);\ndebugster(\"postScale\", matrix);\nmatrix.postRotate(45);\ndebugster(\"postScale\", matrix);\nSkPoint polys[][4] = {{{0, 0}, {0, 1}, {1, 1}, {1, 0}}, {{0, 0}, {0, 1}, {2, 1}, {1, 0}}};\nmatrix.setPolyToPoly(polys[0], polys[1], 4);\ndebugster(\"setPolyToPoly\", matrix);\n}",
    "hash": "ba19b36df8cd78586f3dff54e2d4c093",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::TypeMask",
        "stdout": "after reset: kIdentity_Mask \\nafter postTranslate: kTranslate_Mask \\nafter postScale: kTranslate_Mask kScale_Mask \\nafter postScale: kTranslate_Mask kScale_Mask kAffine_Mask \\nafter setPolyToPoly: kTranslate_Mask kScale_Mask kAffine_Mask kPerspective_Mask\\n"
    },
        "SkMatrix_array1_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setIdentity();\n    SkDebugf(\"with identity matrix: x = %g\\n\", matrix.mapXY(24, 42).fX);\n    SkScalar& skewRef = matrix[SkMatrix::kMSkewX];\n    skewRef = 0;\n    SkDebugf(\"after skew x mod:     x = %g\\n\", matrix.mapXY(24, 42).fX);\n    skewRef = 1;\n    SkDebugf(\"after 2nd skew x mod: x = %g\\n\", matrix.mapXY(24, 42).fX);\n    matrix.dirtyMatrixTypeCache();\n    SkDebugf(\"after dirty cache:    x = %g\\n\", matrix.mapXY(24, 42).fX);\n}",
    "hash": "f4365ef332f51f7fd25040e0771ba9a2",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::operator[](int index)",
        "stdout": "with identity matrix: x = 24\\nafter skew x mod:     x = 24\\nafter 2nd skew x mod: x = 24\\nafter dirty cache:    x = 66\\n"
    },
        "SkMatrix_array_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScale(42, 24);\n    SkDebugf(\"matrix[SkMatrix::kMScaleX] %c= 42\\n\", matrix[SkMatrix::kMScaleX] == 42 ? '=' : '!');\n    SkDebugf(\"matrix[SkMatrix::kMScaleY] %c= 24\\n\", matrix[SkMatrix::kMScaleY] == 24 ? '=' : '!');\n}",
    "hash": "e8740493abdf0c6341762db9cee56b89",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::operator[](int index)_const",
        "stdout": "matrix[SkMatrix::kMScaleX] == 42\\nmatrix[SkMatrix::kMScaleY] == 24\\n"
    },
        "SkMatrix_asAffine": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setAll(2, 3, 4, 5, 6, 7, 0, 0, 1);\n    SkScalar affine[6];\n    matrix.asAffine(affine);\n    const char* names[] = { \"ScaleX\", \"SkewY\", \"SkewX\", \"ScaleY\", \"TransX\", \"TransY\" };\n    for (int i = 0; i < 6; ++i) {\n        SkDebugf(\"%s: %g \", names[i], affine[i]);\n    }\n    SkDebugf(\"\\n\");\n}",
    "hash": "752e4a48ed1dae05765a2499c390f277",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::asAffine",
        "stdout": "ScaleX: 2 SkewY: 5 SkewX: 3 ScaleY: 6 TransX: 4 TransY: 7 \\n"
    },
        "SkMatrix_cheapEqualTo": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkMatrix& a, const SkMatrix& b) -> void {\n        SkDebugf(\"%s: a %c= b a.cheapEqualTo(b): %s\\n\", prefix,\n                 a == b ? '=' : '!', a.cheapEqualTo(b) ? \"true\" : \"false\");\n    };\n    SkMatrix a, b;\n    a.setAll(1, 0, 0,   0, 1, 0,  0, 0, 1);\n    b.setIdentity();\n    debugster(\"identity\", a, b);\n    a.setAll(1, -0.0f, 0,   0, 1, 0,  0, 0, 1);\n    debugster(\"neg zero\", a, b);\n    a.setAll(1, SK_ScalarNaN, 0,   0, 1, 0,  0, 0, 1);\n    debugster(\" one NaN\", a, b);\n    b.setAll(1, SK_ScalarNaN, 0,   0, 1, 0,  0, 0, 1);\n    debugster(\"both NaN\", a, b);\n}",
    "hash": "39016b3cfc6bbabb09348a53822ce508",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::cheapEqualTo",
        "stdout": "identity: a == b a.cheapEqualTo(b): true\\nneg zero: a == b a.cheapEqualTo(b): false\\n one NaN: a != b a.cheapEqualTo(b): false\\nboth NaN: a != b a.cheapEqualTo(b): true\\n"
    },
        "SkMatrix_decomposeScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setRotate(90 * SK_Scalar1);\n    matrix.postScale(1.f / 4, 1.f / 2);\n    matrix.dump();\n    SkSize scale = {SK_ScalarNaN, SK_ScalarNaN};\n    SkMatrix remaining;\n    remaining.reset();\n    bool success = matrix.decomposeScale(&scale, &remaining);\n    SkDebugf(\"success: %s  \", success ? \"true\" : \"false\");\n    SkDebugf(\"scale: %g, %g\\n\", scale.width(), scale.height());\n    remaining.dump();\n    SkMatrix scaleMatrix = SkMatrix::MakeScale(scale.width(), scale.height());\n    SkMatrix combined = SkMatrix::Concat(scaleMatrix, remaining);\n    combined.dump();\n}",
    "hash": "139b874da0a3ede1f3df88119085c0aa",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::decomposeScale",
        "stdout": "[  0.0000  -0.2500   0.0000][  0.5000   0.0000   0.0000][  0.0000   0.0000   1.0000]\\nsuccess: true  scale: 0.5, 0.25\\n[  0.0000  -0.5000   0.0000][  2.0000   0.0000   0.0000][  0.0000   0.0000   1.0000]\\n[  0.0000  -0.2500   0.0000][  0.5000   0.0000   0.0000][  0.0000   0.0000   1.0000]\\n"
    },
        "SkMatrix_dirtyMatrixTypeCache": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setIdentity();\n    SkDebugf(\"with identity matrix: x = %g\\n\", matrix.mapXY(24, 42).fX);\n    SkScalar& skewRef = matrix[SkMatrix::kMSkewX];\n    skewRef = 0;\n    SkDebugf(\"after skew x mod:     x = %g\\n\", matrix.mapXY(24, 42).fX);\n    skewRef = 1;\n    SkDebugf(\"after 2nd skew x mod: x = %g\\n\", matrix.mapXY(24, 42).fX);\n    matrix.dirtyMatrixTypeCache();\n    SkDebugf(\"after dirty cache:    x = %g\\n\", matrix.mapXY(24, 42).fX);\n}",
    "hash": "f4365ef332f51f7fd25040e0771ba9a2",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::dirtyMatrixTypeCache",
        "stdout": "with identity matrix: x = 24\\nafter skew x mod:     x = 24\\nafter 2nd skew x mod: x = 24\\nafter dirty cache:    x = 66\\n"
    },
        "SkMatrix_dump": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setRotate(45);\n    matrix.dump();\n    SkMatrix nearlyEqual;\n    nearlyEqual.setAll(0.7071f, -0.7071f, 0,   0.7071f, 0.7071f, 0,   0, 0, 1);\n    nearlyEqual.dump();\n    SkDebugf(\"matrix %c= nearlyEqual\\n\", matrix == nearlyEqual ? '=' : '!');\n}",
    "hash": "8d72a4818e5a9188348f6c08ab5d8a40",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::dump()",
        "stdout": "[  0.7071  -0.7071   0.0000][  0.7071   0.7071   0.0000][  0.0000   0.0000   1.0000]\\n[  0.7071  -0.7071   0.0000][  0.7071   0.7071   0.0000][  0.0000   0.0000   1.0000]\\nmatrix != nearlyEqual\\n"
    },
        "SkMatrix_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkMatrix& a, const SkMatrix& b) -> void {\n        SkDebugf(\"%s: a %c= b a.cheapEqualTo(b): %s\\n\", prefix,\n                 a == b ? '=' : '!', a.cheapEqualTo(b) ? \"true\" : \"false\");\n    };\n    SkMatrix a, b;\n    a.setAll(1, 0, 0,   0, 1, 0,  0, 0, 1);\n    b.setScale(2, 4);\n    b.postScale(0.5f, 0.25f);\n    debugster(\"identity\", a, b);\n}",
    "hash": "3902859150b0f0c4aeb1f25d00434baa",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::operator==(const SkMatrix& a, const SkMatrix& b)",
        "stdout": "identity: a == b a.cheapEqualTo(b): true\\n"
    },
        "SkMatrix_get": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setSkew(42, 24);\n    SkDebugf(\"matrix.get(SkMatrix::kMSkewX) %c= 42\\n\",\n             matrix.get(SkMatrix::kMSkewX) == 42 ? '=' : '!');\n    SkDebugf(\"matrix.get(SkMatrix::kMSkewY) %c= 24\\n\",\n             matrix.get(SkMatrix::kMSkewY) == 24 ? '=' : '!');\n}",
    "hash": "f5ed382bd04fa7d50b2398cce2fca23a",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::get()",
        "stdout": "matrix.get(SkMatrix::kMSkewX) == 42\\nmatrix.get(SkMatrix::kMSkewY) == 24\\n"
    },
        "SkMatrix_get9": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix = SkMatrix::MakeRectToRect({0, 0, 1, 1}, {3, 4, 7, 9},\n                                               SkMatrix::kFill_ScaleToFit);\n    SkScalar b[9];\n    matrix.get9(b);\n    SkDebugf(\"{%g, %g, %g},\\n{%g, %g, %g},\\n{%g, %g, %g}\\n\", b[0], b[1], b[2], \n             b[3], b[4], b[5], b[6], b[7], b[8]);\n}",
    "hash": "df509d73b47cb98b0475e4465db7b246",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::get9",
        "stdout": "{4, 0, 3},\\n{0, 5, 4},\\n{0, 0, 1}\\n"
    },
        "SkMatrix_getMaxScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScale(42, 24);\n    SkDebugf(\"matrix.getMaxScale() %g\\n\", matrix.getMaxScale());\n}",
    "hash": "3fee4364929899649cf9efc37897e964",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getMaxScale",
        "stdout": "matrix.getMaxScale() 42\\n"
    },
        "SkMatrix_getMinMaxScales": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setAll(1, 0, 0,  0, 1, 0,   0, 0, 0);\n    matrix.invert(&matrix); \n    SkScalar factor[2] = {2, 2};\n    bool result = matrix.getMinMaxScales(factor);\n    SkDebugf(\"matrix.getMinMaxScales() %s %g %g\\n\", result ? \"true\" : \"false\", factor[0], factor[1]);\n}",
    "hash": "cd4dc63d3e04226f0b5861ba8925e223",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getMinMaxScales",
        "stdout": "matrix.getMinMaxScales() false 2 2\\n"
    },
        "SkMatrix_getMinScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScale(42, 24);\n    SkDebugf(\"matrix.getMinScale() %g\\n\", matrix.getMinScale());\n}",
    "hash": "1d6f67904c88a806c3731879e9af4ae5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getMinScale",
        "stdout": "matrix.getMinScale() 24\\n"
    },
        "SkMatrix_getScaleX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScale(42, 24);\n    SkDebugf(\"matrix.getScaleX() %c= 42\\n\", matrix.getScaleX() == 42 ? '=' : '!');\n}",
    "hash": "ab746d9be63975041ae8e50cba84dc3d",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getScaleX",
        "stdout": "matrix.getScaleX() == 42\\n"
    },
        "SkMatrix_getScaleY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScale(42, 24);\n    SkDebugf(\"matrix.getScaleY() %c= 24\\n\", matrix.getScaleY() == 24 ? '=' : '!');\n}",
    "hash": "708b1a548a2f8661b2ab570782fbc751",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getScaleY",
        "stdout": "matrix.getScaleY() == 24\\n"
    },
        "SkMatrix_getSkewX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setSkew(42, 24);\n    SkDebugf(\"matrix.getSkewX() %c= 42\\n\", matrix.getSkewX() == 42 ? '=' : '!');\n}",
    "hash": "df3a5d3c688e7597eae1e4e07bf91ae6",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getSkewX",
        "stdout": "matrix.getSkewX() == 42\\n"
    },
        "SkMatrix_getSkewY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setSkew(42, 24);\n    SkDebugf(\"matrix.getSkewY() %c= 24\\n\", matrix.getSkewY() == 24 ? '=' : '!');\n}",
    "hash": "6be5704506d029ffc91ba03b1d3e674b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getSkewY",
        "stdout": "matrix.getSkewY() == 24\\n"
    },
        "SkMatrix_getTranslateX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setTranslate(42, 24);\n    SkDebugf(\"matrix.getTranslateX() %c= 42\\n\", matrix.getTranslateX() == 42 ? '=' : '!');\n}",
    "hash": "6236f7f2b91aff977a66ba2ee2558ca4",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getTranslateX",
        "stdout": "matrix.getTranslateX() == 42\\n"
    },
        "SkMatrix_getTranslateY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setTranslate(42, 24);\n    SkDebugf(\"matrix.getTranslateY() %c= 24\\n\", matrix.getTranslateY() == 24 ? '=' : '!');\n}",
    "hash": "08464e32d22421d2b254c71a84545ef5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getTranslateY",
        "stdout": "matrix.getTranslateY() == 24\\n"
    },
        "SkMatrix_getType": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setAll(1, 0, 0,   0, 1, 0,    0, 0, 1);\n    SkDebugf(\"identity flags hex: %0x decimal: %d\\n\", matrix.getType(), matrix.getType());\n    matrix.setAll(1, 0, 0,   0, 1, 0,    0, 0, .5f);\n    SkDebugf(\"set all  flags hex: %0x decimal: %d\\n\", matrix.getType(), matrix.getType());\n}",
    "hash": "8e45fe2dd52731bb2d4318686257e1d7",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getType",
        "stdout": "identity flags hex: 0 decimal: 0\\nset all  flags hex: f decimal: 15\\n"
    },
        "SkMatrix_isFinite": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix = SkMatrix::MakeTrans(SK_ScalarNaN, 0);\n    matrix.dump();\n    SkDebugf(\"matrix is finite: %s\\n\", matrix.isFinite() ? \"true\" : \"false\");\n    SkDebugf(\"matrix %c= matrix\\n\", matrix == matrix ? '=' : '!');\n}",
    "hash": "bc6c6f6a5df770287120d87f81b922eb",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isFinite",
        "stdout": "[  1.0000   0.0000      nan][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nmatrix is finite: false\\nmatrix != matrix\\n"
    },
        "SkMatrix_isFixedStepInX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    for (SkScalar px : { 0.0f, 0.1f } ) {\n        for (SkScalar py : { 0.0f, 0.1f } ) {\n            for (SkScalar sy : { 1, 2 } ) {\n                matrix.setAll(1, 0, 0,   0, sy, 0,   px, py, 1);\n                matrix.dump();\n                SkDebugf(\"isFixedStepInX: %s\\n\", matrix.isFixedStepInX() ? \"true\" : \"false\");\n            }\n        }\n    }\n}",
    "hash": "ab57b232acef69f26de9cb23d23c8a1a",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isFixedStepInX",
        "stdout": "[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nisFixedStepInX: true\\n[  1.0000   0.0000   0.0000][  0.0000   2.0000   0.0000][  0.0000   0.0000   1.0000]\\nisFixedStepInX: true\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.1000   1.0000]\\nisFixedStepInX: true\\n[  1.0000   0.0000   0.0000][  0.0000   2.0000   0.0000][  0.0000   0.1000   1.0000]\\nisFixedStepInX: true\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.1000   0.0000   1.0000]\\nisFixedStepInX: false\\n[  1.0000   0.0000   0.0000][  0.0000   2.0000   0.0000][  0.1000   0.0000   1.0000]\\nisFixedStepInX: false\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.1000   0.1000   1.0000]\\nisFixedStepInX: false\\n[  1.0000   0.0000   0.0000][  0.0000   2.0000   0.0000][  0.1000   0.1000   1.0000]\\nisFixedStepInX: false\\n"
    },
        "SkMatrix_isIdentity": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setAll(1, 0, 0,   0, 1, 0,    0, 0, 1);\n    SkDebugf(\"is identity: %s\\n\", matrix.isIdentity() ? \"true\" : \"false\");\n    matrix.setAll(1, 0, 0,   0, 1, 0,    0, 0, 2);\n    SkDebugf(\"is identity: %s\\n\", matrix.isIdentity() ? \"true\" : \"false\");\n}",
    "hash": "780ab376325b3cfa889ea26c0769ec11",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isIdentity",
        "stdout": "is identity: true\\nis identity: false\\n"
    },
        "SkMatrix_isScaleTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    for (SkScalar scaleX : { 1, 2 } ) {\n        for (SkScalar translateX : { 0, 20 } ) {\n            matrix.setAll(scaleX, 0, translateX,   0, 1, 0,    0, 0, 1);\n            SkDebugf(\"is scale-translate: %s\\n\", matrix.isScaleTranslate() ? \"true\" : \"false\");\n        }\n    }\n}",
    "hash": "6287e29674a487eb94174992d45b9a34",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isScaleTranslate",
        "stdout": "is scale-translate: true\\nis scale-translate: true\\nis scale-translate: true\\nis scale-translate: true\\n"
    },
        "SkMatrix_isTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    for (SkScalar scaleX : { 1, 2 } ) {\n        for (SkScalar translateX : { 0, 20 } ) {\n            matrix.setAll(scaleX, 0, translateX,   0, 1, 0,    0, 0, 1);\n            SkDebugf(\"is translate: %s\\n\", matrix.isTranslate() ? \"true\" : \"false\");\n        }\n    }\n}",
    "hash": "73ac71a8a30841873577c11c6c9b38ee",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isTranslate",
        "stdout": "is translate: true\\nis translate: true\\nis translate: false\\nis translate: false\\n"
    },
        "SkMatrix_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkMatrix& a, const SkMatrix& b) -> void {\n        SkDebugf(\"%s: a %c= b a.cheapEqualTo(b): %s\\n\", prefix,\n                 a != b ? '!' : '=', a.cheapEqualTo(b) ? \"true\" : \"false\");\n    };\n    SkMatrix a, b;\n    a.setAll(1, 0, 0,   0, 1, 0,  1, 0, 1);\n    a.invert(&b);\n    debugster(\"identity\", a, b);\n}",
    "hash": "8a8fadf5fd294daa4ee152833cc0dc0e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::operator!=(const SkMatrix& a, const SkMatrix& b)",
        "stdout": "identity: a != b a.cheapEqualTo(b): false\\n"
    },
        "SkMatrix_preservesAxisAlignment": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    for (SkScalar angle: { 0, 90, 180, 270 } ) {\n        matrix.setRotate(angle);\n        SkDebugf(\"preservesAxisAlignment: %s\\n\", matrix.preservesAxisAlignment() ? \"true\" : \"false\");\n    }\n}",
    "hash": "7a234c96608fb7cb8135b9940b0b15f7",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preservesAxisAlignment",
        "stdout": "preservesAxisAlignment: true\\npreservesAxisAlignment: true\\npreservesAxisAlignment: true\\npreservesAxisAlignment: true\\n"
    },
        "SkMatrix_rectStaysRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    for (SkScalar angle: { 0, 90, 180, 270 } ) {\n        matrix.setRotate(angle);\n        SkDebugf(\"rectStaysRect: %s\\n\", matrix.rectStaysRect() ? \"true\" : \"false\");\n    }\n}",
    "hash": "ce5319c036c9b5086da8a0009fe409f8",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::rectStaysRect",
        "stdout": "rectStaysRect: true\\nrectStaysRect: true\\nrectStaysRect: true\\nrectStaysRect: true\\n"
    },
        "SkMatrix_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m;\n    m.reset();\n    SkDebugf(\"m.isIdentity(): %s\\n\", m.isIdentity() ? \"true\" : \"false\");\n}",
    "hash": "ca94f7922bc37ef03bbc51ad70536fcf",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::reset()",
        "stdout": "m.isIdentity(): true\\n"
    },
        "SkMatrix_set": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setIdentity();\n    SkDebugf(\"with identity matrix: x = %g\\n\", matrix.mapXY(24, 42).fX);\n    matrix.set(SkMatrix::kMSkewX, 0);\n    SkDebugf(\"after skew x mod:     x = %g\\n\", matrix.mapXY(24, 42).fX);\n    matrix.set(SkMatrix::kMSkewX, 1);\n    SkDebugf(\"after 2nd skew x mod: x = %g\\n\", matrix.mapXY(24, 42).fX);\n}",
    "hash": "1d400a92ca826cc89bcb88ea051f28c8",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::set()",
        "stdout": "with identity matrix: x = 24\\nafter skew x mod:     x = 24\\nafter 2nd skew x mod: x = 66\\n"
    },
        "SkMatrix_setAffine": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setAll(2, 3, 4, 5, 6, 7, 0, 0, 1);\n    SkScalar affine[6];\n    matrix.asAffine(affine);\n    const char* names[] = { \"ScaleX\", \"SkewY\", \"SkewX\", \"ScaleY\", \"TransX\", \"TransY\" };\n    for (int i = 0; i < 6; ++i) {\n        SkDebugf(\"%s: %g \", names[i], affine[i]);\n    }\n    SkDebugf(\"\\n\");\n    matrix.reset();\n    matrix.setAffine(affine);\n    matrix.dump();\n}",
    "hash": "403370bd53526f59020a7141955d70b0",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setAffine",
        "stdout": "ScaleX: 2 SkewY: 5 SkewX: 3 ScaleY: 6 TransX: 4 TransY: 7 \\n[  2.0000   3.0000   4.0000][  5.0000   6.0000   7.0000][  0.0000   0.0000   1.0000]\\n"
    },
        "SkMatrix_setIdentity": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m;\n    m.setIdentity();\n    SkDebugf(\"m.isIdentity(): %s\\n\", m.isIdentity() ? \"true\" : \"false\");\n}",
    "hash": "3979c865bb482e6ef1fafc71e56bbb91",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setIdentity",
        "stdout": "m.isIdentity(): true\\n"
    },
        "SkMatrix_setRectToRect": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkRect srcs[] = { {0, 0, 0, 0}, {1, 2, 3, 4} };\n    const SkRect dsts[] = { {0, 0, 0, 0}, {5, 6, 8, 9} };\n    for (auto src : srcs) {\n        for (auto dst : dsts) {\n             SkMatrix matrix;\n             matrix.setAll(-1, -1, -1, -1, -1, -1, -1, -1, -1);\n             bool success = matrix.setRectToRect(src, dst, SkMatrix::kFill_ScaleToFit);\n             SkDebugf(\"src: %g, %g, %g, %g  dst: %g, %g, %g, %g  success: %s\\n\",\n                      src.fLeft, src.fTop, src.fRight, src.fBottom,\n                      dst.fLeft, dst.fTop, dst.fRight, dst.fBottom, success ? \"true\" : \"false\");\n             matrix.dump();\n        }\n    }\n}",
    "hash": "69cdea599dcaaec35efcb24403f4287b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setRectToRect",
        "stdout": "src: 0, 0, 0, 0  dst: 0, 0, 0, 0  success: false\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 0, 0, 0, 0  dst: 5, 6, 8, 9  success: false\\n[  1.0000   0.0000   0.0000][  0.0000   1.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 1, 2, 3, 4  dst: 0, 0, 0, 0  success: true\\n[  0.0000   0.0000   0.0000][  0.0000   0.0000   0.0000][  0.0000   0.0000   1.0000]\\nsrc: 1, 2, 3, 4  dst: 5, 6, 8, 9  success: true\\n[  1.5000   0.0000   3.5000][  0.0000   1.5000   3.0000][  0.0000   0.0000   1.0000]\\n"
    },
        "SkMatrix_setScaleTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setScaleTranslate(1, 2, 3, 4);\n    matrix.dump();\n}",
    "hash": "fed43797f13796529cb6731385d6f8f3",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setScaleTranslate",
        "stdout": "[  1.0000   0.0000   3.0000][  0.0000   2.0000   4.0000][  0.0000   0.0000   1.0000]\\n"
    },
        "SkMatrix_toString": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setRotate(45);\n    SkString mStr, neStr;\n    matrix.toString(&mStr);\n    SkMatrix nearlyEqual;\n    nearlyEqual.setAll(0.7071f, -0.7071f, 0,   0.7071f, 0.7071f, 0,   0, 0, 1);\n    nearlyEqual.toString(&neStr);\n    SkDebugf(\"mStr  %s\\n\", mStr.c_str());\n    SkDebugf(\"neStr %s\\n\", neStr.c_str());\n    SkDebugf(\"matrix %c= nearlyEqual\\n\", matrix == nearlyEqual ? '=' : '!');\n}",
    "hash": "1d86e43958e42b8eaaa9b16df1baa4c8",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::toString",
        "stdout": "mStr  [  0.7071  -0.7071   0.0000][  0.7071   0.7071   0.0000][  0.0000   0.0000   1.0000]\\nneStr [  0.7071  -0.7071   0.0000][  0.7071   0.7071   0.0000][  0.0000   0.0000   1.0000]\\nmatrix != nearlyEqual\\n"
    },
        "SkPaint_containsText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    const uint16_t goodChar = 0x00B0;  // degree symbol\n    const uint16_t badChar = 0xD800;   // Unicode surrogate\n    paint.setTextEncoding(SkPaint::kUTF16_TextEncoding);\n    SkDebugf(\"0x%04x %c= has char\\n\", goodChar, \n            paint.containsText(&goodChar, 2) ? '=' : '!');\n    SkDebugf(\"0x%04x %c= has char\\n\", badChar,\n            paint.containsText(&badChar, 2) ? '=' : '!');\n}",
    "hash": "9202369019552f09cd4bec7f3046fee4",
    "file": "SkPaint_Reference",
    "name": "SkPaint::containsText",
        "stdout": "0x00b0 == has char\\n0xd800 != has char\\n"
    },
        "SkPaint_containsText_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    const uint16_t goodGlyph = 511;\n    const uint16_t zeroGlyph = 0;\n    const uint16_t badGlyph = 65535; // larger than glyph count in font\n    paint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);\n    SkDebugf(\"0x%04x %c= has glyph\\n\", goodGlyph, \n            paint.containsText(&goodGlyph, 2) ? '=' : '!');\n    SkDebugf(\"0x%04x %c= has glyph\\n\", zeroGlyph,\n            paint.containsText(&zeroGlyph, 2) ? '=' : '!');\n    SkDebugf(\"0x%04x %c= has glyph\\n\", badGlyph,\n            paint.containsText(&badGlyph, 2) ? '=' : '!');\n}",
    "hash": "904227febfd1c2e264955da0ef66da73",
    "file": "SkPaint_Reference",
    "name": "SkPaint::containsText_2",
        "stdout": "0x01ff == has glyph\\n0x0000 != has glyph\\n0xffff == has glyph\\n"
    },
        "SkPaint_copy_const_SkPaint": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1;\n    paint1.setColor(SK_ColorRED);\n    SkPaint paint2(paint1);\n    paint2.setColor(SK_ColorBLUE);\n    SkDebugf(\"SK_ColorRED %c= paint1.getColor()\\n\", SK_ColorRED == paint1.getColor() ? '=' : '!');\n    SkDebugf(\"SK_ColorBLUE %c= paint2.getColor()\\n\", SK_ColorBLUE == paint2.getColor() ? '=' : '!');\n}",
    "hash": "b99971ad0ef243d617925289d963b62d",
    "file": "SkPaint_Reference",
    "name": "SkPaint::SkPaint(const SkPaint& paint)",
        "stdout": "SK_ColorRED == paint1.getColor()\\nSK_ColorBLUE == paint2.getColor()\\n"
    },
        "SkPaint_copy_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint2 = paint1;\n    SkDebugf(\"SK_ColorRED %c= paint1.getColor()\\n\", SK_ColorRED == paint1.getColor() ? '=' : '!');\n    SkDebugf(\"SK_ColorRED %c= paint2.getColor()\\n\", SK_ColorRED == paint2.getColor() ? '=' : '!');\n}",
    "hash": "b476a9088f80dece176ed577807d3992",
    "file": "SkPaint_Reference",
    "name": "SkPaint::operator=(const SkPaint& paint)",
        "stdout": "SK_ColorRED == paint1.getColor()\\nSK_ColorRED == paint2.getColor()\\n"
    },
        "SkPaint_countText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    const uint8_t utf8[] = { 0x24, 0xC2, 0xA2, 0xE2, 0x82, 0xAC, 0xC2, 0xA5, 0xC2, 0xA3 };\n    SkDebugf(\"count = %d\\n\", paint.countText(utf8, sizeof(utf8)));\n}",
    "hash": "85436c71aab5410767fc688ab0573e09",
    "file": "SkPaint_Reference",
    "name": "SkPaint::countText",
        "stdout": "count = 5\\n"
    },
        "SkPaint_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint2.setColor(0xFFFF0000);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n    float intervals[] = { 5, 5 };\n    paint1.setPathEffect(SkDashPathEffect::Make(intervals, 2, 2.5f));\n    paint2.setPathEffect(SkDashPathEffect::Make(intervals, 2, 2.5f));\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "7481a948e34672720337a631830586dd",
    "file": "SkPaint_Reference",
    "name": "SkPaint::operator==(const SkPaint& a, const SkPaint& b)",
        "stdout": "paint1 == paint2\\npaint1 != paint2\\n"
    },
        "SkPaint_getAlpha": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"255 %c= paint.getAlpha()\\n\", 255 == paint.getAlpha() ? '=' : '!');\n}",
    "hash": "9a85bb62fe3d877b18fb7f952c4fa7f7",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getAlpha",
        "stdout": "255 == paint.getAlpha()\\n"
    },
        "SkPaint_getBlendMode": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"kSrcOver %c= getBlendMode\\n\", \n            SkBlendMode::kSrcOver == paint.getBlendMode() ? '=' : '!');\n   paint.setBlendMode(SkBlendMode::kSrc);\n   SkDebugf(\"kSrcOver %c= getBlendMode\\n\", \n            SkBlendMode::kSrcOver == paint.getBlendMode() ? '=' : '!');\n}\n",
    "hash": "4ec1864b8203d52c0810e8605092f45c",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getBlendMode",
        "stdout": "kSrcOver == getBlendMode\\nkSrcOver != getBlendMode\\n"
    },
        "SkPaint_getColor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorYELLOW);\n    SkColor y = paint.getColor();\n    SkDebugf(\"Yellow is %d%% red, %d%% green, and %d%% blue.\\n\", (int) (SkColorGetR(y) / 2.55f),\n            (int) (SkColorGetG(y) / 2.55f), (int) (SkColorGetB(y) / 2.55f));\n}",
    "hash": "72d41f890203109a41f589a7403acae9",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getColor",
        "stdout": "Yellow is 100% red, 100% green, and 0% blue.\\n"
    },
        "SkPaint_getColorFilter": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= color filter\\n\", paint.getColorFilter() ? '!' : '=');\n   paint.setColorFilter(SkColorFilter::MakeModeFilter(SK_ColorLTGRAY, SkBlendMode::kSrcIn));\n   SkDebugf(\"nullptr %c= color filter\\n\", paint.getColorFilter() ? '!' : '=');\n}\n",
    "hash": "093bdc627d6b59002670fd290931f6c9",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getColorFilter",
        "stdout": "nullptr == color filter\\nnullptr != color filter\\n"
    },
        "SkPaint_getDrawLooper": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= draw looper\\n\", paint.getDrawLooper() ? '!' : '=');\n   SkLayerDrawLooper::Builder looperBuilder;\n   paint.setDrawLooper(looperBuilder.detach());\n   SkDebugf(\"nullptr %c= draw looper\\n\", paint.getDrawLooper() ? '!' : '=');\n}\n",
    "hash": "af4c5acc7a91e7f23c2af48018903ad4",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getDrawLooper",
        "stdout": "nullptr == draw looper\\nnullptr != draw looper\\n"
    },
        "SkPaint_getFilterQuality": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"kNone_SkFilterQuality %c= paint.getFilterQuality()\\n\",\n            kNone_SkFilterQuality == paint.getFilterQuality() ? '=' : '!');\n}",
    "hash": "d4ca1f23809b6835c4ba46ea98a86900",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFilterQuality",
        "stdout": "kNone_SkFilterQuality == paint.getFilterQuality()\\n"
    },
        "SkPaint_getFlags": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkDebugf(\"(SkPaint::kAntiAlias_Flag & paint.getFlags()) %c= 0\\n\",\n        SkPaint::kAntiAlias_Flag & paint.getFlags() ? '!' : '=');\n}",
    "hash": "8a3f8c309533388b01aa66e1267f322d",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFlags",
        "stdout": "(SkPaint::kAntiAlias_Flag \\u0026 paint.getFlags()) != 0\\n"
    },
        "SkPaint_getFontBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPaint::FontMetrics fm;\n    paint.getFontMetrics(&fm);\n    SkRect fb = paint.getFontBounds();\n    SkDebugf(\"metrics bounds = { %g, %g, %g, %g }\\n\", fm.fXMin, fm.fTop, fm.fXMax, fm.fBottom );\n    SkDebugf(\"font bounds    = { %g, %g, %g, %g }\\n\", fb.fLeft, fb.fTop, fb.fRight, fm.fBottom );\n}",
    "hash": "facaddeec7943bc491988e345e27e65f",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFontBounds",
        "stdout": "metrics bounds = { -12.2461, -14.7891, 21.5215, 5.55469 }\\nfont bounds    = { -12.2461, -14.7891, 21.5215, 5.55469 }\\n"
    },
        "SkPaint_getFontSpacing": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    for (SkScalar textSize : { 12, 18, 24, 32 } ) {\n        paint.setTextSize(textSize);\n        SkDebugf(\"textSize: %g fontSpacing: %g\\n\", textSize, paint.getFontSpacing());\n    }\n}",
    "hash": "424741e26e1b174e43087d67422ce14f",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFontSpacing",
        "stdout": "textSize: 12 fontSpacing: 13.9688\\ntextSize: 18 fontSpacing: 20.9531\\ntextSize: 24 fontSpacing: 27.9375\\ntextSize: 32 fontSpacing: 37.25\\n"
    },
        "SkPaint_getHash": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint2.setColor(0xFFFF0000);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n    SkDebugf(\"paint1.getHash() %c= paint2.getHash()\\n\",\n             paint1.getHash() == paint2.getHash() ? '=' : '!');\n}",
    "hash": "7f7e1b701361912b344f90ae6b530393",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getHash",
        "stdout": "paint1 == paint2\\npaint1.getHash() == paint2.getHash()\\n"
    },
        "SkPaint_getHinting": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"SkPaint::kNormal_Hinting %c= paint.getHinting()\\n\",\n            SkPaint::kNormal_Hinting == paint.getHinting() ? '=' : ':');\n}",
    "hash": "329e2e5a5919ac431e1c58878a5b99e0",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getHinting",
        "stdout": "SkPaint::kNormal_Hinting == paint.getHinting()\\n"
    },
        "SkPaint_getImageFilter": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= image filter\\n\", paint.getImageFilter() ? '!' : '=');\n   paint.setImageFilter(SkBlurImageFilter::Make(kOuter_SkBlurStyle, 3, nullptr, nullptr));\n   SkDebugf(\"nullptr %c= image filter\\n\", paint.getImageFilter() ? '!' : '=');\n}\n",
    "hash": "7b8118ff57fcb84e6bc82380d155b62e",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getImageFilter",
        "stdout": "nullptr == image filter\\nnullptr != image filter\\n"
    },
        "SkPaint_getMaskFilter": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= mask filter\\n\", paint.getMaskFilter() ? '!' : '=');\n   paint.setMaskFilter(SkBlurMaskFilter::Make(kOuter_SkBlurStyle, 3));\n   SkDebugf(\"nullptr %c= mask filter\\n\", paint.getMaskFilter() ? '!' : '=');\n}\n",
    "hash": "8cd53ece8fc83e4560599ace094b0f16",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getMaskFilter",
        "stdout": "nullptr == mask filter\\nnullptr != mask filter\\n"
    },
        "SkPaint_getPathEffect": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= path effect\\n\", paint.getPathEffect() ? '!' : '=');\n   paint.setPathEffect(SkCornerPathEffect::Make(10));\n   SkDebugf(\"nullptr %c= path effect\\n\", paint.getPathEffect() ? '!' : '=');\n}\n",
    "hash": "211a1b14bfa6c4332082c8eab4fbc5fd",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getPathEffect",
        "stdout": "nullptr == path effect\\nnullptr != path effect\\n"
    },
        "SkPaint_getShader": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= shader\\n\", paint.getShader() ? '!' : '=');\n   paint.setShader(SkShader::MakeEmptyShader());\n   SkDebugf(\"nullptr %c= shader\\n\", paint.getShader() ? '!' : '=');\n}\n",
    "hash": "09f15b9fd88882850da2d235eb86292f",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getShader",
        "stdout": "nullptr == shader\\nnullptr != shader\\n"
    },
        "SkPaint_getStrokeCap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"kButt_Cap %c= default stroke cap\\n\",\n            SkPaint::kButt_Cap == paint.getStrokeCap() ? '=' : '!');\n}",
    "hash": "aabf9baee8e026fae36fca30e955512b",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getStrokeCap",
        "stdout": "kButt_Cap == default stroke cap\\n"
    },
        "SkPaint_getStrokeJoin": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"kMiter_Join %c= default stroke join\\n\",\n            SkPaint::kMiter_Join == paint.getStrokeJoin() ? '=' : '!');\n}",
    "hash": "31bf751d0a8ddf176b871810820d8199",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getStrokeJoin",
        "stdout": "kMiter_Join == default stroke join\\n"
    },
        "SkPaint_getStrokeMiter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"default miter limit == %g\\n\", paint.getStrokeMiter());\n}",
    "hash": "50da74a43b725f07a914df588c867d36",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getStrokeMiter",
        "stdout": "default miter limit == 4\\n"
    },
        "SkPaint_getStrokeWidth": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"0 %c= paint.getStrokeWidth()\\n\", 0 == paint.getStrokeWidth() ? '=' : '!');\n}",
    "hash": "99aa73f64df8bbf06e656cd891a81b9e",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getStrokeWidth",
        "stdout": "0 == paint.getStrokeWidth()\\n"
    },
        "SkPaint_getStyle": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"SkPaint::kFill_Style %c= paint.getStyle()\\n\",\n            SkPaint::kFill_Style == paint.getStyle() ? '=' : '!');\n}",
    "hash": "1c5e18c3c0102d2dac86a78ba8c8ce01",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getStyle",
        "stdout": "SkPaint::kFill_Style == paint.getStyle()\\n"
    },
        "SkPaint_getTextAlign": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"kLeft_Align %c= default\\n\", SkPaint::kLeft_Align == paint.getTextAlign() ? '=' : '!');\n}",
    "hash": "2df932f526e810f74c89d30ec3f4c947",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextAlign",
        "stdout": "kLeft_Align == default\\n"
    },
        "SkPaint_getTextEncoding": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"kUTF8_TextEncoding %c= text encoding\\n\", \n            SkPaint::kUTF8_TextEncoding == paint.getTextEncoding() ? '=' : '!');\n    paint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);\n    SkDebugf(\"kGlyphID_TextEncoding %c= text encoding\\n\", \n            SkPaint::kGlyphID_TextEncoding == paint.getTextEncoding() ? '=' : '!');\n}",
    "hash": "70ad28bbf7668b38474d7f225e3540bc",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextEncoding",
        "stdout": "kUTF8_TextEncoding == text encoding\\nkGlyphID_TextEncoding == text encoding\\n"
    },
        "SkPaint_getTextScaleX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"1 %c= default text scale x\\n\", 1 == paint.getTextScaleX() ? '=' : '!');\n}",
    "hash": "5dc8e58f6910cb8e4de9ed60f888188b",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextScaleX",
        "stdout": "1 == default text scale x\\n"
    },
        "SkPaint_getTextSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"12 %c= default text size\\n\", 12 == paint.getTextSize() ? '=' : '!');\n}",
    "hash": "983e2a71ba72d4ba8c945420040b8f1c",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextSize",
        "stdout": "12 == default text size\\n"
    },
        "SkPaint_getTextSkewX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"0 %c= default text skew x\\n\", 0 == paint.getTextSkewX() ? '=' : '!');\n}",
    "hash": "11c10f466dae0d1639dbb9f6a0040218",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextSkewX",
        "stdout": "0 == default text skew x\\n"
    },
        "SkPaint_getTypeface": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"nullptr %c= typeface\\n\", paint.getTypeface() ? '!' : '=');\n   paint.setTypeface(SkTypeface::MakeFromName(\"monospace\", SkFontStyle()));\n   SkDebugf(\"nullptr %c= typeface\\n\", paint.getTypeface() ? '!' : '=');\n}\n",
    "hash": "5ce718e5a184baaac80e7098d7dad67b",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTypeface",
        "stdout": "nullptr == typeface\\nnullptr != typeface\\n"
    },
        "SkPaint_isAntiAlias": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isAntiAlias() %c= !!(paint.getFlags() & SkPaint::kAntiAlias_Flag)\\n\",\n            paint.isAntiAlias() == !!(paint.getFlags() & SkPaint::kAntiAlias_Flag) ? '=' : '!');\n    paint.setAntiAlias(true);\n    SkDebugf(\"paint.isAntiAlias() %c= !!(paint.getFlags() & SkPaint::kAntiAlias_Flag)\\n\",\n            paint.isAntiAlias() == !!(paint.getFlags() & SkPaint::kAntiAlias_Flag) ? '=' : '!');\n}",
    "hash": "d7d5f4f7da7acd5104a652f490c6f7b8",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isAntiAlias",
        "stdout": "paint.isAntiAlias() == !!(paint.getFlags() \\u0026 SkPaint::kAntiAlias_Flag)\\npaint.isAntiAlias() == !!(paint.getFlags() \\u0026 SkPaint::kAntiAlias_Flag)\\n"
    },
        "SkPaint_isAutohinted": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    for (auto forceAutoHinting : { false, true} ) {\n    paint.setAutohinted(forceAutoHinting);\n    SkDebugf(\"paint.isAutohinted() %c=\"\n            \" !!(paint.getFlags() & SkPaint::kAutoHinting_Flag)\\n\",\n            paint.isAutohinted() ==\n            !!(paint.getFlags() & SkPaint::kAutoHinting_Flag) ? '=' : '!');\n    }\n}",
    "hash": "aa4781afbe3b90e7ef56a287e5b9ce1e",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isAutohinted",
        "stdout": "paint.isAutohinted() == !!(paint.getFlags() \\u0026 SkPaint::kAutoHinting_Flag)\\npaint.isAutohinted() == !!(paint.getFlags() \\u0026 SkPaint::kAutoHinting_Flag)\\n"
    },
        "SkPaint_isDevKernText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isDevKernText() %c= !!(paint.getFlags() & SkPaint::kDevKernText_Flag)\\n\",\n        paint.isDevKernText() == !!(paint.getFlags() & SkPaint::kDevKernText_Flag) ? '=' : '!');\n    paint.setDevKernText(true);\n    SkDebugf(\"paint.isDevKernText() %c= !!(paint.getFlags() & SkPaint::kDevKernText_Flag)\\n\",\n        paint.isDevKernText() == !!(paint.getFlags() & SkPaint::kDevKernText_Flag) ? '=' : '!');\n}",
    "hash": "4f69a84b2505b12809c30b0cc09c5157",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isDevKernText",
        "stdout": "paint.isDevKernText() == !!(paint.getFlags() \\u0026 SkPaint::kDevKernText_Flag)\\npaint.isDevKernText() == !!(paint.getFlags() \\u0026 SkPaint::kDevKernText_Flag)\\n"
    },
        "SkPaint_isDither": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isDither() %c= !!(paint.getFlags() & SkPaint::kDither_Flag)\\n\",\n            paint.isDither() == !!(paint.getFlags() & SkPaint::kDither_Flag) ? '=' : '!');\n    paint.setDither(true);\n    SkDebugf(\"paint.isDither() %c= !!(paint.getFlags() & SkPaint::kDither_Flag)\\n\",\n            paint.isDither() == !!(paint.getFlags() & SkPaint::kDither_Flag) ? '=' : '!');\n}",
    "hash": "f4ce93f6c5e7335436a985377fd980c0",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isDither",
        "stdout": "paint.isDither() == !!(paint.getFlags() \\u0026 SkPaint::kDither_Flag)\\npaint.isDither() == !!(paint.getFlags() \\u0026 SkPaint::kDither_Flag)\\n"
    },
        "SkPaint_isEmbeddedBitmapText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isEmbeddedBitmapText() %c=\"\n            \" !!(paint.getFlags() & SkPaint::kEmbeddedBitmapText_Flag)\\n\",\n            paint.isEmbeddedBitmapText() ==\n            !!(paint.getFlags() & SkPaint::kEmbeddedBitmapText_Flag) ? '=' : '!');\n    paint.setEmbeddedBitmapText(true);\n    SkDebugf(\"paint.isEmbeddedBitmapText() %c=\"\n            \" !!(paint.getFlags() & SkPaint::kEmbeddedBitmapText_Flag)\\n\",\n            paint.isEmbeddedBitmapText() ==\n            !!(paint.getFlags() & SkPaint::kEmbeddedBitmapText_Flag) ? '=' : '!');\n}",
    "hash": "eba10b27b790e87183ae451b3fc5c4b1",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isEmbeddedBitmapText",
        "stdout": "paint.isEmbeddedBitmapText() == !!(paint.getFlags() \\u0026 SkPaint::kEmbeddedBitmapText_Flag)\\npaint.isEmbeddedBitmapText() == !!(paint.getFlags() \\u0026 SkPaint::kEmbeddedBitmapText_Flag)\\n"
    },
        "SkPaint_isFakeBoldText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isFakeBoldText() %c= !!(paint.getFlags() & SkPaint::kFakeBoldText_Flag)\\n\",\n        paint.isFakeBoldText() == !!(paint.getFlags() & SkPaint::kFakeBoldText_Flag) ? '=' : '!');\n    paint.setFakeBoldText(true);\n    SkDebugf(\"paint.isFakeBoldText() %c= !!(paint.getFlags() & SkPaint::kFakeBoldText_Flag)\\n\",\n        paint.isFakeBoldText() == !!(paint.getFlags() & SkPaint::kFakeBoldText_Flag) ? '=' : '!');\n}",
    "hash": "f54d1f85b16073b80b9eef2e1a1d151d",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isFakeBoldText",
        "stdout": "paint.isFakeBoldText() == !!(paint.getFlags() \\u0026 SkPaint::kFakeBoldText_Flag)\\npaint.isFakeBoldText() == !!(paint.getFlags() \\u0026 SkPaint::kFakeBoldText_Flag)\\n"
    },
        "SkPaint_isLCDRenderText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isLCDRenderText() %c= !!(paint.getFlags() & SkPaint::kLCDRenderText_Flag)\\n\",\n        paint.isLCDRenderText() == !!(paint.getFlags() & SkPaint::kLCDRenderText_Flag) ? '=' : '!');\n    paint.setLCDRenderText(true);\n    SkDebugf(\"paint.isLCDRenderText() %c= !!(paint.getFlags() & SkPaint::kLCDRenderText_Flag)\\n\",\n        paint.isLCDRenderText() == !!(paint.getFlags() & SkPaint::kLCDRenderText_Flag) ? '=' : '!');\n}",
    "hash": "68e1fd95dd2fd06a333899d2bd2396b9",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isLCDRenderText",
        "stdout": "paint.isLCDRenderText() == !!(paint.getFlags() \\u0026 SkPaint::kLCDRenderText_Flag)\\npaint.isLCDRenderText() == !!(paint.getFlags() \\u0026 SkPaint::kLCDRenderText_Flag)\\n"
    },
        "SkPaint_isSrcOver": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"isSrcOver %c= true\\n\", paint.isSrcOver() ? '=' : '!');\n   paint.setBlendMode(SkBlendMode::kSrc);\n   SkDebugf(\"isSrcOver %c= true\\n\", paint.isSrcOver() ? '=' : '!');\n}\n",
    "hash": "257c9473db7a2b3a0fb2b9e2431e59a6",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isSrcOver",
        "stdout": "isSrcOver == true\\nisSrcOver != true\\n"
    },
        "SkPaint_isSubpixelText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isSubpixelText() %c= !!(paint.getFlags() & SkPaint::kSubpixelText_Flag)\\n\",\n        paint.isSubpixelText() == !!(paint.getFlags() & SkPaint::kSubpixelText_Flag) ? '=' : '!');\n    paint.setSubpixelText(true);\n    SkDebugf(\"paint.isSubpixelText() %c= !!(paint.getFlags() & SkPaint::kSubpixelText_Flag)\\n\",\n        paint.isSubpixelText() == !!(paint.getFlags() & SkPaint::kSubpixelText_Flag) ? '=' : '!');\n}",
    "hash": "abe9afc0932e2199324ae6cbb396e67c",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isSubpixelText",
        "stdout": "paint.isSubpixelText() == !!(paint.getFlags() \\u0026 SkPaint::kSubpixelText_Flag)\\npaint.isSubpixelText() == !!(paint.getFlags() \\u0026 SkPaint::kSubpixelText_Flag)\\n"
    },
        "SkPaint_isVerticalText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"paint.isVerticalText() %c= !!(paint.getFlags() & SkPaint::kVerticalText_Flag)\\n\",\n        paint.isVerticalText() == !!(paint.getFlags() & SkPaint::kVerticalText_Flag) ? '=' : '!');\n    paint.setVerticalText(true);\n    SkDebugf(\"paint.isVerticalText() %c= !!(paint.getFlags() & SkPaint::kVerticalText_Flag)\\n\",\n        paint.isVerticalText() == !!(paint.getFlags() & SkPaint::kVerticalText_Flag) ? '=' : '!');\n}",
    "hash": "4a269b16e644d473870ffa873396f139",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isVerticalText",
        "stdout": "paint.isVerticalText() == !!(paint.getFlags() \\u0026 SkPaint::kVerticalText_Flag)\\npaint.isVerticalText() == !!(paint.getFlags() \\u0026 SkPaint::kVerticalText_Flag)\\n"
    },
        "SkPaint_measureText_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"default width = %g\\n\", paint.measureText(\"!\", 1));\n    paint.setTextSize(paint.getTextSize() * 2);\n    SkDebugf(\"double width = %g\\n\", paint.measureText(\"!\", 1));\n}",
    "hash": "f1139a5ddd17fd47c2f45f6e642cac76",
    "file": "SkPaint_Reference",
    "name": "SkPaint::measureText_2",
        "stdout": "default width = 5\\ndouble width = 10\\n"
    },
        "SkPaint_move_SkPaint": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    float intervals[] = { 5, 5 };\n    paint.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 2.5f));\n    SkPaint dashed(std::move(paint));\n    SkDebugf(\"path effect unique: %s\\n\", dashed.getPathEffect()->unique() ? \"true\" : \"false\");\n}",
    "hash": "8ed1488a503cd5282b86a51614aa90b1",
    "file": "SkPaint_Reference",
    "name": "SkPaint::SkPaint(SkPaint&& paint)",
        "stdout": "path effect unique: true\\n"
    },
        "SkPaint_move_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint2 = std::move(paint1);\n    SkDebugf(\"SK_ColorRED == paint2.getColor()\\n\", SK_ColorRED == paint2.getColor() ? '=' : '!');\n}",
    "hash": "9fb7459b097d713f5f1fe5675afe14f5",
    "file": "SkPaint_Reference",
    "name": "SkPaint::operator=(SkPaint&& paint)",
        "stdout": "SK_ColorRED == paint2.getColor()\\n"
    },
        "SkPaint_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint2.setColor(0xFFFF0000);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 != paint2 ? '!' : '=');\n}",
    "hash": "b6c8484b1187f555b435ad5369833be4",
    "file": "SkPaint_Reference",
    "name": "SkPaint::operator!=(const SkPaint& a, const SkPaint& b)",
        "stdout": "paint1 == paint2\\npaint1 == paint2\\n"
    },
        "SkPaint_nothingToDraw": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPaint& p) -> void {\n        SkDebugf(\"%s nothing to draw: %s\\n\", prefix, \n                 p.nothingToDraw() ? \"true\" : \"false\");\n    };\n    SkPaint paint;\n    debugster(\"initial\", paint);\n    paint.setBlendMode(SkBlendMode::kDst);\n    debugster(\"blend dst\", paint);\n    paint.setBlendMode(SkBlendMode::kSrcOver);\n    debugster(\"blend src over\", paint);\n    paint.setAlpha(0);\n    debugster(\"alpha 0\", paint);\n}\n",
    "hash": "fc5a771b915ac341f56554f01d282831",
    "file": "SkPaint_Reference",
    "name": "SkPaint::nothingToDraw",
        "stdout": "initial nothing to draw: false\\nblend dst nothing to draw: true\\nblend src over nothing to draw: false\\nalpha 0 nothing to draw: true\\n"
    },
        "SkPaint_refColorFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColorFilter(SkColorFilter::MakeModeFilter(0xFFFF0000, SkBlendMode::kSrcATop));\n    SkDebugf(\"color filter unique: %s\\n\", paint1.getColorFilter()->unique() ? \"true\" : \"false\");\n    paint2.setColorFilter(paint1.refColorFilter());\n    SkDebugf(\"color filter unique: %s\\n\", paint1.getColorFilter()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "b588c95fa4c86ddbc4b0546762f08297",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refColorFilter",
        "stdout": "color filter unique: true\\ncolor filter unique: false\\n"
    },
        "SkPaint_refDrawLooper": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    SkLayerDrawLooper::Builder looperBuilder;\n    paint1.setDrawLooper(looperBuilder.detach());\n    SkDebugf(\"draw looper unique: %s\\n\", paint1.getDrawLooper()->unique() ? \"true\" : \"false\");\n    paint2.setDrawLooper(paint1.refDrawLooper());\n    SkDebugf(\"draw looper unique: %s\\n\", paint1.getDrawLooper()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "2a3782c33f04ed17a725d0e449c6f7c3",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refDrawLooper",
        "stdout": "draw looper unique: true\\ndraw looper unique: false\\n"
    },
        "SkPaint_refImageFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setImageFilter(SkOffsetImageFilter::Make(25, 25, nullptr));\n    SkDebugf(\"image filter unique: %s\\n\", paint1.getImageFilter()->unique() ? \"true\" : \"false\");\n    paint2.setImageFilter(paint1.refImageFilter());\n    SkDebugf(\"image filter unique: %s\\n\", paint1.getImageFilter()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "13f09088b569251547107d14ae989dc1",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refImageFilter",
        "stdout": "image filter unique: true\\nimage filter unique: false\\n"
    },
        "SkPaint_refMaskFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setMaskFilter(SkBlurMaskFilter::Make(kNormal_SkBlurStyle, 1));\n    SkDebugf(\"mask filter unique: %s\\n\", paint1.getMaskFilter()->unique() ? \"true\" : \"false\");\n    paint2.setMaskFilter(paint1.refMaskFilter());\n    SkDebugf(\"mask filter unique: %s\\n\", paint1.getMaskFilter()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "35a397dce5d44658ee4e9e9dfb9fee22",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refMaskFilter",
        "stdout": "mask filter unique: true\\nmask filter unique: false\\n"
    },
        "SkPaint_refPathEffect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    SkScalar intervals[] = {1, 2};\n    paint1.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 10));\n    SkDebugf(\"path effect unique: %s\\n\", paint1.getPathEffect()->unique() ? \"true\" : \"false\");\n    paint2.setPathEffect(paint1.refPathEffect());\n    SkDebugf(\"path effect unique: %s\\n\", paint1.getPathEffect()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "f56039b94c702c2704c8c5100e623aca",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refPathEffect",
        "stdout": "path effect unique: true\\npath effect unique: false\\n"
    },
        "SkPaint_refShader": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint1, paint2;\n   paint1.setShader(SkShader::MakeEmptyShader());\n   SkDebugf(\"shader unique: %s\\n\", paint1.getShader()->unique() ? \"true\" : \"false\");\n   paint2.setShader(paint1.refShader());\n   SkDebugf(\"shader unique: %s\\n\", paint1.getShader()->unique() ? \"true\" : \"false\");\n}\n",
    "hash": "53da0295972a418cbc9607bbb17feaa8",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refShader",
        "stdout": "shader unique: true\\nshader unique: false\\n"
    },
        "SkPaint_refTypeface": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint1, paint2;\n   paint1.setTypeface(SkTypeface::MakeFromName(\"monospace\", \n            SkFontStyle(SkFontStyle::kNormal_Weight, SkFontStyle::kNormal_Width,\n            SkFontStyle::kItalic_Slant)));\n   SkDebugf(\"typeface1 %c= typeface2\\n\",\n            paint1.getTypeface() == paint2.getTypeface() ? '=' : '!');\n   paint2.setTypeface(paint1.refTypeface());\n   SkDebugf(\"typeface1 %c= typeface2\\n\",\n            paint1.getTypeface() == paint2.getTypeface() ? '=' : '!');\n}\n",
    "hash": "4bf8ed109c4b46d8a05c8b7763c1982c",
    "file": "SkPaint_Reference",
    "name": "SkPaint::refTypeface",
        "stdout": "typeface1 != typeface2\\ntypeface1 == typeface2\\n"
    },
        "SkPaint_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setColor(SK_ColorRED);\n    paint1.reset();\n    SkDebugf(\"paint1 %c= paint2\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "ef269937ade7e7353635121d9a64f9f7",
    "file": "SkPaint_Reference",
    "name": "SkPaint::reset()",
        "stdout": "paint1 == paint2"
    },
        "SkPaint_setARGB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint transRed1, transRed2;\n    transRed1.setARGB(255 / 2, 255, 0, 0);\n    transRed2.setColor(SkColorSetARGB(255 / 2, 255, 0, 0));\n    SkDebugf(\"transRed1 %c= transRed2\", transRed1 == transRed2 ? '=' : '!');\n}",
    "hash": "cb62e4755789ed32f7120dc55984959d",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setARGB",
        "stdout": "transRed1 == transRed2"
    },
        "SkPaint_setAlpha": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(0x00112233);\n    paint.setAlpha(0x44);\n    SkDebugf(\"0x44112233 %c= paint.getColor()\\n\", 0x44112233 == paint.getColor() ? '=' : '!');\n}",
    "hash": "6ddc0360512dfb9947e75c17e6a8103d",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setAlpha",
        "stdout": "0x44112233 == paint.getColor()\\n"
    },
        "SkPaint_setAntiAlias": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setAntiAlias(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kAntiAlias_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "c2ff148374d01cbef845b223e725905c",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setAntiAlias",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setBlendMode": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkDebugf(\"isSrcOver %c= true\\n\", paint.isSrcOver() ? '=' : '!');\n   paint.setBlendMode(SkBlendMode::kSrc);\n   SkDebugf(\"isSrcOver %c= true\\n\", paint.isSrcOver() ? '=' : '!');\n}\n",
    "hash": "257c9473db7a2b3a0fb2b9e2431e59a6",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setBlendMode",
        "stdout": "isSrcOver == true\\nisSrcOver != true\\n"
    },
        "SkPaint_setColor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint green1, green2;\n    unsigned a = 255;\n    unsigned r = 0;\n    unsigned g = 255;\n    unsigned b = 0;\n    green1.setColor((a << 24) + (r << 16) + (g << 8) + (b << 0));\n    green2.setColor(0xFF00FF00);\n    SkDebugf(\"green1 %c= green2\\n\", green1 == green2 ? '=' : '!');\n}",
    "hash": "6e70f18300bd676a3c056ceb6b62f8df",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setColor",
        "stdout": "green1 == green2\\n"
    },
        "SkPaint_setDevKernText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setDevKernText(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kDevKernText_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "2b718a059072908bf68942503f264797",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setDevKernText",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setDither": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setDither(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kDither_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "69b7162e8324d9239dd02dd9ada2bdff",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setDither",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setEmbeddedBitmapText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setEmbeddedBitmapText(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kEmbeddedBitmapText_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "246dffdd93a484ba4ad7ecf71198a5d4",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setEmbeddedBitmapText",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setFakeBoldText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setFakeBoldText(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kFakeBoldText_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "594d47858eb11028cb626515a520910a",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setFakeBoldText",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setFilterQuality": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setFilterQuality(kHigh_SkFilterQuality);\n    SkDebugf(\"kHigh_SkFilterQuality %c= paint.getFilterQuality()\\n\",\n            kHigh_SkFilterQuality == paint.getFilterQuality() ? '=' : '!');\n}",
    "hash": "e4288fabf24ee60b645e8bb6ea0afadf",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setFilterQuality",
        "stdout": "kHigh_SkFilterQuality == paint.getFilterQuality()\\n"
    },
        "SkPaint_setFlags": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setFlags((uint32_t) (SkPaint::kAntiAlias_Flag | SkPaint::kDither_Flag));\n    SkDebugf(\"paint.isAntiAlias()\\n\", paint.isAntiAlias() ? '!' : '=');\n    SkDebugf(\"paint.isDither()\\n\", paint.isDither() ? '!' : '=');\n}",
    "hash": "54baed3f6bc4b9c31ba664e27767fdc7",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setFlags",
        "stdout": "paint.isAntiAlias()\\npaint.isDither()\\n"
    },
        "SkPaint_setHinting": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint2.setHinting(SkPaint::kNormal_Hinting);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : ':');\n}",
    "hash": "78153fbd3f1000cb33b97bbe831ed34e",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setHinting",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setLCDRenderText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setLCDRenderText(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kLCDRenderText_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "50dedf8450159571a3edaf4f0050defe",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setLCDRenderText",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setStrokeCap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeCap(SkPaint::kRound_Cap);\n    paint.setStrokeCap((SkPaint::Cap) SkPaint::kCapCount);\n    SkDebugf(\"kRound_Cap %c= paint.getStrokeCap()\\n\",\n            SkPaint::kRound_Cap == paint.getStrokeCap() ? '=' : '!');\n}",
    "hash": "de83fbd848a4625345b4b87a6e55d98a",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setStrokeCap",
        "stdout": "kRound_Cap == paint.getStrokeCap()\\n"
    },
        "SkPaint_setStrokeJoin": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeJoin(SkPaint::kMiter_Join);\n    paint.setStrokeJoin((SkPaint::Join) SkPaint::kJoinCount);\n    SkDebugf(\"kMiter_Join %c= paint.getStrokeJoin()\\n\",\n            SkPaint::kMiter_Join == paint.getStrokeJoin() ? '=' : '!');\n}",
    "hash": "48d963ad4286eddf680f9c511eb6da91",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setStrokeJoin",
        "stdout": "kMiter_Join == paint.getStrokeJoin()\\n"
    },
        "SkPaint_setStrokeMiter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeMiter(8);\n    paint.setStrokeMiter(-1);\n    SkDebugf(\"default miter limit == %g\\n\", paint.getStrokeMiter());\n}",
    "hash": "700b284dbc97785c6a9c9636088713ad",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setStrokeMiter",
        "stdout": "default miter limit == 8\\n"
    },
        "SkPaint_setStrokeWidth": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(5);\n    paint.setStrokeWidth(-1);\n    SkDebugf(\"5 %c= paint.getStrokeWidth()\\n\", 5 == paint.getStrokeWidth() ? '=' : '!');\n}",
    "hash": "0c4446c0870b5c7b5a2efe77ff92afb8",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setStrokeWidth",
        "stdout": "5 == paint.getStrokeWidth()\\n"
    },
        "SkPaint_setSubpixelText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setSubpixelText(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kSubpixelText_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "a77bbc1a4e3be9a8ab0f842f877c5ee4",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setSubpixelText",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_setTextEncoding": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextEncoding((SkPaint::TextEncoding) 4);\n    SkDebugf(\"4 %c= text encoding\\n\", 4 == paint.getTextEncoding() ? '=' : '!');\n}",
    "hash": "329b92fbc35151dee9aa0c0e70107665",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setTextEncoding",
        "stdout": "4 != text encoding\\n"
    },
        "SkPaint_setTextScaleX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextScaleX(0.f / 0.f);\n    SkDebugf(\"text scale %s-a-number\\n\", SkScalarIsNaN(paint.getTextScaleX()) ? \"not\" : \"is\");\n}",
    "hash": "a75bbdb8bb866b125c4c1dd5e967d470",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setTextScaleX",
        "stdout": "text scale not-a-number\\n"
    },
        "SkPaint_setTextSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkDebugf(\"12 %c= text size\\n\", 12 == paint.getTextSize() ? '=' : '!');\n    paint.setTextSize(-20);\n    SkDebugf(\"12 %c= text size\\n\", 12 == paint.getTextSize() ? '=' : '!');\n}",
    "hash": "6510c9e2f57b83c47e67829e7a68d493",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setTextSize",
        "stdout": "12 == text size\\n12 == text size\\n"
    },
        "SkPaint_setTextSkewX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextScaleX(1.f / 0.f);\n    SkDebugf(\"text scale %s-finite\\n\", SkScalarIsFinite(paint.getTextScaleX()) ? \"is\" : \"not\");\n}",
    "hash": "6bd705a6e0c5f8ee24f302fe531bfabc",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setTextSkewX",
        "stdout": "text scale not-finite\\n"
    },
        "SkPaint_setVerticalText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint1, paint2;\n    paint1.setVerticalText(true);\n    paint2.setFlags(paint2.getFlags() | SkPaint::kVerticalText_Flag);\n    SkDebugf(\"paint1 %c= paint2\\n\", paint1 == paint2 ? '=' : '!');\n}",
    "hash": "6fbd7e9e1a346cb8d7f537786009c736",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setVerticalText",
        "stdout": "paint1 == paint2\\n"
    },
        "SkPaint_toString": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkString str;\n    paint.toString(&str);\n    const char textSize[] = \"TextSize:\";\n    const int trailerSize = strlen(\"</dd><dt>\");\n    int textSizeLoc = str.find(textSize) + strlen(textSize) + trailerSize;\n    const char* sizeStart = &str.c_str()[textSizeLoc];\n    int textSizeEnd = SkStrFind(sizeStart, \"</dd>\");\n    SkDebugf(\"text size = %.*s\\n\", textSizeEnd, sizeStart);\n}",
    "hash": "5670c04b4562908169a776c48c92d104",
    "file": "SkPaint_Reference",
    "name": "SkPaint::toString",
        "stdout": "text size = 12\\n"
    },
        "SkPath_ConvertToNonInverseFillType": {
    "code": "#define nameValue(fill) { SkPath::fill, #fill }\n\nvoid draw(SkCanvas* canvas) {\n    struct {\n        SkPath::FillType fill;\n        const char* name;\n    } fills[] = {\n        nameValue(kWinding_FillType),\n        nameValue(kEvenOdd_FillType),\n        nameValue(kInverseWinding_FillType),\n        nameValue(kInverseEvenOdd_FillType),\n    };\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(fills); ++i) {\n        if (fills[i].fill != (SkPath::FillType) i) {\n            SkDebugf(\"fills array order does not match FillType enum order\");\n            break;\n        } \n        SkDebugf(\"ConvertToNonInverseFillType(%s) == %s\\n\", fills[i].name,\n                fills[(int) SkPath::ConvertToNonInverseFillType(fills[i].fill)].name);\n    }\n}\n",
    "hash": "adfae398bbe9e37495f8220ad544c8f8",
    "file": "SkPath_Reference",
    "name": "SkPath::ConvertToNonInverseFillType",
        "stdout": "ConvertToNonInverseFillType(kWinding_FillType) == kWinding_FillType\\nConvertToNonInverseFillType(kEvenOdd_FillType) == kEvenOdd_FillType\\nConvertToNonInverseFillType(kInverseWinding_FillType) == kWinding_FillType\\nConvertToNonInverseFillType(kInverseEvenOdd_FillType) == kEvenOdd_FillType\\n"
    },
        "SkPath_IsCubicDegenerate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint points[] = {{1, 0}, {0, 0}, {0, 0}, {0, 0}};\n    SkScalar step = 1;\n    SkScalar prior, length, degenerate;\n    do {\n        prior = points[0].fX;\n        step /= 2;\n        if (SkPath::IsCubicDegenerate(points[0], points[1], points[2], points[3], false)) {\n            degenerate = prior;\n            points[0].fX += step;\n        } else {\n            length = prior;\n            points[0].fX -= step;\n        }\n    } while (prior != points[0].fX);\n    SkDebugf(\"%1.8g is degenerate\\n\", degenerate);\n    SkDebugf(\"%1.8g is length\\n\", length);\n}\n",
    "hash": "c79d813f0b37062cb2f7a0c83f4a09f3",
    "file": "SkPath_Reference",
    "name": "SkPath::IsCubicDegenerate",
        "stdout": "0.00024414062 is degenerate\\n0.00024414065 is length\\n"
    },
        "SkPath_IsInverseFillType": {
    "code": "#define nameValue(fill) { SkPath::fill, #fill }\n\nvoid draw(SkCanvas* canvas) {\n    struct {\n        SkPath::FillType fill;\n        const char* name;\n    } fills[] = {\n        nameValue(kWinding_FillType),\n        nameValue(kEvenOdd_FillType),\n        nameValue(kInverseWinding_FillType),\n        nameValue(kInverseEvenOdd_FillType),\n    };\n    for (auto fill: fills ) {\n        SkDebugf(\"IsInverseFillType(%s) == %s\\n\", fill.name, SkPath::IsInverseFillType(fill.fill) ?\n                 \"true\" : \"false\");\n    }\n}\n",
    "hash": "1453856a9d0c73e8192bf298c4143563",
    "file": "SkPath_Reference",
    "name": "SkPath::IsInverseFillType",
        "stdout": "IsInverseFillType(kWinding_FillType) == false\\nIsInverseFillType(kEvenOdd_FillType) == false\\nIsInverseFillType(kInverseWinding_FillType) == true\\nIsInverseFillType(kInverseEvenOdd_FillType) == true\\n"
    },
        "SkPath_IsLineDegenerate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint points[] = { {100, 100}, {100.000001f, 100.000001f}, {100.0001f, 100.0001f} };\n    for (size_t i = 0; i < SK_ARRAY_COUNT(points) - 1; ++i) {\n        for (bool exact : { false, true } ) {\n            SkDebugf(\"line from (%1.8g,%1.8g) to (%1.8g,%1.8g) is %s\" \"degenerate, %s\\n\",\n                    points[i].fX, points[i].fY, points[i + 1].fX, points[i + 1].fY,\n                    SkPath::IsLineDegenerate(points[i], points[i + 1], exact)\n                    ? \"\" : \"not \", exact ? \"exactly\" : \"nearly\");\n        }\n    }\n}\n",
    "hash": "97a031f9186ade586928563840ce9116",
    "file": "SkPath_Reference",
    "name": "SkPath::IsLineDegenerate",
        "stdout": "line from (100,100) to (100,100) is degenerate, nearly\\nline from (100,100) to (100,100) is degenerate, exactly\\nline from (100,100) to (100.0001,100.0001) is degenerate, nearly\\nline from (100,100) to (100.0001,100.0001) is not degenerate, exactly\\n"
    },
        "SkPath_IsQuadDegenerate": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const SkPath& path, bool exact) -> void {\n        SkDebugf(\"quad (%1.8g,%1.8g), (%1.8g,%1.8g), (%1.8g,%1.8g) is %s\" \"degenerate, %s\\n\", \n            path.getPoint(0).fX, path.getPoint(0).fY, path.getPoint(1).fX,\n            path.getPoint(1).fY, path.getPoint(2).fX, path.getPoint(2).fY,\n            SkPath::IsQuadDegenerate(path.getPoint(0), path.getPoint(1), path.getPoint(2), exact) ?\n            \"\" : \"not \", exact ? \"exactly\" : \"nearly\");\n    };\n    SkPath path, offset;\n    path.moveTo({100, 100});\n    path.quadTo({100.00001f, 100.00001f}, {100.00002f, 100.00002f});\n    offset.addPath(path, 1000, 1000);\n    for (bool exact : { false, true } ) {\n        debugster(path, exact);\n        debugster(offset, exact);\n    }\n}\n",
    "hash": "1d50896c528cd4581966646b7d96acff",
    "file": "SkPath_Reference",
    "name": "SkPath::IsQuadDegenerate",
        "stdout": "quad (100,100), (100.00001,100.00001), (100.00002,100.00002) is degenerate, nearly\\nquad (1100,1100), (1100,1100), (1100,1100) is degenerate, nearly\\nquad (100,100), (100.00001,100.00001), (100.00002,100.00002) is not degenerate, exactly\\nquad (1100,1100), (1100,1100), (1100,1100) is degenerate, exactly\\n"
    },
        "SkPath_Iter_Iter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath::Iter iter;\n    SkPoint points[4];\n    SkDebugf(\"iter is \" \"%s\" \"done\\n\", SkPath::kDone_Verb == iter.next(points) ? \"\" : \"not \");\n    SkPath path;\n    iter.setPath(path, false);\n    SkDebugf(\"iter is \" \"%s\" \"done\\n\", SkPath::kDone_Verb == iter.next(points) ? \"\" : \"not \");\n}\n",
    "hash": "01648775cb9b354b2f1836dad82a25ab",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::Iter",
        "stdout": "iter is done\\niter is done\\n"
    },
        "SkPath_Iter_Iter_2": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, SkPath::Iter& iter) -> void {\n        SkDebugf(\"%s:\\n\", prefix);\n        const char* verbStr[] =  { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\", \"Done\" };\n        const int pointCount[] = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n        SkPath::Verb verb;\n        do {\n           SkPoint points[4];\n           verb = iter.next(points);\n           SkDebugf(\"k%s_Verb \", verbStr[(int) verb]);\n           for (int i = 0; i < pointCount[(int) verb]; ++i) {\n                SkDebugf(\"{%g, %g}, \", points[i].fX, points[i].fY);\n           }\n           if (SkPath::kConic_Verb == verb) {\n               SkDebugf(\"weight = %g\", iter.conicWeight());\n           }\n           SkDebugf(\"\\n\");\n        } while (SkPath::kDone_Verb != verb);\n        SkDebugf(\"\\n\");\n    };\n    SkPath path;\n    path.quadTo(10, 20, 30, 40);\n    SkPath::Iter openIter(path, false);\n    debugster(\"open\", openIter);\n    SkPath::Iter closedIter(path, true);\n    debugster(\"closed\", closedIter);\n}\n",
    "hash": "13044dbf68885c0f15322c0633b633a3",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::Iter_2",
        "stdout": "open:\\nkMove_Verb {0, 0}, \\nkQuad_Verb {0, 0}, {10, 20}, {30, 40}, \\nkDone_Verb \\n\\nclosed:\\nkMove_Verb {0, 0}, \\nkQuad_Verb {0, 0}, {10, 20}, {30, 40}, \\nkLine_Verb {30, 40}, {0, 0}, \\nkClose_Verb {0, 0}, \\nkDone_Verb \\n\\n"
    },
        "SkPath_Iter_conicWeight": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPath path;\n   path.conicTo(1, 2, 3, 4, .5f);\n   SkPath::Iter iter(path, false); \n   SkPoint p[4];\n   SkDebugf(\"first verb is \" \"%s\" \"move\\n\", SkPath::kMove_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"next verb is \" \"%s\" \"conic\\n\", SkPath::kConic_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"conic points: {%g,%g}, {%g,%g}, {%g,%g}\\n\", p[0].fX, p[0].fY, p[1].fX, p[1].fY,\n                p[2].fX, p[2].fY);\n   SkDebugf(\"conic weight: %g\\n\", iter.conicWeight());\n}\n",
    "hash": "f97cc1191cf2eef161d6b97fcba67b02",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::conicWeight",
        "stdout": "first verb is move\\nnext verb is conic\\nconic points: {0,0}, {1,2}, {3,4}\\nconic weight: 0.5\\n"
    },
        "SkPath_Iter_isCloseLine": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPath path;\n   path.moveTo(6, 7);\n   path.conicTo(1, 2, 3, 4, .5f);\n   path.close();\n   SkPath::Iter iter(path, false); \n   SkPoint p[4];\n   SkDebugf(\"1st verb is \" \"%s\" \"move\\n\", SkPath::kMove_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"moveTo point: {%g,%g}\\n\", p[0].fX, p[0].fY);\n   SkDebugf(\"2nd verb is \" \"%s\" \"conic\\n\", SkPath::kConic_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"3rd verb is \" \"%s\" \"line\\n\", SkPath::kLine_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"line points: {%g,%g}, {%g,%g}\\n\", p[0].fX, p[0].fY, p[1].fX, p[1].fY);\n   SkDebugf(\"line \" \"%s\" \"generated by close\\n\", iter.isCloseLine() ? \"\" : \"not \");\n   SkDebugf(\"4th verb is \" \"%s\" \"close\\n\", SkPath::kClose_Verb == iter.next(p) ? \"\" : \"not \");\n}\n",
    "hash": "345e0646a010f7dce571078d1321f4df",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::isCloseLine",
        "stdout": "1st verb is move\\nmoveTo point: {6,7}\\n2nd verb is conic\\n3rd verb is line\\nline points: {3,4}, {6,7}\\nline generated by close\\n4th verb is close\\n"
    },
        "SkPath_Iter_isClosedContour": {
    "code": "void draw(SkCanvas* canvas) {\n   for (bool forceClose : { false, true } ) {\n       SkPath path;\n       path.conicTo(1, 2, 3, 4, .5f);\n       SkPath::Iter iter(path, forceClose); \n       SkDebugf(\"without close(), forceClose is %s: isClosedContour returns %s\\n\",\n           forceClose ? \"true \" : \"false\", iter.isClosedContour() ? \"true\" : \"false\");\n       path.close();\n       iter.setPath(path, forceClose);\n       SkDebugf(\"with close(),    forceClose is %s: isClosedContour returns %s\\n\",\n           forceClose ? \"true \" : \"false\", iter.isClosedContour() ? \"true\" : \"false\");\n    }\n}\n",
    "hash": "145ead5d4f5fb9ba0a0320cb6a5bf3e8",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::isClosedContour",
        "stdout": "without close(), forceClose is false: isClosedContour returns false\\nwith close(),    forceClose is false: isClosedContour returns true\\nwithout close(), forceClose is true : isClosedContour returns true\\nwith close(),    forceClose is true : isClosedContour returns true\\n"
    },
        "SkPath_Iter_next": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path, bool degen, bool exact) -> void {\n        SkPath::Iter iter(path, false);\n        SkDebugf(\"%s:\\n\", prefix);\n        const char* verbStr[] =  { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\", \"Done\" };\n        const int pointCount[] = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n        SkPath::Verb verb;\n        do {\n           SkPoint points[4];\n           verb = iter.next(points, degen, exact);\n           SkDebugf(\"k%s_Verb \", verbStr[(int) verb]);\n           for (int i = 0; i < pointCount[(int) verb]; ++i) {\n                SkDebugf(\"{%1.8g, %1.8g}, \", points[i].fX, points[i].fY);\n           }\n           SkDebugf(\"\\n\");\n        } while (SkPath::kDone_Verb != verb);\n        SkDebugf(\"\\n\");\n    };\n    SkPath path;\n    path.moveTo(10, 10);\n    path.moveTo(20, 20);\n    path.quadTo(10, 20, 30, 40);\n    path.moveTo(1, 1);\n    path.close();\n    path.moveTo(30, 30);\n    path.lineTo(30, 30);\n    path.moveTo(30, 30);\n    path.lineTo(30.00001f, 30);\n    debugster(\"skip degenerate\", path, true, false);\n    debugster(\"skip degenerate if exact\", path, true, true);\n    debugster(\"skip none\", path, false, false);\n}\n",
    "hash": "00ae8984856486bdb626d0ed6587855a",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::next()",
        "stdout": "skip degenerate:\\nkMove_Verb {20, 20}, \\nkQuad_Verb {20, 20}, {10, 20}, {30, 40}, \\nkDone_Verb \\n\\nskip degenerate if exact:\\nkMove_Verb {20, 20}, \\nkQuad_Verb {20, 20}, {10, 20}, {30, 40}, \\nkMove_Verb {30, 30}, \\nkLine_Verb {30, 30}, {30.00001, 30}, \\nkDone_Verb \\n\\nskip none:\\nkMove_Verb {10, 10}, \\nkMove_Verb {20, 20}, \\nkQuad_Verb {20, 20}, {10, 20}, {30, 40}, \\nkMove_Verb {1, 1}, \\nkClose_Verb {1, 1}, \\nkMove_Verb {30, 30}, \\nkLine_Verb {30, 30}, {30, 30}, \\nkMove_Verb {30, 30}, \\nkLine_Verb {30, 30}, {30.00001, 30}, \\nkDone_Verb \\n\\n"
    },
        "SkPath_Iter_setPath": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, SkPath::Iter& iter) -> void {\n        SkDebugf(\"%s:\\n\", prefix);\n        const char* verbStr[] =  { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\", \"Done\" };\n        const int pointCount[] = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n        SkPath::Verb verb;\n        do {\n           SkPoint points[4];\n           verb = iter.next(points);\n           SkDebugf(\"k%s_Verb \", verbStr[(int) verb]);\n           for (int i = 0; i < pointCount[(int) verb]; ++i) {\n                SkDebugf(\"{%g, %g}, \", points[i].fX, points[i].fY);\n           }\n           if (SkPath::kConic_Verb == verb) {\n               SkDebugf(\"weight = %g\", iter.conicWeight());\n           }\n           SkDebugf(\"\\n\");\n        } while (SkPath::kDone_Verb != verb);\n        SkDebugf(\"\\n\");\n    };\n    SkPath path;\n    path.quadTo(10, 20, 30, 40);\n    SkPath::Iter iter(path, false);\n    debugster(\"quad open\", iter);\n    SkPath path2;\n    path2.conicTo(1, 2, 3, 4, .5f);\n    iter.setPath(path2, true);\n    debugster(\"conic closed\", iter);\n}\n",
    "hash": "6c9688008cea8937ad5cc188b38ecf16",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter::setPath",
        "stdout": "quad open:\\nkMove_Verb {0, 0}, \\nkQuad_Verb {0, 0}, {10, 20}, {30, 40}, \\nkDone_Verb \\n\\nconic closed:\\nkMove_Verb {0, 0}, \\nkConic_Verb {0, 0}, {1, 2}, {3, 4}, weight = 0.5\\nkLine_Verb {3, 4}, {0, 0}, \\nkClose_Verb {0, 0}, \\nkDone_Verb \\n\\n"
    },
        "SkPath_RawIter_conicWeight": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPath path;\n   path.conicTo(1, 2, 3, 4, .5f);\n   SkPath::RawIter iter(path); \n   SkPoint p[4];\n   SkDebugf(\"first verb is \" \"%s\" \"move\\n\", SkPath::kMove_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"next verb is \" \"%s\" \"conic\\n\", SkPath::kConic_Verb == iter.next(p) ? \"\" : \"not \");\n   SkDebugf(\"conic points: {%g,%g}, {%g,%g}, {%g,%g}\\n\", p[0].fX, p[0].fY, p[1].fX, p[1].fY,\n                p[2].fX, p[2].fY);\n   SkDebugf(\"conic weight: %g\\n\", iter.conicWeight());\n}\n",
    "hash": "9747e8177a50ea551471ba0b706f544b",
    "file": "SkPath_Reference",
    "name": "SkPath::RawIter::conicWeight",
        "stdout": "first verb is move\\nnext verb is conic\\nconic points: {0,0}, {1,2}, {3,4}\\nconic weight: 0.5\\n"
    },
        "SkPath_RawIter_next": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(50, 60);\n    path.quadTo(10, 20, 30, 40);\n    path.close();\n    path.lineTo(30, 30);\n    path.conicTo(1, 2, 3, 4, .5f);\n    path.cubicTo(-1, -2, -3, -4, -5, -6);\n    SkPath::RawIter iter(path);\n    const char* verbStr[] =  { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\", \"Done\" };\n    const int pointCount[] = {     1 ,     2 ,     3 ,      3 ,      4 ,      1 ,     0  };\n    SkPath::Verb verb;\n    do {\n        SkPoint points[4];\n        verb = iter.next(points);\n        SkDebugf(\"k%s_Verb \", verbStr[(int) verb]);\n        for (int i = 0; i < pointCount[(int) verb]; ++i) {\n            SkDebugf(\"{%1.8g, %1.8g}, \", points[i].fX, points[i].fY);\n        }\n        if (SkPath::kConic_Verb == verb) {\n            SkDebugf(\"weight = %g\", iter.conicWeight());\n        }\n        SkDebugf(\"\\n\");\n    } while (SkPath::kDone_Verb != verb);\n}\n",
    "hash": "944a80c7ff8c04e1fecc4aec4a47ea60",
    "file": "SkPath_Reference",
    "name": "SkPath::RawIter::next()",
        "stdout": "kMove_Verb {50, 60}, \\nkQuad_Verb {50, 60}, {10, 20}, {30, 40}, \\nkClose_Verb {50, 60}, \\nkMove_Verb {50, 60}, \\nkLine_Verb {50, 60}, {30, 30}, \\nkConic_Verb {30, 30}, {1, 2}, {3, 4}, weight = 0.5\\nkCubic_Verb {3, 4}, {-1, -2}, {-3, -4}, {-5, -6}, \\nkDone_Verb \\n"
    },
        "SkPath_RawIter_peek": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.quadTo(10, 20, 30, 40);\n    path.conicTo(1, 2, 3, 4, .5f);\n    path.cubicTo(1, 2, 3, 4, .5, 6);\n    SkPath::RawIter iter(path);\n    SkPath::Verb verb, peek = iter.peek();\n    const char* verbStr[] =  { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\", \"Done\" };\n    do {\n        SkPoint points[4];\n        verb = iter.next(points);\n        SkDebugf(\"peek %s %c= verb %s\\n\", verbStr[peek], peek == verb ? '=' : '!', verbStr[verb]);\n        peek = iter.peek();\n    } while (SkPath::kDone_Verb != verb);\n    SkDebugf(\"peek %s %c= verb %s\\n\", verbStr[peek], peek == verb ? '=' : '!', verbStr[verb]);\n}",
    "hash": "eb5fa5bea23059ce538e883502f828f5",
    "file": "SkPath_Reference",
    "name": "SkPath::RawIter::peek()",
        "stdout": "peek Move == verb Move\\npeek Quad == verb Quad\\npeek Conic == verb Conic\\npeek Cubic == verb Cubic\\npeek Done == verb Done\\npeek Done == verb Done\\n"
    },
        "SkPath_SegmentMask": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.conicTo(10, 10, 20, 30, 1);\n    SkDebugf(\"Path kConic_SegmentMask is %s\\n\", path.getSegmentMasks() & \n          SkPath::kConic_SegmentMask ? \"set\" : \"clear\");\n    SkDebugf(\"Path kQuad_SegmentMask is %s\\n\", path.getSegmentMasks() & \n          SkPath::kQuad_SegmentMask ? \"set\" : \"clear\");\n}",
    "hash": "0972a1bd6e012c7519d3998afc32e69f",
    "file": "SkPath_Reference",
    "name": "SkPath::SegmentMask",
        "stdout": "Path kConic_SegmentMask is clear\\nPath kQuad_SegmentMask is set\\n"
    },
        "SkPath_Verb": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.lineTo(20, 20);\n    path.quadTo(-10, -10, 30, 30);\n    path.close();\n    path.cubicTo(1, 2, 3, 4, 5, 6);\n    path.conicTo(0, 0, 0, 0, 2);\n    uint8_t verbs[7];\n    int count = path.getVerbs(verbs, (int) SK_ARRAY_COUNT(verbs));\n    const char* verbStr[] = { \"Move\", \"Line\", \"Quad\", \"Conic\", \"Cubic\", \"Close\" };\n    SkDebugf(\"verb count: %d\\nverbs: \", count);\n    for (int i = 0; i < count; ++i) {\n        SkDebugf(\"k%s_Verb \", verbStr[verbs[i]]);\n    }\n    SkDebugf(\"\\n\");\n}\n",
    "hash": "799096fdc1298aa815934a74e76570ca",
    "file": "SkPath_Reference",
    "name": "SkPath::Verb",
        "stdout": "verb count: 7\\nverbs: kMove_Verb kLine_Verb kQuad_Verb kClose_Verb kMove_Verb kCubic_Verb kConic_Verb \\n"
    },
        "SkPath_arcTo_2_b": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo({156, 20});\n    path.arcTo(200, 20, 170, 50, 50);\n    SkPath::Iter iter(path, false);\n    SkPoint p[4];\n    SkPath::Verb verb;\n    while (SkPath::kDone_Verb != (verb = iter.next(p))) {\n        switch (verb) {\n            case SkPath::kMove_Verb:\n                SkDebugf(\"move to (%g,%g)\\n\", p[0].fX, p[0].fY);\n                break;\n            case SkPath::kLine_Verb:\n                SkDebugf(\"line (%g,%g),(%g,%g)\\n\", p[0].fX, p[0].fY, p[1].fX, p[1].fY);\n                break;\n            case SkPath::kConic_Verb:\n                SkDebugf(\"conic (%g,%g),(%g,%g),(%g,%g) weight %g\\n\",\n                         p[0].fX, p[0].fY, p[1].fX, p[1].fY, p[2].fX, p[2].fY, iter.conicWeight());\n                break;\n            default:\n                SkDebugf(\"unexpected verb\\n\");\n        }\n    }\n}\n",
    "hash": "498360fa0a201cc5db04b1c27256358f",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_2_3",
        "stdout": "move to (156,20)\\nline (156,20),(79.2893,20)\\nconic (79.2893,20),(200,20),(114.645,105.355) weight 0.382683\\n"
    },
        "SkPath_arcTo_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo({156, 20});\n    path.arcTo({200, 20}, {170, 20}, 50);\n    SkPath::Iter iter(path, false);\n    SkPoint p[4];\n    SkPath::Verb verb;\n    while (SkPath::kDone_Verb != (verb = iter.next(p))) {\n        switch (verb) {\n            case SkPath::kMove_Verb:\n                SkDebugf(\"move to (%g,%g)\\n\", p[0].fX, p[0].fY);\n                break;\n            case SkPath::kLine_Verb:\n                SkDebugf(\"line (%g,%g),(%g,%g)\\n\", p[0].fX, p[0].fY, p[1].fX, p[1].fY);\n                break;\n            case SkPath::kConic_Verb:\n                SkDebugf(\"conic (%g,%g),(%g,%g),(%g,%g) weight %g\\n\",\n                          p[0].fX, p[0].fY, p[1].fX, p[1].fY, p[2].fX, p[2].fY, iter.conicWeight());\n                break;\n            default:\n                SkDebugf(\"unexpected verb\\n\");\n        }\n    }\n}\n",
    "hash": "0c056264a361579c18e5d02d3172d4d4",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_3",
        "stdout": "move to (156,20)\\nline (156,20),(200,20)\\n"
    },
        "SkPath_computeTightBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n            const SkRect& bounds = path.computeTightBounds();\n            SkDebugf(\"%s bounds = %g, %g, %g, %g\\n\", prefix, \n                     bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    };\n    SkPath path;\n    debugster(\"empty\", path);\n    path.addCircle(50, 45, 25);\n    debugster(\"circle\", path);\n    SkMatrix matrix;\n    matrix.setRotate(45, 50, 45);\n    path.transform(matrix);\n    debugster(\"rotated circle\", path);\n}",
    "hash": "da34f02e69ec98d5681300aea9a2d0bf",
    "file": "SkPath_Reference",
    "name": "SkPath::computeTightBounds",
        "stdout": "empty bounds = 0, 0, 0, 0\\ncircle bounds = 25, 20, 75, 70\\nrotated circle bounds = 25, 20, 75, 70\\n"
    },
        "SkPath_copy_const_SkPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.lineTo(20, 20);\n    SkPath path2(path);\n    path2.close();\n    SkDebugf(\"path verbs: %d\\n\", path.countVerbs());\n    SkDebugf(\"path2 verbs: %d\\n\", path2.countVerbs());\n    path.reset();\n    SkDebugf(\"after reset\\n\" \"path verbs: %d\\n\", path.countVerbs());\n    SkDebugf(\"path2 verbs: %d\\n\", path2.countVerbs());\n}",
    "hash": "647312aacd946c8a6eabaca797140432",
    "file": "SkPath_Reference",
    "name": "SkPath::SkPath(const SkPath& path)",
        "stdout": "path verbs: 2\\npath2 verbs: 3\\nafter reset\\npath verbs: 0\\npath2 verbs: 3\\n"
    },
        "SkPath_copy_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path1;\n    path1.addRect({10, 20, 30, 40});\n    SkPath path2 = path1;\n    const SkRect& b1 = path1.getBounds();\n    SkDebugf(\"path1 bounds = %g, %g, %g, %g\\n\", b1.fLeft, b1.fTop, b1.fRight, b1.fBottom);\n    const SkRect& b2 = path2.getBounds();\n    SkDebugf(\"path2 bounds = %g, %g, %g, %g\\n\", b2.fLeft, b2.fTop, b2.fRight, b2.fBottom);\n}",
    "hash": "bba288f5f77fc8e37e89d2ec08e0ac60",
    "file": "SkPath_Reference",
    "name": "SkPath::operator=(const SkPath& path)",
        "stdout": "path1 bounds = 10, 20, 30, 40\\npath2 bounds = 10, 20, 30, 40\\n"
    },
        "SkPath_countPoints": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n         SkDebugf(\"%s point count: %d\\n\", prefix, path.countPoints());\n    };\n    SkPath path;\n    debugster(\"empty\", path);\n    path.lineTo(0, 0);\n    debugster(\"zero line\", path);\n    path.rewind();\n    path.moveTo(10, 10);\n    path.lineTo(20, 20);\n    debugster(\"line\", path);\n    path.moveTo(20, 20);\n    debugster(\"second move\", path);\n}\n",
    "hash": "bca6379ccef62cb081b10db7381deb27",
    "file": "SkPath_Reference",
    "name": "SkPath::countPoints",
        "stdout": "empty point count: 0\\nzero line point count: 2\\nline point count: 2\\nsecond move point count: 3\\n"
    },
        "SkPath_countVerbs": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"empty verb count: %d\\n\", path.countVerbs());\n    path.addRoundRect({10, 20, 30, 40}, 5, 5);\n    SkDebugf(\"round rect verb count: %d\\n\", path.countVerbs());\n}",
    "hash": "af0c66aea3ef81b709664c7007f48aae",
    "file": "SkPath_Reference",
    "name": "SkPath::countVerbs",
        "stdout": "empty verb count: 0\\nround rect verb count: 10\\n"
    },
        "SkPath_destructor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath* path = new SkPath();\n    path->lineTo(20, 20);\n    SkPath path2(*path);\n    delete path;\n    SkDebugf(\"path2 is \" \"%s\" \"empty\", path2.isEmpty() ? \"\" : \"not \");\n}\n",
    "hash": "01ad6be9b7d15a2217daea273eb3d466",
    "file": "SkPath_Reference",
    "name": "SkPath::~SkPath()",
        "stdout": "path2 is not empty"
    },
        "SkPath_dump": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.quadTo(20, 30, 40, 50);\n    for (bool forceClose : { false, true } ) {\n        for (bool dumpAsHex : { false, true } ) {\n            path.dump(nullptr, forceClose, dumpAsHex);\n            SkDebugf(\"\\n\");\n        }\n    }\n}",
    "hash": "8036d764452a62f9953af50846f0f3c0",
    "file": "SkPath_Reference",
    "name": "SkPath::dump()",
        "stdout": "path.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(0, 0);\\npath.quadTo(20, 30, 40, 50);\\n\\npath.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(SkBits2Float(0x00000000), SkBits2Float(0x00000000));  // 0, 0\\npath.quadTo(SkBits2Float(0x41a00000), SkBits2Float(0x41f00000), SkBits2Float(0x42200000), SkBits2Float(0x42480000));  // 20, 30, 40, 50\\n\\npath.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(0, 0);\\npath.quadTo(20, 30, 40, 50);\\npath.lineTo(0, 0);\\npath.close();\\n\\npath.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(SkBits2Float(0x00000000), SkBits2Float(0x00000000));  // 0, 0\\npath.quadTo(SkBits2Float(0x41a00000), SkBits2Float(0x41f00000), SkBits2Float(0x42200000), SkBits2Float(0x42480000));  // 20, 30, 40, 50\\npath.lineTo(SkBits2Float(0x00000000), SkBits2Float(0x00000000));  // 0, 0\\npath.close();\\n\\n"
    },
        "SkPath_dumpHex": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, copy;\n    path.lineTo(6.f / 7, 2.f / 3);\n    path.dumpHex();\n    copy.setFillType(SkPath::kWinding_FillType);\n    copy.moveTo(SkBits2Float(0x00000000), SkBits2Float(0x00000000));  // 0, 0\n    copy.lineTo(SkBits2Float(0x3f5b6db7), SkBits2Float(0x3f2aaaab));  // 0.857143f, 0.666667f\n    SkDebugf(\"path is \" \"%s\" \"equal to copy\\n\", path == copy ? \"\" : \"not \");\n}",
    "hash": "72a92fe058e8b3be6c8a30fad7fd1266",
    "file": "SkPath_Reference",
    "name": "SkPath::dumpHex",
        "stdout": "path.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(SkBits2Float(0x00000000), SkBits2Float(0x00000000));  // 0, 0\\npath.lineTo(SkBits2Float(0x3f5b6db7), SkBits2Float(0x3f2aaaab));  // 0.857143f, 0.666667f\\npath is equal to copy\\n"
    },
        "SkPath_dump_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, copy;\n    path.lineTo(6.f / 7, 2.f / 3);\n    path.dump();\n    copy.setFillType(SkPath::kWinding_FillType);\n    copy.moveTo(0, 0);\n    copy.lineTo(0.857143f, 0.666667f);\n    SkDebugf(\"path is \" \"%s\" \"equal to copy\\n\", path == copy ? \"\" : \"not \");\n}",
    "hash": "92e0032f85181795d1f8b5a2c8e4e4b7",
    "file": "SkPath_Reference",
    "name": "SkPath::dump_2",
        "stdout": "path.setFillType(SkPath::kWinding_FillType);\\npath.moveTo(0, 0);\\npath.lineTo(0.857143f, 0.666667f);\\npath is not equal to copy\\n"
    },
        "SkPath_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"path is \" \"%s\" \"empty\", path.isEmpty() ? \"\" : \"not \");\n}",
    "hash": "0a0026fca638d1cd75c0ab884e3ee1c6",
    "file": "SkPath_Reference",
    "name": "SkPath::SkPath()",
        "stdout": "path is empty"
    },
        "SkPath_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& a, const SkPath& b) -> void {\n                SkDebugf(\"%s one %c= two\\n\", prefix, a == b ? '=' : '!');\n    };\n    SkPath one;\n    SkPath two;\n    debugster(\"empty\", one, two);\n    one.moveTo(0, 0);\n    debugster(\"moveTo\", one, two);\n    one.rewind();\n    debugster(\"rewind\", one, two);\n    one.moveTo(0, 0);\n    one.reset();\n    debugster(\"reset\", one, two);\n}\n",
    "hash": "31883f51bb357f2ac5990d88f8b82e02",
    "file": "SkPath_Reference",
    "name": "SkPath::operator==(const SkPath& a, const SkPath& b)",
        "stdout": "empty one == two\\nmoveTo one != two\\nrewind one == two\\nreset one == two\\n"
    },
        "SkPath_getBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n            const SkRect& bounds = path.getBounds();\n            SkDebugf(\"%s bounds = %g, %g, %g, %g\\n\", prefix, \n                     bounds.fLeft, bounds.fTop, bounds.fRight, bounds.fBottom);\n    };\n    SkPath path;\n    debugster(\"empty\", path);\n    path.addCircle(50, 45, 25);\n    debugster(\"circle\", path);\n    SkMatrix matrix;\n    matrix.setRotate(45, 50, 45);\n    path.transform(matrix);\n    debugster(\"rotated circle\", path);\n}",
    "hash": "9160aa6d1476bd87d927cfc8a4bf25e7",
    "file": "SkPath_Reference",
    "name": "SkPath::getBounds",
        "stdout": "empty bounds = 0, 0, 0, 0\\ncircle bounds = 25, 20, 75, 70\\nrotated circle bounds = 14.6447, 9.64466, 85.3553, 80.3553\\n"
    },
        "SkPath_getConvexity": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s path convexity is %s\\n\", prefix, \n                SkPath::kUnknown_Convexity == path.getConvexity() ? \"unknown\" :\n                SkPath::kConvex_Convexity == path.getConvexity() ? \"convex\" : \"concave\"); };\n    SkPath path;\n    debugster(\"initial\", path);\n    path.lineTo(50, 0);\n    debugster(\"first line\", path);\n    path.lineTo(50, 50);\n    debugster(\"second line\", path);\n    path.lineTo(100, 50);\n    debugster(\"third line\", path);\n}\n",
    "hash": "c8f5ac4040cb5026d234bf99e3f01e8e",
    "file": "SkPath_Reference",
    "name": "SkPath::getConvexity",
        "stdout": "initial path convexity is convex\\nfirst line path convexity is convex\\nsecond line path convexity is convex\\nthird line path convexity is concave\\n"
    },
        "SkPath_getConvexityOrUnknown": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s path convexity is %s\\n\", prefix, \n            SkPath::kUnknown_Convexity == path.getConvexityOrUnknown() ? \"unknown\" :\n            SkPath::kConvex_Convexity == path.getConvexityOrUnknown() ? \"convex\" : \"concave\"); };\n    SkPath path;\n    debugster(\"initial\", path);\n    path.lineTo(50, 0);\n    debugster(\"first line\", path);\n    path.getConvexity();\n    path.lineTo(50, 50);\n    debugster(\"second line\", path);\n    path.lineTo(100, 50);\n    path.getConvexity();\n    debugster(\"third line\", path);\n}\n",
    "hash": "bc19da9de880e3f339707247686efc0a",
    "file": "SkPath_Reference",
    "name": "SkPath::getConvexityOrUnknown",
        "stdout": "initial path convexity is unknown\\nfirst line path convexity is unknown\\nsecond line path convexity is unknown\\nthird line path convexity is concave\\n"
    },
        "SkPath_getFillType": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"default path fill type is %s\\n\",\n            path.getFillType() == SkPath::kWinding_FillType ? \"kWinding_FillType\" :\n            path.getFillType() == SkPath::kEvenOdd_FillType ? \"kEvenOdd_FillType\" : \n            path.getFillType() == SkPath::kInverseWinding_FillType ? \"kInverseWinding_FillType\" :\n                                                                     \"kInverseEvenOdd_FillType\");\n}",
    "hash": "2eb8f985d1e263e70b5c0aa4a8b68d8e",
    "file": "SkPath_Reference",
    "name": "SkPath::getFillType",
        "stdout": "default path fill type is kWinding_FillType\\n"
    },
        "SkPath_getGenerationID": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"empty genID = %u\\n\", path.getGenerationID());\n    path.lineTo(1, 2);\n    SkDebugf(\"1st lineTo genID = %u\\n\", path.getGenerationID());\n    path.rewind();\n    SkDebugf(\"empty genID = %u\\n\", path.getGenerationID());\n    path.lineTo(1, 2);\n    SkDebugf(\"2nd lineTo genID = %u\\n\", path.getGenerationID());\n}",
    "hash": "a0f166715d6479f91258d854e63e586d",
    "file": "SkPath_Reference",
    "name": "SkPath::getGenerationID",
        "stdout": "empty genID = 1\\n1st lineTo genID = 2\\nempty genID = 1\\n2nd lineTo genID = 3\\n"
    },
        "SkPath_getLastPt": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(100, 100);\n    path.quadTo(100, 20, 20, 100);\n    SkMatrix matrix;\n    matrix.setRotate(36, 100, 100);\n    path.transform(matrix);\n    SkPoint last;\n    path.getLastPt(&last);\n    SkDebugf(\"last point: %g, %g\\n\", last.fX, last.fY);\n}",
    "hash": "df8160dd7ac8aa4b40fce7286fe49952",
    "file": "SkPath_Reference",
    "name": "SkPath::getLastPt",
        "stdout": "last point: 35.2786, 52.9772\\n"
    },
        "SkPath_getPoint": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n         SkDebugf(\"%s point count: %d\\n\", prefix, path.countPoints());\n    };\n    SkPath path;\n    path.lineTo(20, 20);\n    path.offset(-10, -10);\n    for (int i= 0; i < path.countPoints(); ++i) {\n         SkDebugf(\"point %d: (%1.8g,%1.8g)\\n\", i, path.getPoint(i).fX, path.getPoint(i).fY);\n    }  \n}\n",
    "hash": "1cf6b8dd2994c4ca9a2d6887ff888017",
    "file": "SkPath_Reference",
    "name": "SkPath::getPoint",
        "stdout": "point 0: (-10,-10)\\npoint 1: (10,10)\\n"
    },
        "SkPath_getPoints": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path, SkPoint* points, int max) -> void {\n         int count = path.getPoints(points, max);\n         SkDebugf(\"%s point count: %d  \", prefix, count);\n         for (int i = 0; i < SkTMin(count, max) && points; ++i) {\n             SkDebugf(\"(%1.8g,%1.8g) \", points[i].fX, points[i].fY);\n         }\n         SkDebugf(\"\\n\");\n    };\n    SkPath path;\n    path.lineTo(20, 20);\n    path.lineTo(-10, -10);\n    SkPoint points[3];\n    debugster(\"no points\",  path, nullptr, 0);\n    debugster(\"zero max\",  path, points, 0);\n    debugster(\"too small\",  path, points, 2);\n    debugster(\"just right\",  path, points, path.countPoints());\n}\n",
    "hash": "9bc86efda08cbcd9c6f7c5f220294a24",
    "file": "SkPath_Reference",
    "name": "SkPath::getPoints",
        "stdout": "no points point count: 3  \\nzero max point count: 3  \\ntoo small point count: 3  (0,0) (20,20) \\njust right point count: 3  (0,0) (20,20) (-10,-10) \\n"
    },
        "SkPath_getSegmentMasks": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.quadTo(20, 30, 40, 50);\n    path.close();\n    const char* masks[] = { \"line\", \"quad\", \"conic\", \"cubic\" };\n    int index = 0;\n    for (auto mask : { SkPath::kLine_SegmentMask, SkPath::kQuad_SegmentMask,\n            SkPath::kConic_SegmentMask, SkPath::kCubic_SegmentMask } ) {\n        if (mask & path.getSegmentMasks()) {\n           SkDebugf(\"mask %s set\\n\", masks[index]);\n        }       \n        ++index;\n    }\n}",
    "hash": "dd9f620b419c8ca18cd306c881aadb5f",
    "file": "SkPath_Reference",
    "name": "SkPath::getSegmentMasks",
        "stdout": "mask quad set\\n"
    },
        "SkPath_getVerbs": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path, uint8_t* verbs, int max) -> void {\n         int count = path.getVerbs(verbs, max);\n         SkDebugf(\"%s verb count: %d  \", prefix, count);\n         const char* verbStr[] = { \"move\", \"line\", \"quad\", \"conic\", \"cubic\", \"close\" };\n         for (int i = 0; i < SkTMin(count, max) && verbs; ++i) {\n             SkDebugf(\"%s \", verbStr[verbs[i]]);\n         }\n         SkDebugf(\"\\n\");\n    };\n    SkPath path;\n    path.lineTo(20, 20);\n    path.lineTo(-10, -10);\n    uint8_t verbs[3];\n    debugster(\"no verbs\",  path, nullptr, 0);\n    debugster(\"zero max\",  path, verbs, 0);\n    debugster(\"too small\",  path, verbs, 2);\n    debugster(\"just right\",  path, verbs, path.countVerbs());\n}\n",
    "hash": "2ec66880966a6133ddd9331ce7323438",
    "file": "SkPath_Reference",
    "name": "SkPath::getVerbs",
        "stdout": "no verbs verb count: 3  \\nzero max verb count: 3  \\ntoo small verb count: 3  move line \\njust right verb count: 3  move line line \\n"
    },
        "SkPath_isEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s path is %s\" \"empty\\n\", prefix, path.isEmpty() ? \"\" : \"not \");\n    };\n    SkPath path;\n    debugster(\"initial\", path);\n    path.moveTo(0, 0);\n    debugster(\"after moveTo\", path);\n    path.rewind();\n    debugster(\"after rewind\", path);\n    path.lineTo(0, 0);\n    debugster(\"after lineTo\", path);\n    path.reset();\n    debugster(\"after reset\", path);\n}\n",
    "hash": "0b34e6d55d11586744adeb889d2a12f4",
    "file": "SkPath_Reference",
    "name": "SkPath::isEmpty",
        "stdout": "initial path is empty\\nafter moveTo path is not empty\\nafter rewind path is empty\\nafter lineTo path is not empty\\nafter reset path is empty\\n"
    },
        "SkPath_isFinite": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s path is %s\" \"finite\\n\", prefix, path.isFinite() ? \"\" : \"not \");\n    };\n    SkPath path;\n    debugster(\"initial\", path);\n    path.lineTo(SK_ScalarMax, SK_ScalarMax);\n    debugster(\"after line\", path);\n    SkMatrix matrix;\n    matrix.setScale(2, 2);\n    path.transform(matrix);\n    debugster(\"after scale\", path);\n}\n",
    "hash": "dd4e4dd2aaa8039b2430729c6b3af817",
    "file": "SkPath_Reference",
    "name": "SkPath::isFinite",
        "stdout": "initial path is finite\\nafter line path is finite\\nafter scale path is not finite\\n"
    },
        "SkPath_isInterpolatable": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, path2;\n    path.moveTo(20, 20);\n    path.lineTo(40, 40);\n    path.lineTo(20, 20);\n    path.lineTo(40, 40);\n    path.close();\n    path2.addRect({20, 20, 40, 40});\n    SkDebugf(\"paths are \" \"%s\" \"interpolatable\", path.isInterpolatable(path2) ? \"\" : \"not \");\n}",
    "hash": "c81fc7dfaf785c3fb77209c7f2ebe5b8",
    "file": "SkPath_Reference",
    "name": "SkPath::isInterpolatable",
        "stdout": "paths are interpolatable"
    },
        "SkPath_isInverseFillType": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"default path fill type is inverse: %s\\n\",\n            path.isInverseFillType() ? \"true\" : \"false\");\n}",
    "hash": "2a2d39f5da611545caa18bbcea873ab2",
    "file": "SkPath_Reference",
    "name": "SkPath::isInverseFillType",
        "stdout": "default path fill type is inverse: false\\n"
    },
        "SkPath_isLastContourClosed": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s last contour is %s\" \"closed\\n\", prefix,\n                 path.isLastContourClosed() ? \"\" : \"not \");\n    };\n    SkPath path;\n    debugster(\"initial\", path);\n    path.close();\n    debugster(\"after close\", path);\n    path.lineTo(0, 0);\n    debugster(\"after lineTo\", path);\n    path.close();\n    debugster(\"after close\", path);\n}\n",
    "hash": "03b740ab94b9017800a52e30b5e7fee7",
    "file": "SkPath_Reference",
    "name": "SkPath::isLastContourClosed",
        "stdout": "initial last contour is not closed\\nafter close last contour is not closed\\nafter lineTo last contour is not closed\\nafter close last contour is closed\\n"
    },
        "SkPath_isLine": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkPoint line[2];\n        if (path.isLine(line)) {\n            SkDebugf(\"%s is line (%1.8g,%1.8g) (%1.8g,%1.8g)\\n\", prefix,\n                 line[0].fX, line[0].fY, line[1].fX, line[1].fY);\n        } else {\n            SkDebugf(\"%s is not line\\n\", prefix);\n        }\n    };\n    SkPath path;\n    debugster(\"empty\", path);\n    path.lineTo(0, 0);\n    debugster(\"zero line\", path);\n    path.rewind();\n    path.moveTo(10, 10);\n    path.lineTo(20, 20);\n    debugster(\"line\", path);\n    path.moveTo(20, 20);\n    debugster(\"second move\", path);\n}\n",
    "hash": "1ad07d56e4258e041606d50cad969392",
    "file": "SkPath_Reference",
    "name": "SkPath::isLine",
        "stdout": "empty is not line\\nzero line is line (0,0) (0,0)\\nline is line (10,10) (20,20)\\nsecond move is not line\\n"
    },
        "SkPath_isNestedFillRects": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(5);\n    SkPath path;\n    path.addRect({10, 20, 30, 40});\n    paint.getFillPath(path, &path);\n    SkRect rects[2];\n    SkPath::Direction directions[2];\n    if (path.isNestedFillRects(rects, directions)) {\n        for (int i = 0; i < 2; ++i) {\n            SkDebugf(\"%s (%g, %g, %g, %g); direction %s\\n\", i ? \"inner\" : \"outer\",\n                     rects[i].fLeft, rects[i].fTop, rects[i].fRight, rects[i].fBottom,\n                     SkPath::kCW_Direction == directions[i] ? \"CW\" : \"CCW\");\n        }\n    } else {\n        SkDebugf(\"is not nested rectangles\\n\");\n    }\n}\n",
    "hash": "77e4394caf9fa083c19c21c2462efe14",
    "file": "SkPath_Reference",
    "name": "SkPath::isNestedFillRects",
        "stdout": "outer (7.5, 17.5, 32.5, 42.5); direction CW\\ninner (12.5, 22.5, 27.5, 37.5); direction CCW\\n"
    },
        "SkPath_isRect": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkRect rect;\n        SkPath::Direction direction;\n        bool isClosed;\n        path.isRect(&rect, &isClosed, &direction) ? \n                SkDebugf(\"%s is rect (%g, %g, %g, %g); is %s\" \"closed; direction %s\\n\", prefix,\n                         rect.fLeft, rect.fTop, rect.fRight, rect.fBottom, isClosed ? \"\" : \"not \",\n                         SkPath::kCW_Direction == direction ? \"CW\" : \"CCW\") :\n                SkDebugf(\"%s is not rect\\n\", prefix);\n    };\n    SkPath path;\n    debugster(\"empty\", path);\n    path.addRect({10, 20, 30, 40});\n    debugster(\"addRect\", path);\n    path.moveTo(60, 70);\n    debugster(\"moveTo\", path);\n    path.lineTo(60, 70);\n    debugster(\"lineTo\", path);\n    path.reset();\n    const SkPoint pts[] = { {0, 0}, {0, 80}, {80, 80}, {80, 0}, {40, 0}, {20, 0} };\n    path.addPoly(pts, SK_ARRAY_COUNT(pts), false);\n    debugster(\"addPoly\", path);\n}\n",
    "hash": "063a5f0a8de1fe998d227393e0866557",
    "file": "SkPath_Reference",
    "name": "SkPath::isRect",
        "stdout": "empty is not rect\\naddRect is rect (10, 20, 30, 40); is closed; direction CW\\nmoveTo is rect (10, 20, 30, 40); is closed; direction CW\\nlineTo is not rect\\naddPoly is rect (0, 0, 80, 80); is not closed; direction CCW\\n"
    },
        "SkPath_isVolatile": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkDebugf(\"volatile by default is %s\\n\", path.isVolatile() ? \"true\" : \"false\");\n}",
    "hash": "c722ebe8ac991d77757799ce29e509e1",
    "file": "SkPath_Reference",
    "name": "SkPath::isVolatile",
        "stdout": "volatile by default is false\\n"
    },
        "SkPath_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& a, const SkPath& b) -> void {\n                SkDebugf(\"%s one %c= two\\n\", prefix, a != b ? '!' : '=');\n    };\n    SkPath one;\n    SkPath two;\n    debugster(\"empty\", one, two);\n    one.addRect({10, 20, 30, 40});\n    two.addRect({10, 20, 30, 40});\n    debugster(\"addRect\", one, two);\n    one.setConvexity(SkPath::kConcave_Convexity);\n    debugster(\"setConvexity\", one, two);\n    SkDebugf(\"convexity %c=\\n\", one.getConvexity() == two.getConvexity() ? '=' : '!');\n}\n",
    "hash": "0c6870ba1cea85ce6da5abd489c23d83",
    "file": "SkPath_Reference",
    "name": "SkPath::operator!=(const SkPath& a, const SkPath& b)",
        "stdout": "empty one == two\\naddRect one == two\\nsetConvexity one == two\\nconvexity !=\\n"
    },
        "SkPath_readFromMemory": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, copy;\n    path.lineTo(6.f / 7, 2.f / 3);\n    size_t size = path.writeToMemory(nullptr);\n    SkTDArray<char> storage;\n    storage.setCount(size);\n    path.writeToMemory(storage.begin());\n    size_t wrongSize = size - 4;\n    size_t bytesRead = copy.readFromMemory(storage.begin(), wrongSize);\n    SkDebugf(\"length = %u; returned by readFromMemory = %u\\n\", wrongSize, bytesRead);\n    size_t largerSize = size + 4;\n    bytesRead = copy.readFromMemory(storage.begin(), largerSize);\n    SkDebugf(\"length = %u; returned by readFromMemory = %u\\n\", largerSize, bytesRead);\n}\n",
    "hash": "9c6edd836c573a0fd232d2b8aa11a678",
    "file": "SkPath_Reference",
    "name": "SkPath::readFromMemory",
        "stdout": "length = 60; returned by readFromMemory = 0\\nlength = 68; returned by readFromMemory = 64\\n"
    },
        "SkPath_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path1, path2;\n    path1.setFillType(SkPath::kInverseWinding_FillType);\n    path1.addRect({10, 20, 30, 40});\n    SkDebugf(\"path1 %c= path2\\n\", path1 == path2 ? '=' : '!');\n    path1.reset();\n    SkDebugf(\"path1 %c= path2\\n\", path1 == path2 ? '=' : '!');\n}",
    "hash": "8cdca35d2964bbbecb93d79a13f71c65",
    "file": "SkPath_Reference",
    "name": "SkPath::reset()",
        "stdout": "path1 != path2\\npath1 == path2\\n"
    },
        "SkPath_rewind": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path1, path2;\n    path1.setFillType(SkPath::kInverseWinding_FillType);\n    path1.addRect({10, 20, 30, 40});\n    SkDebugf(\"path1 %c= path2\\n\", path1 == path2 ? '=' : '!');\n    path1.rewind();\n    SkDebugf(\"path1 %c= path2\\n\", path1 == path2 ? '=' : '!');\n}",
    "hash": "f1fedbb89da9c2a33a91805175663012",
    "file": "SkPath_Reference",
    "name": "SkPath::rewind()",
        "stdout": "path1 != path2\\npath1 == path2\\n"
    },
        "SkPath_serialize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, copy;\n    path.lineTo(6.f / 7, 2.f / 3);\n    sk_sp<SkData> data = path.serialize();\n    copy.readFromMemory(data->data(), data->size());\n    SkDebugf(\"path is \" \"%s\" \"equal to copy\\n\", path == copy ? \"\" : \"not \");\n}\n",
    "hash": "2c6aff73608cd198659db6d1eeaaae4f",
    "file": "SkPath_Reference",
    "name": "SkPath::serialize()",
        "stdout": "path is equal to copy\\n"
    },
        "SkPath_setConvexity": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const char* prefix, const SkPath& path) -> void {\n        SkDebugf(\"%s path convexity is %s\\n\", prefix, \n                SkPath::kUnknown_Convexity == path.getConvexity() ? \"unknown\" :\n                SkPath::kConvex_Convexity == path.getConvexity() ? \"convex\" : \"concave\"); };\n        SkPoint quad[] = {{70, 70}, {20, 20}, {120, 20}, {120, 120}}; \n        SkPath path;\n        path.addPoly(quad, SK_ARRAY_COUNT(quad), true);\n        debugster(\"initial\", path);\n        path.setConvexity(SkPath::kConcave_Convexity);\n        debugster(\"after forcing concave\", path);\n        path.setConvexity(SkPath::kUnknown_Convexity);\n        debugster(\"after forcing unknown\", path);\n}\n",
    "hash": "6fe0d520507eeafe118b80f7f1d9b588",
    "file": "SkPath_Reference",
    "name": "SkPath::setConvexity",
        "stdout": "initial path convexity is convex\\nafter forcing concave path convexity is concave\\nafter forcing unknown path convexity is convex\\n"
    },
        "SkPath_swap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path1, path2;\n    path1.addRect({10, 20, 30, 40});\n    path1.swap(path2);\n    const SkRect& b1 = path1.getBounds();\n    SkDebugf(\"path1 bounds = %g, %g, %g, %g\\n\", b1.fLeft, b1.fTop, b1.fRight, b1.fBottom);\n    const SkRect& b2 = path2.getBounds();\n    SkDebugf(\"path2 bounds = %g, %g, %g, %g\\n\", b2.fLeft, b2.fTop, b2.fRight, b2.fBottom);\n}",
    "hash": "4c5ebee2b5039e5faefa07ae63a15467",
    "file": "SkPath_Reference",
    "name": "SkPath::swap()",
        "stdout": "path1 bounds = 0, 0, 0, 0\\npath2 bounds = 10, 20, 30, 40\\n"
    },
        "SkPath_updateBoundsCache": {
    "code": "void draw(SkCanvas* canvas) {\n    double times[2] = { 0, 0 };\n    for (int i = 0; i < 10000; ++i) {\n      SkPath path;\n      for (int j = 1; j < 100; ++ j) {\n        path.addCircle(50 + j, 45 + j, 25 + j);\n      }\n      if (1 & i) {\n        path.updateBoundsCache();\n      }\n      double start = SkTime::GetNSecs();\n      (void) path.getBounds();\n      times[1 & i] += SkTime::GetNSecs() - start;\n    }\n    SkDebugf(\"uncached avg: %g ms\\n\", times[0] * 1e-6);\n    SkDebugf(\"cached avg: %g ms\\n\", times[1] * 1e-6);\n}",
    "hash": "bb761cd858e6d0ca05627262cd22ff5e",
    "file": "SkPath_Reference",
    "name": "SkPath::updateBoundsCache",
        "stdout": "uncached avg: 0.18048 ms\\ncached avg: 0.182784 ms\\n"
    },
        "SkPath_writeToMemory": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, copy;\n    path.lineTo(6.f / 7, 2.f / 3);\n    size_t size = path.writeToMemory(nullptr);\n    SkTDArray<char> storage;\n    storage.setCount(size);\n    path.writeToMemory(storage.begin());\n    copy.readFromMemory(storage.begin(), size);\n    SkDebugf(\"path is \" \"%s\" \"equal to copy\\n\", path == copy ? \"\" : \"not \");\n}\n",
    "hash": "e5f16eda6a1c2d759556285f72598445",
    "file": "SkPath_Reference",
    "name": "SkPath::writeToMemory",
        "stdout": "path is equal to copy\\n"
    },
        "SkPixmap_addr": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    pixels.resize(image->height() * image->width() * 4);\n    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,\n            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n    image->readPixels(pixmap, 0, 0);\n    SkDebugf(\"pixels address: 0x%llx\\n\", pixmap.addr());\n    SkPixmap inset;\n    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {\n         SkDebugf(\"inset address:  0x%llx\\n\", inset.addr());\n    }\n}",
    "hash": "17bcabaaee2dbb7beba562e9ca50b55e",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr()",
        "stdout": "pixels address: 0x7f2a440bb010\\ninset address:  0x7f2a440fb210\\n"
    },
        "SkPixmap_addr16": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint16_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kARGB_4444_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr16() %c= storage\\n\",\n              pixmap.addr16()  == storage ? '=' : '!');\n}",
    "hash": "9b16012d265c954c6de13f3fc960da52",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr16",
        "stdout": "pixmap.addr16() == storage\\n"
    },
        "SkPixmap_addr16_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint16_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kARGB_4444_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr16(1, 2) %c= &storage[1 + 2 * w]\\n\",\n              pixmap.addr16(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');\n}",
    "hash": "2c0c88a546d4ef093ab63ff72dac00b9",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr16_2",
        "stdout": "pixmap.addr16(1, 2) == \\u0026storage[1 + 2 * w]\\n"
    },
        "SkPixmap_addr32": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint32_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr32() %c= storage\\n\",\n              pixmap.addr32()  == storage ? '=' : '!');\n}",
    "hash": "6b90c7ae9f254fe4ea9ef638f893a3e6",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr32",
        "stdout": "pixmap.addr32() == storage\\n"
    },
        "SkPixmap_addr32_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint32_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_8888_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr32(1, 2) %c= &storage[1 + 2 * w]\\n\",\n              pixmap.addr32(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');\n}",
    "hash": "12f8b5ce9fb25604f33df336677f5d62",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr32_2",
        "stdout": "pixmap.addr32(1, 2) == \\u0026storage[1 + 2 * w]\\n"
    },
        "SkPixmap_addr64": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint64_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr64() %c= storage\\n\",\n              pixmap.addr64()  == storage ? '=' : '!');\n}",
    "hash": "0d17085a4698a8a2e2235fad9041b4b4",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr64",
        "stdout": "pixmap.addr64() == storage\\n"
    },
        "SkPixmap_addr64_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint64_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr64(1, 2) %c= &storage[1 + 2 * w]\\n\",\n              pixmap.addr64(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');\n}",
    "hash": "5449f65fd7673273b0b57807fd3117ff",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr64_2",
        "stdout": "pixmap.addr64(1, 2) == \\u0026storage[1 + 2 * w]\\n"
    },
        "SkPixmap_addr8": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint8_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kGray_8_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr8() %c= storage\\n\",\n              pixmap.addr8()  == storage ? '=' : '!');\n}",
    "hash": "9adda80b2dd1b08ec5ccf66da7c8bd91",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr8",
        "stdout": "pixmap.addr8() == storage\\n"
    },
        "SkPixmap_addr8_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint8_t storage[w * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kGray_8_SkColorType, kPremul_SkAlphaType),\n                    storage, w * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addr8(1, 2) %c= &storage[1 + 2 * w]\\n\",\n              pixmap.addr8(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');\n}",
    "hash": "5b986272268ef2c52045c1856f8b6107",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr8_2",
        "stdout": "pixmap.addr8(1, 2) == \\u0026storage[1 + 2 * w]\\n"
    },
        "SkPixmap_addrF16": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    uint16_t storage[w * h * 4];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),\n                    storage, w * 4 * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addrF16() %c= storage\\n\",\n              pixmap.addrF16()  == storage ? '=' : '!');\n}",
    "hash": "54e8525a592f05623c33b375aebc90c1",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addrF16",
        "stdout": "pixmap.addrF16() == storage\\n"
    },
        "SkPixmap_addrF16_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    const int wordsPerPixel = 4;\n    const int rowWords = w * wordsPerPixel;\n    uint16_t storage[rowWords * h];\n    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),\n                    storage, rowWords * sizeof(storage[0]));\n    SkDebugf(\"pixmap.addrF16(1, 2) %c= &storage[1 * wordsPerPixel + 2 * rowWords]\\n\",\n              pixmap.addrF16(1, 2)  == &storage[1 * wordsPerPixel + 2 * rowWords] ? '=' : '!');\n}",
    "hash": "f6076cad455bc80af5d06eb121d3b6f2",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addrF16_2",
        "stdout": "pixmap.addrF16(1, 2) == \\u0026storage[1 * wordsPerPixel + 2 * rowWords]\\n"
    },
        "SkPixmap_addr_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    std::vector<SkPMColor> storage;\n    storage.resize(w * h);\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), &storage.front(), w * 4);\n    SkDebugf(\"pixmap.addr(1, 2) %c= &storage[1 + 2 * w]\\n\",\n              pixmap.addr(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');\n}",
    "hash": "6e6e29e860eafed77308c973400cc84d",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::addr_2",
        "stdout": "pixmap.addr(1, 2) == \\u0026storage[1 + 2 * w]\\n"
    },
        "SkPixmap_alphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);\n    SkDebugf(\"alpha type: k\" \"%s\" \"_SkAlphaType\\n\", alphas[pixmap.alphaType()]);\n}",
    "hash": "070b1a60232be499eb10c6ea62371804",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::alphaType",
        "stdout": "alpha type: kPremul_SkAlphaType\\n"
    },
        "SkPixmap_bounds": {
    "code": "void draw(SkCanvas* canvas) {\n    for (int width : { 0, 2 } ) {\n        for (int height : { 0, 2 } ) {\n             SkPixmap pixmap(SkImageInfo::MakeA8(width, height), nullptr, width);\n             SkDebugf(\"width: %d height: %d empty: %s\\n\", width, height,\n                      pixmap.bounds().isEmpty() ? \"true\" : \"false\");\n        }\n    }\n}",
    "hash": "79750fb1d898a4e5c8c828b7bc9acec5",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::bounds()",
        "stdout": "width: 0 height: 0 empty: true\\nwidth: 0 height: 2 empty: true\\nwidth: 2 height: 0 empty: true\\nwidth: 2 height: 2 empty: false\\n"
    },
        "SkPixmap_colorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap(SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType, \n            SkColorSpace::MakeSRGBLinear()), nullptr, 64);\n    SkColorSpace* colorSpace = pixmap.colorSpace();\n    SkDebugf(\"gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\\n\",\n            colorSpace->gammaCloseToSRGB() ? \"true\" : \"false\",\n            colorSpace->gammaIsLinear() ? \"true\" : \"false\",\n            colorSpace->isSRGB() ? \"true\" : \"false\");\n}",
    "hash": "34c71f803b8edb48eaf1cd0c55bb212e",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::colorSpace",
        "stdout": "gammaCloseToSRGB: false  gammaIsLinear: true  isSRGB: false\\n"
    },
        "SkPixmap_colorType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);\n    SkDebugf(\"color type: k\" \"%s\" \"_SkColorType\\n\", colors[pixmap.colorType()]);\n}",
    "hash": "0ab5c7af272685f2ce177cc79e6b9457",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::colorType",
        "stdout": "color type: kAlpha_8_SkColorType\\n"
    },
        "SkPixmap_computeByteSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap;\n    for (int width : { 1, 1000, 1000000 } ) {\n        for (int height: { 1, 1000, 1000000 } ) {\n            SkImageInfo imageInfo = SkImageInfo::MakeN32(width, height, kPremul_SkAlphaType);\n            pixmap.reset(imageInfo, nullptr, width * 5);\n            SkDebugf(\"width: %7d height: %7d computeByteSize: %13lld\\n\", width, height,\n                     pixmap.computeByteSize());\n        }\n    }\n}",
    "hash": "410d14ddc45d272598c5a4e52bb047de",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::computeByteSize",
        "stdout": "width:       1 height:       1 computeByteSize:             4\\nwidth:       1 height:    1000 computeByteSize:          4999\\nwidth:       1 height: 1000000 computeByteSize:       4999999\\nwidth:    1000 height:       1 computeByteSize:          4000\\nwidth:    1000 height:    1000 computeByteSize:       4999000\\nwidth:    1000 height: 1000000 computeByteSize:    4999999000\\nwidth: 1000000 height:       1 computeByteSize:       4000000\\nwidth: 1000000 height:    1000 computeByteSize:    4999000000\\nwidth: 1000000 height: 1000000 computeByteSize: 4999999000000\\n"
    },
        "SkPixmap_computeIsOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<uint32_t> pixels;\n    const int height = 2;\n    const int width = 2;\n    pixels.resize(height * width * 4);\n    SkPixmap pixmap(SkImageInfo::Make(width, height, kN32_SkColorType,\n            kPremul_SkAlphaType), (const void*) &pixels.front(), width * 4);\n    for (int index = 0; index < 2; ++index) {\n        pixmap.erase(0x00000000);\n        SkDebugf(\"computeIsOpaque: %s\\n\", pixmap.computeIsOpaque() ? \"true\" : \"false\");\n        pixmap.erase(0xFFFFFFFF);\n        SkDebugf(\"computeIsOpaque: %s\\n\", pixmap.computeIsOpaque() ? \"true\" : \"false\");\n        pixmap.reset(pixmap.info().makeAlphaType(kOpaque_SkAlphaType),\n                     (const void*) &pixels.front(), width * 4);\n    }\n}",
    "hash": "6ef37d5be03d0bfaec992dbb5a94c66f",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::computeIsOpaque",
        "stdout": "computeIsOpaque: false\\ncomputeIsOpaque: true\\ncomputeIsOpaque: false\\ncomputeIsOpaque: true\\n"
    },
        "SkPixmap_const_SkImageInfo_const_star": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"image alpha only = %s\\n\", image->isAlphaOnly() ? \"true\" : \"false\");\n    SkPMColor pmColors = 0;\n    sk_sp<SkImage> copy = SkImage::MakeRasterCopy({SkImageInfo::MakeA8(1, 1),\n                                                  (uint8_t*)&pmColors,\n                                                  1});\n    SkDebugf(\"copy alpha only = %s\\n\", copy->isAlphaOnly() ? \"true\" : \"false\");\n}",
    "hash": "9a00774be57d7308313b3a9073e6e696",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::SkPixmap(const SkImageInfo& info, const void* addr, size_t rowBytes)",
        "stdout": "image alpha only = false\\ncopy alpha only = true\\n"
    },
        "SkPixmap_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkPixmap pixmap;\n    for (int i = 0; i < 2; ++i) {\n       SkDebugf(\"width: %2d  height: %2d\", pixmap.width(), pixmap.height());\n       SkDebugf(\"  color: k%s_SkColorType\", colors[pixmap.colorType()]);\n       SkDebugf(\"  alpha: k%s_SkAlphaType\\n\", alphas[pixmap.alphaType()]);\n       pixmap.reset(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType),\n                    nullptr, 0);\n    }\n}\n",
    "hash": "9547e74a9d37553a667b913ffd1312dd",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::SkPixmap()",
        "stdout": "width:  0  height:  0  color: kUnknown_SkColorType  alpha: kUnknown_SkAlphaType\\nwidth: 25  height: 35  color: kRGBA_8888_SkColorType  alpha: kOpaque_SkAlphaType\\n"
    },
        "SkPixmap_getColor": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    std::vector<SkPMColor> storage;\n    storage.resize(w * h);\n    SkDebugf(\"Premultiplied:\\n\");\n    for (int y = 0; y < h; ++y) {\n        SkDebugf(\"(0, %d) \", y);\n        for (int x = 0; x < w; ++x) {\n            int a = 0xFF * (x + y) / (w - 1 + h - 1);\n            storage[x + y * w] = SkPackARGB32(a, a * x / (w - 1), a * y / (h - 1), a);\n            SkDebugf(\"0x%08x%c\", storage[x + y * w], x == w - 1 ? '\\n' : ' ');\n        }\n    }\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), &storage.front(), w * 4);\n    SkDebugf(\"Unpremultiplied:\\n\");\n    for (int y = 0; y < h; ++y) {\n        SkDebugf(\"(0, %d) \", y);\n        for (int x = 0; x < w; ++x) {\n            SkDebugf(\"0x%08x%c\", pixmap.getColor(x, y), x == w - 1 ? '\\n' : ' ');\n        }\n    }\n}",
    "hash": "94ad244056dc80ecd87daae004266334",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::getColor",
        "stdout": "Premultiplied:\\n(0, 0) 0x00000000 0x2a0e002a 0x55380055 0x7f7f007f\\n(0, 1) 0x2a000e2a 0x551c1c55 0x7f542a7f 0xaaaa38aa\\n(0, 2) 0x55003855 0x7f2a547f 0xaa7171aa 0xd4d48dd4\\n(0, 3) 0x7f007f7f 0xaa38aaaa 0xd48dd4d4 0xffffffff\\nUnpremultiplied:\\n(0, 0) 0x00000000 0x2a5500ff 0x55a800ff 0x7fff00ff\\n(0, 1) 0x2a0055ff 0x555454ff 0x7fa954ff 0xaaff54ff\\n(0, 2) 0x5500a8ff 0x7f54a9ff 0xaaaaaaff 0xd4ffaaff\\n(0, 3) 0x7f00ffff 0xaa54ffff 0xd4aaffff 0xffffffff\\n"
    },
        "SkPixmap_height": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);\n    SkDebugf(\"pixmap height: %d  info height: %d\\n\", pixmap.height(), pixmap.info().height());\n}",
    "hash": "4a996d32122f469d51ddd0186efb48cc",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::height()",
        "stdout": "pixmap height: 32  info height: 32\\n"
    },
        "SkPixmap_info": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    pixels.resize(image->height() * image->width() * 4);\n    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,\n            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n    image->readPixels(pixmap, 0, 0);\n    SkPixmap inset;\n    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {\n        const SkImageInfo& info = inset.info();\n        const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n        const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\",\n                \"RGB_888x\", \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n        SkDebugf(\"width: %d height: %d color: %s alpha: %s\\n\", info.width(), info.height(),\n                 colors[info.colorType()], alphas[info.alphaType()]);\n    }\n}",
    "hash": "6e0f558bf7fabc655041116288559134",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::info()",
        "stdout": "width: 384 height: 384 color: BGRA_8888 alpha: Opaque\\n"
    },
        "SkPixmap_isOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<uint32_t> pixels;\n    const int height = 2;\n    const int width = 2;\n    pixels.resize(height * width * 4);\n    SkPixmap pixmap(SkImageInfo::Make(width, height, kN32_SkColorType,\n            kPremul_SkAlphaType), (const void*) &pixels.front(), width * 4);\n    for (int index = 0; index < 2; ++index) {\n        pixmap.erase(0x00000000);\n        SkDebugf(\"isOpaque: %s\\n\", pixmap.isOpaque() ? \"true\" : \"false\");\n        pixmap.erase(0xFFFFFFFF);\n        SkDebugf(\"isOpaque: %s\\n\", pixmap.isOpaque() ? \"true\" : \"false\");\n        pixmap.reset(pixmap.info().makeAlphaType(kOpaque_SkAlphaType),\n                     (const void*) &pixels.front(), width * 4);\n    }\n}",
    "hash": "efd083f121e888a523455ea8a49e50d1",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::isOpaque",
        "stdout": "isOpaque: false\\nisOpaque: false\\nisOpaque: true\\nisOpaque: true\\n"
    },
        "SkPixmap_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphas[] = {\"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\"};\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkPixmap pixmap(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType),\n                    nullptr, 0);\n    for (int i = 0; i < 2; ++i) {\n       SkDebugf(\"width: %2d  height: %2d\", pixmap.width(), pixmap.height());\n       SkDebugf(\"  color: k%s_SkColorType\", colors[pixmap.colorType()]);\n       SkDebugf(\"  alpha: k%s_SkAlphaType\\n\", alphas[pixmap.alphaType()]);\n       pixmap.reset();\n    }\n}\n",
    "hash": "d9eb583c39f4f0baea79896b89245c98",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::reset()",
        "stdout": "width: 25  height: 35  color: kRGBA_8888_SkColorType  alpha: kOpaque_SkAlphaType\\nwidth:  0  height:  0  color: kUnknown_SkColorType  alpha: kUnknown_SkAlphaType\\n"
    },
        "SkPixmap_reset_3": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 2;\n    const int height = 2;\n    uint8_t bytes[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n    SkMask mask;\n    mask.fFormat = SkMask::kA8_Format;\n    mask.fBounds = {0, 0, width, height};\n    mask.fImage = bytes;\n    mask.fRowBytes = (width + 7) >> 3;\n    SkPixmap pixmap;\n    bool success = pixmap.reset(mask);\n    SkDebugf(\"success: %s width: %d height: %d\\n\", success ? \"true \" : \"false\",\n                pixmap.width(), pixmap.height()); \n    mask.fFormat = SkMask::kBW_Format;\n    success = pixmap.reset(mask);\n    SkDebugf(\"success: %s width: %d height: %d\\n\", success ? \"true \" : \"false\",\n                pixmap.width(), pixmap.height());\n}",
    "hash": "379761a97bd7a116638a34eb3e80bf0d",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::reset_3",
        "stdout": "success: true  width: 2 height: 2\\nsuccess: false width: 0 height: 0\\n"
    },
        "SkPixmap_rowBytes": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap badPixmap = {SkImageInfo::MakeA8(4, 4), nullptr, 2};\n    SkPixmap okPixmap = {SkImageInfo::MakeA8(4, 4), nullptr, 8};\n    for (auto& pixmap : { badPixmap, okPixmap } ) {\n        SkDebugf(\"rowBytes: %d minRowBytes: %d\\n\", pixmap.rowBytes(), \n           pixmap.info().minRowBytes());\n    }\n}",
    "hash": "da5e1f7f49891d3805a5a6103a000eff",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::rowBytes",
        "stdout": "rowBytes: 2 minRowBytes: 4\\nrowBytes: 8 minRowBytes: 4\\n"
    },
        "SkPixmap_rowBytesAsPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    for (int rowBytes : { 4, 5, 6, 7, 8} ) {\n        SkPixmap pixmap(SkImageInfo::MakeN32(1, 1, kPremul_SkAlphaType), nullptr, rowBytes);\n        SkDebugf(\"rowBytes: %d rowBytesAsPixels: %d\\n\", rowBytes, pixmap.rowBytesAsPixels());\n    }\n}",
    "hash": "6231bb212d0c231b5bc44eac626fbcb5",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::rowBytesAsPixels",
        "stdout": "rowBytes: 4 rowBytesAsPixels: 1\\nrowBytes: 5 rowBytesAsPixels: 1\\nrowBytes: 6 rowBytesAsPixels: 1\\nrowBytes: 7 rowBytesAsPixels: 1\\nrowBytes: 8 rowBytesAsPixels: 2\\n"
    },
        "SkPixmap_setColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap;\n    sk_sp<SkColorSpace> colorSpace1 = SkColorSpace::MakeRGB(SkColorSpace::kLinear_RenderTargetGamma,\n                                                            SkColorSpace::kRec2020_Gamut);\n    SkDebugf(\"is %sunique\\n\", colorSpace1->unique() ? \"\" : \"not \"); \n    pixmap.setColorSpace(colorSpace1);\n    SkDebugf(\"is %sunique\\n\", colorSpace1->unique() ? \"\" : \"not \");   \n}\n",
    "hash": "bc42aea1e30b7234544bc25b4fc09dd0",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::setColorSpace",
        "stdout": "is unique\\nis not unique\\n"
    },
        "SkPixmap_shiftPerPixel": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* colors[] = {\"Unknown\", \"Alpha_8\", \"RGB_565\", \"ARGB_4444\", \"RGBA_8888\", \"RGB_888x\",\n                            \"BGRA_8888\", \"RGBA_1010102\", \"RGB_101010x\", \"Gray_8\", \"RGBA_F16\"};\n    SkImageInfo info = SkImageInfo::MakeA8(1, 1);\n    for (SkColorType colorType : { kUnknown_SkColorType,   kAlpha_8_SkColorType,\n                                   kRGB_565_SkColorType,   kARGB_4444_SkColorType, \n                                   kRGBA_8888_SkColorType, kBGRA_8888_SkColorType,\n                                   kGray_8_SkColorType,    kRGBA_F16_SkColorType } ) {\n        SkPixmap pixmap(info.makeColorType(colorType), nullptr, 4);\n        SkDebugf(\"color: k\" \"%s\" \"_SkColorType\" \"%*s\" \"bytesPerPixel: %d shiftPerPixel: %d\\n\",\n                colors[colorType], 10 - strlen(colors[colorType]), \" \",\n                pixmap.info().bytesPerPixel(), pixmap.shiftPerPixel());\n    }\n}",
    "hash": "2e778ffd6edea51af4b07f5d322ceb6a",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::shiftPerPixel",
        "stdout": "color: kUnknown_SkColorType   bytesPerPixel: 0 shiftPerPixel: 0\\ncolor: kAlpha_8_SkColorType   bytesPerPixel: 1 shiftPerPixel: 0\\ncolor: kRGB_565_SkColorType   bytesPerPixel: 2 shiftPerPixel: 1\\ncolor: kARGB_4444_SkColorType bytesPerPixel: 2 shiftPerPixel: 1\\ncolor: kRGBA_8888_SkColorType bytesPerPixel: 4 shiftPerPixel: 2\\ncolor: kBGRA_8888_SkColorType bytesPerPixel: 4 shiftPerPixel: 2\\ncolor: kGray_8_SkColorType    bytesPerPixel: 1 shiftPerPixel: 0\\ncolor: kRGBA_F16_SkColorType  bytesPerPixel: 8 shiftPerPixel: 3\\n"
    },
        "SkPixmap_width": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeA8(16, 32);\n    SkPixmap pixmap(info, nullptr, 64);\n    SkDebugf(\"pixmap width: %d  info width: %d\\n\", pixmap.width(), info.width());\n}",
    "hash": "f68617b7153a20b2ed3d7f9ed5c6e5e4",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::width()",
        "stdout": "pixmap width: 16  info width: 16\\n"
    },
        "SkPixmap_writable_addr": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    SkPMColor storage[w * h * 4];\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), storage, w * 4);\n    SkDebugf(\"pixmap.writable_addr() %c= (void *)storage\\n\",\n              pixmap.writable_addr()  == (void *)storage ? '=' : '!');\n    pixmap.erase(0x00000000);\n    *(SkPMColor*)pixmap.writable_addr() = 0xFFFFFFFF;\n    SkDebugf(\"pixmap.getColor(0, 1) %c= 0x00000000\\n\",\n              pixmap.getColor(0, 1)  == 0x00000000 ? '=' : '!');\n    SkDebugf(\"pixmap.getColor(0, 0) %c= 0xFFFFFFFF\\n\",\n              pixmap.getColor(0, 0)  == 0xFFFFFFFF ? '=' : '!');\n}",
    "hash": "74ef460f89ed5904334d0f8883e781c4",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr",
        "stdout": "pixmap.writable_addr() == (void *)storage\\npixmap.getColor(0, 1) == 0x00000000\\npixmap.getColor(0, 0) == 0xFFFFFFFF\\n"
    },
        "SkPixmap_writable_addr_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int w = 4;\n    const int h = 4;\n    SkPMColor storage[w * h * 4];\n    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), storage, w * 4);\n    SkDebugf(\"pixmap.writable_addr() %c= (void *)storage\\n\",\n              pixmap.writable_addr()  == (void *)storage ? '=' : '!');\n    pixmap.erase(0x00000000);\n    *(SkPMColor*)pixmap.writable_addr(1, 2) = 0xFFFFFFFF;\n    SkDebugf(\"pixmap.getColor(0, 0) %c= 0x00000000\\n\",\n              pixmap.getColor(0, 0)  == 0x00000000 ? '=' : '!');\n    SkDebugf(\"pixmap.getColor(1, 2) %c= 0xFFFFFFFF\\n\",\n              pixmap.getColor(1, 2)  == 0xFFFFFFFF ? '=' : '!');\n}",
    "hash": "559eaca89c765bc8466ea1ba3331d4db",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr_2",
        "stdout": "pixmap.writable_addr() == (void *)storage\\npixmap.getColor(0, 0) == 0x00000000\\npixmap.getColor(1, 2) == 0xFFFFFFFF\\n"
    },
        "SkPoint_Make": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt1 = {45, 66};\n    SkPoint pt2 = SkPoint::Make(45, 66);\n    SkVector v1 = {45, 66};\n    SkVector v2 = SkPoint::Make(45, 66);\n    SkDebugf(\"all %s\" \"equal\\n\", pt1 == pt2 && pt2 == v1 && v1 == v2 ? \"\" : \"not \");\n}",
    "hash": "d266e70977847001f7c42f8a2513bee7",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Make",
        "stdout": "all equal\\n"
    },
        "SkPoint_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0, -0.f}, {-1, -2}, {SK_ScalarInfinity, 1}, {SK_ScalarNaN, -1} };\n    for (const SkPoint& pt : test) {\n        SkDebugf(\"pt: %g, %g  %c= pt\\n\", pt.fX, pt.fY, pt == pt ? '=' : '!');\n    }\n}",
    "hash": "741f793334a48a35dadf4310d7ea52cb",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator==(const SkPoint& a, const SkPoint& b)",
        "stdout": "pt: 0, -0  == pt\\npt: -1, -2  == pt\\npt: inf, 1  == pt\\npt: nan, -1  != pt\\n"
    },
        "SkPoint_equals": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0, -0.f}, {-1, -2}, {SK_ScalarInfinity, 1}, {SK_ScalarNaN, -1} };\n    for (const SkPoint& pt : test) {\n        SkDebugf(\"pt: %g, %g  %c= pt\\n\", pt.fX, pt.fY, pt.equals(pt.fX, pt.fY) ? '=' : '!');\n    }\n}",
    "hash": "4cecb878c8b66beffda051f26c00f817",
    "file": "SkPoint_Reference",
    "name": "SkPoint::equals()",
        "stdout": "pt: 0, -0  == pt\\npt: -1, -2  == pt\\npt: inf, 1  == pt\\npt: nan, -1  != pt\\n"
    },
        "SkPoint_isFinite": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0, -0.f}, {-1, -2}, {SK_ScalarInfinity, 1}, {SK_ScalarNaN, -1} };\n    for (const SkPoint& pt : test) {\n        SkDebugf(\"pt: %g, %g  finite: %s\\n\", pt.fX, pt.fY, pt.isFinite() ? \"true\" : \"false\");\n    }\n}",
    "hash": "937cc166cc0e220f33fb82501141d0b3",
    "file": "SkPoint_Reference",
    "name": "SkPoint::isFinite",
        "stdout": "pt: 0, -0  finite: true\\npt: -1, -2  finite: true\\npt: inf, 1  finite: false\\npt: nan, -1  finite: false\\n"
    },
        "SkPoint_isZero": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt = { 0.f, -0.f};\n    SkDebugf(\"pt.fX=%c%g pt.fY=%c%g\\n\", std::signbit(pt.fX) ? '-' : '+', fabsf(pt.fX),\n                                        std::signbit(pt.fY) ? '-' : '+', fabsf(pt.fY));\n    SkDebugf(\"pt.isZero() == %s\\n\", pt.isZero() ? \"true\" : \"false\");\n}",
    "hash": "81b9665110b88ef6bcbc20464aed7da1",
    "file": "SkPoint_Reference",
    "name": "SkPoint::isZero",
        "stdout": "pt.fX=+0 pt.fY=-0\\npt.isZero() == true\\n"
    },
        "SkPoint_iset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt1, pt2 = { SK_MinS16, SK_MaxS16 };\n    pt1.iset(SK_MinS16, SK_MaxS16);\n    SkDebugf(\"pt1 %c= pt2\\n\", pt1 == pt2 ? '=' : '!');\n}",
    "hash": "0d9e8ed734981b5b113f22c7bfde5357",
    "file": "SkPoint_Reference",
    "name": "SkPoint::iset()",
        "stdout": "pt1 == pt2\\n"
    },
        "SkPoint_iset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIPoint iPt = { SK_MinS32, SK_MaxS32 };\n    SkPoint fPt;\n    fPt.iset(iPt);\n    SkDebugf(\"iPt: %d, %d\\n\", iPt.fX, iPt.fY);\n    SkDebugf(\"fPt: %g, %g\\n\", fPt.fX, fPt.fY);\n}",
    "hash": "12b7164a769e232bb772f19c59600ee7",
    "file": "SkPoint_Reference",
    "name": "SkPoint::iset_2",
        "stdout": "iPt: -2147483647, 2147483647\\nfPt: -2.14748e+09, 2.14748e+09\\n"
    },
        "SkPoint_minus_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0.f, -0.f}, {-1, -2},\n                       { SK_ScalarInfinity, SK_ScalarNegativeInfinity },\n                       { SK_ScalarNaN, -SK_ScalarNaN } };\n    for (const SkPoint& pt : test) {\n        SkPoint negPt = -pt;\n        SkDebugf(\"pt: %g, %g  negate: %g, %g\\n\", pt.fX, pt.fY, negPt.fX, negPt.fY);\n    }\n}",
    "hash": "9baf247cfcd8272c0ddf6ce93f676b37",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator-()_const",
        "stdout": "pt: 0, -0  negate: -0, 0\\npt: -1, -2  negate: 1, 2\\npt: inf, -inf  negate: -inf, inf\\npt: nan, -nan  negate: -nan, nan\\n"
    },
        "SkPoint_negate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0.f, -0.f}, {-1, -2},\n                       { SK_ScalarInfinity, SK_ScalarNegativeInfinity },\n                       { SK_ScalarNaN, -SK_ScalarNaN } };\n    for (const SkPoint& pt : test) {\n        SkPoint negPt = pt;\n        negPt.negate();\n        SkDebugf(\"pt: %g, %g  negate: %g, %g\\n\", pt.fX, pt.fY, negPt.fX, negPt.fY);\n    }\n}",
    "hash": "312c0c8065ab5d0adfda80cccf2d11e6",
    "file": "SkPoint_Reference",
    "name": "SkPoint::negate()",
        "stdout": "pt: 0, -0  negate: -0, 0\\npt: -1, -2  negate: 1, 2\\npt: inf, -inf  negate: -inf, inf\\npt: nan, -nan  negate: -nan, nan\\n"
    },
        "SkPoint_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0, -0.f}, {-1, -2}, {SK_ScalarInfinity, 1}, {SK_ScalarNaN, -1} };\n    for (const SkPoint& pt : test) {\n        SkDebugf(\"pt: %g, %g  %c= pt\\n\", pt.fX, pt.fY, pt != pt ? '!' : '=');\n    }\n}",
    "hash": "8fe8572685eaa617f25a5a6767a874dc",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator!=(const SkPoint& a, const SkPoint& b)",
        "stdout": "pt: 0, -0  == pt\\npt: -1, -2  == pt\\npt: inf, 1  == pt\\npt: nan, -1  != pt\\n"
    },
        "SkPoint_set": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt1, pt2 = { SK_ScalarPI, SK_ScalarSqrt2 };\n    pt1.set(SK_ScalarPI, SK_ScalarSqrt2);\n    SkDebugf(\"pt1 %c= pt2\\n\", pt1 == pt2 ? '=' : '!');\n}",
    "hash": "d08d1e7dafcad4342d1619fdbb2f5781",
    "file": "SkPoint_Reference",
    "name": "SkPoint::set()",
        "stdout": "pt1 == pt2\\n"
    },
        "SkPoint_setAbs": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint test[] = { {0.f, -0.f}, {-1, -2},\n                       { SK_ScalarInfinity, SK_ScalarNegativeInfinity },\n                       { SK_ScalarNaN, -SK_ScalarNaN } };\n    for (const SkPoint& pt : test) {\n        SkPoint absPt;\n        absPt.setAbs(pt);\n        SkDebugf(\"pt: %g, %g  abs: %g, %g\\n\", pt.fX, pt.fY, absPt.fX, absPt.fY);\n    }\n}",
    "hash": "7f70860e820b67a347cff03c00488426",
    "file": "SkPoint_Reference",
    "name": "SkPoint::setAbs",
        "stdout": "pt: 0, -0  abs: 0, 0\\npt: -1, -2  abs: 1, 2\\npt: inf, -inf  abs: inf, inf\\npt: nan, -nan  abs: nan, nan\\n"
    },
        "SkPoint_x": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt1 = {45, 66};\n    SkDebugf(\"pt1.fX %c= pt1.x()\\n\", pt1.fX == pt1.x() ? '=' : '!');\n}",
    "hash": "9f3fe446b800ae1d940785d438634941",
    "file": "SkPoint_Reference",
    "name": "SkPoint::x()",
        "stdout": "pt1.fX == pt1.x()\\n"
    },
        "SkPoint_y": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pt1 = {45, 66};\n    SkDebugf(\"pt1.fY %c= pt1.y()\\n\", pt1.fY == pt1.y() ? '=' : '!');\n}",
    "hash": "4c962850c2dbea4d2325df469400680e",
    "file": "SkPoint_Reference",
    "name": "SkPoint::y()",
        "stdout": "pt1.fY == pt1.y()\\n"
    },
        "SkRect_Intersects": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"%s intersection\", SkRect::Intersects({10, 40, 50, 80}, {30, 60, 70, 90}) ? \"\" : \"no \");\n}",
    "hash": "795061764b10c9e05efb466c9cb60644",
    "file": "SkRect_Reference",
    "name": "SkRect::Intersects",
        "stdout": "intersection"
    },
        "SkRect_Make": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = SkRect::MakeSize({2, 35});\n    SkRect rect2 = SkRect::MakeIWH(2, 35);\n    SkDebugf(\"rect1 %c= rect2\\n\", rect1 == rect2 ? '=' : '!');\n}",
    "hash": "e866f5e4f6ac52e89acadf48e54ac8e0",
    "file": "SkRect_Reference",
    "name": "SkRect::Make",
        "stdout": "rect1 == rect2\\n"
    },
        "SkRect_MakeEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = SkRect::MakeEmpty();\n    SkDebugf(\"MakeEmpty isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.offset(10, 10);\n    SkDebugf(\"offset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.inset(10, 10);\n    SkDebugf(\"inset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n    rect.outset(20, 20);\n    SkDebugf(\"outset rect isEmpty: %s\\n\", rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "2e262d0ac4b8ef51695e0525fc3ecdf6",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeEmpty",
        "stdout": "MakeEmpty isEmpty: true\\noffset rect isEmpty: true\\ninset rect isEmpty: true\\noutset rect isEmpty: false\\n"
    },
        "SkRect_MakeIWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect i_rect = SkIRect::MakeWH(25, 35);\n    SkRect  f_rect = SkRect::MakeIWH(25, 35);\n    SkDebugf(\"i_rect width: %d f_rect width:%g\\n\", i_rect.width(), f_rect.width());\n    i_rect = SkIRect::MakeWH(125000111, 0);\n    f_rect = SkRect::MakeIWH(125000111, 0);\n    SkDebugf(\"i_rect width: %d f_rect width:%.0f\\n\", i_rect.width(), f_rect.width());\n}",
    "hash": "faa660ac19eaddc3f3eab57a0bddfdcb",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeIWH",
        "stdout": "i_rect width: 25 f_rect width:25\\ni_rect width: 125000111 f_rect width:125000112\\n"
    },
        "SkRect_MakeLTRB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = SkRect::MakeLTRB(5, 35, 15, 25);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "158b8dd9d02d65a5ae5ab7d1595a5b4c",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeLTRB",
        "stdout": "rect: 5, 35, 15, 25  isEmpty: true\\nrect: 5, 25, 15, 35  isEmpty: false\\n"
    },
        "SkRect_MakeSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkSize size = {25.5f, 35.5f};\n    SkRect rect = SkRect::MakeSize(size);\n    SkDebugf(\"rect width: %g  height: %g\\n\", rect.width(), rect.height());\n    SkISize floor = size.toFloor();\n    rect = SkRect::MakeSize(SkSize::Make(floor));\n    SkDebugf(\"floor width: %g  height: %g\\n\", rect.width(), rect.height());\n}",
    "hash": "ab2c1a55016c8de9172b77fdf69e00a2",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeSize",
        "stdout": "rect width: 25.5  height: 35.5\\nfloor width: 25  height: 35\\n"
    },
        "SkRect_MakeWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = SkRect::MakeWH(25, 35);\n    SkRect rect2 = SkRect::MakeIWH(25, 35);\n    SkRect rect3 = SkRect::MakeXYWH(0, 0, 25, 35);\n    SkRect rect4 = SkRect::MakeLTRB(0, 0, 25, 35);\n    SkDebugf(\"all %s\" \"equal\\n\", rect1 == rect2 && rect2 == rect3 && rect3 == rect4 ?\n             \"\" : \"not \");\n}",
    "hash": "8009d30f431e01f8aea4808e9017d9bf",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeWH",
        "stdout": "all equal\\n"
    },
        "SkRect_MakeXYWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = SkRect::MakeXYWH(5, 35, -15, 25);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "38e464dba13be11ac21e210fbf3b5afc",
    "file": "SkRect_Reference",
    "name": "SkRect::MakeXYWH",
        "stdout": "rect: 5, 35, -10, 60  isEmpty: true\\nrect: -10, 35, 5, 60  isEmpty: false\\n"
    },
        "SkRect_Make_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect i_rect1 = {2, 35, 22, 53};\n    SkRect f_rect = SkRect::Make(i_rect1);\n    f_rect.offset(0.49f, 0.49f);\n    SkIRect i_rect2;\n    f_rect.round(&i_rect2);\n    SkDebugf(\"i_rect1 %c= i_rect2\\n\", i_rect1 == i_rect2? '=' : '!');\n}",
    "hash": "dd801faa1e60a0fe9e0657674461e063",
    "file": "SkRect_Reference",
    "name": "SkRect::Make_2",
        "stdout": "i_rect1 == i_rect2\\n"
    },
        "SkRect_asScalars": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {7, 11, 13, 17};\n SkDebugf(\"rect.asScalars() %c= &rect.fLeft\\n\", rect.asScalars() == &rect.fLeft? '=' : '!');\n}",
    "hash": "e1ea5f949d80276f3637931eae93a07c",
    "file": "SkRect_Reference",
    "name": "SkRect::asScalars",
        "stdout": "rect.asScalars() == \\u0026rect.fLeft\\n"
    },
        "SkRect_bottom": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fBottom: %g unsorted.bottom(): %g\\n\", unsorted.fBottom, unsorted.bottom());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fBottom: %g sorted.bottom(): %g\\n\", sorted.fBottom, sorted.bottom());\n}",
    "hash": "a98993a66616ae406d8bdc54adfb1411",
    "file": "SkRect_Reference",
    "name": "SkRect::bottom()",
        "stdout": "unsorted.fBottom: 5 unsorted.bottom(): 5\\nsorted.fBottom: 25 sorted.bottom(): 25\\n"
    },
        "SkRect_centerX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect tests[] = {{20, 30, 41, 51}, {-20, -30, -41, -51}};\n    for (auto rect : tests) {\n        SkDebugf(\"left: %3g right: %3g centerX: %3g\\n\", rect.left(), rect.right(), rect.centerX());\n        rect.sort();\n        SkDebugf(\"left: %3g right: %3g centerX: %3g\\n\", rect.left(), rect.right(), rect.centerX());\n    }\n}",
    "hash": "d8439ba8d23a424fa032fb97147fd2d2",
    "file": "SkRect_Reference",
    "name": "SkRect::centerX",
        "stdout": "left:  20 right:  41 centerX: 30.5\\nleft:  20 right:  41 centerX: 30.5\\nleft: -20 right: -41 centerX: -30.5\\nleft: -41 right: -20 centerX: -30.5\\n"
    },
        "SkRect_centerY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 2e+38, 2e+38, 3e+38, 3e+38 };\n    SkDebugf(\"left: %g right: %g centerX: %g \", rect.left(), rect.right(), rect.centerX());\n    SkDebugf(\"safe mid x: %g\\n\", rect.left() / 2 + rect.right() / 2);\n}",
    "hash": "ebeeafafeb8fe39d5ffc9115b02c2340",
    "file": "SkRect_Reference",
    "name": "SkRect::centerY",
        "stdout": "left: 2e+38 right: 3e+38 centerX: inf safe mid x: 2.5e+38\\n"
    },
        "SkRect_contains": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30, 50, 40, 60 };\n    SkRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        SkDebugf(\"rect: (%g, %g, %g, %g) %s (%g, %g, %g, %g)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.contains(contained) ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "92f9e6aa5bb76791139a24cf7d8df99e",
    "file": "SkRect_Reference",
    "name": "SkRect::contains()",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkRect_contains_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30, 50, 40, 60 };\n    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };\n    for (auto contained : tests) {\n        SkDebugf(\"rect: (%g, %g, %g, %g) %s (%d, %d, %d, %d)\\n\",\n                 rect.left(), rect.top(), rect.right(), rect.bottom(),\n                 rect.contains(contained) ? \"contains\" : \"does not contain\",\n                 contained.left(), contained.top(), contained.right(), contained.bottom());\n    }\n}",
    "hash": "dd58b699551dd44026a2c6386be27d88",
    "file": "SkRect_Reference",
    "name": "SkRect::contains_2",
        "stdout": "rect: (30, 50, 40, 60) contains (30, 50, 31, 51)\\nrect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)\\nrect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)\\n"
    },
        "SkRect_dump": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {20, 30, 40, 50};\n     for (bool dumpAsHex : { false, true } ) {\n         rect.dump(dumpAsHex);\n         SkDebugf(\"\\n\");\n     }\n}",
    "hash": "cea049ffff702a5923da41fe0ae0763b",
    "file": "SkRect_Reference",
    "name": "SkRect::dump()",
        "stdout": "SkRect::MakeLTRB(20, 30, 40, 50);\\n\\nSkRect::MakeLTRB(SkBits2Float(0x41a00000), /* 20.000000 */\\n                 SkBits2Float(0x41f00000), /* 30.000000 */\\n                 SkBits2Float(0x42200000), /* 40.000000 */\\n                 SkBits2Float(0x42480000)  /* 50.000000 */);\\n\\n"
    },
        "SkRect_dumpHex": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {6.f / 7, 2.f / 3, 26.f / 10, 42.f / 6};\n rect.dumpHex();\n SkRect copy = SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */\n                  SkBits2Float(0x3f2aaaab), /* 0.666667 */\n                  SkBits2Float(0x40266666), /* 2.600000 */\n                  SkBits2Float(0x40e00000)  /* 7.000000 */);\n SkDebugf(\"rect is \" \"%s\" \"equal to copy\\n\", rect == copy ? \"\" : \"not \");\n}",
    "hash": "824b5a3fcfd46a7e1c5f9e3c16e6bb39",
    "file": "SkRect_Reference",
    "name": "SkRect::dumpHex",
        "stdout": "SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */\\n                 SkBits2Float(0x3f2aaaab), /* 0.666667 */\\n                 SkBits2Float(0x40266666), /* 2.600000 */\\n                 SkBits2Float(0x40e00000)  /* 7.000000 */);\\nrect is equal to copy\\n"
    },
        "SkRect_dump_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {6.f / 7, 2.f / 3, 26.f / 10, 42.f / 6};\n    rect.dump();\n    SkRect copy = SkRect::MakeLTRB(0.857143f, 0.666667f, 2.6f, 7);\n    SkDebugf(\"rect is \" \"%s\" \"equal to copy\\n\", rect == copy ? \"\" : \"not \");\n}",
    "hash": "9fb76971b1a104a2a59816e0392267a7",
    "file": "SkRect_Reference",
    "name": "SkRect::dump_2",
        "stdout": "SkRect::MakeLTRB(0.857143f, 0.666667f, 2.6f, 7);\\nrect is not equal to copy\\n"
    },
        "SkRect_equal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto debugster = [](const SkRect& test) -> void {\n        SkRect negZero = {-0.0f, -0.0f, 2, 2};\n        SkDebugf(\"{%g, %g, %g, %g} %c= {%g, %g, %g, %g} %s numerically equal\\n\",\n                 test.fLeft, test.fTop, test.fRight, test.fBottom,\n                 negZero.fLeft, negZero.fTop, negZero.fRight, negZero.fBottom,\n                 test == negZero ? '=' : '!',\n                 test.fLeft == negZero.fLeft && test.fTop == negZero.fTop &&\n                 test.fRight == negZero.fRight && test.fBottom == negZero.fBottom ?\n                 \"and are\" : \"yet are not\");\n    };\n    SkRect tests[] = {{0, 0, 2, 2}, {-0, -0, 2, 2}, {0.0f, 0.0f, 2, 2}};\n    SkDebugf(\"tests are %s\" \"equal\\n\", tests[0] == tests[1] && tests[1] == tests[2] ? \"\" : \"not \");\n    for (auto rect : tests) {\n        debugster(rect);\n    }\n}",
    "hash": "c6c5b40cad7c3a839fdf576b380391a6",
    "file": "SkRect_Reference",
    "name": "SkRect::operator==(const SkRect& a, const SkRect& b)",
        "stdout": "tests are equal\\n{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal\\n{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal\\n{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal\\n"
    },
        "SkRect_height": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 20 };\n    SkDebugf(\"unsorted height: %g\\n\", unsorted.height());\n    SkRect large = { 1, -2147483647.f, 2, 2147483644.f };\n    SkDebugf(\"large height: %.0f\\n\", large.height());\n}",
    "hash": "39429e45f05240218ecd511443ab3e44",
    "file": "SkRect_Reference",
    "name": "SkRect::height()",
        "stdout": "unsorted height: -5\\nlarge height: 4294967296\\n"
    },
        "SkRect_inset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 14, 50, 73 };\n    rect.inset(5, 13);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "dae21340941dc6e4d048816dfd9f204c",
    "file": "SkRect_Reference",
    "name": "SkRect::inset()",
        "stdout": "rect: 15, 27, 45, 60\\n"
    },
        "SkRect_intersect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect leftRect =  { 10, 40, 50, 80 };\n    SkRect rightRect = { 30, 60, 70, 90 };\n    SkDebugf(\"%s intersection: \", leftRect.intersect(rightRect) ? \"\" : \"no \");\n    SkDebugf(\"%g, %g, %g, %g\\n\", leftRect.left(), leftRect.top(), \n                                 leftRect.right(), leftRect.bottom());\n}",
    "hash": "70e5b3979fc8a31eda070cfed91bc271",
    "file": "SkRect_Reference",
    "name": "SkRect::intersect()",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkRect_intersect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect leftRect =  { 10, 40, 50, 80 };\n    SkDebugf(\"%s intersection: \", leftRect.intersect(30, 60, 70, 90) ? \"\" : \"no \");\n    SkDebugf(\"%g, %g, %g, %g\\n\", leftRect.left(), leftRect.top(), \n                                 leftRect.right(), leftRect.bottom());\n}",
    "hash": "9f06dad5e6c712f7a2c149d075e816d2",
    "file": "SkRect_Reference",
    "name": "SkRect::intersect_2",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkRect_intersect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect result;\n    bool intersected = result.intersect({ 10, 40, 50, 80 }, { 30, 60, 70, 90 });\n    SkDebugf(\"%s intersection: %g, %g, %g, %g\\n\", intersected ? \"\" : \"no \",\n             result.left(), result.top(), result.right(), result.bottom());\n}",
    "hash": "d610437a65dd3e952719efe605cbd0c7",
    "file": "SkRect_Reference",
    "name": "SkRect::intersect_3",
        "stdout": "intersection: 30, 60, 50, 80\\n"
    },
        "SkRect_intersects": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 40, 50, 80 };\n    SkDebugf(\"%s intersection\", rect.intersects(30, 60, 70, 90) ? \"\" : \"no \");\n}",
    "hash": "7145dc17ebce4f54e892102f6c98e811",
    "file": "SkRect_Reference",
    "name": "SkRect::intersects()",
        "stdout": "intersection"
    },
        "SkRect_intersects_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 40, 50, 80 };\n    SkDebugf(\"%s intersection\", rect.intersects({30, 60, 70, 90}) ? \"\" : \"no \");\n}",
    "hash": "ca37b4231b21eb8296cb19ba9e0c781b",
    "file": "SkRect_Reference",
    "name": "SkRect::intersects_2",
        "stdout": "intersection"
    },
        "SkRect_isEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};\n    for (auto rect : tests) {\n        SkDebugf(\"rect: {%g, %g, %g, %g} is\" \"%s empty\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isEmpty() ? \"\" : \" not\");\n        rect.sort();\n        SkDebugf(\"sorted: {%g, %g, %g, %g} is\" \"%s empty\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isEmpty() ? \"\" : \" not\");\n    }\n}",
    "hash": "1d7b924d6ca2a6aef09684a8a632439c",
    "file": "SkRect_Reference",
    "name": "SkRect::isEmpty",
        "stdout": "rect: {20, 40, 10, 50} is empty\\nsorted: {10, 40, 20, 50} is not empty\\nrect: {20, 40, 20, 50} is empty\\nsorted: {20, 40, 20, 50} is empty\\n"
    },
        "SkRect_isFinite": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect largest = { SK_ScalarMin, SK_ScalarMin, SK_ScalarMax, SK_ScalarMax };\n        SkDebugf(\"largest is finite: %s\\n\", largest.isFinite() ? \"true\" : \"false\");\n        SkDebugf(\"large width %g\\n\", largest.width());\n        SkRect widest = SkRect::MakeWH(largest.width(), largest.height());\n        SkDebugf(\"widest is finite: %s\\n\", widest.isFinite() ? \"true\" : \"false\");\n}",
    "hash": "443fe5f8296d4cdb19cc9862a9cf77a4",
    "file": "SkRect_Reference",
    "name": "SkRect::isFinite",
        "stdout": "largest is finite: true\\nlarge width inf\\nwidest is finite: false\\n"
    },
        "SkRect_isSorted": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};\n    for (auto rect : tests) {\n        SkDebugf(\"rect: {%g, %g, %g, %g} is\" \"%s sorted\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isSorted() ? \"\" : \" not\");\n        rect.sort();\n        SkDebugf(\"sorted: {%g, %g, %g, %g} is\" \"%s sorted\\n\", rect.left(), rect.top(), rect.right(),\n                 rect.bottom(), rect.isSorted() ? \"\" : \" not\");\n    }\n}",
    "hash": "c7065a83b220a96f903dbbb65906fe7b",
    "file": "SkRect_Reference",
    "name": "SkRect::isSorted",
        "stdout": "rect: {20, 40, 10, 50} is not sorted\\nsorted: {10, 40, 20, 50} is sorted\\nrect: {20, 40, 20, 50} is sorted\\nsorted: {20, 40, 20, 50} is sorted\\n"
    },
        "SkRect_iset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = {3, 4, 1, 2};\n    SkDebugf(\"rect1: {%g, %g, %g, %g}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkRect rect2;\n    rect2.iset(3, 4, 1, 2);\n    SkDebugf(\"rect2: {%g, %g, %g, %g}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "18532f1aa90b76364fb8d7ea072f1892",
    "file": "SkRect_Reference",
    "name": "SkRect::iset()",
        "stdout": "rect1: {3, 4, 1, 2}\\nrect2: {3, 4, 1, 2}\\n"
    },
        "SkRect_isetWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = {0, 0, 1, 2};\n    SkDebugf(\"rect1: {%g, %g, %g, %g}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkRect rect2;\n    rect2.isetWH(1, 2);\n    SkDebugf(\"rect2: {%g, %g, %g, %g}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "ee6000080fc7123214ea404018cf9176",
    "file": "SkRect_Reference",
    "name": "SkRect::isetWH",
        "stdout": "rect1: {0, 0, 1, 2}\\nrect2: {0, 0, 1, 2}\\n"
    },
        "SkRect_join": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 20, 15, 25};\n    rect.join(50, 60, 55, 65);\n    SkDebugf(\"join: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "afa9c6b4d05bb669db07fe0b7b97e6aa",
    "file": "SkRect_Reference",
    "name": "SkRect::join()",
        "stdout": "join: 10, 20, 55, 65\\n"
    },
        "SkRect_joinNonEmptyArg": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 100, 15, 0};\n    SkRect sorted = rect.makeSorted();\n    SkRect toJoin = { 50, 60, 55, 65 };\n    rect.joinNonEmptyArg(toJoin);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    sorted.joinNonEmptyArg(toJoin);\n    SkDebugf(\"sorted: %g, %g, %g, %g\\n\", sorted.fLeft, sorted.fTop, sorted.fRight, sorted.fBottom);\n}",
    "hash": "88439de2aa0911262c60c0eb506396cb",
    "file": "SkRect_Reference",
    "name": "SkRect::joinNonEmptyArg",
        "stdout": "rect: 50, 60, 55, 65\\nsorted: 10, 0, 55, 100\\n"
    },
        "SkRect_joinPossiblyEmptyRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 100, 15, 0};\n    SkRect sorted = rect.makeSorted();\n    SkRect toJoin = { 50, 60, 55, 65 };\n    rect.joinPossiblyEmptyRect(toJoin);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    sorted.joinPossiblyEmptyRect(toJoin);\n    SkDebugf(\"sorted: %g, %g, %g, %g\\n\", sorted.fLeft, sorted.fTop, sorted.fRight, sorted.fBottom);\n}",
    "hash": "a476548d0001296afd8e58c1eba1b70b",
    "file": "SkRect_Reference",
    "name": "SkRect::joinPossiblyEmptyRect",
        "stdout": "rect: 10, 60, 55, 65\\nsorted: 10, 0, 55, 100\\n"
    },
        "SkRect_join_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 20, 15, 25};\n    rect.join({50, 60, 55, 65});\n    SkDebugf(\"join: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "26500032494cf93c5fa3423110fe82af",
    "file": "SkRect_Reference",
    "name": "SkRect::join_2",
        "stdout": "join: 10, 20, 55, 65\\n"
    },
        "SkRect_left": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 5, 10, 25 };\n    SkDebugf(\"unsorted.fLeft: %g unsorted.left(): %g\\n\", unsorted.fLeft, unsorted.left());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fLeft: %g sorted.left(): %g\\n\", sorted.fLeft, sorted.left());\n}",
    "hash": "900dc96c3549795a87036d6458c4fde6",
    "file": "SkRect_Reference",
    "name": "SkRect::left()",
        "stdout": "unsorted.fLeft: 15 unsorted.left(): 15\\nsorted.fLeft: 10 sorted.left(): 10\\n"
    },
        "SkRect_makeInset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeInset(15, 32);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "b8d32ab2f7ea3d4d5fb5a4ea2156f1c5",
    "file": "SkRect_Reference",
    "name": "SkRect::makeInset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: 25, 82, 5, 28  isEmpty: true\\n"
    },
        "SkRect_makeOffset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeOffset(15, 32);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "98841ab0a932f99cccd8e6a34d94ba05",
    "file": "SkRect_Reference",
    "name": "SkRect::makeOffset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: 25, 82, 35, 92  isEmpty: false\\n"
    },
        "SkRect_makeOutset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 50, 20, 60 };\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect = rect.makeOutset(15, 32);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "87176fc60914cbca9c6a20998a033c24",
    "file": "SkRect_Reference",
    "name": "SkRect::makeOutset",
        "stdout": "rect: 10, 50, 20, 60  isEmpty: false\\nrect: -5, 18, 35, 92  isEmpty: false\\n"
    },
        "SkRect_makeSorted": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 20.5f, 10.5f };\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    SkRect sort = rect.makeSorted();\n    SkDebugf(\"sorted: %g, %g, %g, %g\\n\", sort.fLeft, sort.fTop, sort.fRight, sort.fBottom);\n}",
    "hash": "f59567042b87f6b26f9bfeeb04468032",
    "file": "SkRect_Reference",
    "name": "SkRect::makeSorted",
        "stdout": "rect: 30.5, 50.5, 20.5, 10.5\\nsorted: 20.5, 10.5, 30.5, 50.5\\n"
    },
        "SkRect_notequal_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect test = {0, 0, 2, SK_ScalarNaN};\n    SkDebugf(\"test with NaN is %s\" \"equal to itself\\n\", test == test ? \"\" : \"not \");\n}",
    "hash": "286072f8c27ff15be9eb945fa38dc9f7",
    "file": "SkRect_Reference",
    "name": "SkRect::operator!=(const SkRect& a, const SkRect& b)",
        "stdout": "test with NaN is not equal to itself\\n"
    },
        "SkRect_offset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 14, 50, 73 };\n    rect.offset(5, 13);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "04eb33f0fd376f2942ca5f1c7f6cbcfc",
    "file": "SkRect_Reference",
    "name": "SkRect::offset()",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkRect_offsetTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 14, 50, 73 };\n    rect.offsetTo(15, 27);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "bedb04b7b3e1af3e8039f9cffe66989e",
    "file": "SkRect_Reference",
    "name": "SkRect::offsetTo",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkRect_offset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 14, 50, 73 };\n    rect.offset({5, 13});\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "b24cf65561c98c1858a06c39f10fb797",
    "file": "SkRect_Reference",
    "name": "SkRect::offset_2",
        "stdout": "rect: 15, 27, 55, 86\\n"
    },
        "SkRect_outset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 10, 14, 50, 73 };\n    rect.outset(5, 13);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "861f873ba660af8c8bf8b0b83d829cf4",
    "file": "SkRect_Reference",
    "name": "SkRect::outset()",
        "stdout": "rect: 5, 1, 55, 86\\n"
    },
        "SkRect_right": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fRight: %g unsorted.right(): %g\\n\", unsorted.fRight, unsorted.right());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fRight: %g sorted.right(): %g\\n\", sorted.fRight, sorted.right());\n}",
    "hash": "ca3de7e5e292b3ad3633b1c39a31d3ab",
    "file": "SkRect_Reference",
    "name": "SkRect::right()",
        "stdout": "unsorted.fRight: 10 unsorted.right(): 10\\nsorted.fRight: 15 sorted.right(): 15\\n"
    },
        "SkRect_round": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkIRect round;\n    rect.round(&round);\n    SkDebugf(\"round: %d, %d, %d, %d\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "8b9e5a9af0a9b878f76919534d88f41e",
    "file": "SkRect_Reference",
    "name": "SkRect::round()",
        "stdout": "round: 31, 51, 41, 61\\n"
    },
        "SkRect_roundIn": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkIRect round;\n    rect.roundIn(&round);\n    SkDebugf(\"round: %d, %d, %d, %d\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "abb337da8fc1891f016c61258681c64c",
    "file": "SkRect_Reference",
    "name": "SkRect::roundIn",
        "stdout": "round: 31, 51, 40, 60\\n"
    },
        "SkRect_roundOut": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkIRect round;\n    rect.roundOut(&round);\n    SkDebugf(\"round: %d, %d, %d, %d\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "0bd13d7e6426ae7a3befa2ab151ac5fc",
    "file": "SkRect_Reference",
    "name": "SkRect::roundOut",
        "stdout": "round: 30, 50, 41, 61\\n"
    },
        "SkRect_roundOut_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkRect round;\n    rect.roundOut(&round);\n    SkDebugf(\"round: %g, %g, %g, %g\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "e09a6a12869a8ac21e9c2af98a5bb686",
    "file": "SkRect_Reference",
    "name": "SkRect::roundOut_2",
        "stdout": "round: 30, 50, 41, 61\\n"
    },
        "SkRect_roundOut_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkIRect round = rect.roundOut();\n    SkDebugf(\"round: %d, %d, %d, %d\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "05f0f65ae148f192656cd87df90f1d57",
    "file": "SkRect_Reference",
    "name": "SkRect::roundOut_3",
        "stdout": "round: 30, 50, 41, 61\\n"
    },
        "SkRect_round_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };\n    SkIRect round = rect.round();\n    SkDebugf(\"round: %d, %d, %d, %d\\n\", round.fLeft, round.fTop, round.fRight, round.fBottom);\n}",
    "hash": "ef7ae1dd522c235b0afe41b55a624f46",
    "file": "SkRect_Reference",
    "name": "SkRect::round_2",
        "stdout": "round: 31, 51, 41, 61\\n"
    },
        "SkRect_set": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect i_rect = {3, 4, 1, 2};\n    SkDebugf(\"i_rect: {%d, %d, %d, %d}\\n\", i_rect.fLeft, i_rect.fTop, i_rect.fRight, i_rect.fBottom);\n    SkRect f_rect;\n    f_rect.set(i_rect);\n    SkDebugf(\"f_rect: {%g, %g, %g, %g}\\n\", f_rect.fLeft, f_rect.fTop, f_rect.fRight, f_rect.fBottom);\n}",
    "hash": "a10ad8d97062bc3f40942f47e5108917",
    "file": "SkRect_Reference",
    "name": "SkRect::set()",
        "stdout": "i_rect: {3, 4, 1, 2}\\nf_rect: {3, 4, 1, 2}\\n"
    },
        "SkRect_setBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};\n    for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {\n        SkRect rect;\n        rect.setBounds(points, count);\n        if (count > 0) {\n            SkDebugf(\"added: %3g, %g \", points[count - 1].fX,  points[count - 1].fY);\n        } else {\n            SkDebugf(\"%14s\", \" \");\n        }\n        SkDebugf(\"count: %d rect: %g, %g, %g, %g\\n\", count,\n                rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    }\n}",
    "hash": "cf0da15f48aa54fd1889e7f913601710",
    "file": "SkRect_Reference",
    "name": "SkRect::setBounds",
        "stdout": "count: 0 rect: 0, 0, 0, 0\\nadded:   3, 4 count: 1 rect: 3, 4, 3, 4\\nadded:   1, 2 count: 2 rect: 1, 2, 3, 4\\nadded:   5, 6 count: 3 rect: 1, 2, 5, 6\\nadded: nan, 8 count: 4 rect: 0, 0, 0, 0\\n"
    },
        "SkRect_setBoundsCheck": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};\n    for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {\n        SkRect rect;\n        bool success = rect.setBoundsCheck(points, count);\n        if (count > 0) {\n            SkDebugf(\"added: %3g, %g \", points[count - 1].fX,  points[count - 1].fY);\n        } else {\n            SkDebugf(\"%14s\", \" \");\n        }\n        SkDebugf(\"count: %d rect: %g, %g, %g, %g success: %s\\n\", count,\n                rect.fLeft, rect.fTop, rect.fRight, rect.fBottom, success ? \"true\" : \"false\");\n    }\n}",
    "hash": "83d879b92683b15f9daaf0c9e71c5b35",
    "file": "SkRect_Reference",
    "name": "SkRect::setBoundsCheck",
        "stdout": "count: 0 rect: 0, 0, 0, 0 success: true\\nadded:   3, 4 count: 1 rect: 3, 4, 3, 4 success: true\\nadded:   1, 2 count: 2 rect: 1, 2, 3, 4 success: true\\nadded:   5, 6 count: 3 rect: 1, 2, 5, 6 success: true\\nadded: nan, 8 count: 4 rect: 0, 0, 0, 0 success: false\\n"
    },
        "SkRect_setEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {3, 4, 1, 2};\n    for (int i = 0; i < 2; ++i) {\n    SkDebugf(\"rect: {%g, %g, %g, %g} is %s\" \"empty\\n\", rect.fLeft, rect.fTop,\n             rect.fRight, rect.fBottom, rect.isEmpty() ? \"\" : \"not \");\n    rect.setEmpty();\n    }\n}",
    "hash": "2cf67542d45ef5d7a7efb673b651ff54",
    "file": "SkRect_Reference",
    "name": "SkRect::setEmpty",
        "stdout": "rect: {3, 4, 1, 2} is empty\\nrect: {0, 0, 0, 0} is empty\\n"
    },
        "SkRect_setLTRB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = {3, 4, 1, 2};\n    SkDebugf(\"rect1: {%g, %g, %g, %g}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkRect rect2;\n    rect2.setLTRB(3, 4, 1, 2);\n    SkDebugf(\"rect2: {%g, %g, %g, %g}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "70692838793454c8e045d6eaf7edcbff",
    "file": "SkRect_Reference",
    "name": "SkRect::setLTRB",
        "stdout": "rect1: {3, 4, 1, 2}\\nrect2: {3, 4, 1, 2}\\n"
    },
        "SkRect_setWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect;\n    rect.setWH(-15, 25);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "9cb5fee17802fa49341f3707bdf5d235",
    "file": "SkRect_Reference",
    "name": "SkRect::setWH",
        "stdout": "rect: 0, 0, -15, 25  isEmpty: true\\nrect: -15, 0, 0, 25  isEmpty: false\\n"
    },
        "SkRect_setXYWH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect;\n    rect.setXYWH(5, 35, -15, 25);\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n    rect.sort();\n    SkDebugf(\"rect: %g, %g, %g, %g  isEmpty: %s\\n\", rect.left(), rect.top(), rect.right(),\n              rect.bottom(), rect.isEmpty() ? \"true\" : \"false\");\n}",
    "hash": "373cce4c61b9da0384b735b838765163",
    "file": "SkRect_Reference",
    "name": "SkRect::setXYWH",
        "stdout": "rect: 5, 35, -10, 60  isEmpty: true\\nrect: -10, 35, 5, 60  isEmpty: false\\n"
    },
        "SkRect_set_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect1 = {3, 4, 1, 2};\n    SkDebugf(\"rect1: {%g, %g, %g, %g}\\n\", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);\n    SkRect rect2;\n    rect2.set(3, 4, 1, 2);\n    SkDebugf(\"rect2: {%g, %g, %g, %g}\\n\", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);\n}",
    "hash": "9b29ea460d69b4d47323fd9e3e17721e",
    "file": "SkRect_Reference",
    "name": "SkRect::set_2",
        "stdout": "rect1: {3, 4, 1, 2}\\nrect2: {3, 4, 1, 2}\\n"
    },
        "SkRect_set_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};\n    for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {\n        SkRect rect;\n        rect.set(points, count);\n        if (count > 0) {\n            SkDebugf(\"added: %3g, %g \", points[count - 1].fX,  points[count - 1].fY);\n        } else {\n            SkDebugf(\"%14s\", \" \");\n        }\n        SkDebugf(\"count: %d rect: %g, %g, %g, %g\\n\", count,\n                rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    }\n}",
    "hash": "94295fa5197e21256171b99b4023dd48",
    "file": "SkRect_Reference",
    "name": "SkRect::set_3",
        "stdout": "count: 0 rect: 0, 0, 0, 0\\nadded:   3, 4 count: 1 rect: 3, 4, 3, 4\\nadded:   1, 2 count: 2 rect: 1, 2, 3, 4\\nadded:   5, 6 count: 3 rect: 1, 2, 5, 6\\nadded: nan, 8 count: 4 rect: 0, 0, 0, 0\\n"
    },
        "SkRect_set_4": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint point1 = {SK_ScalarNaN, 8};\n    SkPoint point2 = {3, 4};\n    SkRect rect;\n    rect.set(point1, point2);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    rect.set(point2, point1);\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "ee72450381f768f3869153cdbeccdc3e",
    "file": "SkRect_Reference",
    "name": "SkRect::set_4",
        "stdout": "rect: 3, 4, 3, 8\\nrect: nan, 4, nan, 8\\n"
    },
        "SkRect_sort": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 30.5f, 50.5f, 20.5f, 10.5f };\n    SkDebugf(\"rect: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    rect.sort();\n    SkDebugf(\"sorted: %g, %g, %g, %g\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n}",
    "hash": "e624fe398e3d770b573c09fc74c0c400",
    "file": "SkRect_Reference",
    "name": "SkRect::sort()",
        "stdout": "rect: 30.5, 50.5, 20.5, 10.5\\nsorted: 20.5, 10.5, 30.5, 50.5\\n"
    },
        "SkRect_toQuad": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = {1, 2, 3, 4};\n    SkPoint corners[4];\n    rect.toQuad(corners);\n    SkDebugf(\"rect: {%g, %g, %g, %g}\\n\", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);\n    SkDebugf(\"corners:\");\n    for (auto corner : corners) {\n        SkDebugf(\" {%g, %g}\", corner.fX, corner.fY);\n    }\n    SkDebugf(\"\\n\");\n}",
    "hash": "59a6e7d202ac17ab80ec21b233e51f59",
    "file": "SkRect_Reference",
    "name": "SkRect::toQuad",
        "stdout": "rect: {1, 2, 3, 4}\\ncorners: {1, 2} {3, 2} {3, 4} {1, 4}\\n"
    },
        "SkRect_top": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fTop: %g unsorted.top(): %g\\n\", unsorted.fTop, unsorted.top());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fTop: %g sorted.top(): %g\\n\", sorted.fTop, sorted.top());\n}",
    "hash": "3cfc24b011aef1ca8ccb57c05711620c",
    "file": "SkRect_Reference",
    "name": "SkRect::top()",
        "stdout": "unsorted.fTop: 25 unsorted.top(): 25\\nsorted.fTop: 5 sorted.top(): 5\\n"
    },
        "SkRect_width": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted width: %g\\n\", unsorted.width());\n    SkRect large = { -2147483647.f, 1, 2147483644.f, 2 };\n    SkDebugf(\"large width: %.0f\\n\", large.width());\n}",
    "hash": "11f8f0efe6291019fee0ac17844f6c1a",
    "file": "SkRect_Reference",
    "name": "SkRect::width()",
        "stdout": "unsorted width: -5\\nlarge width: 4294967296\\n"
    },
        "SkRect_x": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 5, 10, 25 };\n    SkDebugf(\"unsorted.fLeft: %g unsorted.x(): %g\\n\", unsorted.fLeft, unsorted.x());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fLeft: %g sorted.x(): %g\\n\", sorted.fLeft, sorted.x());\n}",
    "hash": "23c77a35ac54a439a2989f840aa5cb99",
    "file": "SkRect_Reference",
    "name": "SkRect::x()",
        "stdout": "unsorted.fLeft: 15 unsorted.x(): 15\\nsorted.fLeft: 10 sorted.x(): 10\\n"
    },
        "SkRect_y": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect unsorted = { 15, 25, 10, 5 };\n    SkDebugf(\"unsorted.fTop: %g unsorted.y(): %g\\n\", unsorted.fTop, unsorted.y());\n    SkRect sorted = unsorted.makeSorted();\n    SkDebugf(\"sorted.fTop: %g sorted.y(): %g\\n\", sorted.fTop, sorted.y());\n}",
    "hash": "c653d9017983d2a047b1fee6a481d82b",
    "file": "SkRect_Reference",
    "name": "SkRect::y()",
        "stdout": "unsorted.fTop: 25 unsorted.y(): 25\\nsorted.fTop: 5 sorted.y(): 5\\n"
    },
        "SkSurface_MakeNull": {
    "code": "void draw(SkCanvas* canvas) {\n    SkDebugf(\"SkSurface::MakeNull(0, 0) %c= nullptr\\n\", SkSurface::MakeNull(0, 0) == nullptr ?\n             '=' : '!');\n    const int w = 37;\n    const int h = 1000;\n    auto surf = SkSurface::MakeNull(w, h);\n    auto nullCanvas = surf->getCanvas();\n    nullCanvas->drawPaint(SkPaint());   // does not crash, nothing draws\n    SkDebugf(\"surf->makeImageSnapshot() %c= nullptr\\n\", surf->makeImageSnapshot() == nullptr ?\n            '=' : '!');\n}",
    "hash": "99a54b814ccab7d2b1143c88581649ff",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeNull",
        "stdout": "SkSurface::MakeNull(0, 0) == nullptr\\nsurf-\\u003emakeImageSnapshot() == nullptr\\n"
    },
        "SkSurface_MakeRaster": {
    "code": "void draw(SkCanvas* ) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(3, 3);\n    const size_t rowBytes = 64;\n    sk_sp<SkSurface> surface(SkSurface::MakeRaster(info, rowBytes, nullptr));\n    SkCanvas* canvas = surface->getCanvas();\n    canvas->clear(SK_ColorWHITE);\n    SkPixmap pixmap;\n    if (surface->peekPixels(&pixmap)) {\n        const uint32_t* colorPtr = pixmap.addr32();\n        SkPMColor pmWhite = colorPtr[0];\n        SkPaint paint;\n        canvas->drawPoint(1, 1, paint);\n        canvas->flush();  // ensure that point was drawn\n        for (int y = 0; y < info.height(); ++y) {\n            for (int x = 0; x < info.width(); ++x) {\n                SkDebugf(\"%c\", colorPtr[x] == pmWhite ? '-' : 'x');\n            }\n            colorPtr += rowBytes / sizeof(colorPtr[0]);\n            SkDebugf(\"\\n\");\n        }\n    }\n}\n",
    "hash": "a803910ada4f8733f0b62456afead55f",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRaster",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkSurface_MakeRasterDirect": {
    "code": "void draw(SkCanvas* ) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(3, 3);\n    const size_t size = info.computeMinByteSize();\n    SkAutoTMalloc<SkPMColor> storage(size);\n    SkPMColor* pixels = storage.get();\n    sk_sp<SkSurface> surface(SkSurface::MakeRasterDirect(info, pixels, info.minRowBytes()));\n    SkCanvas* canvas = surface->getCanvas();\n    canvas->clear(SK_ColorWHITE);\n    SkPMColor pmWhite = pixels[0];\n    SkPaint paint;\n    canvas->drawPoint(1, 1, paint);\n    canvas->flush();  // ensure that point was drawn\n    for (int y = 0; y < info.height(); ++y) {\n        for (int x = 0; x < info.width(); ++x) {\n            SkDebugf(\"%c\", *pixels++ == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}\n",
    "hash": "3f5aeb870104187643197354a7f1d27a",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRasterDirect",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkSurface_MakeRasterDirectReleaseProc": {
    "code": "static void release_direct_surface_storage(void* pixels, void* context) {\n    if (pixels == context) {\n        SkDebugf(\"expected release context\\n\");\n    }\n    sk_free(pixels);\n}\n\nvoid draw(SkCanvas* ) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(3, 3);\n    const size_t rowBytes = info.minRowBytes();\n    void* pixels = sk_malloc_throw(info.computeByteSize(rowBytes));\n    sk_sp<SkSurface> surface(SkSurface::MakeRasterDirectReleaseProc(info, pixels, rowBytes,\n            release_direct_surface_storage, pixels));\n    SkCanvas* canvas = surface->getCanvas();\n    canvas->clear(SK_ColorWHITE);\n    SkPMColor* colorPtr = (SkPMColor*) pixels;\n    SkPMColor pmWhite = colorPtr[0];\n    SkPaint paint;\n    canvas->drawPoint(1, 1, paint);\n    canvas->flush();  // ensure that point was drawn\n    for (int y = 0; y < info.height(); ++y) {\n        for (int x = 0; x < info.width(); ++x) {\n            SkDebugf(\"%c\", *colorPtr++ == pmWhite ? '-' : 'x');\n        }\n        SkDebugf(\"\\n\");\n    }\n}\n",
    "hash": "8e6530b26ab4096a9a91cfaadda1c568",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRasterDirectReleaseProc",
        "stdout": "---\\n-x-\\n---\\nexpected release context\\n"
    },
        "SkSurface_MakeRasterN32Premul": {
    "code": "void draw(SkCanvas* ) {\n    sk_sp<SkSurface> surface(SkSurface::MakeRasterN32Premul(3, 3));\n    SkCanvas* canvas = surface->getCanvas();\n    canvas->clear(SK_ColorWHITE);\n    SkPixmap pixmap;\n    if (surface->peekPixels(&pixmap)) {\n        const uint32_t* colorPtr = pixmap.addr32();\n        SkPMColor pmWhite = colorPtr[0];\n        SkPaint paint;\n        canvas->drawPoint(1, 1, paint);\n        canvas->flush();  // ensure that point was drawn\n        for (int y = 0; y < surface->height(); ++y) {\n            for (int x = 0; x < surface->width(); ++x) {\n                SkDebugf(\"%c\", colorPtr[x] == pmWhite ? '-' : 'x');\n            }\n            colorPtr += surface->width();\n            SkDebugf(\"\\n\");\n        }\n    }\n}\n",
    "hash": "b932a2bd68455fb0af2e7a1ed19e36b3",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRasterN32Premul",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkSurface_MakeRaster_2": {
    "code": "void draw(SkCanvas* ) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(3, 3);\n    sk_sp<SkSurface> surface(SkSurface::MakeRaster(info));\n    SkCanvas* canvas = surface->getCanvas();\n    canvas->clear(SK_ColorWHITE);\n    SkPixmap pixmap;\n    if (surface->peekPixels(&pixmap)) {\n        const uint32_t* colorPtr = pixmap.addr32();\n        SkPMColor pmWhite = colorPtr[0];\n        SkPaint paint;\n        canvas->drawPoint(1, 1, paint);\n        canvas->flush();  // ensure that point was drawn\n        for (int y = 0; y < info.height(); ++y) {\n            for (int x = 0; x < info.width(); ++x) {\n                SkDebugf(\"%c\", colorPtr[x] == pmWhite ? '-' : 'x');\n            }\n            colorPtr += info.width();\n            SkDebugf(\"\\n\");\n        }\n    }\n}\n",
    "hash": "c6197d204ef9e4ccfb583242651fb2a7",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRaster_2",
        "stdout": "---\\n-x-\\n---\\n"
    },
        "SkSurface_generationID": {
    "code": "void draw(SkCanvas* canvas) {\n    auto surface = SkSurface::MakeRasterN32Premul(1, 1);\n    for (int i = 0; i < 3; ++i) {\n        SkDebugf(\"surface generationID: %d\\n\", surface->generationID());\n        if (0 == i) {\n            surface->getCanvas()->drawColor(SK_ColorBLACK);\n        } else {\n            surface->notifyContentWillChange(SkSurface::kDiscard_ContentChangeMode);\n        }\n    }\n}",
    "hash": "be9574c4a14f891e1abb4ec2b1e51d6c",
    "file": "SkSurface_Reference",
    "name": "SkSurface::generationID",
        "stdout": "surface generationID: 1\\nsurface generationID: 2\\nsurface generationID: 3\\n"
    },
        "SkSurface_height": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 37;\n    const int height = 1000;\n    auto surf = SkSurface::MakeNull(width, height);\n    auto nullCanvas = surf->getCanvas();\n    SkDebugf(\"surface height=%d  canvas height=%d\\n\", surf->height(),\n             nullCanvas->getBaseLayerSize().fHeight);\n}",
    "hash": "20571cc23e3146deaa09046b64cc0aef",
    "file": "SkSurface_Reference",
    "name": "SkSurface::height()",
        "stdout": "surface height=1000  canvas height=1000\\n"
    },
        "SkSurface_notifyContentWillChange": {
    "code": "void draw(SkCanvas* canvas) {\n    auto surface = SkSurface::MakeRasterN32Premul(1, 1);\n    for (int i = 0; i < 3; ++i) {\n        SkDebugf(\"surface generationID: %d\\n\", surface->generationID());\n        if (0 == i) {\n            surface->getCanvas()->drawColor(SK_ColorBLACK);\n        } else {\n            surface->notifyContentWillChange(SkSurface::kDiscard_ContentChangeMode);\n        }\n    }\n}",
    "hash": "be9574c4a14f891e1abb4ec2b1e51d6c",
    "file": "SkSurface_Reference",
    "name": "SkSurface::notifyContentWillChange",
        "stdout": "surface generationID: 1\\nsurface generationID: 2\\nsurface generationID: 3\\n"
    },
        "SkSurface_props": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* names[] = { \"Unknown\", \"RGB_H\", \"BGR_H\", \"RGB_V\", \"BGR_V\" };\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    SkDebugf(\"surf.props(): k%s_SkPixelGeometry\\n\", names[surf->props().pixelGeometry()]);\n}",
    "hash": "13cf9e7b2894ae6e98c1fd719040bf01",
    "file": "SkSurface_Reference",
    "name": "SkSurface::props()",
        "stdout": "surf.props(): kRGB_H_SkPixelGeometry\\n"
    },
        "SkSurface_width": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 37;\n    const int height = 1000;\n    auto surf = SkSurface::MakeNull(width, height);\n    auto nullCanvas = surf->getCanvas();\n    SkDebugf(\"surface width=%d  canvas width=%d\\n\", surf->width(),\n             nullCanvas->getBaseLayerSize().fWidth);\n}",
    "hash": "df066b56dd97c7c589fd2bb6a2539de8",
    "file": "SkSurface_Reference",
    "name": "SkSurface::width()",
        "stdout": "surface width=37  canvas width=37\\n"
    }
    }

    var pngs = {"Canvas_Clip": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint redPaint, scalePaint;\n    redPaint.setAntiAlias(true);\n    redPaint.setColor(SK_ColorRED);\n    canvas->save();\n    for (bool antialias : { false, true } ) {\n        canvas->save();\n        canvas->clipRect(SkRect::MakeWH(19.5f, 11.5f), antialias);\n        canvas->drawCircle(17, 11, 8, redPaint);\n        canvas->restore();\n        canvas->translate(16, 0);\n    }\n    canvas->restore();\n    SkMatrix matrix;\n    matrix.setScale(6, 6);\n    scalePaint.setImageFilter(\n            SkImageFilter::MakeMatrixFilter(matrix, kNone_SkFilterQuality, nullptr));\n    SkCanvas::SaveLayerRec saveLayerRec(\n            nullptr, &scalePaint, SkCanvas::kInitWithPrevious_SaveLayerFlag); \n    canvas->saveLayer(saveLayerRec);\n    canvas->restore();\n}",
    "width": 256,
    "height": 90,
    "hash": "d2e60e5171f26ff9ddefae48387f889b",
    "file": "SkCanvas_Reference",
    "name": "Clip"
},
    "Canvas_State_Stack": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->save();                             // records stack depth to restore  \n    canvas->clipRect(SkRect::MakeWH(100, 100)); // constrains drawing to clip\n    canvas->clear(SK_ColorRED);                 // draws to limit of clip\n    canvas->save();                             // records stack depth to restore \n    canvas->clipRect(SkRect::MakeWH(50, 150));  // Rect below 100 is ignored\n    canvas->clear(SK_ColorBLUE);                // draws to smaller clip\n    canvas->restore();                          // enlarges clip\n    canvas->drawLine(20, 20, 150, 150, paint);  // line below 100 is not drawn\n    canvas->restore();                          // enlarges clip\n    canvas->drawLine(150, 20, 50, 120, paint);  // line below 100 is drawn\n}\n",
    "width": 256,
    "height": 160,
    "hash": "a4548baa133302e933b4d3442c06f5b3",
    "file": "SkCanvas_Reference",
    "name": "State_Stack"
},
    "Canvas_State_Stack_a": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clipRect(SkRect::MakeWH(100, 100));\n    canvas->clear(SK_ColorRED);\n    canvas->scale(.5, .5);\n    canvas->clipRect(SkRect::MakeWH(100, 100));\n    canvas->clear(SK_ColorBLUE);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "9f563a2d60aa31d4b26742e5aa17aa4e",
    "file": "SkCanvas_Reference",
    "name": "State_Stack_2"
},
    "Paint_Anti_alias": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocN32Pixels(50, 50);\n    SkCanvas offscreen(bitmap);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    for (bool antialias : { false, true }) {\n        paint.setColor(antialias ? SK_ColorRED : SK_ColorBLUE);\n        paint.setAntiAlias(antialias);\n        bitmap.eraseColor(0);\n        offscreen.drawLine(5, 5, 15, 30, paint);\n        canvas->drawLine(5, 5, 15, 30, paint);\n        canvas->save();\n        canvas->scale(10, 10);\n        canvas->drawBitmap(bitmap, antialias ? 12 : 0, 0);\n        canvas->restore();\n        canvas->translate(15, 0);\n    }\n}\n",
    "width": 512,
    "height": 256,
    "hash": "a6575a49467ce8d28bb01cc7638fa04d",
    "file": "SkPaint_Reference",
    "name": "Anti-alias"
},
    "Paint_Blend_Mode_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint normal, blender;\n    normal.setColor(0xFF58a889);\n    blender.setColor(0xFF8958a8);\n    canvas->clear(0);\n    for (SkBlendMode m : { SkBlendMode::kSrcOver, SkBlendMode::kSrcIn, SkBlendMode::kSrcOut } ) {\n        normal.setBlendMode(SkBlendMode::kSrcOver);\n        canvas->drawOval(SkRect::MakeXYWH(30, 30, 30, 80), normal);\n        blender.setBlendMode(m);\n        canvas->drawOval(SkRect::MakeXYWH(10, 50, 80, 30), blender);\n        canvas->translate(70, 70);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "73092d4d06faecea3c204d852a4dd8a8",
    "file": "SkPaint_Reference",
    "name": "Blend_Mode_Methods"
},
    "Paint_Color_Filter_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColorFilter(SkColorMatrixFilter::MakeLightingFilter(0xFFFFFF, 0xFF0000));\n    for (SkColor c : { SK_ColorBLACK, SK_ColorGREEN } ) {\n        paint.setColor(c);\n        canvas->drawRect(SkRect::MakeXYWH(10, 10, 50, 50), paint);\n        paint.setAlpha(0x80);\n        canvas->drawRect(SkRect::MakeXYWH(60, 60, 50, 50), paint);\n        canvas->translate(100, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "5abde56ca2f89a18b8e231abd1b57c56",
    "file": "SkPaint_Reference",
    "name": "Color_Filter_Methods"
},
    "Paint_Color_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(0x8000FF00);  // transparent green\n    canvas->drawCircle(50, 50, 40, paint);\n    paint.setARGB(128, 255, 0, 0); // transparent red\n    canvas->drawCircle(80, 50, 40, paint);\n    paint.setColor(SK_ColorBLUE);\n    paint.setAlpha(0x80);\n    canvas->drawCircle(65, 65, 40, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "214b559d75c65a7bef6ef4be1f860053",
    "file": "SkPaint_Reference",
    "name": "Color_Methods"
},
    "Paint_Device_Text": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocN32Pixels(24, 33);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(SK_ColorWHITE);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(20);\n    for (bool lcd : { false, true }) {\n        paint.setLCDRenderText(lcd);\n        for (bool subpixel : { false, true }) {\n            paint.setSubpixelText(subpixel);\n            offscreen.drawString(\",,,,\", 0, 4, paint);\n            offscreen.translate(0, 7);\n        }\n    }\n    canvas->drawBitmap(bitmap, 4, 12);\n    canvas->scale(9, 9);\n    canvas->drawBitmap(bitmap, 4, -1);\n}",
    "width": 256,
    "height": 256,
    "hash": "4606ae1be792d6bc46d496432f050ee9",
    "file": "SkPaint_Reference",
    "name": "Device_Text"
},
    "Paint_Dither": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bm16;\n    bm16.allocPixels(SkImageInfo::Make(32, 32, kRGB_565_SkColorType, kOpaque_SkAlphaType));\n    SkCanvas c16(bm16);\n    SkPaint colorPaint;\n    for (auto dither : { false, true } ) {\n        colorPaint.setDither(dither);\n        for (auto colors : { 0xFF333333, 0xFF666666, 0xFF999999, 0xFFCCCCCC } ) {\n            for (auto mask : { 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFFFF } ) {\n                 colorPaint.setColor(colors & mask);\n                 c16.drawRect({0, 0, 8, 4}, colorPaint);\n                 c16.translate(8, 0);\n            }\n            c16.translate(-32, 4);\n        }\n    }\n    canvas->scale(8, 8);\n    canvas->drawBitmap(bm16, 0, 0);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8b26507690b71462f44642b911890bbf",
    "file": "SkPaint_Reference",
    "name": "Dither"
},
    "Paint_Dither_a": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(0);\n    SkBitmap bm32;\n    bm32.allocPixels(SkImageInfo::Make(20, 10, kN32_SkColorType, kPremul_SkAlphaType));\n    SkCanvas c32(bm32);\n    SkPoint points[] = {{0, 0}, {20, 0}};\n    SkColor colors[] = {0xFF334455, 0xFF662211 };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(\n                     points, colors, nullptr, SK_ARRAY_COUNT(colors),\n                     SkShader::kClamp_TileMode, 0, nullptr));\n    paint.setDither(true);\n    c32.drawPaint(paint);\n    canvas->scale(12, 12);\n    canvas->drawBitmap(bm32, 0, 0);\n    paint.setBlendMode(SkBlendMode::kPlus);\n    canvas->drawBitmap(bm32, 0, 11, &paint);\n    canvas->drawBitmap(bm32, 0, 11, &paint);\n    canvas->drawBitmap(bm32, 0, 11, &paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "76d4d4a7931a48495e4d5f54e073be53",
    "file": "SkPaint_Reference",
    "name": "Dither_2"
},
    "Paint_Draw_Looper_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkLayerDrawLooper::LayerInfo info;\n    info.fPaintBits = (SkLayerDrawLooper::BitFlags) SkLayerDrawLooper::kColorFilter_Bit;\n    info.fColorMode = SkBlendMode::kSrc;\n    SkLayerDrawLooper::Builder looperBuilder;\n    SkPaint* loopPaint = looperBuilder.addLayer(info);\n    loopPaint->setColor(SK_ColorRED);\n    info.fOffset.set(20, 20);\n    loopPaint = looperBuilder.addLayer(info);\n    loopPaint->setColor(SK_ColorBLUE);\n    SkPaint paint;\n    paint.setDrawLooper(looperBuilder.detach());\n    canvas->drawCircle(50, 50, 50, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "84ec12a36e50df5ac565cc7a75ffbe9f",
    "file": "SkPaint_Reference",
    "name": "Draw_Looper_Methods"
},
    "Paint_Fake_Bold": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(40);\n    canvas->drawString(\"OjYy_-\", 10, 35, paint);\n    paint.setFakeBoldText(true);\n    canvas->drawString(\"OjYy_-\", 10, 75, paint);\n    // create a custom fake bold by varying the stroke width\n    paint.setFakeBoldText(false);\n    paint.setStyle(SkPaint::kStrokeAndFill_Style);\n    paint.setStrokeWidth(40.f / 48);\n    canvas->drawString(\"OjYy_-\", 10, 115, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "e811f4829a2daaaeaad3795504a7e02a",
    "file": "SkPaint_Reference",
    "name": "Fake_Bold"
},
    "Paint_Filter_Quality_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->scale(.2f, .2f);\n    for (SkFilterQuality q : { kNone_SkFilterQuality, kLow_SkFilterQuality, \n                               kMedium_SkFilterQuality, kHigh_SkFilterQuality } ) {\n        paint.setFilterQuality(q);\n        canvas->drawImage(image.get(), 0, 0, &paint);\n        canvas->translate(550, 0);\n        if (kLow_SkFilterQuality == q) canvas->translate(-1100, 550);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "ee77f83f7291e07ae0d89f1380c7d67c",
    "file": "SkPaint_Reference",
    "name": "Filter_Quality_Methods"
},
    "Paint_Font_Metrics": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(120);\n    SkPaint::FontMetrics fm;\n    SkScalar lineHeight = paint.getFontMetrics(&fm);\n    SkPoint pt = { 70, 180 };\n    canvas->drawString(\"M\", pt.fX, pt.fY, paint);\n    canvas->drawLine(pt.fX, pt.fY, pt.fX, pt.fY + fm.fTop, paint);\n    SkScalar ascent = pt.fY + fm.fAscent;\n    canvas->drawLine(pt.fX - 25, ascent, pt.fX - 25, ascent + lineHeight, paint);\n    canvas->drawLine(pt.fX - 50, pt.fY, pt.fX - 50, pt.fY + fm.fDescent, paint);\n    canvas->drawLine(pt.fX + 100, pt.fY, pt.fX + 100, pt.fY + fm.fAscent, paint);\n    canvas->drawLine(pt.fX + 125, pt.fY, pt.fX + 125, pt.fY - fm.fXHeight, paint);\n    canvas->drawLine(pt.fX + 150, pt.fY, pt.fX + 150, pt.fY - fm.fCapHeight, paint);\n    canvas->drawLine(pt.fX + 5, pt.fY, pt.fX + 5, pt.fY + fm.fBottom, paint);\n    SkScalar xmin = pt.fX + fm.fXMin;\n    canvas->drawLine(xmin, pt.fY + 60, xmin + fm.fMaxCharWidth, pt.fY + 60, paint);\n    canvas->drawLine(xmin, pt.fY - 145, pt.fX, pt.fY - 145, paint);\n    canvas->drawLine(pt.fX + fm.fXMax, pt.fY - 160, pt.fX, pt.fY - 160, paint);\n    SkScalar upos = pt.fY + fm.fUnderlinePosition;\n    canvas->drawLine(pt.fX + 25, upos, pt.fX + 160, upos, paint);\n    SkScalar ut = fm.fUnderlineThickness;\n    canvas->drawLine(pt.fX + 130, upos + ut, pt.fX + 160, upos + ut, paint);\n    paint.setTextSize(12);\n    canvas->drawString(\"x-min\",          pt.fX - 50, pt.fY - 148, paint);\n    canvas->drawString(\"x-max\",          pt.fX + 140, pt.fY - 150, paint);\n    canvas->drawString(\"max char width\", pt.fX + 120, pt.fY + 57, paint);\n    canvas->drawString(\"underline position\", pt.fX + 30, pt.fY + 22, paint);\n    canvas->drawString(\"underline thickness\", pt.fX + 162, pt.fY + 13, paint);\n    canvas->rotate(-90);\n    canvas->drawString(\"descent\",     -pt.fY - 30, pt.fX - 54,  paint);\n    canvas->drawString(\"line height\", -pt.fY,      pt.fX - 29,  paint);\n    canvas->drawString(\"top\",         -pt.fY + 30, pt.fX - 4,   paint);\n    canvas->drawString(\"ascent\",      -pt.fY,      pt.fX + 110, paint);\n    canvas->drawString(\"x-height\",    -pt.fY,      pt.fX + 135, paint);\n    canvas->drawString(\"cap-height\",  -pt.fY,      pt.fX + 160, paint);\n    canvas->drawString(\"bottom\",      -pt.fY - 50, pt.fX + 15,  paint);\n}\n",
    "width": 512,
    "height": 256,
    "hash": "2bfa3783719fcd769af177a1b244e171",
    "file": "SkPaint_Reference",
    "name": "Font_Metrics"
},
    "Paint_Image_Filter_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(2);\n    SkRegion region;\n    region.op( 10, 10, 50, 50, SkRegion::kUnion_Op);\n    region.op( 10, 50, 90, 90, SkRegion::kUnion_Op);\n    paint.setImageFilter(SkBlurImageFilter::Make(5.0f, 5.0f, nullptr));\n    canvas->drawRegion(region, paint);\n    paint.setImageFilter(nullptr);\n    paint.setMaskFilter(SkBlurMaskFilter::Make(kNormal_SkBlurStyle, 5));\n    canvas->translate(100, 100);\n    canvas->drawRegion(region, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "0b2eec148d6397d6231e1fa0b3d1496d",
    "file": "SkPaint_Reference",
    "name": "Image_Filter_Methods"
},
    "Paint_Mask_Filter_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setMaskFilter(SkBlurMaskFilter::Make(kSolid_SkBlurStyle, 3));\n    canvas->drawRect(SkRect::MakeXYWH(40, 40, 175, 175), paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "320b04ea1e1291d49f1e61994a0410fe",
    "file": "SkPaint_Reference",
    "name": "Mask_Filter_Methods"
},
    "Paint_Miter_Limit": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint pts[] = {{ 10, 50 }, { 110, 80 }, { 10, 110 }};\n    SkVector v[] = { pts[0] - pts[1], pts[2] - pts[1] };\n    SkScalar angle1 = SkScalarATan2(v[0].fY, v[0].fX);\n    SkScalar angle2 = SkScalarATan2(v[1].fY, v[1].fX);\n    const SkScalar strokeWidth = 20;\n    SkScalar miterLimit = 1 / SkScalarSin((angle2 - angle1) / 2);\n    SkScalar miterLength = strokeWidth * miterLimit;\n    SkPath path;\n    path.moveTo(pts[0]);\n    path.lineTo(pts[1]);\n    path.lineTo(pts[2]);\n    SkPaint paint;  // set to default kMiter_Join\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeMiter(miterLimit);\n    paint.setStrokeWidth(strokeWidth);\n    canvas->drawPath(path, paint);\n    paint.setStrokeWidth(1);\n    canvas->drawLine(pts[1].fX - miterLength / 2, pts[1].fY + 50,\n                     pts[1].fX + miterLength / 2, pts[1].fY + 50, paint);\n    canvas->translate(200, 0);\n    miterLimit *= 0.99f;\n    paint.setStrokeMiter(miterLimit);\n    paint.setStrokeWidth(strokeWidth);\n    canvas->drawPath(path, paint);\n    paint.setStrokeWidth(1);\n    canvas->drawLine(pts[1].fX - miterLength / 2, pts[1].fY + 50,\n                     pts[1].fX + miterLength / 2, pts[1].fY + 50, paint);\n}\n",
    "width": 384,
    "height": 170,
    "hash": "5de2de0f00354e59074a9bb1a42d5a63",
    "file": "SkPaint_Reference",
    "name": "Miter_Limit"
},
    "Paint_Path_Effect_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(16);\n    SkScalar intervals[] = {30, 10};\n    paint.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 1));\n    canvas->drawRoundRect({20, 20, 120, 120}, 20, 20, paint);\n}\n",
    "width": 256,
    "height": 160,
    "hash": "8cf5684b187d60f09e11c4a48993ea39",
    "file": "SkPaint_Reference",
    "name": "Path_Effect_Methods"
},
    "Paint_Shader_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkPoint center = { 50, 50 };\n   SkScalar radius = 50;\n   const SkColor colors[] = { 0xFFFFFFFF, 0xFF000000 };\n   paint.setShader(SkGradientShader::MakeRadial(center, radius, colors,\n        nullptr, SK_ARRAY_COUNT(colors), SkShader::kClamp_TileMode));\n   for (SkScalar a : { 0.3f, 0.6f, 1.0f } ) {\n       paint.setAlpha((int) (a * 255));\n       canvas->drawCircle(center.fX, center.fY, radius, paint);\n       canvas->translate(70, 70);\n   }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "c015dc2010c15e1c00b4f7330232b0f7",
    "file": "SkPaint_Reference",
    "name": "Shader_Methods"
},
    "Paint_Shader_Methods_a": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   SkBitmap bitmap;\n   bitmap.setInfo(SkImageInfo::MakeA8(5, 1), 5);  // bitmap only contains alpha\n   uint8_t pixels[5] = { 0x22, 0x55, 0x88, 0xBB, 0xFF };\n   bitmap.setPixels(pixels);\n   paint.setShader(SkShader::MakeBitmapShader(bitmap, \n            SkShader::kMirror_TileMode, SkShader::kMirror_TileMode));\n   for (SkColor c : { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN } ) {\n       paint.setColor(c);  // all components in color affect shader\n       canvas->drawCircle(50, 50, 50, paint);\n       canvas->translate(70, 70);\n   }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "9673be7720ba3adcdae42ddc1565b588",
    "file": "SkPaint_Reference",
    "name": "Shader_Methods_2"
},
    "Paint_Stroke_Cap": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    SkPath path;\n    path.moveTo(30, 30);\n    path.lineTo(30, 30);\n    path.moveTo(70, 30);\n    path.lineTo(90, 40);\n    for (SkPaint::Cap c : { SkPaint::kButt_Cap, SkPaint::kRound_Cap, SkPaint::kSquare_Cap } ) {\n        paint.setStrokeCap(c);\n        canvas->drawPath(path, paint);\n        canvas->translate(0, 70);\n    }\n}",
    "width": 256,
    "height": 200,
    "hash": "2bffb6384cc20077e632e7d01da045ca",
    "file": "SkPaint_Reference",
    "name": "Stroke_Cap"
},
    "Paint_Stroke_Join": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    SkPath path;\n    path.moveTo(30, 20);\n    path.lineTo(40, 40);\n    path.conicTo(70, 20, 100, 20, .707f);\n    for (SkPaint::Join j : { SkPaint::kMiter_Join, SkPaint::kRound_Join, SkPaint::kBevel_Join } ) {\n        paint.setStrokeJoin(j);\n        canvas->drawPath(path, paint);\n        canvas->translate(0, 70);\n    }\n}",
    "width": 256,
    "height": 200,
    "hash": "917c44b504d3f9308571fd3835d90a0d",
    "file": "SkPaint_Reference",
    "name": "Stroke_Join"
},
    "Paint_Stroke_Width": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    for (bool antialias : { false, true }) { \n        paint.setAntiAlias(antialias);\n        for (int width = 0; width <= 4; ++width) {\n            SkScalar offset = antialias * 100 + width * 20;\n            paint.setStrokeWidth(width * 0.25f);\n            canvas->drawLine(10 + offset,  10, 20 + offset,  60, paint);\n            canvas->drawLine(10 + offset, 110, 60 + offset, 160, paint);\n        }\n    }\n}\n",
    "width": 256,
    "height": 170,
    "hash": "01e3e08a3022a351628ff54e84887756",
    "file": "SkPaint_Reference",
    "name": "Stroke_Width"
},
    "Paint_Text_Align": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(40);\n    SkPoint position[] = {{100, 50}, {150, 40}};\n    for (SkPaint::Align a : { SkPaint::kLeft_Align,\n                              SkPaint::kCenter_Align,\n                              SkPaint::kRight_Align}) {\n        paint.setTextAlign(a);\n        canvas->drawPosText(\"Aa\", 2, position, paint);\n        canvas->translate(0, 50);\n    }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "702617fd9ebc3f12e30081b5db93e8a8",
    "file": "SkPaint_Reference",
    "name": "Text_Align"
},
    "Paint_Text_Align_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(40);\n    paint.setVerticalText(true);\n    for (SkPaint::Align a : { SkPaint::kLeft_Align,\n                              SkPaint::kCenter_Align,\n                              SkPaint::kRight_Align }) {\n        paint.setTextAlign(a);\n        canvas->drawString(\"Aa\", 50, 80, paint);\n        canvas->translate(50, 0);\n    }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "f1cbbbafe6b3c52b81309cccbf96a308",
    "file": "SkPaint_Reference",
    "name": "Text_Align_2"
},
    "Paint_Text_Encoding": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    const char hello8[] = \"Hello\" \"\\xE2\" \"\\x98\" \"\\xBA\";\n    const uint16_t hello16[] = { 'H', 'e', 'l', 'l', 'o', 0x263A };\n    const uint32_t hello32[] = { 'H', 'e', 'l', 'l', 'o', 0x263A };\n    paint.setTextSize(24);\n    canvas->drawText(hello8, sizeof(hello8) - 1, 10, 30, paint);\n    paint.setTextEncoding(SkPaint::kUTF16_TextEncoding);\n    canvas->drawText(hello16, sizeof(hello16), 10, 60, paint);\n    paint.setTextEncoding(SkPaint::kUTF32_TextEncoding);\n    canvas->drawText(hello32, sizeof(hello32), 10, 90, paint);\n    uint16_t glyphs[SK_ARRAY_COUNT(hello32)];\n    paint.textToGlyphs(hello32, sizeof(hello32), glyphs);\n    paint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);\n    canvas->drawText(glyphs, sizeof(glyphs), 10, 120, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "b29294e7f29d160a1b46abf2dcec9d2a",
    "file": "SkPaint_Reference",
    "name": "Text_Encoding"
},
    "Paint_Text_Scale_X": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    paint.setTextScaleX(.8f);\n    canvas->drawString(\"narrow\", 10, 20, paint);\n    paint.setTextScaleX(1);\n    canvas->drawString(\"normal\", 10, 60, paint);\n    paint.setTextScaleX(1.2f);\n    canvas->drawString(\"wide\", 10, 100, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "d13d787c1e36f515319fc998411c1d91",
    "file": "SkPaint_Reference",
    "name": "Text_Scale_X"
},
    "Paint_Text_Size": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->drawString(\"12 point\", 10, 20, paint);\n    paint.setTextSize(24);\n    canvas->drawString(\"24 point\", 10, 60, paint);\n    paint.setTextSize(48);\n    canvas->drawString(\"48 point\", 10, 120, paint);\n}\n",
    "width": 256,
    "height": 135,
    "hash": "91c9a3e498bb9412e4522a95d076ed5f",
    "file": "SkPaint_Reference",
    "name": "Text_Size"
},
    "Paint_Text_Skew_X": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    paint.setTextSkewX(-.25f);\n    canvas->drawString(\"right-leaning\", 10, 100, paint);\n    paint.setTextSkewX(0);\n    canvas->drawString(\"normal\", 10, 60, paint);\n    paint.setTextSkewX(.25f);\n    canvas->drawString(\"left-leaning\", 10, 20, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "aff208b0aab265f273045b27e683c17c",
    "file": "SkPaint_Reference",
    "name": "Text_Skew_X"
},
    "Paint_Typeface_Methods": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTypeface(SkTypeface::MakeFromName(nullptr, SkFontStyle()));\n    paint.setAntiAlias(true);\n    paint.setTextSize(36);\n    canvas->drawString(\"A Big Hello!\", 10, 40, paint);\n    paint.setTypeface(nullptr);\n    paint.setFakeBoldText(true);\n    canvas->drawString(\"A Big Hello!\", 10, 80, paint);\n}\n",
    "width": 256,
    "height": 100,
    "hash": "1a7a5062725139760962582f599f1b97",
    "file": "SkPaint_Reference",
    "name": "Typeface_Methods"
},
    "Paint_Vertical_Text": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(50);\n    for (bool vertical : { false, true } ) {\n        paint.setVerticalText(vertical);\n        canvas->drawString(\"aAlL\", 25, 50, paint);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8df5800819311b71373d9abb669b49b8",
    "file": "SkPaint_Reference",
    "name": "Vertical_Text"
},
    "Path": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    path.moveTo(124, 108);\n    path.lineTo(172, 24);\n    path.addCircle(50, 50, 30);\n    path.moveTo(36, 148);\n    path.quadTo(66, 188, 120, 136);\n    canvas->drawPath(path, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStrokeWidth(3);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 192,
    "hash": "93887af0c1dac49521972698cf04069c",
    "file": "SkPath_Reference",
    "name": "Path"
},
    "Path_Arc": {
    "code": "struct data {\n   const char* name;\n   char super;\n   int yn[10];\n};\nconst data dataSet[] = {\n{ \"arcTo sweep\",    '1', {1,  3, 1, 0, 0, 0, 0, 1, 0, 0 }},\n{ \"drawArc\",         0,  {1, -1, 1, 1, 1, 1, 1, 0, 0, 0 }},\n{ \"addArc\",          0,  {1,  1, 1, 4, 0, 1, 1, 1, 0, 0 }},\n{ \"arcTo tangents\", '4', {0,  0, 0, 0, 0, 0, 0, 1, 1, 0 }},\n{ \"arcTo radii\",    '5', {1,  0, 1, 0, 0, 0, 0, 1, 1, 0 }},\n{ \"conicTo\",         0,  {1,  1, 0, 0, 0, 0, 0, 1, 1, 1 }}\n};\n#define __degree_symbol__ \"\\xC2\" \"\\xB0\"\nconst char* headers[] = {\n    \"Oval part\",\n    \"force moveTo\",\n    \"can draw 180\" __degree_symbol__,\n    \"can draw 360\" __degree_symbol__,\n    \"can draw greater than 360\" __degree_symbol__,\n    \"ignored if radius is zero\",\n    \"ignored if sweep is zero\",\n    \"requires Path\",\n    \"describes rotation\",\n    \"describes perspective\",\n};\nconst char* yna[] = {\n     \"n/a\",\n     \"no\",\n     \"yes\"\n};\n\nvoid draw(SkCanvas* canvas) {\n    SkPaint lp;\n    lp.setAntiAlias(true);\n    SkPaint tp(lp);\n    SkPaint sp(tp);\n    SkPaint bp(tp);\n    bp.setFakeBoldText(true);\n    sp.setTextSize(10);\n    lp.setColor(SK_ColorGRAY);\n    canvas->translate(0, 32);\n    const int tl = 115;\n    for (unsigned col = 0; col <= SK_ARRAY_COUNT(headers); ++col) {\n       canvas->drawLine(tl + col * 35, 100, tl + col * 35, 250, lp);\n       if (0 == col) {\n          continue;\n       }\n       canvas->drawLine(tl + col * 35, 100, tl + 100 + col * 35, 0, lp);\n       SkPath path;\n       path.moveTo(tl - 3 + col * 35, 103);\n       path.lineTo(tl + 124 + col * 35, -24);\n       canvas->drawTextOnPathHV(headers[col -1], strlen(headers[col -1]), path, 0, -9, bp);\n    }\n    for (unsigned row = 0; row <= SK_ARRAY_COUNT(dataSet); ++row) {\n        if (0 == row) {\n            canvas->drawLine(tl, 100, tl + 350, 100, lp);\n        } else {\n            canvas->drawLine(5, 100 + row * 25, tl + 350, 100 + row * 25, lp);\n        }\n        if (row == SK_ARRAY_COUNT(dataSet)) {\n            break;\n        }\n        canvas->drawString(dataSet[row].name, 5, 117 + row * 25, bp);\n        if (dataSet[row].super) {\n            SkScalar width = bp.measureText(dataSet[row].name, strlen(dataSet[row].name));\n            canvas->drawText(&dataSet[row].super, 1, 8 + width, 112 + row * 25, sp);\n        }\n        for (unsigned col = 0; col < SK_ARRAY_COUNT(headers); ++col) {\n            int val = dataSet[row].yn[col];\n            canvas->drawString(yna[SkTMin(2, val + 1)], tl + 5 + col * 35, 117 + row * 25, tp);\n            if (val > 1) {\n                char supe = '0' + val - 1;\n                canvas->drawText(&supe, 1, tl + 25 + col * 35, 112 + row * 25, sp);\n            }\n        }\n    }\n}\n",
    "width": 600,
    "height": 300,
    "hash": "891ac93abd0cdb27c4156685d3b1bb4c",
    "file": "SkPath_Reference",
    "name": "Arc"
},
    "Path_Arc_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect oval = {8, 8, 56, 56};\n    SkPaint ovalPaint;\n    ovalPaint.setAntiAlias(true);\n    SkPaint textPaint(ovalPaint);\n    ovalPaint.setStyle(SkPaint::kStroke_Style);\n    SkPaint arcPaint(ovalPaint);\n    arcPaint.setStrokeWidth(5);\n    arcPaint.setColor(SK_ColorBLUE);\n    canvas->translate(-64, 0);\n    for (char arcStyle = '1'; arcStyle <= '6'; ++arcStyle) {\n        '4' == arcStyle ? canvas->translate(-96, 55) : canvas->translate(64, 0);\n        canvas->drawText(&arcStyle, 1, 30, 36, textPaint);\n        canvas->drawOval(oval, ovalPaint);\n        SkPath path;\n        path.moveTo({56, 32});\n        switch (arcStyle) {\n            case '1':\n                path.arcTo(oval, 0, 90, false);\n                break;\n            case '2':\n                canvas->drawArc(oval, 0, 90, false, arcPaint);\n                continue;\n            case '3':\n                path.addArc(oval, 0, 90);\n                break;\n            case '4':\n                path.arcTo({56, 56}, {32, 56}, 24);\n                break;\n            case '5':\n                path.arcTo({24, 24}, 0, SkPath::kSmall_ArcSize, SkPath::kCW_Direction, {32, 56});\n                break;\n            case '6':\n                path.conicTo({56, 56}, {32, 56}, SK_ScalarRoot2Over2);\n                break;\n         }\n         canvas->drawPath(path, arcPaint);\n     }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "5acc77eba0cb4d00bbf3a8f4db0c0aee",
    "file": "SkPath_Reference",
    "name": "Arc_2"
},
    "Path_Contour": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawString(\"1st contour\", 150, 100, paint);\n    canvas->drawString(\"2nd contour\", 130, 160, paint);\n    canvas->drawString(\"3rd contour\", 40, 30, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(124, 108);\n    path.lineTo(172, 24);\n    path.moveTo(36, 148);\n    path.quadTo(66, 188, 120, 136);\n    path.close();\n    path.conicTo(70, 20, 110, 40, 0.6f);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 192,
    "hash": "0374f2dcd7effeb1dd435205a6c2de6f",
    "file": "SkPath_Reference",
    "name": "Contour"
},
    "Path_Contour_Zero_Length": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(8);\n    paint.setStrokeCap(SkPaint::kRound_Cap);\n    SkPath path;\n    path.moveTo(36, 48);\n    path.lineTo(36, 48);\n    canvas->drawPath(path, paint);\n    path.reset();\n    paint.setStrokeCap(SkPaint::kSquare_Cap);\n    path.moveTo(56, 48);\n    path.close();\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "62848df605af6258653d9e16b27d8f7f",
    "file": "SkPath_Reference",
    "name": "Zero_Length"
},
    "Path_Contour_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(8);\n    SkPath path;\n    path.moveTo(36, 48);\n    path.quadTo(66, 88, 120, 36);\n    canvas->drawPath(path, paint);\n    path.close();\n    canvas->translate(0, 50);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 160,
    "hash": "7a1f39b12d2cd8b7f5b1190879259cb2",
    "file": "SkPath_Reference",
    "name": "Contour_2"
},
    "Path_Cubic": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPoint cubicPts[] = {{20, 150}, {90, 10}, {160, 150}, {230, 10}};\n    SkColor colors[] = { 0xff88ff00, 0xff0088bb, 0xff6600cc, 0xffbb3377 };\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(colors); ++i) {\n        paint.setColor(0x7fffffff & colors[i]);\n        paint.setStrokeWidth(1);\n        for (unsigned j = 0; j < 3; ++j) {\n            canvas->drawLine(cubicPts[j], cubicPts[j + 1], paint);\n        }\n        SkPath path;\n        path.moveTo(cubicPts[0]);\n        path.cubicTo(cubicPts[1], cubicPts[2], cubicPts[3]);\n        paint.setStrokeWidth(3);\n        paint.setColor(colors[i]);\n        canvas->drawPath(path, paint);\n        cubicPts[1].fY += 30;\n        cubicPts[2].fX += 30;\n   }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "466445ed991d86de08587066392d654a",
    "file": "SkPath_Reference",
    "name": "Cubic"
},
    "Path_Quad": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPoint quadPts[] = {{20, 90}, {120, 10}, {220, 90}};\n    canvas->drawLine(quadPts[0], quadPts[1], paint);\n    canvas->drawLine(quadPts[1], quadPts[2], paint);\n    SkPath path;\n    path.moveTo(quadPts[0]);\n    path.quadTo(quadPts[1], quadPts[2]);\n    paint.setStrokeWidth(3);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 110,
    "hash": "78ad51fa1cd33eb84a6f99061e56e067",
    "file": "SkPath_Reference",
    "name": "Quad"
},
    "Path_Quad_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPoint quadPts[] = {{20, 150}, {120, 10}, {220, 150}};\n    SkColor colors[] = { 0xff88ff00, 0xff0088bb, 0xff6600cc, 0xffbb3377 };\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(colors); ++i) {\n        paint.setColor(0x7fffffff & colors[i]);\n        paint.setStrokeWidth(1);\n        canvas->drawLine(quadPts[0], quadPts[1], paint);\n        canvas->drawLine(quadPts[1], quadPts[2], paint);\n        SkPath path;\n        path.moveTo(quadPts[0]);\n        path.quadTo(quadPts[1], quadPts[2]);\n        paint.setStrokeWidth(3);\n        paint.setColor(colors[i]);\n        canvas->drawPath(path, paint);\n        quadPts[1].fY += 30;\n   }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "4082f66a42df11bb20462b232b156bb6",
    "file": "SkPath_Reference",
    "name": "Quad_2"
},
    "Path_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    path.moveTo(36, 48);\n    path.quadTo(66, 88, 120, 36);\n    canvas->drawPath(path, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStrokeWidth(8);\n    canvas->translate(0, 50);\n    canvas->drawPath(path, paint);\n    paint.setStyle(SkPaint::kStrokeAndFill_Style);\n    paint.setColor(SK_ColorRED);\n    canvas->translate(0, 50);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 192,
    "hash": "36a995442c081ee779ecab2962d36e69",
    "file": "SkPath_Reference",
    "name": "Path_2"
},
    "SkAlphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkAlphaType"
},
    "SkAutoCanvasRestore_SkCanvas_star": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(64);\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            SkMatrix m = SkMatrix::MakeAll(sx, 1, 96,    0, sy, 64,   0, 0, 1);\n            canvas->concat(m);\n            canvas->drawString(\"R\", 0, 0, p);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "466ef576b88e29d7252422db7adeed1c",
    "file": "SkAutoCanvasRestore_Reference",
    "name": "SkAutoCanvasRestore::SkAutoCanvasRestore(SkCanvas* canvas, bool doSave)"
},
    "SkBitmap_allocN32Pixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRandom random;\n    SkBitmap bitmap;\n    bitmap.allocN32Pixels(64, 64);\n    bitmap.eraseColor(SK_ColorTRANSPARENT);\n    for (int y = 0; y < 256; y += 64) {\n        for (int x = 0; x < 256; x += 64) {\n            SkColor color = random.nextU();\n            uint32_t w = random.nextRangeU(4, 32);\n            uint32_t cx = random.nextRangeU(0, 64 - w);\n            uint32_t h = random.nextRangeU(4, 32);\n            uint32_t cy = random.nextRangeU(0, 64 - h);\n            bitmap.erase(color, SkIRect::MakeXYWH(cx, cy, w, h));\n            canvas->drawBitmap(bitmap, x, y);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "c717491f9251604724c9cbde7088ec20",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocN32Pixels"
},
    "SkBitmap_allocPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    SkImageInfo info = SkImageInfo::Make(256, 64, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    bitmap.allocPixels(info, info.width() * info.bytesPerPixel() + 64);\n    SkCanvas offscreen(bitmap);\n    offscreen.scale(.5f, .5f);\n    for (int y : { 0, 64, 128, 192 } ) {\n        offscreen.drawBitmap(source, 0, -y);\n        canvas->drawBitmap(bitmap, 0, y);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "555c0f62f96602a9dcd459badcd005e0",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocPixels"
},
    "SkBitmap_allocPixelsFlags": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixelsFlags(SkImageInfo::MakeN32(44, 16, kPremul_SkAlphaType), \n                            SkBitmap::kZeroPixels_AllocFlag);\n    SkCanvas offscreen(bitmap);\n    SkPaint paint;\n    offscreen.drawString(\"!@#$%\", 0, 12, paint);\n    canvas->scale(6, 6);\n    canvas->drawBitmap(bitmap, 0, 0);\n    canvas->drawBitmap(bitmap, 8, 8);\n}",
    "width": 256,
    "height": 128,
    "hash": "f21b8965a88c94a32393a8890c4672af",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocPixelsFlags"
},
    "SkBitmap_allocPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::Make(64, 64, kGray_8_SkColorType, kOpaque_SkAlphaType));\n    SkCanvas offscreen(bitmap);\n    offscreen.scale(.5f, .5f);\n    for (int y : { 0, 64, 128, 192 } ) {\n        offscreen.drawBitmap(source, -y, -y);\n        canvas->drawBitmap(bitmap, y, y);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "91f474a11a2112cd5c88c40a9015048d",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocPixels_2"
},
    "SkBitmap_allocPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t set1[5] = { 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 };\n    uint8_t set2[5] = { 0xAC, 0xA8, 0x89, 0x47, 0x87 };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::Make(5, 1, kGray_8_SkColorType, kOpaque_SkAlphaType), set1, 5);\n    canvas->scale(10, 50);\n    canvas->drawBitmap(bitmap, 0, 0);\n    bitmap.allocPixels();\n    bitmap.eraseColor(SK_ColorBLACK);\n    canvas->drawBitmap(bitmap, 8, 0);\n    bitmap.setPixels(set2);\n    canvas->drawBitmap(bitmap, 16, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "1219b38c788bf270fb20f8cd2d78cff8",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocPixels_3"
},
    "SkBitmap_allocPixels_4": {
    "code": "class TinyAllocator : public SkBitmap::Allocator {\npublic:\n    bool allocPixelRef(SkBitmap* bitmap) override {\n        const SkImageInfo& info = bitmap->info();\n        if (info.height() * info.minRowBytes() > sizeof(storage)) {\n            return false;\n        }\n        sk_sp<SkPixelRef> pr = sk_sp<SkPixelRef>(\n                new SkPixelRef(info.width(), info.height(), storage, info.minRowBytes()));\n        bitmap->setPixelRef(std::move(pr), 0, 0);\n        return true;\n    }\n    char storage[16];\n};\n\nvoid draw(SkCanvas* canvas) {\n   TinyAllocator tinyAllocator;\n   SkBitmap bitmap;\n   bitmap.setInfo(SkImageInfo::MakeN32(2, 2, kOpaque_SkAlphaType));\n   if (bitmap.tryAllocPixels(&tinyAllocator)) {\n       bitmap.eraseColor(0xff55aa33);\n       bitmap.erase(0xffaa3355, SkIRect::MakeXYWH(1, 1, 1, 1));\n       canvas->scale(16, 16);\n       canvas->drawBitmap(bitmap, 0, 0);\n   }\n}\n",
    "width": 256,
    "height": 32,
    "hash": "1b2800d23c9ea249b45c2c21a34b6d14",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::allocPixels_4"
},
    "SkBitmap_bounds": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(.5f, .5f);\n    SkIRect bounds = source.bounds();\n    for (int x : { 0, bounds.width() } ) {\n        for (int y : { 0, bounds.height() } ) {\n            canvas->drawBitmap(source, x, y);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "41a60435d6eb76cb400fe9be635e3762",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::bounds()"
},
    "SkBitmap_erase": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap; \n    bitmap.allocPixels(SkImageInfo::MakeN32(2, 2, kPremul_SkAlphaType));\n    bitmap.erase(0x7fff7f3f, SkIRect::MakeWH(1, 1));\n    bitmap.erase(0x7f7f3fff, SkIRect::MakeXYWH(0, 1, 1, 1));\n    bitmap.erase(0x7f3fff7f, SkIRect::MakeXYWH(1, 0, 1, 1));\n    bitmap.erase(0x7f1fbf5f, SkIRect::MakeXYWH(1, 1, 1, 1));\n    canvas->scale(25, 25);\n    canvas->drawBitmap(bitmap, 0, 0);\n    canvas->drawBitmap(bitmap, .5f, .5f);\n}",
    "width": 256,
    "height": 70,
    "hash": "116baaa35348b5c0a353fb6d4917d574",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::erase()"
},
    "SkBitmap_eraseARGB": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap; \n    bitmap.allocPixels(SkImageInfo::MakeN32(1, 1, kPremul_SkAlphaType));\n    bitmap.eraseARGB(0x7f, 0xff, 0x7f, 0x3f);\n    canvas->scale(50, 50);\n    canvas->drawBitmap(bitmap, 0, 0);\n    canvas->drawBitmap(bitmap, .5f, .5f);\n}",
    "width": 256,
    "height": 80,
    "hash": "ebaa436565ce9c0f883bef871d099654",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::eraseARGB"
},
    "SkBitmap_eraseColor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap; \n    bitmap.allocPixels(SkImageInfo::MakeN32(1, 1, kOpaque_SkAlphaType));\n    bitmap.eraseColor(SK_ColorRED);\n    canvas->scale(16, 16);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 20,
    "hash": "22804faa423192f96a29578b1d396ace",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::eraseColor"
},
    "SkBitmap_extractAlpha": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap alpha, bitmap;\n    bitmap.allocN32Pixels(100, 100);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(0);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    offscreen.drawCircle(50, 50, 39, paint);\n    offscreen.flush();\n    bitmap.extractAlpha(&alpha);\n    paint.setColor(SK_ColorRED);\n    canvas->drawBitmap(bitmap, 0, 0, &paint);\n    canvas->drawBitmap(alpha, 100, 0, &paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "ab6577df079e6c70511cf2bfc6447b44",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::extractAlpha"
},
    "SkBitmap_extractAlpha_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap alpha, bitmap;\n    bitmap.allocN32Pixels(100, 100);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(0);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    offscreen.drawCircle(50, 50, 39, paint);\n    offscreen.flush();\n    const SkScalar kBlurSigma = SkBlurMaskFilter::ConvertRadiusToSigma(SkIntToScalar(25));\n    paint.setMaskFilter(SkBlurMaskFilter::Make(kNormal_SkBlurStyle, kBlurSigma,\n                                    SkBlurMaskFilter::kHighQuality_BlurFlag));\n    SkIPoint offset;\n    bitmap.extractAlpha(&alpha, &paint, &offset);\n    paint.setColor(SK_ColorRED);\n    canvas->drawBitmap(bitmap, 0, -offset.fY, &paint);\n    canvas->drawBitmap(alpha, 100 + offset.fX, 0, &paint);\n}",
    "width": 256,
    "height": 160,
    "hash": "e122936b119f20098aace454c2105a12",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::extractAlpha_2"
},
    "SkBitmap_extractAlpha_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap alpha, bitmap;\n    bitmap.allocN32Pixels(100, 100);\n    SkCanvas offscreen(bitmap);\n    offscreen.clear(0);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    offscreen.drawCircle(50, 50, 39, paint);\n    offscreen.flush();\n    paint.setMaskFilter(SkBlurMaskFilter::Make(kOuter_SkBlurStyle, 3));\n    SkIPoint offset;\n    bitmap.extractAlpha(&alpha, &paint, nullptr, &offset);\n    paint.setColor(SK_ColorRED);\n    canvas->drawBitmap(bitmap, 0, -offset.fY, &paint);\n    canvas->drawBitmap(alpha, 100 + offset.fX, 0, &paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "3563cb608791d55bb584f38e842f3003",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::extractAlpha_3"
},
    "SkBitmap_getBounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect bounds;\n    source.getBounds(&bounds);\n    bounds.offset(100, 100);\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    canvas->scale(.25f, .25f);\n    canvas->drawRect(bounds, paint);\n    canvas->drawBitmap(source, 40, 40);\n}",
    "width": 256,
    "height": 160,
    "hash": "2431ebc7e7d1e91e6d9daafd0f7a478f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getBounds"
},
    "SkBitmap_getBounds_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect bounds;\n    source.getBounds(&bounds);\n    bounds.inset(100, 100);\n    SkBitmap bitmap;\n    source.extractSubset(&bitmap, bounds);\n    canvas->scale(.5f, .5f);\n    canvas->drawBitmap(bitmap, 10, 10);\n}",
    "width": 256,
    "height": 256,
    "hash": "0c45da35172bc0a529b2faecddae62a2",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::getBounds_2"
},
    "SkBitmap_installMaskPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t storage[][5] = {{ 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 },\n                            { 0xAC, 0xA8, 0x89, 0x47, 0x87 },\n                            { 0x4B, 0x25, 0x25, 0x25, 0x46 },\n                            { 0x90, 0x81, 0x25, 0x41, 0x33 },\n                            { 0x75, 0x55, 0x44, 0x20, 0x00 }};\n    SkMask mask;\n    mask.fImage = storage[0];\n    mask.fBounds = SkIRect::MakeWH(5, 5);\n    mask.fRowBytes = 5;\n    mask.fFormat = SkMask::kA8_Format;\n    SkBitmap bitmap;\n    bitmap.installMaskPixels(mask);\n    canvas->scale(10, 10);\n    canvas->drawBitmap(bitmap, 0, 0);\n    storage[2][2] = 0xFF;\n    bitmap.installMaskPixels(mask);\n    canvas->drawBitmap(bitmap, 10, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "b0456fc063ca467ccecf2105160a3d1d",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::installMaskPixels"
},
    "SkBitmap_installPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n   SkRandom random;\n   SkBitmap bitmap;\n   const int width = 8;\n   const int height = 8;\n   uint32_t pixels[width * height];\n   for (unsigned x = 0; x < width * height; ++x) {\n       pixels[x] = random.nextU();\n   }\n   SkImageInfo info = SkImageInfo::MakeN32(width, height, kUnpremul_SkAlphaType);\n   if (bitmap.installPixels(info, pixels, info.minRowBytes())) {\n       canvas->scale(32, 32);\n       canvas->drawBitmap(bitmap, 0, 0);\n   }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "a7e04447b2081010c50d7920e80a6bb2",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::installPixels_2"
},
    "SkBitmap_installPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t storage[][5] = {{ 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 },\n                            { 0xAC, 0xA8, 0x89, 0x47, 0x87 },\n                            { 0x4B, 0x25, 0x25, 0x25, 0x46 },\n                            { 0x90, 0x81, 0x25, 0x41, 0x33 },\n                            { 0x75, 0x55, 0x44, 0x20, 0x00 }};\n    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->scale(10, 10);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *pixmap.writable_addr8(2, 2) = 0xFF;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 10, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "6e2a8c9358b34aebd2ec586815fe9d3a",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::installPixels_3"
},
    "SkBitmap_notifyPixelsChanged": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap; \n    bitmap.setInfo(SkImageInfo::Make(1, 1, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));\n    bitmap.allocPixels();\n    bitmap.eraseColor(SK_ColorRED);\n    canvas->scale(16, 16);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *(SkPMColor*) bitmap.getPixels() = SkPreMultiplyColor(SK_ColorBLUE);\n    canvas->drawBitmap(bitmap, 2, 0);\n    bitmap.notifyPixelsChanged();\n    *(SkPMColor*) bitmap.getPixels() = SkPreMultiplyColor(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 4, 0);\n}",
    "width": 256,
    "height": 20,
    "hash": "706e6409c8364e7786d6c69db7242c76",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::notifyPixelsChanged"
},
    "SkBitmap_readPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 256;\n    const int height = 32;\n    std::vector<int32_t> dstPixels;\n    dstPixels.resize(height * width * 4);\n    SkImageInfo info = SkImageInfo::MakeN32Premul(width, height);\n    SkColor  gradColors[] = { 0xFFAA3300, 0x7F881122 };\n    SkPoint  gradPoints[] = { { 0, 0 }, { width, 0 } };\n    SkPaint gradPaint;\n    gradPaint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,\n                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));\n    for (auto behavior : { SkTransferFunctionBehavior::kRespect,\n                           SkTransferFunctionBehavior::kIgnore} ) {\n        SkBitmap bitmap;\n        bitmap.allocPixels(info);\n        SkCanvas srcCanvas(bitmap);\n        srcCanvas.drawRect(SkRect::MakeWH(width, height), gradPaint);\n        if (bitmap.readPixels(info, &dstPixels.front(), width * 4, 0, 0, behavior)) {\n            SkPixmap dstPixmap(info, &dstPixels.front(), width * 4);\n            bitmap.installPixels(dstPixmap);\n            canvas->drawBitmap(bitmap, 0, 0);\n        }\n        canvas->translate(0, height);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "86fb9979516d256d71aa3f3f2182fe0c",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::readPixels"
},
    "SkBitmap_readPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 256;\n    const int height = 64;\n    SkImageInfo srcInfo = SkImageInfo::MakeN32Premul(width, height);\n    SkColor  gradColors[] = { 0xFFAA3300, 0x7F881122 };\n    SkPoint  gradPoints[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,\n                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));\n    SkBitmap bitmap;\n    bitmap.allocPixels(srcInfo);\n    SkCanvas srcCanvas(bitmap);\n    srcCanvas.drawRect(SkRect::MakeWH(width, height), paint);\n    canvas->drawBitmap(bitmap, 0, 0);\n    SkImageInfo dstInfo = srcInfo.makeColorType(kARGB_4444_SkColorType);\n    std::vector<int16_t> dstPixels;\n    dstPixels.resize(height * width);\n    bitmap.readPixels(dstInfo, &dstPixels.front(), width * 2, 0, 0);\n    SkPixmap dstPixmap(dstInfo, &dstPixels.front(), width * 2);\n    bitmap.installPixels(dstPixmap);\n    canvas->drawBitmap(bitmap, 0, 64);\n}",
    "width": 256,
    "height": 128,
    "hash": "b2cbbbbcffb618865d8aae3bc04b2a62",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::readPixels_2"
},
    "SkBitmap_readPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    srcPixels.resize(source.height() * source.rowBytes());\n    for (int y = 0; y < 4; ++y) {\n        for (int x = 0; x < 4; ++x) {\n            SkPixmap pixmap(SkImageInfo::MakeN32Premul(source.width() / 4, source.height() / 4),\n                    &srcPixels.front() + x * source.height() * source.width() / 4 +\n                    y * source.width() / 4, source.rowBytes());\n            source.readPixels(pixmap, x * source.width() / 4, y * source.height() / 4);\n        }\n    }\n    canvas->scale(.5f, .5f);\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(source.width(), source.height()),\n                             &srcPixels.front(), source.rowBytes());\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "e9f70cbc9827097449a386ec7a8a8188",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::readPixels_3"
},
    "SkBitmap_readPixels_4": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    srcPixels.resize(source.height() * source.width() * 8);\n    for (int i = 0;  i < 2; ++i) {\n    SkPixmap pixmap(SkImageInfo::Make(source.width() * 2, source.height(), \n                    i ? kRGBA_8888_SkColorType : kBGRA_8888_SkColorType, kPremul_SkAlphaType),\n                    &srcPixels.front() + i * source.width(), source.rowBytes() * 2);\n        source.readPixels(pixmap);\n    }\n    canvas->scale(.25f, .25f);\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(source.width() * 2, source.height()),\n                         &srcPixels.front(), source.rowBytes() * 2);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 128,
    "hash": "2260ff6d04708699b6223b4f73fd268e",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::readPixels_4"
},
    "SkBitmap_readyToDraw": {
    "code": "void draw(SkCanvas* canvas) {\n    if (source.readyToDraw()) {\n        canvas->drawBitmap(source, 10, 10);\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "e89c78ca992e2e789ed50944fe68f920",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::readyToDraw"
},
    "SkBitmap_setInfo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeN32(44, 16, kOpaque_SkAlphaType));\n    bitmap.allocPixels();\n    bitmap.eraseColor(SK_ColorGREEN);\n    SkCanvas offscreen(bitmap);\n    SkPaint paint;\n    offscreen.drawString(\"!@#$%\", 0, 12, paint);\n    canvas->scale(6, 6);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 96,
    "hash": "599ab64d0aea005498176249bbfb64eb",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setInfo"
},
    "SkBitmap_setIsVolatile": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap; \n    bitmap.setInfo(SkImageInfo::Make(1, 1, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));\n    bitmap.allocPixels();\n    bitmap.eraseColor(SK_ColorRED);\n    canvas->scale(16, 16);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *(SkPMColor*) bitmap.getPixels() = SkPreMultiplyColor(SK_ColorBLUE);\n    canvas->drawBitmap(bitmap, 2, 0);\n    bitmap.setIsVolatile(true);\n    *(SkPMColor*) bitmap.getPixels() = SkPreMultiplyColor(SK_ColorGREEN);\n    canvas->drawBitmap(bitmap, 4, 0);\n}",
    "width": 256,
    "height": 20,
    "hash": "9443ada07e6123fc895be4c958244218",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setIsVolatile"
},
    "SkBitmap_setPixelRef": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::Make(source.width() - 5, source.height() - 5, \n                   kGray_8_SkColorType, kOpaque_SkAlphaType), source.rowBytes());\n    bitmap.setPixelRef(sk_ref_sp(source.pixelRef()), 5, 5);\n    canvas->drawBitmap(bitmap, 10, 10);\n}",
    "width": 256,
    "height": 140,
    "hash": "13df9e5b1adcec33d11e4b0f8a91ecb8",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setPixelRef"
},
    "SkBitmap_setPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t set1[5] = { 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 };\n    uint8_t set2[5] = { 0xAC, 0xA8, 0x89, 0x47, 0x87 };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::Make(5, 1, kGray_8_SkColorType, kOpaque_SkAlphaType), set1, 5);\n    canvas->scale(10, 50);\n    canvas->drawBitmap(bitmap, 0, 0);\n    bitmap.setPixels(set2);\n    canvas->drawBitmap(bitmap, 10, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "f0db16e06c9a1436917c8179f8c1718f",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::setPixels"
},
    "SkBitmap_tryAllocN32Pixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    if (bitmap.tryAllocN32Pixels(80, 80)) {\n        bitmap.eraseColor(SK_ColorTRANSPARENT);\n        bitmap.erase(0x7f3f7fff, SkIRect::MakeWH(50, 30));\n        bitmap.erase(0x3f7fff3f, SkIRect::MakeXYWH(20, 10, 50, 30));\n        bitmap.erase(0x5fff3f7f, SkIRect::MakeXYWH(40, 20, 50, 30));\n        canvas->drawBitmap(bitmap, 0, 0);\n        for (int x : { 0, 30, 60, 90 } ) {\n            canvas->drawBitmap(bitmap, x, 70);\n        }\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "a2b1e0910f37066f15ae56368775a6d8",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocN32Pixels"
},
    "SkBitmap_tryAllocPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    SkImageInfo info = SkImageInfo::Make(64, 256, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    if (bitmap.tryAllocPixels(info, 0)) {\n        SkCanvas offscreen(bitmap);\n        offscreen.scale(.5f, .5f);\n        for (int x : { 0, 64, 128, 192 } ) {\n            offscreen.drawBitmap(source, -x, 0);\n            canvas->drawBitmap(bitmap, x, 0);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "34479d5aa23ce9f5e334b0786c9edb22",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocPixels"
},
    "SkBitmap_tryAllocPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    if (bitmap.tryAllocPixels(SkImageInfo::Make(64, 64, kGray_8_SkColorType, kOpaque_SkAlphaType))) {\n        SkCanvas offscreen(bitmap);\n        offscreen.scale(.25f, .5f);\n        for (int y : { 0, 64, 128, 192 } ) {\n            offscreen.drawBitmap(source, -y, -y);\n            canvas->drawBitmap(bitmap, y, y);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "7ef3d043c4c5885649e591dd7dca92ff",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocPixels_2"
},
    "SkBitmap_tryAllocPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t set1[5] = { 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::Make(5, 1, kGray_8_SkColorType, kOpaque_SkAlphaType), set1, 5);\n    canvas->scale(10, 50);\n    canvas->drawBitmap(bitmap, 0, 0);\n    if (bitmap.tryAllocPixels()) {\n        bitmap.eraseColor(SK_ColorBLACK);\n        canvas->drawBitmap(bitmap, 8, 0);\n        bitmap.setPixels(set1);\n        canvas->drawBitmap(bitmap, 16, 0);\n    }\n}",
    "width": 256,
    "height": 50,
    "hash": "720e4c053fae9e929ab6518b47e49370",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocPixels_3"
},
    "SkBitmap_tryAllocPixels_4": {
    "code": "class LargePixelRef : public SkPixelRef {\npublic:\n    LargePixelRef(const SkImageInfo& info, char* storage, size_t rowBytes)\n        : SkPixelRef(info.width(), info.height(), storage, rowBytes) {\n    }\n    ~LargePixelRef() override {\n        delete[] (char* ) this->pixels();\n    }\n};\nclass LargeAllocator : public SkBitmap::Allocator {\npublic:\n    bool allocPixelRef(SkBitmap* bitmap) override {\n        const SkImageInfo& info = bitmap->info();\n        uint64_t rowBytes = info.minRowBytes64();\n        uint64_t size = info.height() * rowBytes;\n        char* addr = new char[size];\n        if (nullptr == addr) {\n            return false;\n        }\n        sk_sp<SkPixelRef> pr = sk_sp<SkPixelRef>(new LargePixelRef(info, addr, rowBytes));\n        if (!pr) {\n            return false;\n        }\n        bitmap->setPixelRef(std::move(pr), 0, 0);\n        return true;\n    }\n};\n\nvoid draw(SkCanvas* canvas) {\n   LargeAllocator largeAllocator;\n   SkBitmap bitmap;\n   int width = 100; // make this 20000\n   int height = 100; // and this 100000 to allocate 8 gigs on a 64-bit platform\n   bitmap.setInfo(SkImageInfo::MakeN32(width, height, kOpaque_SkAlphaType));\n   if (bitmap.tryAllocPixels(&largeAllocator)) {\n       bitmap.eraseColor(0xff55aa33);\n       canvas->drawBitmap(bitmap, 0, 0);\n   }\n}\n",
    "width": 256,
    "height": 100,
    "hash": "eb6f861ca1839146d26e40d56c2a001c",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::tryAllocPixels_4"
},
    "SkBitmap_writePixels": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    int width = image->width();\n    int height = image->height();\n    srcPixels.resize(height * width  * 4);\n    SkPixmap pixmap(SkImageInfo::MakeN32Premul(width, height), (const void*) &srcPixels.front(),\n                    width * 4);\n    image->readPixels(pixmap, 0, 0);\n    canvas->scale(.5f, .5f);\n    width /= 4;\n    height /= 4;\n    for (int y = 0; y < 4; ++y) {\n        for (int x = 0; x < 4; ++x) {\n            SkBitmap bitmap;\n            bitmap.allocPixels(SkImageInfo::MakeN32Premul(width, height));\n            bitmap.writePixels(pixmap, -y * width, -x * height);\n            canvas->drawBitmap(bitmap, x * width, y * height);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "9b3133a6673d2514d166398adbe1f9f4",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::writePixels"
},
    "SkBitmap_writePixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(2, 2));\n    bitmap.eraseColor(SK_ColorGREEN);\n    SkPMColor color = 0xFF5599BB;\n    SkPixmap src(SkImageInfo::MakeN32Premul(1, 1), &color, 4);\n    bitmap.writePixels(src);\n    canvas->scale(40, 40);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 80,
    "hash": "faa5dfa466f6e16c07c124d971f32679",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::writePixels_2"
},
    "SkBitmap_writePixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    const int width = 256;\n    const int height = 32;\n    std::vector<int32_t> dstPixels;\n    dstPixels.resize(height * width * 4);\n    SkImageInfo info = SkImageInfo::MakeN32Premul(width, height);\n    SkColor  gradColors[] = { 0xFFAA3300, 0x7F881122 };\n    SkPoint  gradPoints[] = { { 0, 0 }, { width, 0 } };\n    SkPaint gradPaint;\n    gradPaint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,\n                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));\n    for (auto behavior : { SkTransferFunctionBehavior::kRespect,\n                           SkTransferFunctionBehavior::kIgnore} ) {\n        SkPixmap dstPixmap(info, &dstPixels.front(), width * 4);\n        SkBitmap bitmap;\n        bitmap.installPixels(dstPixmap);\n        SkCanvas srcCanvas(bitmap);\n        srcCanvas.drawRect(SkRect::MakeWH(width, height), gradPaint);\n        if (bitmap.writePixels(dstPixmap, 0, 0, behavior)) {\n            canvas->drawBitmap(bitmap, 0, 0);\n        }\n        canvas->translate(0, height);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "9f046f407b01b759cb737d702a994620",
    "file": "SkBitmap_Reference",
    "name": "SkBitmap::writePixels_3"
},
    "SkCanvas_PointMode": {
    "code": "void draw(SkCanvas* canvas) {\n  SkPaint paint;\n  paint.setStyle(SkPaint::kStroke_Style);\n  paint.setStrokeWidth(10);\n  SkPoint points[] = {{64, 32}, {96, 96}, {32, 96}};\n  canvas->drawPoints(SkCanvas::kPoints_PointMode, 3, points, paint);\n  canvas->translate(128, 0);\n  canvas->drawPoints(SkCanvas::kLines_PointMode, 3, points, paint);\n  canvas->translate(0, 128);\n  canvas->drawPoints(SkCanvas::kPolygon_PointMode, 3, points, paint);\n  SkPath path;\n  path.addPoly(points, 3, false);\n  canvas->translate(-128, 0);\n  canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "292b4b2008961b6f612434d3121fc4ce",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::PointMode"
},
    "SkCanvas_SaveLayerRec": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint redPaint, bluePaint;\n    redPaint.setAntiAlias(true);\n    redPaint.setColor(SK_ColorRED);\n    canvas->drawCircle(21, 21, 8, redPaint);\n    bluePaint.setColor(SK_ColorBLUE);\n    canvas->drawCircle(31, 21, 8, bluePaint);\n    SkMatrix matrix;\n    matrix.setScale(4, 4);\n    auto scaler = SkImageFilter::MakeMatrixFilter(matrix, kNone_SkFilterQuality, nullptr);\n    SkCanvas::SaveLayerRec saveLayerRec(nullptr, nullptr, scaler.get(), 0); \n    canvas->saveLayer(saveLayerRec);\n    canvas->drawCircle(125, 85, 8, redPaint);\n    canvas->restore();\n}\n",
    "width": 256,
    "height": 160,
    "hash": "7b18146582fc2440656b839a173ed500",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SaveLayerRec"
},
    "SkCanvas_SrcRectConstraint": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap redBorder;\n    redBorder.allocPixels(SkImageInfo::MakeN32Premul(4, 4));\n    SkCanvas checkRed(redBorder);\n    checkRed.clear(SK_ColorRED);\n    uint32_t checkers[][2] = { { SK_ColorBLACK, SK_ColorWHITE },\n                               { SK_ColorWHITE, SK_ColorBLACK } };\n    checkRed.writePixels(\n            SkImageInfo::MakeN32Premul(2, 2), (void*) checkers, sizeof(checkers[0]), 1, 1);\n    canvas->scale(16, 16);\n    canvas->drawBitmap(redBorder, 0, 0, nullptr);\n    canvas->resetMatrix();\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(redBorder);\n    SkPaint lowPaint;\n    lowPaint.setFilterQuality(kLow_SkFilterQuality);\n    for (auto constraint : { SkCanvas::kStrict_SrcRectConstraint,\n                             SkCanvas::kFast_SrcRectConstraint } ) {\n        canvas->translate(80, 0);\n        canvas->drawImageRect(image.get(), SkRect::MakeLTRB(1, 1, 3, 3),\n                SkRect::MakeLTRB(16, 16, 48, 48), &lowPaint, constraint);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "5df49d1f4da37275a1f10ef7f1a749f0",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::SrcRectConstraint"
},
    "SkCanvas__anonymous": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint redPaint, bluePaint, scalePaint;\n    redPaint.setColor(SK_ColorRED);\n    canvas->drawCircle(21, 21, 8, redPaint);\n    bluePaint.setColor(SK_ColorBLUE);\n    canvas->drawCircle(31, 21, 8, bluePaint);\n    SkMatrix matrix;\n    matrix.setScale(4, 4);\n    scalePaint.setAlpha(0x40);\n    scalePaint.setImageFilter(\n            SkImageFilter::MakeMatrixFilter(matrix, kNone_SkFilterQuality, nullptr));\n    SkCanvas::SaveLayerRec saveLayerRec(nullptr, &scalePaint,\n            SkCanvas::kInitWithPrevious_SaveLayerFlag); \n    canvas->saveLayer(saveLayerRec);\n    canvas->restore();\n}\n",
    "width": 256,
    "height": 160,
    "hash": "d314c688925d2c549d4762f5cc6e6a1a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::_anonymous"
},
    "SkCanvas_accessTopLayerPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    if (canvas->accessTopLayerPixels(nullptr, nullptr)) {\n         canvas->clear(SK_ColorRED);\n    } else {\n         canvas->clear(SK_ColorBLUE);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "38d0d6ca9bea146d31bcbec197856359",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::accessTopLayerPixels"
},
    "SkCanvas_accessTopLayerPixels_a": {
    "code": "void draw(SkCanvas* canvas) {\n  SkPaint paint;\n  paint.setTextSize(100);\n  canvas->drawString(\"ABC\", 20, 160, paint);\n  SkRect layerBounds = SkRect::MakeXYWH(32, 32, 192, 192);\n  canvas->saveLayerAlpha(&layerBounds, 128);\n  canvas->clear(SK_ColorWHITE);\n  canvas->drawString(\"DEF\", 20, 160, paint);\n  SkImageInfo imageInfo;\n  size_t rowBytes;\n  SkIPoint origin;\n  uint32_t* access = (uint32_t*) canvas->accessTopLayerPixels(&imageInfo, &rowBytes, &origin);\n  if (access) {\n    int h = imageInfo.height();\n    int v = imageInfo.width();\n    int rowWords = rowBytes / sizeof(uint32_t);\n    for (int y = 0; y < h; ++y) {\n        int newY = (y - h / 2) * 2 + h / 2;\n        if (newY < 0 || newY >= h) {\n            continue;\n        }\n        for (int x = 0; x < v; ++x) {\n            int newX = (x - v / 2) * 2 + v / 2;\n            if (newX < 0 || newX >= v) {\n                continue;\n            }\n            if (access[y * rowWords + x] == SK_ColorBLACK) {\n                access[newY * rowWords + newX] = SK_ColorGRAY;\n            }\n        }\n    }\n  }\n  canvas->restore();\n}\n",
    "width": 256,
    "height": 256,
    "hash": "a7ac9c21bbabcdeeca00f72a61cd0f3e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::accessTopLayerPixels_2"
},
    "SkCanvas_clear": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->save();\n    canvas->clipRect(SkRect::MakeWH(256, 128));\n    canvas->clear(SkColorSetARGB(0x80, 0xFF, 0x00, 0x00)); \n    canvas->restore();\n    canvas->save();\n    canvas->clipRect(SkRect::MakeWH(150, 192));\n    canvas->clear(SkColorSetARGB(0x80, 0x00, 0xFF, 0x00));\n    canvas->restore();\n    canvas->clipRect(SkRect::MakeWH(75, 256));\n    canvas->clear(SkColorSetARGB(0x80, 0x00, 0x00, 0xFF));\n}\n",
    "width": 256,
    "height": 256,
    "hash": "d97750e04989d42dc879406127b22c0b",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clear()"
},
    "SkCanvas_clipPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    path.addRect({20, 30, 100, 110});\n    path.setFillType(SkPath::kInverseWinding_FillType);\n    canvas->save();\n    canvas->clipPath(path, SkClipOp::kDifference, false);\n    canvas->drawCircle(70, 100, 60, paint);\n    canvas->restore();\n    canvas->translate(100, 100);\n    path.setFillType(SkPath::kWinding_FillType);\n    canvas->clipPath(path, SkClipOp::kIntersect, false);\n    canvas->drawCircle(70, 100, 60, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "ee47ae6b813bfaa55e1a7b7c053ed60d",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipPath"
},
    "SkCanvas_clipPath_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    path.addRect({20, 15, 100, 95});\n    path.addRect({50, 65, 130, 135});\n    path.setFillType(SkPath::kWinding_FillType);\n    canvas->save();\n    canvas->clipPath(path, SkClipOp::kIntersect);\n    canvas->drawCircle(70, 85, 60, paint);\n    canvas->restore();\n    canvas->translate(100, 100);\n    path.setFillType(SkPath::kEvenOdd_FillType);\n    canvas->clipPath(path, SkClipOp::kIntersect);\n    canvas->drawCircle(70, 85, 60, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "7856755c1bf8431c286c734b353345ad",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipPath_2"
},
    "SkCanvas_clipPath_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    SkPoint poly[] = {{20, 20}, { 80, 20}, { 80,  80}, {40,  80},\n                      {40, 40}, {100, 40}, {100, 100}, {20, 100}};\n    path.addPoly(poly, SK_ARRAY_COUNT(poly), true);\n    path.setFillType(SkPath::kWinding_FillType);\n    canvas->save();\n    canvas->clipPath(path, SkClipOp::kIntersect);\n    canvas->drawCircle(50, 50, 45, paint);\n    canvas->restore();\n    canvas->translate(100, 100);\n    path.setFillType(SkPath::kEvenOdd_FillType);\n    canvas->clipPath(path, SkClipOp::kIntersect);\n    canvas->drawCircle(50, 50, 45, paint);\n}\n",
    "width": 256,
    "height": 212,
    "hash": "187a7ae77a8176e417181411988534b6",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipPath_3"
},
    "SkCanvas_clipRRect": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(SK_ColorWHITE);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(0x8055aaff);\n    SkRRect oval;\n    oval.setOval({10, 20, 90, 100});\n    canvas->clipRRect(oval, SkClipOp::kIntersect, true);\n    canvas->drawCircle(70, 100, 60, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "182ef48ab5e04ba3578496fda8d9fa36",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRRect"
},
    "SkCanvas_clipRRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(0x8055aaff);\n    auto oval = SkRRect::MakeOval({10, 20, 90, 100});\n    canvas->clipRRect(oval, SkClipOp::kIntersect);\n    canvas->drawCircle(70, 100, 60, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "ef6ae2eaae6761130ce38065d0364abd",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRRect_2"
},
    "SkCanvas_clipRRect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    auto oval = SkRRect::MakeRectXY({10, 20, 90, 100}, 9, 13);\n    canvas->clipRRect(oval, true);\n    canvas->drawCircle(70, 100, 60, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "f583114580b2176fe3e75b0994476a84",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRRect_3"
},
    "SkCanvas_clipRect": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->rotate(10);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    for (auto alias: { false, true } ) {\n        canvas->save();\n        canvas->clipRect(SkRect::MakeWH(90, 80), SkClipOp::kIntersect, alias);\n        canvas->drawCircle(100, 60, 60, paint);\n        canvas->restore();\n        canvas->translate(80, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "6a614faa0fbcf19958b5559c19b02d0f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRect"
},
    "SkCanvas_clipRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    for (SkClipOp op: { SkClipOp::kIntersect, SkClipOp::kDifference } ) {\n        canvas->save();\n        canvas->clipRect(SkRect::MakeWH(90, 120), op, false);\n        canvas->drawCircle(100, 100, 60, paint);\n        canvas->restore();\n        canvas->translate(80, 0);\n    }\n}\n",
    "width": 280,
    "height": 192,
    "hash": "13bbc5fa5597a6cd4d704b419dbc66d9",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRect_2"
},
    "SkCanvas_clipRect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(SK_ColorWHITE);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(0x8055aaff);\n    SkRect clipRect = { 0, 0, 87.4f, 87.4f };\n    for (auto alias: { false, true } ) {\n        canvas->save();\n        canvas->clipRect(clipRect, SkClipOp::kIntersect, alias);\n        canvas->drawCircle(67, 67, 60, paint);\n        canvas->restore();\n        canvas->save();\n        canvas->clipRect(clipRect, SkClipOp::kDifference, alias);\n        canvas->drawCircle(67, 67, 60, paint);\n        canvas->restore();\n        canvas->translate(120, 0);\n    }\n}\n",
    "width": 256,
    "height": 133,
    "hash": "1d4e0632c97e42692775d834fe10aa99",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRect_3"
},
    "SkCanvas_clipRegion": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkIRect iRect = {30, 40, 120, 130 };\n    SkRegion region(iRect);\n    canvas->rotate(10);\n    canvas->save();\n    canvas->clipRegion(region, SkClipOp::kIntersect);\n    canvas->drawCircle(50, 50, 45, paint);\n    canvas->restore();\n    canvas->translate(100, 100);\n    canvas->clipRect(SkRect::Make(iRect), SkClipOp::kIntersect);\n    canvas->drawCircle(50, 50, 45, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "7bb57c0e456c5fda2c2cca4abb68b19e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::clipRegion"
},
    "SkCanvas_concat": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(80);\n    paint.setTextScaleX(.3);\n    SkMatrix matrix;\n    SkRect rect[2] = {{ 10, 20, 90, 110 }, { 40, 130, 140, 180 }};\n    matrix.setRectToRect(rect[0], rect[1], SkMatrix::kFill_ScaleToFit);\n    canvas->drawRect(rect[0], paint);\n    canvas->drawRect(rect[1], paint);\n    paint.setColor(SK_ColorWHITE);\n    canvas->drawString(\"Here\", rect[0].fLeft + 10, rect[0].fBottom - 10, paint);\n    canvas->concat(matrix);\n    canvas->drawString(\"There\", rect[0].fLeft + 10, rect[0].fBottom - 10, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8f6818b25a92a88638ad99b2dd293f61",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::concat()"
},
    "SkCanvas_destructor": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(200, 200));\n    {\n        SkCanvas offscreen(bitmap);\n        SkPaint paint;\n        paint.setTextSize(100);\n        offscreen.drawString(\"ABC\", 20, 160, paint);\n        SkRect layerBounds = SkRect::MakeXYWH(32, 32, 192, 192);\n        offscreen.saveLayerAlpha(&layerBounds, 128);\n        offscreen.clear(SK_ColorWHITE);\n        offscreen.drawString(\"DEF\", 20, 160, paint);\n    }\n    canvas->drawBitmap(bitmap, 0, 0, nullptr);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "b7bc91ff16c9b9351b2a127f35394b82",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::~SkCanvas()"
},
    "SkCanvas_drawAnnotation": {
    "code": "void draw(SkCanvas* canvas) {\n    const char text[] = \"Click this link!\";\n    SkRect bounds;\n    SkPaint paint;\n    paint.setTextSize(40);\n    (void)paint.measureText(text, strlen(text), &bounds);\n    const char url[] = \"https://www.google.com/\";\n    sk_sp<SkData> urlData(SkData::MakeWithCString(url));\n    canvas->drawAnnotation(bounds, \"url_key\", urlData.get());\n}",
    "width": 256,
    "height": 1,
    "hash": "00b430bd80d740e19c6d020a940f56d5",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAnnotation"
},
    "SkCanvas_drawAnnotation_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const char text[] = \"Click this link!\";\n    SkRect bounds;\n    SkPaint paint;\n    paint.setTextSize(40);\n    (void)paint.measureText(text, strlen(text), &bounds);\n    const char url[] = \"https://www.google.com/\";\n    sk_sp<SkData> urlData(SkData::MakeWithCString(url));\n    canvas->drawAnnotation(bounds, \"url_key\", urlData.get());\n}",
    "width": 256,
    "height": 1,
    "hash": "00b430bd80d740e19c6d020a940f56d5",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAnnotation_2"
},
    "SkCanvas_drawArc": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRect oval = { 4, 4, 60, 60};\n    for (auto useCenter : { false, true } ) {\n        for (auto style : { SkPaint::kFill_Style, SkPaint::kStroke_Style } ) {\n            paint.setStyle(style);\n            for (auto degrees : { 45, 90, 180, 360} ) {\n                canvas->drawArc(oval, 0, degrees , useCenter, paint);\n                canvas->translate(64, 0);\n            }\n            canvas->translate(-256, 64);\n        }\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "11f0fbe7b30d776913c2e7c92c02ff57",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawArc"
},
    "SkCanvas_drawArc_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(4);\n    SkRect oval = { 4, 4, 60, 60};\n    float intervals[] = { 5, 5 };\n    paint.setPathEffect(SkDashPathEffect::Make(intervals, 2, 2.5f));\n    for (auto degrees : { 270, 360, 540, 720 } ) {\n        canvas->drawArc(oval, 0, degrees, false, paint);\n        canvas->translate(64, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "e91dbe45974489b8962c815017b7914f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawArc_2"
},
    "SkCanvas_drawAtlas": {
    "code": "void draw(SkCanvas* canvas) {\n  // SkBitmap source = mandrill;\n  SkRSXform xforms[] = { { .5f, 0, 0, 0 }, {0, .5f, 200, 100 } };\n  SkRect tex[] = { { 0, 0, 250, 250 }, { 0, 0, 250, 250 } };\n  SkColor colors[] = { 0x7f55aa00, 0x7f3333bf };\n  const SkImage* imagePtr = image.get();\n  canvas->drawAtlas(imagePtr, xforms, tex, colors, 2, SkBlendMode::kSrcOver, nullptr, nullptr);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "1df575f9b8132306ce0552a2554ed132",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAtlas"
},
    "SkCanvas_drawAtlas_2": {
    "code": "void draw(SkCanvas* canvas) {\n  // SkBitmap source = mandrill;\n  SkRSXform xforms[] = { { .5f, 0, 0, 0 }, {0, .5f, 200, 100 } };\n  SkRect tex[] = { { 0, 0, 250, 250 }, { 0, 0, 250, 250 } };\n  SkColor colors[] = { 0x7f55aa00, 0x7f3333bf };\n  SkPaint paint;\n  paint.setAlpha(127);\n  canvas->drawAtlas(image, xforms, tex, colors, 2, SkBlendMode::kPlus, nullptr, &paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "0e66a8f230a8d531bcef9f5ebdc5aac1",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAtlas_2"
},
    "SkCanvas_drawAtlas_3": {
    "code": "void draw(SkCanvas* canvas) {\n  // sk_sp<SkImage> image = mandrill;\n  SkRSXform xforms[] = { { .5f, 0, 0, 0 }, {0, .5f, 200, 100 } };\n  SkRect tex[] = { { 0, 0, 250, 250 }, { 0, 0, 250, 250 } };\n  const SkImage* imagePtr = image.get();\n  canvas->drawAtlas(imagePtr, xforms, tex, 2, nullptr, nullptr);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8dc0d0fdeab20bbc21cac6874ddbefcd",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAtlas_3"
},
    "SkCanvas_drawAtlas_4": {
    "code": "void draw(SkCanvas* canvas) {\n  // sk_sp<SkImage> image = mandrill;\n  SkRSXform xforms[] = { { 1, 0, 0, 0 }, {0, 1, 300, 100 } };\n  SkRect tex[] = { { 0, 0, 200, 200 }, { 200, 0, 400, 200 } };\n  canvas->drawAtlas(image, xforms, tex, 2, nullptr, nullptr);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "c093c2b14bd3e6171ede7cd4049d9b57",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawAtlas_4"
},
    "SkCanvas_drawBitmap": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t pixels[][8] = { { 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00},\n                            { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00},\n                            { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},\n                            { 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF},\n                            { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n                            { 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00},\n                            { 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00},\n                            { 0xFF, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeA8(8, 8), \n            (void*) pixels, sizeof(pixels[0]));\n    SkPaint paint;\n    canvas->scale(4, 4);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xFF007F00} ) {\n        paint.setColor(color);\n        canvas->drawBitmap(bitmap, 0, 0, &paint);\n        canvas->translate(12, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "70d7fbf7de82264dd66a526d98d31def",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmap"
},
    "SkCanvas_drawBitmapLattice": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect center = { 20, 10, 50, 40 };\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(60, 60));\n    SkCanvas bitCanvas(bitmap);\n    SkPaint paint;\n    SkColor gray = 0xFF000000;\n    int left = 0;\n    for (auto right: { center.fLeft, center.fRight, bitmap.width() } ) {\n        int top = 0;\n        for (auto bottom: { center.fTop, center.fBottom, bitmap.height() } ) {\n            paint.setColor(gray);\n            bitCanvas.drawIRect(SkIRect::MakeLTRB(left, top, right, bottom), paint);\n            gray += 0x001f1f1f;\n            top = bottom;\n        }\n        left = right; \n    }\n    const int xDivs[] = { center.fLeft, center.fRight };\n    const int yDivs[] = { center.fTop, center.fBottom };\n    SkCanvas::Lattice::RectType fillTypes[3][3];\n    memset(fillTypes, 0, sizeof(fillTypes));\n    fillTypes[1][1] = SkCanvas::Lattice::kTransparent;\n    SkColor dummy[9];  // temporary pending bug fix\n    SkCanvas::Lattice lattice = { xDivs, yDivs, fillTypes[0], SK_ARRAY_COUNT(xDivs),\n         SK_ARRAY_COUNT(yDivs), nullptr, dummy };\n    for (auto dest: { 20, 30, 40, 60, 90 } ) {\n        canvas->drawBitmapLattice(bitmap, lattice, SkRect::MakeWH(dest, 110 - dest), nullptr);\n        canvas->translate(dest + 4, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "7a02b16a4cc8158d88858a76907c9d89",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmapLattice"
},
    "SkCanvas_drawBitmapNine": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect center = { 20, 10, 50, 40 };\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(60, 60));\n    SkCanvas bitCanvas(bitmap);\n    SkPaint paint;\n    SkColor gray = 0xFF000000;\n    int left = 0;\n    for (auto right: { center.fLeft, center.fRight, bitmap.width() } ) {\n        int top = 0;\n        for (auto bottom: { center.fTop, center.fBottom, bitmap.height() } ) {\n            paint.setColor(gray);\n            bitCanvas.drawIRect(SkIRect::MakeLTRB(left, top, right, bottom), paint);\n            gray += 0x001f1f1f;\n            top = bottom;\n        }\n        left = right; \n    }\n    for (auto dest: { 20, 30, 40, 60, 90 } ) {\n        canvas->drawBitmapNine(bitmap, center, SkRect::MakeWH(dest, 110 - dest), nullptr);\n        canvas->translate(dest + 4, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "a4a30aa10e566a85fe6f6cad2ff9935b",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmapNine"
},
    "SkCanvas_drawBitmapRect": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t pixels[][8] = { { 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00},\n                            { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00},\n                            { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},\n                            { 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF},\n                            { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n                            { 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00},\n                            { 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00},\n                            { 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeA8(8, 8), \n            (void*) pixels, sizeof(pixels[0]));\n    SkPaint paint;\n    paint.setMaskFilter(SkBlurMaskFilter::Make(kSolid_SkBlurStyle, 6));\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xFF007F00} ) {\n        paint.setColor(color);\n        canvas->drawBitmapRect(bitmap, SkRect::MakeWH(8, 8), SkRect::MakeWH(32, 32), &paint);\n        canvas->translate(48, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "de449106e78ec558d9921b9f076de164",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmapRect"
},
    "SkCanvas_drawBitmapRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t pixels[][8] = { { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00},\n                            { 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00},\n                            { 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0xFF},\n                            { 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0xFF},\n                            { 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF},\n                            { 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF},\n                            { 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00},\n                            { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeA8(8, 8), \n            (void*) pixels, sizeof(pixels[0]));\n    SkPaint paint;\n    paint.setFilterQuality(kHigh_SkFilterQuality);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xFF007F00, 0xFF7f007f} ) {\n        paint.setColor(color);\n        canvas->drawBitmapRect(bitmap, SkIRect::MakeWH(8, 8), SkRect::MakeWH(32, 32), &paint);\n        canvas->translate(48.25f, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "69b028ef1f95c355672fbdcbf47550f2",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmapRect_2"
},
    "SkCanvas_drawBitmapRect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t pixels[][2] = { { 0x00000000, 0x55550000},\n                             { 0xAAAA0000, 0xFFFF0000} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(2, 2), \n            (void*) pixels, sizeof(pixels[0]));\n    SkPaint paint;\n    canvas->scale(4, 4);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN } ) {\n        paint.setColorFilter(SkColorFilter::MakeModeFilter(color, SkBlendMode::kPlus));\n        canvas->drawBitmapRect(bitmap, SkRect::MakeWH(8, 8), &paint);\n        canvas->translate(8, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "76b74b826e43b4a595d18115564e88c7",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawBitmapRect_3"
},
    "SkCanvas_drawCircle": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawCircle(128, 128, 90, paint);\n    paint.setColor(SK_ColorWHITE);\n    canvas->drawCircle(86, 86, 20, paint);\n    canvas->drawCircle(160, 76, 20, paint);\n    canvas->drawCircle(140, 150, 35, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "841229e25ca9dfb68bd0dc4dfff356eb",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawCircle"
},
    "SkCanvas_drawCircle_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    canvas->drawCircle(128, 128, 90, paint);\n    paint.setColor(SK_ColorWHITE);\n    canvas->drawCircle({86, 86}, 20, paint);\n    canvas->drawCircle({160, 76}, 20, paint);\n    canvas->drawCircle({140, 150}, 35, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "9303ffae45ddd0b0a1f93d816a1762f4",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawCircle_2"
},
    "SkCanvas_drawColor": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->drawColor(SK_ColorRED);\n    canvas->clipRect(SkRect::MakeWH(150, 150));\n    canvas->drawColor(SkColorSetARGB(0x80, 0x00, 0xFF, 0x00), SkBlendMode::kPlus);\n    canvas->clipRect(SkRect::MakeWH(75, 75));\n    canvas->drawColor(SkColorSetARGB(0x80, 0x00, 0x00, 0xFF), SkBlendMode::kPlus);\n}",
    "width": 256,
    "height": 256,
    "hash": "9cf94fead1e6b17d836c704b4eac269a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawColor"
},
    "SkCanvas_drawDRRect": {
    "code": "void draw(SkCanvas* canvas) {\n   SkRRect outer = SkRRect::MakeRect({20, 40, 210, 200});\n   SkRRect inner = SkRRect::MakeOval({60, 70, 170, 160});\n   SkPaint paint;\n   canvas->drawDRRect(outer, inner, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "02e33141f13da2f19aef7feb7117b541",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawDRRect"
},
    "SkCanvas_drawDRRect_a": {
    "code": "void draw(SkCanvas* canvas) {\n   SkRRect outer = SkRRect::MakeRect({20, 40, 210, 200});\n   SkRRect inner = SkRRect::MakeRectXY({60, 70, 170, 160}, 10, 10);\n   SkPaint paint;\n   paint.setAntiAlias(true);\n   paint.setStyle(SkPaint::kStroke_Style);\n   paint.setStrokeWidth(20);\n   paint.setStrokeJoin(SkPaint::kRound_Join);\n   canvas->drawDRRect(outer, inner, paint);\n   paint.setStrokeWidth(1);\n   paint.setColor(SK_ColorWHITE);\n   canvas->drawDRRect(outer, inner, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "30823cb4edf884d330285ea161664931",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawDRRect_2"
},
    "SkCanvas_drawDrawable": {
    "code": "struct MyDrawable : public SkDrawable {\n    SkRect onGetBounds() override { return SkRect::MakeWH(50, 100);  }\n    void onDraw(SkCanvas* canvas) override {\n       SkPath path;\n       path.conicTo(10, 90, 50, 90, 0.9f);\n       SkPaint paint;\n       paint.setColor(SK_ColorBLUE);\n       canvas->drawRect(path.getBounds(), paint);\n       paint.setAntiAlias(true);\n       paint.setColor(SK_ColorWHITE);\n       canvas->drawPath(path, paint);\n    }\n};\n\nvoid draw(SkCanvas* canvas) {\n    sk_sp<SkDrawable> drawable(new MyDrawable);\n  SkMatrix matrix;\n  matrix.setTranslate(10, 10);\n  canvas->drawDrawable(drawable.get(), &matrix);\n}\n",
    "width": 256,
    "height": 100,
    "hash": "3a4dfcd08838866b5cfc0d82489195ba",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawDrawable"
},
    "SkCanvas_drawDrawable_2": {
    "code": "struct MyDrawable : public SkDrawable {\n    SkRect onGetBounds() override { return SkRect::MakeWH(50, 100);  }\n    void onDraw(SkCanvas* canvas) override {\n       SkPath path;\n       path.conicTo(10, 90, 50, 90, 0.9f);\n       SkPaint paint;\n       paint.setColor(SK_ColorBLUE);\n       canvas->drawRect(path.getBounds(), paint);\n       paint.setAntiAlias(true);\n       paint.setColor(SK_ColorWHITE);\n       canvas->drawPath(path, paint);\n    }\n};\n\nvoid draw(SkCanvas* canvas) {\n    sk_sp<SkDrawable> drawable(new MyDrawable);\n  canvas->drawDrawable(drawable.get(), 10, 10);\n}\n",
    "width": 256,
    "height": 100,
    "hash": "1bdc07ad3b154c89b771722c2fcaee3f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawDrawable_2"
},
    "SkCanvas_drawIRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect rect = { 64, 48, 192, 160 };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    paint.setStrokeJoin(SkPaint::kRound_Join);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorYELLOW, SK_ColorMAGENTA } ) {\n        paint.setColor(color);\n        canvas->drawIRect(rect, paint);\n        canvas->rotate(30, 128, 128);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "d3d8ca584134560750b1efa4a4c6e138",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawIRect"
},
    "SkCanvas_drawImage": {
    "code": "void draw(SkCanvas* canvas) {\n   // sk_sp<SkImage> image;\n   SkImage* imagePtr = image.get();\n   canvas->drawImage(imagePtr, 0, 0);\n   SkPaint paint;\n   canvas->drawImage(imagePtr, 80, 0, &paint);\n   paint.setAlpha(0x80);\n   canvas->drawImage(imagePtr, 160, 0, &paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "185746dc0faa6f1df30c4afe098646ff",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImage"
},
    "SkCanvas_drawImageLattice": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect center = { 20, 10, 50, 40 };\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(60, 60));\n    SkCanvas bitCanvas(bitmap);\n    SkPaint paint;\n    SkColor gray = 0xFF000000;\n    int left = 0;\n    for (auto right: { center.fLeft, center.fRight, bitmap.width() } ) {\n        int top = 0;\n        for (auto bottom: { center.fTop, center.fBottom, bitmap.height() } ) {\n            paint.setColor(gray);\n            bitCanvas.drawIRect(SkIRect::MakeLTRB(left, top, right, bottom), paint);\n            gray += 0x001f1f1f;\n            top = bottom;\n        }\n        left = right; \n    }\n    const int xDivs[] = { center.fLeft, center.fRight };\n    const int yDivs[] = { center.fTop, center.fBottom };\n    SkCanvas::Lattice::RectType fillTypes[3][3];\n    memset(fillTypes, 0, sizeof(fillTypes));  \n    fillTypes[1][1] = SkCanvas::Lattice::kTransparent;\n    SkColor dummy[9];  // temporary pending bug fix\n    SkCanvas::Lattice lattice = { xDivs, yDivs, fillTypes[0], SK_ARRAY_COUNT(xDivs),\n         SK_ARRAY_COUNT(yDivs), nullptr, dummy };\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkImage* imagePtr = image.get();\n    for (auto dest: { 20, 30, 40, 60, 90 } ) {\n        canvas->drawImageNine(imagePtr, center, SkRect::MakeWH(dest, dest), nullptr);\n        canvas->translate(dest + 4, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "75f43f11c6bd58175071b8b54ebec676",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageLattice"
},
    "SkCanvas_drawImageNine": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect center = { 20, 10, 50, 40 };\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(60, 60));\n    SkCanvas bitCanvas(bitmap);\n    SkPaint paint;\n    SkColor gray = 0xFF000000;\n    int left = 0;\n    for (auto right: { center.fLeft, center.fRight, bitmap.width() } ) {\n        int top = 0;\n        for (auto bottom: { center.fTop, center.fBottom, bitmap.height() } ) {\n            paint.setColor(gray);\n            bitCanvas.drawIRect(SkIRect::MakeLTRB(left, top, right, bottom), paint);\n            gray += 0x001f1f1f;\n            top = bottom;\n        }\n        left = right; \n    }\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkImage* imagePtr = image.get();\n    for (auto dest: { 20, 30, 40, 60, 90 } ) {\n        canvas->drawImageNine(imagePtr, center, SkRect::MakeWH(dest, dest), nullptr);\n        canvas->translate(dest + 4, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "47f78f3f70ccd9e6c40ee3203a5c71dd",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageNine"
},
    "SkCanvas_drawImageNine_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect center = { 20, 10, 50, 40 };\n    SkBitmap bitmap;\n    bitmap.allocPixels(SkImageInfo::MakeN32Premul(60, 60));\n    SkCanvas bitCanvas(bitmap);\n    SkPaint paint;\n    SkColor gray = 0xFF000000;\n    int left = 0;\n    for (auto right: { center.fLeft, center.fRight, bitmap.width() } ) {\n        int top = 0;\n        for (auto bottom: { center.fTop, center.fBottom, bitmap.height() } ) {\n            paint.setColor(gray);\n            bitCanvas.drawIRect(SkIRect::MakeLTRB(left, top, right, bottom), paint);\n            gray += 0x001f1f1f;\n            top = bottom;\n        }\n        left = right; \n    }\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    for (auto dest: { 20, 30, 40, 60, 90 } ) {\n        canvas->drawImageNine(image, center, SkRect::MakeWH(dest, 110 - dest), nullptr);\n        canvas->translate(dest + 4, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "e941e553970569d1ffb03a42f7fcd6d9",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageNine_2"
},
    "SkCanvas_drawImageRect": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t pixels[][4] = { \n            { 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000 },\n            { 0xFFFF0000, 0xFF000000, 0xFFFFFFFF, 0xFFFF0000 },\n            { 0xFFFF0000, 0xFFFFFFFF, 0xFF000000, 0xFFFF0000 },\n            { 0xFFFF0000, 0xFFFF0000, 0xFFFF0000, 0xFFFF0000 } };\n    SkBitmap redBorder;\n    redBorder.installPixels(SkImageInfo::MakeN32Premul(4, 4), \n            (void*) pixels, sizeof(pixels[0]));\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(redBorder);\n    SkPaint lowPaint;\n    for (auto constraint : {\n            SkCanvas::kFast_SrcRectConstraint,\n            SkCanvas::kStrict_SrcRectConstraint,\n            SkCanvas::kFast_SrcRectConstraint } ) {\n        canvas->drawImageRect(image.get(), SkRect::MakeLTRB(1, 1, 3, 3),\n                SkRect::MakeLTRB(16, 16, 48, 48), &lowPaint, constraint);\n        lowPaint.setFilterQuality(kLow_SkFilterQuality);\n        canvas->translate(80, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "2b01c707ef8b5ce3023b7a1d55fce059",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect"
},
    "SkCanvas_drawImageRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    // sk_sp<SkImage> image;\n    for (auto i : { 1, 2, 4, 8 } ) {\n        canvas->drawImageRect(image.get(), SkIRect::MakeLTRB(0, 0, 100, 100), \n                SkRect::MakeXYWH(i * 20, i * 20, i * 20, i * 20), nullptr);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "b63b8f9f587b8d918973dc065ce4a593",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect_2"
},
    "SkCanvas_drawImageRect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    // sk_sp<SkImage> image;\n    for (auto i : { 20, 40, 80, 160 } ) {\n        canvas->drawImageRect(image.get(), SkRect::MakeXYWH(i, i, i, i), nullptr);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "3cf8fb639fef99993cafc064d550c739",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect_3"
},
    "SkCanvas_drawImageRect_4": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t pixels[][2] = { { SK_ColorBLACK, SK_ColorWHITE },\n                             { SK_ColorWHITE, SK_ColorBLACK } };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(2, 2), \n            (void*) pixels, sizeof(pixels[0]));\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkPaint paint;\n    canvas->scale(4, 4);\n    for (auto alpha : { 50, 100, 150, 255 } ) {\n        paint.setAlpha(alpha);\n        canvas->drawImageRect(image, SkRect::MakeWH(2, 2), SkRect::MakeWH(8, 8), &paint);\n        canvas->translate(8, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "589999454db90c573f7facfb007253a7",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect_4"
},
    "SkCanvas_drawImageRect_5": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t pixels[][2] = { { 0x00000000, 0x55555555},\n                             { 0xAAAAAAAA, 0xFFFFFFFF} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(2, 2), \n            (void*) pixels, sizeof(pixels[0]));\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkPaint paint;\n    canvas->scale(4, 4);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN } ) {\n        paint.setColorFilter(SkColorFilter::MakeModeFilter(color, SkBlendMode::kPlus));\n        canvas->drawImageRect(image, SkIRect::MakeWH(2, 2), SkRect::MakeWH(8, 8), &paint);\n        canvas->translate(8, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "249fadde5d0d0fc515e9f53f188af48b",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect_5"
},
    "SkCanvas_drawImageRect_6": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t pixels[][2] = { { 0x00000000, 0x55550000},\n                             { 0xAAAA0000, 0xFFFF0000} };\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(2, 2), \n            (void*) pixels, sizeof(pixels[0]));\n    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);\n    SkPaint paint;\n    canvas->scale(4, 4);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorGREEN } ) {\n        paint.setColorFilter(SkColorFilter::MakeModeFilter(color, SkBlendMode::kPlus));\n        canvas->drawImageRect(image, SkRect::MakeWH(8, 8), &paint);\n        canvas->translate(8, 0);\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "37a85bd2247487c7af584e42c1cabe4a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImageRect_6"
},
    "SkCanvas_drawImage_2": {
    "code": "void draw(SkCanvas* canvas) {\n   // sk_sp<SkImage> image;\n   canvas->drawImage(image, 0, 0);\n   SkPaint paint;\n   canvas->drawImage(image, 80, 0, &paint);\n   paint.setAlpha(0x80);\n   canvas->drawImage(image, 160, 0, &paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "a4e877e891b1be5faa2b7fd07f673a10",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawImage_2"
},
    "SkCanvas_drawLine": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(0xFF9a67be);\n    paint.setStrokeWidth(20);\n    canvas->skew(1, 0);\n    canvas->drawLine(32, 96, 32, 160, paint);\n    canvas->skew(-2, 0);\n    canvas->drawLine(288, 96, 288, 160, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "d10ee4a265f278d02afe11ad889b293b",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawLine"
},
    "SkCanvas_drawLine_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(0xFF9a67be);\n    paint.setStrokeWidth(20);\n    canvas->skew(1, 0);\n    canvas->drawLine({32, 96}, {32, 160}, paint);\n    canvas->skew(-2, 0);\n    canvas->drawLine({288, 96}, {288, 160}, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "f8525816cb596dde1a3855446792c8e0",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawLine_2"
},
    "SkCanvas_drawOval": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(0xFF3f5f9f);\n    SkColor  kColor1 = SkColorSetARGB(0xff, 0xff, 0x7f, 0);\n    SkColor  g1Colors[] = { kColor1, SkColorSetA(kColor1, 0x20) };\n    SkPoint  g1Points[] = { { 0, 0 }, { 0, 100 } };\n    SkScalar pos[] = { 0.2f, 1.0f };\n    SkRect bounds = SkRect::MakeWH(80, 70);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setShader(SkGradientShader::MakeLinear(g1Points, g1Colors, pos, SK_ARRAY_COUNT(g1Colors),\n            SkShader::kClamp_TileMode));\n    canvas->drawOval(bounds , paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8b6b86f8a022811cd29a9c6ab771df12",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawOval"
},
    "SkCanvas_drawPaint": {
    "code": "void draw(SkCanvas* canvas) {\n    SkColor     colors[] = { SK_ColorRED, SK_ColorGREEN, SK_ColorBLUE };\n    SkScalar    pos[] = { 0, SK_Scalar1/2, SK_Scalar1 };\n    SkPaint     paint;\n    paint.setShader(SkGradientShader::MakeSweep(256, 256, colors, pos, SK_ARRAY_COUNT(colors)));\n    canvas->drawPaint(paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "1cd076b9b1a7c976cdca72b93c4f42dd",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPaint"
},
    "SkCanvas_drawPatch": {
    "code": "void draw(SkCanvas* canvas) {\n    // SkBitmap source = cmbkygk;\n    SkPaint paint;\n    paint.setFilterQuality(kLow_SkFilterQuality);\n    paint.setAntiAlias(true);\n    SkPoint cubics[] = { { 3, 1 },    { 4, 2 }, { 5, 1 },    { 7, 3 },\n                      /* { 7, 3 }, */ { 6, 4 }, { 7, 5 },    { 5, 7 },\n                      /* { 5, 7 }, */ { 4, 6 }, { 3, 7 },    { 1, 5 },\n                      /* { 1, 5 }, */ { 2, 4 }, { 1, 3 }, /* { 3, 1 } */ };\n    SkColor colors[] = { 0xbfff0000, 0xbf0000ff, 0xbfff00ff, 0xbf00ffff };\n    SkPoint texCoords[] = { { -30, -30 }, { 162, -30}, { 162, 162}, { -30, 162} };\n    paint.setShader(SkShader::MakeBitmapShader(source, SkShader::kClamp_TileMode,\n                                                       SkShader::kClamp_TileMode, nullptr));\n    canvas->scale(15, 15);\n    for (auto blend : { SkBlendMode::kSrcOver, SkBlendMode::kModulate, SkBlendMode::kXor } ) {\n        canvas->drawPatch(cubics, colors, texCoords, blend, paint);\n        canvas->translate(4, 4);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "accb545d67984ced168f5be6ab824795",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPatch"
},
    "SkCanvas_drawPatch_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint cubics[] = { { 3, 1 },    { 4, 2 }, { 5, 1 },    { 7, 3 },\n                      /* { 7, 3 }, */ { 6, 4 }, { 7, 5 },    { 5, 7 },\n                      /* { 5, 7 }, */ { 4, 6 }, { 3, 7 },    { 1, 5 },\n                      /* { 1, 5 }, */ { 2, 4 }, { 1, 3 }, /* { 3, 1 } */ };\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE, SK_ColorYELLOW, SK_ColorCYAN };\n    canvas->scale(30, 30);\n    canvas->drawPatch(cubics, colors, nullptr, paint);\n    SkPoint text[] = { {3,0.9f}, {4,2.5f}, {5,0.9f}, {7.5f,3.2f}, {5.5f,4.2f},\n            {7.5f,5.2f}, {5,7.5f}, {4,5.9f}, {3,7.5f}, {0.5f,5.2f}, {2.5f,4.2f},\n            {0.5f,3.2f} };\n    paint.setTextSize(18.f / 30);\n    paint.setTextAlign(SkPaint::kCenter_Align);\n    for (int i = 0; i< 10; ++i) {\n       char digit = '0' + i;\n       canvas->drawText(&digit, 1, text[i].fX, text[i].fY, paint);\n    }\n    canvas->drawString(\"10\", text[10].fX, text[10].fY, paint);\n    canvas->drawString(\"11\", text[11].fX, text[11].fY, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, 12, cubics, paint);\n    canvas->drawLine(cubics[11].fX, cubics[11].fY, cubics[0].fX, cubics[0].fY, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "4cf70f8d194867d053d7e177e5088445",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPatch_2"
},
    "SkCanvas_drawPatch_2_a": {
    "code": "void draw(SkCanvas* canvas) {\n    // SkBitmap source = checkerboard;\n    SkPaint paint;\n    paint.setFilterQuality(kLow_SkFilterQuality);\n    paint.setAntiAlias(true);\n    SkPoint cubics[] = { { 3, 1 },    { 4, 2 }, { 5, 1 },    { 7, 3 },\n                      /* { 7, 3 }, */ { 6, 4 }, { 7, 5 },    { 5, 7 },\n                      /* { 5, 7 }, */ { 4, 6 }, { 3, 7 },    { 1, 5 },\n                      /* { 1, 5 }, */ { 2, 4 }, { 1, 3 }, /* { 3, 1 } */ };\n    SkPoint texCoords[] = { { 0, 0 }, { 0, 62}, { 62, 62}, { 62, 0 } };\n    paint.setShader(SkShader::MakeBitmapShader(source, SkShader::kClamp_TileMode,\n                                                       SkShader::kClamp_TileMode, nullptr));\n    canvas->scale(30, 30);\n    canvas->drawPatch(cubics, nullptr, texCoords, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "3412c2a16cb529af0e04878d264451f2",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPatch_2_2"
},
    "SkCanvas_drawPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(20, 20);\n    path.quadTo(60, 20, 60, 60);\n    path.close();\n    path.moveTo(60, 20);\n    path.quadTo(60, 60, 20, 60);\n    SkPaint paint;\n    paint.setStrokeWidth(10);\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (auto join: { SkPaint::kBevel_Join, SkPaint::kRound_Join, SkPaint::kMiter_Join } ) {\n        paint.setStrokeJoin(join);\n        for (auto cap: { SkPaint::kButt_Cap, SkPaint::kSquare_Cap, SkPaint::kRound_Cap  } ) {\n            paint.setStrokeCap(cap);\n            canvas->drawPath(path, paint);\n            canvas->translate(80, 0);\n        }\n        canvas->translate(-240, 60);\n    }\n    paint.setStyle(SkPaint::kFill_Style);\n    for (auto fill : { SkPath::kWinding_FillType, \n                       SkPath::kEvenOdd_FillType, \n                       SkPath::kInverseWinding_FillType } ) {\n        path.setFillType(fill);\n        canvas->save();\n        canvas->clipRect({0, 10, 80, 70});\n        canvas->drawPath(path, paint);\n        canvas->restore();\n        canvas->translate(80, 0);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "d489555a878cb2ab08eea5faf516f54e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPath"
},
    "SkCanvas_drawPicture": {
    "code": "void draw(SkCanvas* canvas) {  \n    SkPictureRecorder recorder;\n    SkCanvas* recordingCanvas = recorder.beginRecording(50, 50);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xff007f00 } ) {\n        SkPaint paint;\n        paint.setColor(color);\n        recordingCanvas->drawRect({10, 10, 30, 40}, paint);\n        recordingCanvas->translate(10, 10);\n        recordingCanvas->scale(1.2f, 1.4f);\n    }\n    sk_sp<SkPicture> playback = recorder.finishRecordingAsPicture();\n    const SkPicture* playbackPtr = playback.get();\n    canvas->drawPicture(playback);\n    canvas->scale(2, 2);\n    canvas->translate(50, 0);\n    canvas->drawPicture(playback);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "fde216281ff93d612768a49f2cf309ae",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPicture"
},
    "SkCanvas_drawPicture_2": {
    "code": "void draw(SkCanvas* canvas) {  \n    SkPictureRecorder recorder;\n    SkCanvas* recordingCanvas = recorder.beginRecording(50, 50);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xff007f00 } ) {\n        SkPaint paint;\n        paint.setColor(color);\n        recordingCanvas->drawRect({10, 10, 30, 40}, paint);\n        recordingCanvas->translate(10, 10);\n        recordingCanvas->scale(1.2f, 1.4f);\n    }\n    sk_sp<SkPicture> playback = recorder.finishRecordingAsPicture();\n    canvas->drawPicture(playback);\n    canvas->scale(2, 2);\n    canvas->translate(50, 0);\n    canvas->drawPicture(playback);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "a7373b01354dda73dafe8718f4fd0cfc",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPicture_2"
},
    "SkCanvas_drawPicture_3": {
    "code": "void draw(SkCanvas* canvas) {  \n    SkPaint paint;\n    SkPictureRecorder recorder;\n    SkCanvas* recordingCanvas = recorder.beginRecording(50, 50);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xff007f00 } ) {\n        paint.setColor(color);\n        recordingCanvas->drawRect({10, 10, 30, 40}, paint);\n        recordingCanvas->translate(10, 10);\n        recordingCanvas->scale(1.2f, 1.4f);\n    }\n    sk_sp<SkPicture> playback = recorder.finishRecordingAsPicture();\n    const SkPicture* playbackPtr = playback.get();\n    SkMatrix matrix;\n    matrix.reset();\n    for (auto alpha : { 70, 140, 210 } ) {\n    paint.setAlpha(alpha);\n    canvas->drawPicture(playbackPtr, &matrix, &paint);\n    matrix.preTranslate(70, 70);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "4ec028d8ffa0a6ae1a99ff8d094b02bc",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPicture_3"
},
    "SkCanvas_drawPicture_4": {
    "code": "void draw(SkCanvas* canvas) {  \n    SkPaint paint;\n    SkPictureRecorder recorder;\n    SkCanvas* recordingCanvas = recorder.beginRecording(50, 50);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xff007f00 } ) {\n        paint.setColor(color);\n        recordingCanvas->drawRect({10, 10, 30, 40}, paint);\n        recordingCanvas->translate(10, 10);\n        recordingCanvas->scale(1.2f, 1.4f);\n    }\n    sk_sp<SkPicture> playback = recorder.finishRecordingAsPicture();\n    SkMatrix matrix;\n    matrix.reset();\n    for (auto alpha : { 70, 140, 210 } ) {\n    paint.setAlpha(alpha);\n    canvas->drawPicture(playback, &matrix, &paint);\n    matrix.preTranslate(70, 70);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "7295eb14091e98565cec0353661a6a7d",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPicture_4"
},
    "SkCanvas_drawPoint": {
    "code": "void draw(SkCanvas* canvas) {\n  SkPaint paint;\n  paint.setAntiAlias(true);\n  paint.setColor(0x80349a45);\n  paint.setStyle(SkPaint::kStroke_Style);\n  paint.setStrokeWidth(100);\n  paint.setStrokeCap(SkPaint::kRound_Cap);\n  canvas->scale(1, 1.2f);\n  canvas->drawPoint(64, 96, paint);\n  canvas->scale(.6f, .8f);\n  paint.setColor(SK_ColorWHITE);\n  canvas->drawPoint(106, 120, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "3476b553e7b547b604a3f6969f02d933",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPoint"
},
    "SkCanvas_drawPoint_2": {
    "code": "void draw(SkCanvas* canvas) {\n  SkPaint paint;\n  paint.setAntiAlias(true);\n  paint.setColor(0x80349a45);\n  paint.setStyle(SkPaint::kStroke_Style);\n  paint.setStrokeWidth(100);\n  paint.setStrokeCap(SkPaint::kSquare_Cap);\n  canvas->scale(1, 1.2f);\n  canvas->drawPoint({64, 96}, paint);\n  canvas->scale(.6f, .8f);\n  paint.setColor(SK_ColorWHITE);\n  canvas->drawPoint(106, 120, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "1a0a839061c69d870acca2bcfbdf1a41",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPoint_2"
},
    "SkCanvas_drawPoints": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    paint.setColor(0x80349a45);\n    const SkPoint points[] = {{32, 16}, {48, 48}, {16, 32}};\n    const SkPaint::Join join[] = { SkPaint::kRound_Join, \n                                   SkPaint::kMiter_Join,\n                                   SkPaint::kBevel_Join };\n    int joinIndex = 0;\n    SkPath path;\n    path.addPoly(points, 3, false);\n    for (const auto cap : { SkPaint::kRound_Cap, SkPaint::kSquare_Cap, SkPaint::kButt_Cap } ) {\n        paint.setStrokeCap(cap);\n        paint.setStrokeJoin(join[joinIndex++]);\n        for (const auto mode : { SkCanvas::kPoints_PointMode,\n                                 SkCanvas::kLines_PointMode,\n                                 SkCanvas::kPolygon_PointMode } ) {\n            canvas->drawPoints(mode, 3, points, paint);\n            canvas->translate(64, 0);\n        }\n        canvas->drawPath(path, paint);\n        canvas->translate(-192, 64);\n    }\n}\n",
    "width": 256,
    "height": 200,
    "hash": "f1dfbb0d5a17c8beab19af29f2aaba8c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPoints"
},
    "SkCanvas_drawPosText": {
    "code": "void draw(SkCanvas* canvas) {\n  const char hello[] = \"HeLLo!\";\n  const SkPoint pos[] = { {40, 100}, {82, 95}, {115, 110}, {130, 95}, {145, 85},\n    {172, 100} };\n  SkPaint paint;\n  paint.setTextSize(60);\n  canvas->drawPosText(hello, strlen(hello), pos, paint);\n}\n",
    "width": 256,
    "height": 120,
    "hash": "bf0b2402533a23b6392e0676b7a8414c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPosText"
},
    "SkCanvas_drawPosTextH": {
    "code": "void draw(SkCanvas* canvas) {\n    SkScalar xpos[] = { 20, 40, 80, 160 };\n    SkPaint paint;\n    canvas->drawPosTextH(\"XXXX\", 4, xpos, 20, paint);\n}\n",
    "width": 256,
    "height": 40,
    "hash": "95c6a7ef82993a8d2add676080e9438a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawPosTextH"
},
    "SkCanvas_drawRRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRect outer = {30, 40, 210, 220};\n    SkRect radii = {30, 50, 70, 90 };\n    SkRRect rRect;\n    rRect.setNinePatch(outer, radii.fLeft, radii.fTop, radii.fRight, radii.fBottom);\n    canvas->drawRRect(rRect, paint);\n    paint.setColor(SK_ColorWHITE);\n    canvas->drawLine(outer.fLeft + radii.fLeft, outer.fTop,\n                     outer.fLeft + radii.fLeft, outer.fBottom, paint);\n    canvas->drawLine(outer.fRight - radii.fRight, outer.fTop, \n                     outer.fRight - radii.fRight, outer.fBottom, paint);\n    canvas->drawLine(outer.fLeft,  outer.fTop + radii.fTop, \n                     outer.fRight, outer.fTop + radii.fTop, paint);\n    canvas->drawLine(outer.fLeft,  outer.fBottom - radii.fBottom, \n                     outer.fRight, outer.fBottom - radii.fBottom, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "369cdbfb2a200d5bb8ae40f7cc1025c3",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawRRect"
},
    "SkCanvas_drawRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint rectPts[] = { {64, 48}, {192, 160} };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    paint.setStrokeJoin(SkPaint::kRound_Join);\n    SkMatrix rotator;\n    rotator.setRotate(30, 128, 128);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, SK_ColorYELLOW, SK_ColorMAGENTA } ) {\n        paint.setColor(color);\n        SkRect rect;\n        rect.set(rectPts[0], rectPts[1]);\n        canvas->drawRect(rect, paint);\n        rotator.mapPoints(rectPts, 2);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "871b0da9b4a23de11ae7a772ce14aed3",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawRect"
},
    "SkCanvas_drawRegion": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRegion region;\n    region.op( 10, 10, 50, 50, SkRegion::kUnion_Op);\n    region.op( 10, 50, 90, 90, SkRegion::kUnion_Op);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    paint.setStrokeJoin(SkPaint::kRound_Join);\n    canvas->drawRegion(region, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "80309e0deca0f8add616cec7bec634ca",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawRegion"
},
    "SkCanvas_drawRoundRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkVector radii[] = { {0, 20}, {10, 10}, {10, 20}, {10, 40} };\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeJoin(SkPaint::kRound_Join);\n    paint.setAntiAlias(true);\n    for (auto style : { SkPaint::kStroke_Style, SkPaint::kFill_Style  } ) {\n        paint.setStyle(style );\n        for (size_t i = 0; i < SK_ARRAY_COUNT(radii); ++i) {\n           canvas->drawRoundRect({10, 10, 60, 40}, radii[i].fX, radii[i].fY, paint);\n           canvas->translate(0, 60);\n        }\n        canvas->translate(80, -240);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "199fe818c09026c114e165bff166a39f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawRoundRect"
},
    "SkCanvas_drawString": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->drawString(\"a small hello\", 20, 20, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "65cc4b15cd1a8d067eb1dbfd7e2c17dd",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawString"
},
    "SkCanvas_drawString_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkString string(\"a small hello\");\n    canvas->drawString(string, 20, 20, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "435178c09feb3bfec5e35d983609a013",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawString_2"
},
    "SkCanvas_drawText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    float textSizes[] = { 12, 18, 24, 36 };\n    for (auto size: textSizes ) {\n        paint.setTextSize(size);\n        canvas->drawText(\"Aa\", 2, 10, 20, paint);\n        canvas->translate(0, size * 2);\n    }\n    paint.reset();\n    paint.setAntiAlias(true);\n    float yPos = 20;\n    for (auto size: textSizes ) {\n        float scale = size / 12.f;\n        canvas->resetMatrix();\n        canvas->translate(100, 0);\n        canvas->scale(scale, scale);\n        canvas->drawText(\"Aa\", 2, 10 / scale, yPos / scale, paint);\n        yPos += size * 2; \n    }\n}\n",
    "width": 256,
    "height": 200,
    "hash": "a3365bd3044b13e8e0318ee8aefbdf91",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawText"
},
    "SkCanvas_drawTextBlob": {
    "code": "void draw(SkCanvas* canvas) {\n    SkTextBlobBuilder textBlobBuilder;\n    const char bunny[] = \"/(^x^)\\\\\";\n    const int len = sizeof(bunny) - 1;\n    uint16_t glyphs[len];\n    SkPaint paint;\n    paint.textToGlyphs(bunny, len, glyphs);\n    paint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);\n    int runs[] = { 3, 1, 3 };\n    SkPoint textPos = { 20, 100 };\n    int glyphIndex = 0;\n    for (auto runLen : runs) {\n        paint.setTextSize(1 == runLen ? 20 : 50);\n        const SkTextBlobBuilder::RunBuffer& run = \n                textBlobBuilder.allocRun(paint, runLen, textPos.fX, textPos.fY);\n        memcpy(run.glyphs, &glyphs[glyphIndex], sizeof(glyphs[0]) * runLen);\n        textPos.fX += paint.measureText(&glyphs[glyphIndex], sizeof(glyphs[0]) * runLen, nullptr);\n        glyphIndex += runLen;\n    }\n    sk_sp<const SkTextBlob> blob = textBlobBuilder.make();\n    paint.reset();\n    canvas->drawTextBlob(blob.get(), 0, 0, paint);\n}\n",
    "width": 256,
    "height": 120,
    "hash": "2254beaa675e3b329dccddca4eeea735",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawTextBlob"
},
    "SkCanvas_drawTextBlob_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkTextBlobBuilder textBlobBuilder;\n    SkPaint paint;\n    paint.setTextSize(50);\n    paint.setColor(SK_ColorRED);\n    paint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);\n    const SkTextBlobBuilder::RunBuffer& run = \n            textBlobBuilder.allocRun(paint, 1, 20, 100);\n    run.glyphs[0] = 20;\n    sk_sp<const SkTextBlob> blob = textBlobBuilder.make();\n    paint.setTextSize(10);\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawTextBlob(blob.get(), 0, 0, paint);\n}\n",
    "width": 256,
    "height": 120,
    "hash": "d88b17d85fa68c56b3c1ad02b69068bf",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawTextBlob_2"
},
    "SkCanvas_drawTextOnPath": {
    "code": "void draw(SkCanvas* canvas) { \n    const char roller[] = \"rollercoaster\";\n    const size_t len = sizeof(roller) - 1;\n    SkPath path;\n    path.cubicTo(40, -80, 120, 80, 160, -40);\n    SkPaint paint;\n    paint.setTextSize(32);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    for (int i = 0; i < 3; ++i) {\n        canvas->translate(25, 60);\n        canvas->drawPath(path, paint);\n        canvas->drawTextOnPath(roller, len, path, &matrix, paint);\n        matrix.preTranslate(0, 10);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "0f60797fbdce3d3c71c46b800e6bd6f8",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawTextOnPath"
},
    "SkCanvas_drawTextOnPathHV": {
    "code": "void draw(SkCanvas* canvas) { \n    const char aero[] = \"correo a\" \"\\xC3\" \"\\xA9\" \"reo\";\n    const size_t len = sizeof(aero) - 1;\n    SkPath path;\n    path.addOval({43-26, 43-26, 43+26, 43+26}, SkPath::kCW_Direction, 3);\n    SkPaint paint;\n    paint.setTextSize(24);\n    for (auto offset : { 0, 10, 20 } ) {\n        canvas->drawTextOnPathHV(aero, len, path, 0, -offset, paint);\n        canvas->translate(70 + offset, 70 + offset);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "25cc5452156d7f06e85f514913d46b5c",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawTextOnPathHV"
},
    "SkCanvas_drawTextRSXform": {
    "code": "void draw(SkCanvas* canvas) {  \n    const int iterations = 26;\n    SkRSXform transforms[iterations];\n    char alphabet[iterations];\n    SkScalar angle = 0;\n    SkScalar scale = 1;\n    for (size_t i = 0; i < SK_ARRAY_COUNT(transforms); ++i) {\n        const SkScalar s = SkScalarSin(angle) * scale;\n        const SkScalar c = SkScalarCos(angle) * scale;\n        transforms[i] = SkRSXform::Make(-c, -s, -s * 16, c * 16);\n        angle += .45;\n        scale += .2;\n        alphabet[i] = 'A' + i;\n    }\n    SkPaint paint;\n    paint.setTextAlign(SkPaint::kCenter_Align);\n    canvas->translate(110, 138);\n    canvas->drawTextRSXform(alphabet, sizeof(alphabet), transforms, nullptr, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "55c84c39890c7516f7c835c46b1b8fc9",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawTextRSXform"
},
    "SkCanvas_drawVertices": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPoint points[] = { { 0, 0 }, { 250, 0 }, { 100, 100 }, { 0, 250 } };\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE, SK_ColorYELLOW, SK_ColorCYAN };\n    auto vertices = SkVertices::MakeCopy(SkVertices::kTriangleFan_VertexMode,\n            SK_ARRAY_COUNT(points), points, nullptr, colors);\n    canvas->drawVertices(vertices.get(), SkBlendMode::kSrc, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "f48b22eaad1bb7adcc3faaa321754af6",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawVertices"
},
    "SkCanvas_drawVertices_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPoint points[] = { { 0, 0 }, { 250, 0 }, { 100, 100 }, { 0, 250 } };\n    SkPoint texs[] = { { 0, 0 }, { 0, 250 }, { 250, 250 }, { 250, 0 } };\n    SkColor colors[] = { SK_ColorRED, SK_ColorBLUE, SK_ColorYELLOW, SK_ColorCYAN };\n    paint.setShader(SkGradientShader::MakeLinear(points, colors, nullptr, 4,\n            SkShader::kClamp_TileMode));\n    auto vertices = SkVertices::MakeCopy(SkVertices::kTriangleFan_VertexMode,\n            SK_ARRAY_COUNT(points), points, texs, colors);\n    canvas->drawVertices(vertices.get(), SkBlendMode::kDarken, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "94e32538646d5f1299c427e473f9ec87",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::drawVertices_2"
},
    "SkCanvas_getGrContext": {
    "code": "void draw(SkCanvas* canvas) {\n    if (canvas->getGrContext()) {\n         canvas->clear(SK_ColorRED);\n    } else {\n         canvas->clear(SK_ColorBLUE);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "c4ea949e5fa5a0630dcb6b0204bd498f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::getGrContext"
},
    "SkCanvas_readPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->clear(SK_ColorBLUE);\n    SkPaint paint;\n    canvas->drawCircle(32, 32, 28, paint);\n    SkImageInfo info = SkImageInfo::Make(64, 64, kBGRA_8888_SkColorType, kPremul_SkAlphaType);\n    sk_sp<SkData> data(SkData::MakeUninitialized(info.minRowBytes() * info.height()));\n    sk_bzero(data->writable_data(), info.minRowBytes() * info.height());\n    for (int x : { 32, -32 } ) {\n        for (int y : { 32, -32 } ) {\n            canvas->readPixels(info, data->writable_data(), info.minRowBytes(), x, y);\n        } \n    }\n    sk_sp<SkImage> image = SkImage::MakeRasterData(info, data, info.minRowBytes());\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 64,
    "height": 64,
    "hash": "2964297993747769b0760874c19e0168",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::readPixels"
},
    "SkCanvas_resetMatrix": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->scale(4, 6);\n    canvas->drawString(\"truth\", 2, 10, paint);\n    canvas->resetMatrix();\n    canvas->scale(2.8f, 6);\n    canvas->drawString(\"consequences\", 2, 20, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "412afffdf4682baa503a4e2e99201967",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::resetMatrix"
},
    "SkCanvas_rotate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->translate(128, 128);\n    canvas->drawCircle(0, 0, 60, paint);\n    canvas->save();\n    canvas->rotate(10 * 360 / 60);   // 10 minutes of 60 scaled to 360 degrees\n    canvas->drawLine(0, 0, 0, -50, paint); \n    canvas->restore();\n    canvas->rotate((5 + 10.f/60) * 360 / 12); // 5 and 10/60 hours of 12 scaled to 360 degrees\n    canvas->drawLine(0, 0, 0, -30, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "caafb205771b714948e00dcd58ccaf1f",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::rotate()"
},
    "SkCanvas_rotate_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(96);\n    canvas->drawString(\"A1\", 130, 100, paint);\n    canvas->rotate(180, 130, 100);\n    canvas->drawString(\"A1\", 130, 100, paint);\n}\n",
    "width": 256,
    "height": 192,
    "hash": "bcf5baea1c66a957d5ffd7b54bbbfeff",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::rotate_2"
},
    "SkCanvas_save": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRect rect = { 0, 0, 25, 25 };\n    canvas->drawRect(rect, paint);\n    canvas->save();\n    canvas->translate(50, 50);\n    canvas->drawRect(rect, paint);\n    canvas->restore();\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect(rect, paint);\n}\n",
    "width": 256,
    "height": 100,
    "hash": "e477dce358a9ba3b0aa1bf33b8a376de",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::save()"
},
    "SkCanvas_saveLayer": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint, blur;\n    blur.setImageFilter(SkBlurImageFilter::Make(3, 3, nullptr));\n    canvas->saveLayer(nullptr, &blur);\n    SkRect rect = { 25, 25, 50, 50};\n    canvas->drawRect(rect, paint);\n    canvas->translate(50, 50);\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect(rect, paint);\n    canvas->restore();\n}\n",
    "width": 256,
    "height": 128,
    "hash": "1a025d6018f64140af2dc36acad59008",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::saveLayer"
},
    "SkCanvas_saveLayerAlpha": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorRED);\n    canvas->drawCircle(50, 50, 50, paint);\n    canvas->saveLayerAlpha(nullptr, 128);\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawCircle(100, 50, 50, paint);\n    paint.setColor(SK_ColorGREEN);\n    paint.setAlpha(128);\n    canvas->drawCircle(75, 90, 50, paint);\n    canvas->restore();\n}",
    "width": 256,
    "height": 256,
    "hash": "8ab88d86fb438856cc48d6e2f08a6e24",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::saveLayerAlpha"
},
    "SkCanvas_saveLayerPreserveLCDTextRequests": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setLCDRenderText(true);\n    paint.setTextSize(20);\n    for (auto preserve : { false, true } ) {\n        preserve ? canvas->saveLayerPreserveLCDTextRequests(nullptr, nullptr)\n                 : canvas->saveLayer(nullptr, nullptr);\n        SkPaint p;\n        p.setColor(SK_ColorWHITE);\n        // Comment out the next line to draw on a non-opaque background.\n        canvas->drawRect(SkRect::MakeLTRB(25, 40, 200, 70), p);\n        canvas->drawString(\"Hamburgefons\", 30, 60, paint);\n        p.setColor(0xFFCCCCCC);\n        canvas->drawRect(SkRect::MakeLTRB(25, 70, 200, 100), p);\n        canvas->drawString(\"Hamburgefons\", 30, 90, paint);\n        canvas->restore();\n        canvas->translate(0, 80);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "8460bf8b013f46c67e0bd96e13451aff",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::saveLayerPreserveLCDTextRequests"
},
    "SkCanvas_saveLayer_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint, blur;\n    blur.setImageFilter(SkBlurImageFilter::Make(3, 3, nullptr));\n    canvas->saveLayer(SkRect::MakeWH(90, 90), &blur);\n    SkRect rect = { 25, 25, 50, 50};\n    canvas->drawRect(rect, paint);\n    canvas->translate(50, 50);\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect(rect, paint);\n    canvas->restore();\n}\n",
    "width": 256,
    "height": 128,
    "hash": "5b59231feae0c09cb1ab6a292229d7a4",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::saveLayer_2"
},
    "SkCanvas_saveLayer_3": {
    "code": "void draw(SkCanvas* canvas) {\n    // sk_sp<SkImage> image = GetResourceAsImage(\"images/mandrill_256.png\");\n    canvas->drawImage(image, 0, 0, nullptr);\n    SkCanvas::SaveLayerRec rec;\n    SkPaint paint;\n    paint.setBlendMode(SkBlendMode::kPlus);\n    rec.fSaveLayerFlags = SkCanvas::kInitWithPrevious_SaveLayerFlag;\n    rec.fPaint = &paint;\n    canvas->saveLayer(rec);\n    paint.setBlendMode(SkBlendMode::kClear);\n    canvas->drawCircle(128, 128, 96, paint);\n    canvas->restore();\n}",
    "width": 256,
    "height": 256,
    "hash": "7d3751e82d1b6ec328ffa3d6f48ca831",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::saveLayer_3"
},
    "SkCanvas_scale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkRect rect = { 10, 20, 60, 120 };\n    canvas->translate(20, 20);\n    canvas->drawRect(rect, paint);\n    canvas->scale(2, .5f);\n    paint.setColor(SK_ColorGRAY);\n    canvas->drawRect(rect, paint);\n}\n",
    "width": 256,
    "height": 160,
    "hash": "7d0d801ef13c6c6da51e840c22ac15b0",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::scale()"
},
    "SkCanvas_setMatrix": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    canvas->scale(4, 6);\n    canvas->drawString(\"truth\", 2, 10, paint);\n    SkMatrix matrix;\n    matrix.setScale(2.8f, 6);\n    canvas->setMatrix(matrix);\n    canvas->drawString(\"consequences\", 2, 20, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "24b9cf7e6f9a08394e1e07413bd8733a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::setMatrix"
},
    "SkCanvas_skew": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    canvas->translate(30, 130);\n    canvas->save();\n    canvas->skew(-.5, 0);\n    canvas->drawString(\"A1\", 0, 0, paint);\n    canvas->restore();\n    canvas->save();\n    canvas->skew(0, .5);\n    paint.setColor(SK_ColorRED);\n    canvas->drawString(\"A1\", 0, 0, paint);\n    canvas->restore();\n    canvas->skew(-.5, .5);\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawString(\"A1\", 0, 0, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "2e2acc21d7774df7e0940a30ad2ca99e",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::skew()"
},
    "SkCanvas_translate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint filledPaint;\n    SkPaint outlinePaint;\n    outlinePaint.setStyle(SkPaint::kStroke_Style);\n    outlinePaint.setColor(SK_ColorBLUE);\n    canvas->save();\n    canvas->translate(50, 50);\n    canvas->drawCircle(28, 28, 15, outlinePaint);  // blue center: (50+28, 50+28)\n    canvas->scale(2, 1/2.f);\n    canvas->drawCircle(28, 28, 15, filledPaint);   // black center: (50+(28*2), 50+(28/2))\n    canvas->restore();\n    filledPaint.setColor(SK_ColorGRAY);\n    outlinePaint.setColor(SK_ColorRED);\n    canvas->scale(2, 1/2.f);\n    canvas->drawCircle(28, 28, 15, outlinePaint);  // red center: (28*2, 28/2)\n    canvas->translate(50, 50);\n    canvas->drawCircle(28, 28, 15, filledPaint);   // gray center: ((50+28)*2, (50+28)/2)\n}\n",
    "width": 256,
    "height": 128,
    "hash": "eb93d5fa66a5f7a10f4f9210494d7222",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::translate()"
},
    "SkCanvas_writePixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo imageInfo = SkImageInfo::MakeN32(256, 1, kPremul_SkAlphaType);\n    for (int y = 0; y < 256; ++y) {\n        uint32_t pixels[256];\n        for (int x = 0; x < 256; ++x) {\n            pixels[x] = SkColorSetARGB(x, x + y, x, x - y);\n        }\n        canvas->writePixels(imageInfo, &pixels, sizeof(pixels), 0, y);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "29b98ebf58aa9fd1edfaabf9f4490b3a",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::writePixels"
},
    "SkCanvas_writePixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo imageInfo = SkImageInfo::MakeN32Premul(2, 2);\n    SkBitmap bitmap;\n    bitmap.setInfo(imageInfo);\n    uint32_t pixels[4];\n    bitmap.setPixels(pixels);\n    for (int y = 0; y < 256; y += 2) {\n        for (int x = 0; x < 256;  x += 2) {\n            pixels[0] = SkColorSetRGB(x, y, x | y);\n            pixels[1] = SkColorSetRGB(x ^ y, y, x);\n            pixels[2] = SkColorSetRGB(x, x & y, y);\n            pixels[3] = SkColorSetRGB(~x, ~y, x);\n            canvas->writePixels(bitmap, x, y);\n        }\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8b128e067881f9251357653692fa28da",
    "file": "SkCanvas_Reference",
    "name": "SkCanvas::writePixels_2"
},
    "SkColorType": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkColorType"
},
    "SkDestinationSurfaceColorMode": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkDestinationSurfaceColorMode"
},
    "SkIPoint_add_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto draw_lines = [=](const SkIPoint pts[], size_t count, SkPaint& paint) -> void {\n        for (size_t i = 0; i < count - 1; ++i) {\n            SkPoint p0, p1;\n            p0.iset(pts[i]);\n            p1.iset(pts[i + 1]);\n            canvas->drawLine(p0, p1, paint);\n        }\n    };\n    SkIPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 } };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->scale(30, 15);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n    SkIPoint mod = {4, 1};\n    for (auto& point : points) {\n        point = point + mod;\n        mod.fX -= 1;\n        mod.fY += 1;\n    }\n    paint.setColor(SK_ColorRED);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "63f4cba971c6d8434595906f865b5a29",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator+(const SkIPoint& a, const SkIVector& b)"
},
    "SkIPoint_addto_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto draw_lines = [=](const SkIPoint pts[], size_t count, SkPaint& paint) -> void {\n        for (size_t i = 0; i < count - 1; ++i) {\n            SkPoint p0, p1;\n            p0.iset(pts[i]);\n            p1.iset(pts[i + 1]);\n            canvas->drawLine(p0, p1, paint);\n        }\n    };\n    SkIPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 } };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->scale(30, 15);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n    points[1] += {1, 1};\n    points[2] += {-1, -1};\n    paint.setColor(SK_ColorRED);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "4eb2d95c9e9a66f05296e345bb68bd51",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator+=(const SkIVector& v)"
},
    "SkIPoint_subtract_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto draw_lines = [=](const SkIPoint pts[], size_t count, SkPaint& paint) -> void {\n        for (size_t i = 0; i < count - 1; ++i) {\n            SkPoint p0, p1;\n            p0.iset(pts[i]);\n            p1.iset(pts[i + 1]);\n            canvas->drawLine(p0, p1, paint);\n        }\n    };\n    SkIPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 } };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->scale(30, 15);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n    points[1] += points[0] - points[3];\n    points[2] -= points[1] - points[0];\n    paint.setColor(SK_ColorRED);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "e626e26bf557857b824aa7d03f723e0f",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator-(const SkIPoint& a, const SkIPoint& b)"
},
    "SkIPoint_subtractfrom_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    auto draw_lines = [=](const SkIPoint pts[], size_t count, SkPaint& paint) -> void {\n        for (size_t i = 0; i < count - 1; ++i) {\n            SkPoint p0, p1;\n            p0.iset(pts[i]);\n            p1.iset(pts[i + 1]);\n            canvas->drawLine(p0, p1, paint);\n        }\n    };\n    SkIPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 } };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->scale(30, 15);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n    points[1] -= {1, 1};\n    points[2] -= {-1, -1};\n    paint.setColor(SK_ColorRED);\n    draw_lines(points, SK_ARRAY_COUNT(points), paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "a01e533dc7ab34ed728dc4e7a5f1f0ee",
    "file": "SkIPoint_Reference",
    "name": "SkIPoint::operator-=(const SkIVector& v)"
},
    "SkImageInfo_ByteSizeOverflowed": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::ByteSizeOverflowed"
},
    "SkImageInfo_Make": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::Make"
},
    "SkImageInfo_MakeA8": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeA8"
},
    "SkImageInfo_MakeN32": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeN32"
},
    "SkImageInfo_MakeN32Premul": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeN32Premul"
},
    "SkImageInfo_MakeN32Premul_2": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeN32Premul_2"
},
    "SkImageInfo_MakeS32": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeS32"
},
    "SkImageInfo_MakeUnknown": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeUnknown"
},
    "SkImageInfo_MakeUnknown_2": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::MakeUnknown_2"
},
    "SkImageInfo_alphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::alphaType"
},
    "SkImageInfo_bounds": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::bounds()"
},
    "SkImageInfo_bytesPerPixel": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::bytesPerPixel"
},
    "SkImageInfo_colorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::colorSpace"
},
    "SkImageInfo_colorType": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::colorType"
},
    "SkImageInfo_computeByteSize": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::computeByteSize"
},
    "SkImageInfo_computeMinByteSize": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::computeMinByteSize"
},
    "SkImageInfo_computeOffset": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::computeOffset"
},
    "SkImageInfo_dimensions": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::dimensions()"
},
    "SkImageInfo_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::SkImageInfo()"
},
    "SkImageInfo_equal1_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::operator==(const SkImageInfo& other)_const"
},
    "SkImageInfo_flatten": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::flatten()"
},
    "SkImageInfo_gammaCloseToSRGB": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::gammaCloseToSRGB"
},
    "SkImageInfo_height": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::height()"
},
    "SkImageInfo_isEmpty": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::isEmpty"
},
    "SkImageInfo_isOpaque": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::isOpaque"
},
    "SkImageInfo_makeAlphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::makeAlphaType"
},
    "SkImageInfo_makeColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::makeColorSpace"
},
    "SkImageInfo_makeColorType": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::makeColorType"
},
    "SkImageInfo_makeWH": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::makeWH"
},
    "SkImageInfo_minRowBytes": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::minRowBytes"
},
    "SkImageInfo_minRowBytes64": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::minRowBytes64"
},
    "SkImageInfo_notequal1_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::operator!=(const SkImageInfo& other)_const"
},
    "SkImageInfo_refColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::refColorSpace"
},
    "SkImageInfo_reset": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::reset()"
},
    "SkImageInfo_shiftPerPixel": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::shiftPerPixel"
},
    "SkImageInfo_unflatten": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::unflatten()"
},
    "SkImageInfo_validRowBytes": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::validRowBytes"
},
    "SkImageInfo_validate": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::validate()"
},
    "SkImageInfo_width": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkImageInfo::width()"
},
    "SkImage_DeferredTextureImageUsageParams": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImage_Reference",
    "name": "SkImage::DeferredTextureImageUsageParams"
},
    "SkImage_DeferredTextureImageUsageParams_DeferredTextureImageUsageParams": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImage_Reference",
    "name": "SkImage::DeferredTextureImageUsageParams::DeferredTextureImageUsageParams"
},
    "SkImage_LegacyBitmapMode": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImage_Reference",
    "name": "SkImage::LegacyBitmapMode"
},
    "SkImage_MakeBackendTextureFromSkImage": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeBackendTextureFromSkImage"
},
    "SkImage_MakeCrossContextFromEncoded": {
    "code": "void draw(SkCanvas* canvas) {\n    GrContext* context = canvas->getGrContext();\n    sk_sp<SkData> encodedData = image->encodeToData(SkEncodedImageFormat::kJPEG, 100);\n    sk_sp<SkImage> image = SkImage::MakeCrossContextFromEncoded(context,\n                                                                encodedData, false, nullptr);\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "069c7b116479e3ca46f953f07dcbdd36",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeCrossContextFromEncoded"
},
    "SkImage_MakeCrossContextFromPixmap": {
    "code": "void draw(SkCanvas* canvas) {\n    GrContext* context = canvas->getGrContext();\n    SkPixmap pixmap;\n    if (source.peekPixels(&pixmap)) {\n        sk_sp<SkImage> image = SkImage::MakeCrossContextFromPixmap(context, pixmap,\n                                                                   false, nullptr);\n        canvas->drawImage(image, 0, 0);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "45bca8747b8f49b5be34b520897ef048",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeCrossContextFromPixmap"
},
    "SkImage_MakeFromAdoptedTexture_2": {
    "code": "void draw(SkCanvas* canvas) {\n    if (!canvas->getGrContext()) {\n        return;\n    }\n    canvas->scale(.5f, .5f);\n    canvas->clear(0x7f3f5f7f);\n    int x = 0, y = 0;\n    for (auto origin : { kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin } ) {\n        for (auto alpha : { kOpaque_SkAlphaType, kPremul_SkAlphaType, kUnpremul_SkAlphaType } ) {\n            sk_sp<SkImage> image = SkImage::MakeFromAdoptedTexture(canvas->getGrContext(),\n                                                                   backEndTexture, origin, \n                                                                   kRGBA_8888_SkColorType, alpha);\n            canvas->drawImage(image, x, y);\n            x += 160;\n        }\n        x -= 160 * 3;\n        y += 256;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "b07964ec9c5c8a6febba805f1cf4d071",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromAdoptedTexture_2"
},
    "SkImage_MakeFromBitmap": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t storage[][5] = {{ 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 },\n                            { 0xAC, 0xA8, 0x89, 0xA7, 0x87 },\n                            { 0x9B, 0xB5, 0xE5, 0x95, 0x46 },\n                            { 0x90, 0x81, 0xC5, 0x71, 0x33 },\n                            { 0x75, 0x55, 0x44, 0x40, 0x30 }};\n    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    sk_sp<SkImage> image1 = SkImage::MakeFromBitmap(bitmap);\n    bitmap.setImmutable();\n    sk_sp<SkImage> image2 = SkImage::MakeFromBitmap(bitmap);\n    *pixmap.writable_addr8(2, 2) = 0x00;\n    canvas->scale(10, 10);\n    canvas->drawImage(image1, 0, 0);\n    canvas->drawImage(image2, 10, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "cf2cf53321e4e6a77c2841bfbc0ef707",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromBitmap"
},
    "SkImage_MakeFromDeferredTextureImageData": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromDeferredTextureImageData"
},
    "SkImage_MakeFromEncoded": {
    "code": "void draw(SkCanvas* canvas) {\n    int x = 0;\n    for (int quality : { 100, 50, 10, 1} ) {\n        sk_sp<SkData> encodedData = image->encodeToData(SkEncodedImageFormat::kJPEG, quality);\n        sk_sp<SkImage> image = SkImage::MakeFromEncoded(encodedData);\n        canvas->drawImage(image, x, 0);\n        x += 64;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "894f732ed6409b1f392bc5481421d0e9",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromEncoded"
},
    "SkImage_MakeFromGenerator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPictureRecorder recorder;\n    recorder.beginRecording(100, 100)->drawColor(SK_ColorRED);\n    auto picture = recorder.finishRecordingAsPicture();\n    auto gen = SkImageGenerator::MakeFromPicture({100, 100}, picture, nullptr, nullptr,\n                                                 SkImage::BitDepth::kU8, SkColorSpace::MakeSRGB());\n    sk_sp<SkImage> image = SkImage::MakeFromGenerator(std::move(gen));\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 256,
    "height": 128,
    "hash": "c2fec0746f88ca34d7dce59dd9bdef9e",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromGenerator"
},
    "SkImage_MakeFromPicture": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPictureRecorder recorder;\n    SkCanvas* recordingCanvas = recorder.beginRecording(50, 50);\n    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xff007f00 } ) {\n        paint.setColor(color);\n        recordingCanvas->drawRect({10, 10, 30, 40}, paint);\n        recordingCanvas->translate(10, 10);\n        recordingCanvas->scale(1.2f, 1.4f);\n    }\n    sk_sp<SkPicture> playback = recorder.finishRecordingAsPicture();\n    int x = 0, y = 0;\n    for (auto alpha : { 70, 140, 210 } ) {\n        paint.setAlpha(alpha);\n        auto srgbColorSpace = SkColorSpace::MakeSRGB();\n        sk_sp<SkImage> image = SkImage::MakeFromPicture(playback, {50, 50}, nullptr, &paint,\n                                                        SkImage::BitDepth::kU8, srgbColorSpace);\n        canvas->drawImage(image, x, y);\n        x += 70; y += 70;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "4aa2879b9e44dfd6648995326d2c4dcf",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromPicture"
},
    "SkImage_MakeFromTexture_3": {
    "code": "void draw(SkCanvas* canvas) {\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n       return;\n    }\n    canvas->scale(.25f, .25f);\n    int x = 0;\n    for (auto origin : { kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin } ) {\n        sk_sp<SkImage> image = SkImage::MakeFromTexture(context, backEndTexture,\n               origin, kOpaque_SkAlphaType, nullptr);\n        canvas->drawImage(image, x, 0);\n    x += 512;\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "d5e43961a54548f445eece91d517381c",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromTexture_3"
},
    "SkImage_MakeFromTexture_4": {
    "code": "void draw(SkCanvas* canvas) {\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n       return;\n    }\n    auto debugster = [](SkImage::ReleaseContext releaseContext) -> void {\n        *((int *) releaseContext) += 128;\n    };\n    int x = 0;\n    for (auto origin : { kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin } ) {\n        sk_sp<SkImage> image = SkImage::MakeFromTexture(context, backEndTexture,\n               origin, kRGBA_8888_SkColorType, kOpaque_SkAlphaType, nullptr, debugster, &x);\n        canvas->drawImage(image, x, 0);\n        x += 128;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "c7be9423f7c2ef819523ba4d607d17b8",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeFromTexture_4"
},
    "SkImage_MakeRasterCopy": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t storage[][5] = {{ 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 },\n                            { 0xAC, 0xA8, 0x89, 0xA7, 0x87 },\n                            { 0x9B, 0xB5, 0xE5, 0x95, 0x46 },\n                            { 0x90, 0x81, 0xC5, 0x71, 0x33 },\n                            { 0x75, 0x55, 0x44, 0x40, 0x30 }};\n    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kOpaque_SkAlphaType);\n    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    sk_sp<SkImage> image = SkImage::MakeRasterCopy(pixmap);\n    *pixmap.writable_addr8(2, 2) = 0x00;\n    canvas->scale(10, 10);\n    canvas->drawBitmap(bitmap, 0, 0);\n    canvas->drawImage(image, 10, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "513afec5795a9504ebf6af5373d16b6b",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeRasterCopy"
},
    "SkImage_MakeRasterData": {
    "code": "void draw(SkCanvas* canvas) {\n    size_t rowBytes = image->width() * SkColorTypeBytesPerPixel(kRGBA_8888_SkColorType);\n    sk_sp<SkData> data = SkData::MakeUninitialized(rowBytes * image->height());\n    SkImageInfo dstInfo = SkImageInfo::MakeN32(image->width(), image->height(), \n                                               kPremul_SkAlphaType);\n    image->readPixels(dstInfo, data->writable_data(), rowBytes, 0, 0, SkImage::kAllow_CachingHint);\n    sk_sp<SkImage> raw = SkImage::MakeRasterData(dstInfo.makeColorType(kRGBA_8888_SkColorType),\n                                                 data, rowBytes);\n    canvas->drawImage(image, 0, 0);\n    canvas->drawImage(raw.get(), 128, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "367bdf6ee6ef2482eea95d4a9887c9b0",
    "file": "SkImage_Reference",
    "name": "SkImage::MakeRasterData"
},
    "SkImage_alphaType": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* alphaTypeStr[] = { \"Unknown\", \"Opaque\", \"Premul\", \"Unpremul\" };\n    SkAlphaType alphaType = image->alphaType();\n    canvas->drawImage(image, 16, 0);\n    SkPaint paint;\n    canvas->drawString(alphaTypeStr[(int) alphaType], 20, image->height() + 20, paint);\n}",
    "width": 256,
    "height": 96,
    "hash": "dac1403132a42459d6881585efbfe74b",
    "file": "SkImage_Reference",
    "name": "SkImage::alphaType"
},
    "SkImage_asLegacyBitmap": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImage_Reference",
    "name": "SkImage::asLegacyBitmap"
},
    "SkImage_bounds": {
    "code": "void draw(SkCanvas* canvas) {\n    SkIRect bounds = image->bounds();\n    for (int x : { 0, bounds.width() } ) {\n        for (int y : { 0, bounds.height() } ) {\n            canvas->drawImage(image, x, y);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "c204b38b3fc08914b0a634aa4eaec894",
    "file": "SkImage_Reference",
    "name": "SkImage::bounds()"
},
    "SkImage_colorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap;\n    source.peekPixels(&pixmap);\n    canvas->scale(.25f, .25f);\n    int y = 0;\n    for (auto gamma : { SkColorSpace::kLinear_RenderTargetGamma,\n                        SkColorSpace::kSRGB_RenderTargetGamma } ) {\n        int x = 0;\n        sk_sp<SkColorSpace> colorSpace = SkColorSpace::MakeRGB(gamma, SkColorSpace::kSRGB_Gamut);\n        for (int index = 0; index < 2; ++index) {\n            pixmap.setColorSpace(colorSpace);\n            sk_sp<SkImage> image = SkImage::MakeRasterCopy(pixmap);\n            canvas->drawImage(image, x, y);\n            colorSpace = image->colorSpace()->makeColorSpin();\n            x += 512;\n        }\n        y += 512;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "4468d573f42af6f5e234be10a5453bb2",
    "file": "SkImage_Reference",
    "name": "SkImage::colorSpace"
},
    "SkImage_encodeToData": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(4, 4);\n    SkIRect subset = {0, 0, 16, 64};\n    int x = 0;\n    for (int quality : { 0, 10, 50, 100 } ) {\n        sk_sp<SkData> data(image->encodeToData(SkEncodedImageFormat::kJPEG, quality));\n        sk_sp<SkImage> filtered = SkImage::MakeFromEncoded(data, &subset);\n        canvas->drawImage(filtered, x, 0);\n        x += 16;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "7a3bf8851bb7160e4e49c48f8c09639d",
    "file": "SkImage_Reference",
    "name": "SkImage::encodeToData"
},
    "SkImage_encodeToData_2": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(4, 4);\n    SkIRect subset = {136, 32, 200, 96};\n    sk_sp<SkData> data(image->encodeToData());\n    sk_sp<SkImage> eye = SkImage::MakeFromEncoded(data, &subset);\n    canvas->drawImage(eye, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "30cee813f6aa476b0a9c8a24283e53a3",
    "file": "SkImage_Reference",
    "name": "SkImage::encodeToData_2"
},
    "SkImage_getDeferredTextureImageData": {
    "code": "void draw(SkCanvas* canvas) {\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n        return;\n    }\n    sk_sp<GrContextThreadSafeProxy> proxy(context->threadSafeProxy());\n    auto params = SkImage::DeferredTextureImageUsageParams(SkMatrix::MakeScale(2, 2),\n                                                           kNone_SkFilterQuality, 0);\n    SkColorSpace* colorSpace = canvas->imageInfo().colorSpace();\n    size_t requiredMemoryInBytes = image->getDeferredTextureImageData(\n            *proxy, &params, 1, nullptr, colorSpace);\n    std::vector<uint8_t> memory;\n    memory.resize(requiredMemoryInBytes);\n    image->getDeferredTextureImageData(*proxy, &params, 1, memory.data(), colorSpace);\n    sk_sp<SkImage> uploadedEncodedImage = SkImage::MakeFromDeferredTextureImageData(\n            context, memory.data(), SkBudgeted::kNo);\n    canvas->scale(2, 2);\n    canvas->drawImage(uploadedEncodedImage, 10, 10);\n}",
    "width": 256,
    "height": 256,
    "hash": "31d224ac4d22ba60221c565f9a12ad50",
    "file": "SkImage_Reference",
    "name": "SkImage::getDeferredTextureImageData"
},
    "SkImage_getTextureHandle": {
    "code": "void draw(SkCanvas* canvas) {\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n       return;\n    }\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkString str;\n    int y = -10;\n    for (auto origin : { kTopLeft_GrSurfaceOrigin, kBottomLeft_GrSurfaceOrigin } ) {\n        sk_sp<SkImage> srcImage(SkImage::MakeFromTexture(context,\n                backEndTexture, origin, kPremul_SkAlphaType, nullptr));\n        GrSurfaceOrigin readBackOrigin;\n        GrBackendObject readBackHandle = srcImage->getTextureHandle(false, &readBackOrigin);\n        str.printf(\"readBackHandle: 0x%x\", readBackHandle);\n        canvas->drawString(str, 5, y += 30, paint);\n        canvas->drawImage(srcImage, 80, y += 10);\n        str.printf(\"origin: k%s_GrSurfaceOrigin\", readBackOrigin ? \"BottomLeft\" : \"TopLeft\");\n        canvas->drawString(str, 5, y += srcImage->height() + 10, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "f8943191063bfcc69f29f2b149df5c6d",
    "file": "SkImage_Reference",
    "name": "SkImage::getTextureHandle"
},
    "SkImage_getTextureHandle_a": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {\n        if (nullptr == image) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        paint.setTextAlign(SkPaint::kCenter_Align);\n        canvas->drawImage(image, 0, image->height() / 4);\n        canvas->drawString(label, image->width() / 2, image->height() / 8, paint);\n        GrSurfaceOrigin readBackOrigin;\n        GrBackendObject readBackHandle = image->getTextureHandle(false, &readBackOrigin);\n        canvas->drawString(readBackHandle ? \"has readBackHandle\" : \"no readBackHandle\",\n                           image->width() / 2, image->height() * 11 / 8, paint);\n    };\n    drawImage(image, \"image\");\n    canvas->translate(image->width(), 0);\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr));\n    drawImage(textureImage, \"backEndTexture\");\n}",
    "width": 256,
    "height": 256,
    "hash": "a86c580638fcf83f782047b95c60f43f",
    "file": "SkImage_Reference",
    "name": "SkImage::getTextureHandle_2"
},
    "SkImage_height": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->translate(10, 10);\n    canvas->drawImage(image, 0, 0);\n    canvas->translate(image->width(), 0);\n    SkPaint paint;\n    paint.setTextAlign(SkPaint::kCenter_Align);\n    paint.setVerticalText(true);\n    canvas->drawLine(10, 0, 10, image->height(), paint);\n    canvas->drawString(\"height\", 25, image->height() / 2, paint);\n}",
    "width": 256,
    "height": 96,
    "hash": "6e563cb8351d34bd8af555a51bcd7a96",
    "file": "SkImage_Reference",
    "name": "SkImage::height()"
},
    "SkImage_isLazyGenerated": {
    "code": "class TestImageGenerator : public SkImageGenerator {\npublic:\n    TestImageGenerator() : SkImageGenerator(SkImageInfo::MakeN32Premul(10, 10)) {}\n    ~TestImageGenerator() override {}\nprotected:\n    bool onGetPixels(const SkImageInfo& info, void* pixelPtr, size_t rowBytes,\n                     const Options& options) override {\n        SkPMColor* pixels = static_cast<SkPMColor*>(pixelPtr);\n        for (int y = 0; y < info.height(); ++y) {\n            for (int x = 0; x < info.width(); ++x) {\n                pixels[y * info.width() + x] = 0xff223344 + y * 0x000C0811;\n            }\n        }\n        return true;\n    }\n};\n\nvoid draw(SkCanvas* canvas) {\n    auto gen = std::unique_ptr<TestImageGenerator>(new TestImageGenerator());\n    sk_sp<SkImage> image(SkImage::MakeFromGenerator(std::move(gen)));\n    SkString lazy(image->isLazyGenerated() ? \"is lazy\" : \"not lazy\");\n    canvas->scale(8, 8);\n    canvas->drawImage(image, 0, 0, nullptr);\n    SkPaint paint;\n    paint.setTextSize(4);\n    canvas->drawString(lazy, 2, 5, paint);\n}\n",
    "width": 256,
    "height": 80,
    "hash": "a8b8bd4bfe968e2c63085f867665227f",
    "file": "SkImage_Reference",
    "name": "SkImage::isLazyGenerated"
},
    "SkImage_isLazyGenerated_a": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {\n        if (nullptr == image) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        paint.setTextAlign(SkPaint::kCenter_Align);\n        canvas->drawImage(image, 0, 0);\n        canvas->drawString(label, image->width() / 2, image->height() / 4, paint);\n        canvas->drawString(\n                image->isLazyGenerated() ? \"is lazily generated\" : \"not lazily generated\",\n                image->width() / 2, image->height() * 3 / 4, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr));\n    drawImage(image, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, \"backEndTexture\");\n}\n",
    "width": 256,
    "height": 256,
    "hash": "070dd0405890b84c07827d93fa01c331",
    "file": "SkImage_Reference",
    "name": "SkImage::isLazyGenerated_2"
},
    "SkImage_isTextureBacked": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {\n        if (nullptr == image) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        paint.setTextAlign(SkPaint::kCenter_Align);\n        canvas->drawImage(image, 0, 0);\n        canvas->drawString(label, image->width() / 2, image->height() / 4, paint);\n        canvas->drawString(image->isTextureBacked() ? \"is GPU texture\" : \"not GPU texture\",\n                           image->width() / 2, image->height() * 3 / 4, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr));\n    drawImage(image, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, \"backEndTexture\");\n}",
    "width": 256,
    "height": 256,
    "hash": "96fd92d399778486a51c5d828ef99322",
    "file": "SkImage_Reference",
    "name": "SkImage::isTextureBacked"
},
    "SkImage_isValid": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {\n        if (nullptr == image) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        paint.setTextAlign(SkPaint::kCenter_Align);\n        canvas->drawImage(image, 0, 0);\n        canvas->drawString(label, image->width() / 2, image->height() / 4, paint);\n        if (canvas->getGrContext()) {\n            canvas->drawString(image->isValid(canvas->getGrContext()) ? \"is valid on GPU\" :\n                    \"not valid on GPU\", image->width() / 2, image->height() * 5 / 8, paint);\n        }\n        canvas->drawString(image->isValid(nullptr) ? \"is valid on CPU\" :\n                \"not valid on CPU\", image->width() / 2, image->height() * 7 / 8, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr));\n    drawImage(image, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, \"backEndTexture\");\n}",
    "width": 256,
    "height": 256,
    "hash": "daf1507ab3a5f7cb0f90058cbc028402",
    "file": "SkImage_Reference",
    "name": "SkImage::isValid"
},
    "SkImage_makeColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkColorSpace> normalColorSpace = SkColorSpace::MakeRGB(\n             SkColorSpace::kSRGB_RenderTargetGamma, SkColorSpace::kSRGB_Gamut);\n    sk_sp<SkColorSpace> wackyColorSpace = normalColorSpace->makeColorSpin();\n    for (auto colorSpace : { normalColorSpace, wackyColorSpace  } ) {\n        for (auto transfer : { SkTransferFunctionBehavior::kRespect,\n                               SkTransferFunctionBehavior::kIgnore } ) {\n            sk_sp<SkImage> colorSpaced = image->makeColorSpace(colorSpace, transfer);\n            canvas->drawImage(colorSpaced, 0, 0);\n            canvas->translate(128, 0);\n        }\n        canvas->translate(-256, 128);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "ab8bcb9acecbee444019a724d2b0503c",
    "file": "SkImage_Reference",
    "name": "SkImage::makeColorSpace"
},
    "SkImage_makeNonTextureImage": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {\n        if (nullptr == image) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        paint.setTextAlign(SkPaint::kCenter_Align);\n        sk_sp<SkImage> nonTexture(image->makeNonTextureImage());\n        canvas->drawImage(nonTexture, 0, 0);\n        canvas->drawString(label, nonTexture->width() / 2, nonTexture->height() / 4, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr));\n    drawImage(image, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, \"backEndTexture\");\n}",
    "width": 256,
    "height": 256,
    "hash": "220d369551a553f8ba4cd1c21b97a793",
    "file": "SkImage_Reference",
    "name": "SkImage::makeNonTextureImage"
},
    "SkImage_makeRasterImage": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {\n        if (nullptr == image) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        paint.setTextAlign(SkPaint::kCenter_Align);\n        sk_sp<SkImage> raster(image->makeRasterImage());\n        canvas->drawImage(raster, 0, 0);\n        canvas->drawString(label, raster->width() / 2, raster->height() / 4, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr));\n    drawImage(image, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, \"backEndTexture\");\n}",
    "width": 256,
    "height": 256,
    "hash": "d821b8e345df9ff0c8cbb6d91c588c02",
    "file": "SkImage_Reference",
    "name": "SkImage::makeRasterImage"
},
    "SkImage_makeShader": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setRotate(45);\n    SkPaint paint;\n    paint.setShader(image->makeShader(SkShader::kRepeat_TileMode, SkShader::kMirror_TileMode,\n                                      &matrix));\n    canvas->drawPaint(paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "1c6de6fe72b00b5be970f5f718363449",
    "file": "SkImage_Reference",
    "name": "SkImage::makeShader"
},
    "SkImage_makeShader_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setRotate(45);\n    matrix.postTranslate(125, 30);\n    SkPaint paint;\n    paint.setShader(image->makeShader(&matrix));\n    canvas->drawPaint(paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "10172fca71b9dbdcade772513ffeb27e",
    "file": "SkImage_Reference",
    "name": "SkImage::makeShader_2"
},
    "SkImage_makeSubset": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(.5f, .5f);\n    const int width = 32;\n    const int height = 32;\n    for (int y = 0; y < 512; y += height ) {\n        for (int x = 0; x < 512; x += width ) {\n            sk_sp<SkImage> subset(image->makeSubset({x, y, x + width, y + height}));\n            canvas->drawImage(subset, x * 3 / 2, y * 3 / 2);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "93669037c9eb9d142e7776b9f936fa96",
    "file": "SkImage_Reference",
    "name": "SkImage::makeSubset"
},
    "SkImage_makeTextureImage": {
    "code": "void draw(SkCanvas* canvas) {\n    auto drawImage = [=](sk_sp<SkImage> image, GrContext* context, const char* label) -> void {\n        if (nullptr == image || nullptr == context) {\n            return;\n        }\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        paint.setTextAlign(SkPaint::kCenter_Align);\n        sk_sp<SkImage> texture(image->makeTextureImage(context, nullptr));\n        canvas->drawImage(texture, 0, 0);\n        canvas->drawString(label, texture->width() / 2, texture->height() / 4, paint);\n    };\n    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));\n    GrContext* context = canvas->getGrContext();\n    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(context, backEndTexture,\n                                kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr));\n    drawImage(image, context, \"image\");\n    canvas->translate(image->width(), 0);\n    drawImage(bitmapImage, context, \"source\");\n    canvas->translate(-image->width(), image->height());\n    drawImage(textureImage, context, \"backEndTexture\");\n}",
    "width": 256,
    "height": 256,
    "hash": "7d060e137662b233960200b7b2597ba6",
    "file": "SkImage_Reference",
    "name": "SkImage::makeTextureImage"
},
    "SkImage_makeWithFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkImageFilter> shadowFilter = SkDropShadowImageFilter::Make(\n                -10.0f * frame, 5.0f * frame, 3.0f, 3.0f, SK_ColorBLUE,\n                SkDropShadowImageFilter::kDrawShadowAndForeground_ShadowMode,\n                nullptr);\n    sk_sp<SkImageFilter> offsetFilter = SkOffsetImageFilter::Make(40, 40, shadowFilter, nullptr);\n    SkIRect subset = image->bounds();\n    SkIRect clipBounds = image->bounds();\n    clipBounds.outset(60, 60);\n    SkIRect outSubset;\n    SkIPoint offset;\n    sk_sp<SkImage> filtered(image->makeWithFilter(offsetFilter.get(), subset, clipBounds,\n                            &outSubset, &offset));\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawLine(0, 0, offset.fX, offset.fY, paint);\n    canvas->translate(offset.fX, offset.fY);\n    canvas->drawImage(filtered, 0, 0);\n    canvas->drawRect(SkRect::MakeFromIRect(outSubset), paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "eabb12543886ace5e1212af220a19c6d",
    "file": "SkImage_Reference",
    "name": "SkImage::makeWithFilter"
},
    "SkImage_readPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->scale(.5f, .5f);\n    const int width = 32;\n    const int height = 32;\n    std::vector<int32_t> dstPixels;\n    dstPixels.resize(height * width * 4);\n    SkImageInfo info = SkImageInfo::MakeN32Premul(width, height);\n    for (int y = 0; y < 512; y += height ) {\n        for (int x = 0; x < 512; x += width ) {\n            if (image->readPixels(info, &dstPixels.front(), width * 4, x, y)) {\n                SkPixmap dstPixmap(info, &dstPixels.front(), width * 4);\n                SkBitmap bitmap;\n                bitmap.installPixels(dstPixmap);\n                canvas->drawBitmap(bitmap, 0, 0);\n            }\n            canvas->translate(48, 0);\n        }\n        canvas->translate(-16 * 48, 48);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "8aa8ca63dff4641dfc6ea8a3c555d59c",
    "file": "SkImage_Reference",
    "name": "SkImage::readPixels"
},
    "SkImage_readPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    int rowBytes = image->width() * 4;\n    int quarterWidth = image->width() / 4;\n    int quarterHeight = image->height() / 4;\n    srcPixels.resize(image->height() * rowBytes);\n    for (int y = 0; y < 4; ++y) {\n        for (int x = 0; x < 4; ++x) {\n            SkPixmap pixmap(SkImageInfo::MakeN32Premul(quarterWidth, quarterHeight),\n                    &srcPixels.front() + x * image->height() * quarterWidth +\n                    y * quarterWidth, rowBytes);\n            image->readPixels(pixmap, x * quarterWidth, y * quarterHeight);\n        }\n    }\n    canvas->scale(.5f, .5f);\n    SkBitmap bitmap;\n    bitmap.installPixels(SkImageInfo::MakeN32Premul(image->width(), image->height()),\n                             &srcPixels.front(), rowBytes);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "b77a73c4baa63a4a8e2a4fdd96144d0b",
    "file": "SkImage_Reference",
    "name": "SkImage::readPixels_2"
},
    "SkImage_refColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPixmap pixmap;\n    source.peekPixels(&pixmap);\n    canvas->scale(.25f, .25f);\n    int y = 0;\n    for (auto gamma : { SkColorSpace::kLinear_RenderTargetGamma,\n                        SkColorSpace::kSRGB_RenderTargetGamma } ) {\n        int x = 0;\n        sk_sp<SkColorSpace> colorSpace = SkColorSpace::MakeRGB(gamma, SkColorSpace::kSRGB_Gamut);\n        for (int index = 0; index < 2; ++index) {\n            pixmap.setColorSpace(colorSpace);\n            sk_sp<SkImage> image = SkImage::MakeRasterCopy(pixmap);\n            canvas->drawImage(image, x, y);\n            colorSpace = image->refColorSpace()->makeColorSpin();\n            x += 512;\n        }\n        y += 512;\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "59b2078ebfbda8736a57c0486ae33332",
    "file": "SkImage_Reference",
    "name": "SkImage::refColorSpace"
},
    "SkImage_refEncodedData": {
    "code": "void draw(SkCanvas* canvas) {\n    struct {\n        const char* name;\n        sk_sp<SkImage> image;\n    } tests[] = { { \"image\", image }, { \"bitmap\", SkImage::MakeFromBitmap(source) },\n          { \"texture\", SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                            kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr) } };\n    SkString string;\n    SkPaint paint;\n    for (const auto& test : tests ) {\n        if (!test.image) {\n            string.printf(\"no %s\", test.name);\n        } else {\n            string.printf(\"%s\" \"encoded %s\", test.image->refEncodedData() ? \"\" : \"no \", test.name);\n        }\n        canvas->drawString(string, 10, 20, paint);\n        canvas->translate(0, 20);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "91866923b37edd673c18232fdf3eabd8",
    "file": "SkImage_Reference",
    "name": "SkImage::refEncodedData"
},
    "SkImage_scalePixels": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> srcPixels;\n    int quarterWidth = image->width() / 16;\n    int rowBytes = quarterWidth * 4;\n    int quarterHeight = image->height() / 16;\n    srcPixels.resize(quarterHeight * rowBytes);\n    SkPixmap pixmap(SkImageInfo::MakeN32Premul(quarterWidth, quarterHeight),\n                    &srcPixels.front(), rowBytes);\n    canvas->scale(4, 4);\n    SkFilterQuality qualities[] = { kNone_SkFilterQuality, kLow_SkFilterQuality,\n                     kMedium_SkFilterQuality, kHigh_SkFilterQuality };\n    for (unsigned index = 0; index < SK_ARRAY_COUNT(qualities); ++index) {\n        image->scalePixels(pixmap, qualities[index]);\n        sk_sp<SkImage> filtered = SkImage::MakeFromRaster(pixmap, nullptr, nullptr);\n        canvas->drawImage(filtered, 16 * index, 0);\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "5949c9a63610cae30019e5b1899ee38f",
    "file": "SkImage_Reference",
    "name": "SkImage::scalePixels"
},
    "SkImage_toString": {
    "code": "void draw(SkCanvas* canvas) {\n    struct {\n        const char* name;\n        sk_sp<SkImage> image;\n    } tests[] = { { \"image\", image }, { \"bitmap\", SkImage::MakeFromBitmap(source) },\n          { \"texture\", SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,\n                            kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr) } };\n    SkString string;\n    SkPaint paint;\n    for (const auto& test : tests ) {\n        string.printf(\"%s: \", test.name);\n        test.image ? (void) test.image->toString(&string) : string.append(\"no image\");\n        canvas->drawString(string, 10, 20, paint);\n        canvas->translate(0, 20);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "e5eae6d362434154730e3bacff165ebd",
    "file": "SkImage_Reference",
    "name": "SkImage::toString"
},
    "SkImage_uniqueID": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkImage> subset = image->makeSubset({10, 20, 90, 100});\n    canvas->drawImage(image, 0, 0);\n    canvas->drawImage(subset, 128, 0);\n    SkPaint paint;\n    SkString s;\n    s.printf(\"original id: %d\", image->uniqueID());\n    canvas->drawString(s, 20, image->height() + 20, paint);\n    s.printf(\"subset id: %d\", subset->uniqueID());\n    canvas->drawString(s, 148, subset->height() + 20, paint);\n}",
    "width": 256,
    "height": 156,
    "hash": "d70194c9c51e700335f95de91846d023",
    "file": "SkImage_Reference",
    "name": "SkImage::uniqueID"
},
    "SkImage_width": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->translate(10, 10);\n    canvas->drawImage(image, 0, 0);\n    canvas->translate(0, image->height());\n    SkPaint paint;\n    paint.setTextAlign(SkPaint::kCenter_Align);\n    canvas->drawLine(0, 10, image->width(), 10, paint);\n    canvas->drawString(\"width\", image->width() / 2, 25, paint);\n}",
    "width": 256,
    "height": 96,
    "hash": "39a6d0bbeac6d957c2338e0bff865cf8",
    "file": "SkImage_Reference",
    "name": "SkImage::width()"
},
    "SkMatrix_Concat": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix, matrix2;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix2.setPolyToPoly(perspect, bitmapBounds, 4);\n    SkMatrix concat = SkMatrix::Concat(matrix, matrix2);\n    canvas->concat(concat);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "6b4562c7052da94f3d5b2412dca41946",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::Concat"
},
    "SkMatrix_MakeAll": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(64);\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            SkMatrix m = SkMatrix::MakeAll(sx, 1, 128,    0, sy, 128,   0, 0, 1);\n            canvas->concat(m);\n            canvas->drawString(\"K\", 0, 0, p);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "6bad83b64de9266e323c29d550e04188",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::MakeAll"
},
    "SkMatrix_MakeScale": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->concat(SkMatrix::MakeScale(4, 3));\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "7ff17718111df6d6f95381d8a8f1b389",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::MakeScale"
},
    "SkMatrix_MakeScale_2": {
    "code": "void draw(SkCanvas* canvas) {\n    canvas->concat(SkMatrix::MakeScale(4));\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "2956aeb50fa862cdb13995e1e56a4bc8",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::MakeScale_2"
},
    "SkMatrix_MakeTrans": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix = SkMatrix::MakeTrans(64, 48);\n    for (int i = 0; i < 4; ++i) {\n        canvas->drawBitmap(source, 0, 0);\n        canvas->concat(matrix);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "b2479df0d9cf296ff64ac31e36684557",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::MakeTrans"
},
    "SkMatrix_ScaleToFit": {
    "code": "void draw(SkCanvas* canvas) {\n    const char* labels[] = { \"Fill\", \"Start\", \"Center\", \"End\" };\n    SkRect rects[] = {{5, 5, 59, 59}, {5, 74, 59, 108}, {10, 123, 44, 172}, {10, 187, 54, 231}};\n    SkRect bounds;\n    source.getBounds(&bounds);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    for (auto fit : { SkMatrix::kFill_ScaleToFit, SkMatrix::kStart_ScaleToFit,\n                      SkMatrix::kCenter_ScaleToFit, SkMatrix::kEnd_ScaleToFit } ) {\n        for (auto rect : rects ) {\n            canvas->drawRect(rect, paint);\n            SkMatrix matrix;\n            if (!matrix.setRectToRect(bounds, rect, fit)) {\n                continue;\n            }\n            SkAutoCanvasRestore acr(canvas, true);\n            canvas->concat(matrix);\n            canvas->drawBitmap(source, 0, 0);\n        }\n        canvas->drawString(labels[fit], 10, 255, paint);\n        canvas->translate(64, 0);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "17c3070b31b700ea8f52e48af9a66b6e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::ScaleToFit"
},
    "SkMatrix__anonymous": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint black;\n    black.setAntiAlias(true);\n    black.setTextSize(48);\n    SkPaint gray = black;\n    gray.setColor(0xFF9f9f9f);\n    SkScalar offset[] = { 1.5f, 1.5f, 20,   1.5f, 1.5f, 20,   .03f, .01f, 2 };\n    for (int i : { SkMatrix::kMScaleX, SkMatrix::kMSkewX,  SkMatrix::kMTransX,\n                   SkMatrix::kMSkewY,  SkMatrix::kMScaleY, SkMatrix::kMTransY,\n                   SkMatrix::kMPersp0, SkMatrix::kMPersp1, SkMatrix::kMPersp2 } ) {\n        SkMatrix m;\n        m.setIdentity();\n        m.set(i, offset[i]);\n        SkAutoCanvasRestore autoRestore(canvas, true);\n        canvas->translate(22 + (i % 3) * 88, 44 + (i / 3) * 88);\n        canvas->drawString(\"&\", 0, 0, gray);\n        canvas->concat(m);\n        canvas->drawString(\"&\", 0, 0, black);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "3bbf75f4748420810aa2586e3c8548d9",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::_anonymous"
},
    "SkMatrix_fixedStepInX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    const SkPoint center = { 128, 128 };\n    matrix.setScale(20, 25, center.fX, center.fY);\n    matrix.postRotate(75, center.fX, center.fY);\n    {\n       SkAutoCanvasRestore acr(canvas, true);\n       canvas->concat(matrix);\n       canvas->drawBitmap(source, 0, 0);\n    }\n    if (matrix.isFixedStepInX()) {\n       SkPaint paint;\n       paint.setAntiAlias(true);\n       SkVector step = matrix.fixedStepInX(128);\n       SkVector end = center + step;\n       canvas->drawLine(center, end, paint);\n       SkVector arrow = { step.fX + step.fY, step.fY - step.fX};\n       arrow = arrow * .25f;\n       canvas->drawLine(end, end - arrow, paint);\n       canvas->drawLine(end, {end.fX + arrow.fY, end.fY - arrow.fX}, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "fad6b92b21b1e1deeae61978cec2d232",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::fixedStepInX"
},
    "SkMatrix_getPerspX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m;\n    m.setIdentity();\n    m.set(SkMatrix::kMPersp0, -0.004f);\n    SkAutoCanvasRestore autoRestore(canvas, true);\n    canvas->translate(22, 144);\n    SkPaint black;\n    black.setAntiAlias(true);\n    black.setTextSize(24);\n    SkPaint gray = black;\n    gray.setColor(0xFF9f9f9f);\n    SkString string;\n    string.appendScalar(m.getPerspX());\n    canvas->drawString(string, 0, -72, gray);\n    canvas->concat(m);\n    canvas->drawString(string, 0, 0, black);\n}",
    "width": 256,
    "height": 256,
    "hash": "a0f5bf4b55e8c33bfda29bf67e34306f",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getPerspX"
},
    "SkMatrix_getPerspY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m;\n    m.setIdentity();\n    m.set(SkMatrix::kMPersp1, -0.004f);\n    SkAutoCanvasRestore autoRestore(canvas, true);\n    canvas->translate(22, 144);\n    SkPaint black;\n    black.setAntiAlias(true);\n    black.setTextSize(24);\n    SkPaint gray = black;\n    gray.setColor(0xFF9f9f9f);\n    SkString string;\n    string.appendScalar(m.getPerspY());\n    canvas->drawString(string, 0, -72, gray);\n    canvas->concat(m);\n    canvas->drawString(string, 0, 0, black);\n}",
    "width": 256,
    "height": 256,
    "hash": "424a00a73675dbd99ad20feb0267442b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::getPerspY"
},
    "SkMatrix_hasPerspective": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    canvas->concat(matrix);\n    SkString string;\n    string.printf(\"hasPerspective %s\", matrix.hasPerspective() ? \"true\" : \"false\");\n    canvas->drawBitmap(source, 0, 0);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(48);\n    canvas->drawString(string, 0, source.bounds().height() + 48, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "688123908c733169bbbfaf11f41ecff6",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::hasPerspective"
},
    "SkMatrix_invert": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkPoint src[] = { { 10, 120}, {120, 120}, {120, 10}, {  10, 10} };\n    const SkPoint dst[] = { {150, 120}, {200, 100}, {240, 30}, { 130, 40} };\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    matrix.setPolyToPoly(src, dst, 4);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, 4, src, paint);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, 4, dst, paint);\n    paint.setColor(SK_ColorBLUE);\n    paint.setStrokeWidth(3);\n    paint.setStrokeCap(SkPaint::kRound_Cap);\n    canvas->drawPoints(SkCanvas::kPoints_PointMode, 4, dst, paint);\n    matrix.invert(&matrix);\n    canvas->concat(matrix);\n    canvas->drawPoints(SkCanvas::kPoints_PointMode, 4, dst, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "10a10c5bf2ac7ec88e84204441fc83b6",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::invert()"
},
    "SkMatrix_isSimilarity": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    SkMatrix m;\n    int below = 175;\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            m.setAll(sx, 1, 128,    1, sy, 32,   0, 0, 1);\n            bool isSimilarity = m.isSimilarity();\n            SkString str;\n            str.printf(\"sx: %g sy: %g sim: %s\", sx, sy, isSimilarity ? \"true\" : \"false\");\n            {\n                SkAutoCanvasRestore autoRestore(canvas, true);\n                canvas->concat(m);\n                canvas->drawString(str, 0, 0, p);    \n            }\n            if (!isSimilarity) {\n                canvas->drawString(str, 40, below, p);\n                below += 20;\n            }\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "98d60230ad633ae74d851de3a65d72d6",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::isSimilarity"
},
    "SkMatrix_mapHomogeneousPoints": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint3 src[] = {{3, 3, 1}, {8, 2, 2}, {5, 0, 4}, {0, 1, 3},\n                      {3, 7, 1}, {8, 6, 2}, {5, 4, 4}, {0, 5, 3}};\n    int lines[] = { 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 };\n    constexpr int count = SK_ARRAY_COUNT(src);\n    auto debugster = [=](SkPoint3 src[]) -> void {\n    for (size_t i = 0; i < SK_ARRAY_COUNT(lines); i += 2) {\n        const SkPoint3& s = src[lines[i]];\n        const SkPoint3& e = src[lines[i + 1]];\n        SkPaint paint;\n        paint.setARGB(77, 23, 99, 154);\n        canvas->drawLine(s.fX / s.fZ, s.fY / s.fZ, e.fX / e.fZ, e.fY / e.fZ, paint);\n    }\n    };\n    canvas->save();\n    canvas->translate(5, 5);\n    canvas->scale(15, 15);\n    debugster(src);\n    canvas->restore();\n    canvas->translate(128, 128);\n    SkMatrix matrix;\n    matrix.setAll(15, 0, 0, 0, 15, 0, -0.08, 0.04, 1);\n    matrix.mapHomogeneousPoints(src, src, count);\n    debugster(src);\n}",
    "width": 256,
    "height": 256,
    "hash": "d56f93e4bc763c7ba4914321ed07a8b5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapHomogeneousPoints"
},
    "SkMatrix_mapPoints": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.reset();\n    const int count = 4;\n    SkPoint src[count];\n    matrix.mapRectToQuad(src, {40, 70, 180, 220} );\n    SkPaint paint;\n    paint.setARGB(77, 23, 99, 154);\n    for (int i = 0; i < 5; ++i) {\n        SkPoint dst[count];\n        matrix.mapPoints(dst, src, count);\n        canvas->drawPoints(SkCanvas::kPolygon_PointMode, count, dst, paint);\n        matrix.preRotate(35, 128, 128);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "f99dcb00296d0c56b6c0e178e94b3534",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapPoints"
},
    "SkMatrix_mapPoints_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    matrix.setRotate(35, 128, 128);\n    const int count = 4;\n    SkPoint pts[count];\n    matrix.mapRectToQuad(pts, {40, 70, 180, 220} );\n    SkPaint paint;\n    paint.setARGB(77, 23, 99, 154);\n    for (int i = 0; i < 5; ++i) {\n        canvas->drawPoints(SkCanvas::kPolygon_PointMode, count, pts, paint);\n        matrix.mapPoints(pts, count);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "428ca171ae3bd0d3f992458ac598b97b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapPoints_2"
},
    "SkMatrix_mapRadius": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    const SkPoint center = {108, 93};\n    matrix.setScale(2, .5f, center.fX, center.fY);\n    matrix.postRotate(45, center.fX, center.fY);\n    const SkScalar circleRadius = 50;\n    SkScalar mappedRadius = matrix.mapRadius(circleRadius);\n    SkVector minorAxis, majorAxis;\n    matrix.mapVector(0, circleRadius, &minorAxis);\n    matrix.mapVector(circleRadius, 0, &majorAxis);\n    SkString mappedArea;\n    mappedArea.printf(\"area = %g\", mappedRadius * mappedRadius);\n    canvas->drawString(mappedArea, 145, 250, paint);\n    canvas->drawString(\"mappedRadius\", center.fX + mappedRadius + 3, center.fY, paint);\n    paint.setColor(SK_ColorRED);\n    SkString axArea;\n    axArea.printf(\"area = %g\", majorAxis.length() * minorAxis.length());\n    paint.setStyle(SkPaint::kFill_Style);\n    canvas->drawString(axArea, 15, 250, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRect({10, 200, 10 + majorAxis.length(), 200 + minorAxis.length()}, paint);\n    paint.setColor(SK_ColorBLACK);\n    canvas->drawLine(center.fX, center.fY, center.fX + mappedRadius, center.fY, paint);\n    canvas->drawLine(center.fX, center.fY, center.fX, center.fY + mappedRadius, paint);\n    canvas->drawRect({140, 180, 140 + mappedRadius, 180 + mappedRadius}, paint);\n    canvas->concat(matrix);\n    canvas->drawCircle(center.fX, center.fY, circleRadius, paint);\n    paint.setColor(SK_ColorRED);\n    canvas->drawLine(center.fX, center.fY, center.fX + circleRadius, center.fY, paint);\n    canvas->drawLine(center.fX, center.fY, center.fX, center.fY + circleRadius, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "6d6f2082fcf59d9f02bfb1758b87db69",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapRadius"
},
    "SkMatrix_mapRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    matrix.setRotate(45, 128, 128);\n    SkRect rotatedBounds, bounds = {40, 50, 190, 200};\n    matrix.mapRect(&rotatedBounds, bounds );\n    paint.setColor(SK_ColorGRAY);\n    canvas->drawRect(rotatedBounds, paint);\n    canvas->concat(matrix);\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect(bounds, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "dbcf928b035a31ca69c99392e2e2cca9",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapRect"
},
    "SkMatrix_mapRectScaleTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkMatrix matrix;\n    SkRect rect = {100, 50, 150, 180};\n    matrix.setScale(2, .5f, rect.centerX(), rect.centerY());\n    SkRect rotated;\n    matrix.mapRectScaleTranslate(&rotated, rect);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect(rotated, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "62bc26989c2b4c2a54d516596a71dd97",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapRectScaleTranslate"
},
    "SkMatrix_mapRectToQuad": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    matrix.setRotate(60, 128, 128);\n    SkRect rect = {50, 50, 150, 150};\n    SkPoint pts[4];\n    matrix.mapRectToQuad(pts, rect);\n    for (int i = 0; i < 4; ++i) {\n        canvas->drawCircle(pts[i].fX, pts[i].fY, 3, paint);\n    }\n    canvas->concat(matrix);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 192,
    "hash": "c69cd2a590b5733c3cbc92cb9ceed3f5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapRectToQuad"
},
    "SkMatrix_mapRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    matrix.setRotate(45, 128, 128);\n    SkRect bounds = {40, 50, 190, 200};\n    matrix.mapRect(&bounds);\n    paint.setColor(SK_ColorGRAY);\n    canvas->drawRect(bounds, paint);\n    canvas->concat(matrix);\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect({40, 50, 190, 200}, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "5fafd0bd23d1ed37425b970b4a3c6cc9",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapRect_2"
},
    "SkMatrix_mapVector": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGREEN);\n    paint.setAntiAlias(true);\n    paint.setTextSize(48);\n    SkMatrix matrix;\n    matrix.setRotate(90);\n    SkVector offset = { 7, 7 };\n    for (int i = 0; i < 4; ++i) {\n        paint.setImageFilter(SkDropShadowImageFilter::Make(offset.fX, offset.fY, 3, 3,\n              SK_ColorBLUE, SkDropShadowImageFilter::kDrawShadowAndForeground_ShadowMode, nullptr));\n        matrix.mapVector(offset.fX, offset.fY, &offset);\n        canvas->translate(0, 60);\n        canvas->drawString(\"Text\", 50, 0, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "aed143fc6cd0bce4ed029b98d1e61f2d",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapVector"
},
    "SkMatrix_mapVector_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGREEN);\n    paint.setAntiAlias(true);\n    paint.setTextSize(48);\n    SkMatrix matrix;\n    matrix.setRotate(90);\n    SkVector offset = { 7, 7 };\n    for (int i = 0; i < 4; ++i) {\n        paint.setImageFilter(SkDropShadowImageFilter::Make(offset.fX, offset.fY, 3, 3,\n              SK_ColorBLUE, SkDropShadowImageFilter::kDrawShadowAndForeground_ShadowMode, nullptr));\n        offset = matrix.mapVector(offset.fX, offset.fY);\n        canvas->translate(0, 60);\n        canvas->drawString(\"Text\", 50, 0, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "8bf1518db3f369696cd3065b541a8bd7",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapVector_2"
},
    "SkMatrix_mapVectors": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkMatrix matrix;\n    matrix.reset();\n    const SkVector radii[] = {{8, 4}, {9, 1}, {6, 2}, {7, 3}};\n    for (int i = 0; i < 4; ++i) {\n        SkVector rScaled[4];\n        matrix.preScale(1.5f, 2.f);\n        matrix.mapVectors(rScaled, radii, SK_ARRAY_COUNT(radii));\n        SkRRect rrect;\n        rrect.setRectRadii({20, 20, 180, 70}, rScaled);\n        canvas->drawRRect(rrect, paint);\n        canvas->translate(0, 60);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "918a9778c3d7d5cb306692784399f6dc",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapVectors"
},
    "SkMatrix_mapVectors_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkMatrix matrix;\n    matrix.setScale(2, 3);\n    SkVector radii[] = {{7, 7}, {3, 3}, {2, 2}, {4, 0}};\n    for (int i = 0; i < 4; ++i) {\n        SkRRect rrect;\n        rrect.setRectRadii({20, 20, 180, 70}, radii);\n        canvas->drawRRect(rrect, paint);\n        canvas->translate(0, 60);\n        matrix.mapVectors(radii, SK_ARRAY_COUNT(radii));\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "5754501a00a1323e76353fb53153e939",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapVectors_2"
},
    "SkMatrix_mapXY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkMatrix matrix;\n    matrix.setRotate(60, 128, 128);\n    SkPoint lines[] = {{50, 50}, {150, 50}, {150, 150}};\n    for (size_t i = 0; i < SK_ARRAY_COUNT(lines); ++i) {\n        SkPoint pt;\n        matrix.mapXY(lines[i].fX, lines[i].fY, &pt);\n        canvas->drawCircle(pt.fX, pt.fY, 3, paint);\n    }\n    canvas->concat(matrix);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(lines), lines, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "9e50185d502dc6903783679a84106089",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapXY"
},
    "SkMatrix_mapXY_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {30, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStrokeWidth(3);\n    for (int x : { 0, source.width() } ) {\n        for (int y : { 0, source.height() } ) {\n            canvas->drawPoint(matrix.mapXY(x, y), paint);\n        }\n    }\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "b1ead09c67a177ab8eace12b061610a7",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::mapXY_2"
},
    "SkMatrix_postConcat": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix, matrix2;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postConcat(matrix);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "0a4214289249c77f48d59227c4ac4d9e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postConcat"
},
    "SkMatrix_postIDiv": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix, matrix2;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postIDiv(1, 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "58c844b8f0c36acdbc8211e8c929c253",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postIDiv"
},
    "SkMatrix_postRotate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postRotate(45, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "e09194ee48a81e7b375ade473d340f0d",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postRotate"
},
    "SkMatrix_postRotate_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postRotate(45);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "52e4c53e26971af5576b30de60fa70c2",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postRotate_2"
},
    "SkMatrix_postScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postScale(.75f, 1.5f, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "ed3aa18ba0ea95c85cc49aa3829fe384",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postScale"
},
    "SkMatrix_postScale_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postScale(.75f, 1.5f);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "1931017698766a67d3a26423453b8095",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postScale_2"
},
    "SkMatrix_postSkew": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postSkew(.5f, 0, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "8c34ae3a2b7e2742bb969819737365ec",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postSkew"
},
    "SkMatrix_postSkew_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.postSkew(.5f, 0);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "3aa2603225dff72ac53dd359f897f494",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postSkew_2"
},
    "SkMatrix_postTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    for (int i = 0; i < 2; ++i ) {\n        SkMatrix matrix;\n        i == 0 ? matrix.reset(): matrix.setRotate(25, rect.centerX(), 320);\n        { \n            SkAutoCanvasRestore acr(canvas, true);\n            canvas->concat(matrix);\n            paint.setColor(SK_ColorGRAY);\n            canvas->drawRect(rect, paint);\n        }\n        paint.setColor(SK_ColorRED);\n        for (int j = 0; j < 2; ++j ) {\n            SkAutoCanvasRestore acr(canvas, true);\n            matrix.postTranslate(40, 40);\n            canvas->concat(matrix);\n            canvas->drawCircle(0, 0, 3, paint);\n        }\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "57e4cff302c0d754ac6c66050d741772",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::postTranslate"
},
    "SkMatrix_preConcat": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix, matrix2;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix2.setPolyToPoly(perspect, bitmapBounds, 4);\n    matrix.preConcat(matrix2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "b07e62298e7b0ab5683db199faffceb2",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preConcat"
},
    "SkMatrix_preRotate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preRotate(45, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "a70bb18d67c06a20ab514e7a47924e5a",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preRotate"
},
    "SkMatrix_preRotate_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preRotate(45);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "5acd49bd931c79a808dd6c7cc0e92f72",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preRotate_2"
},
    "SkMatrix_preScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preScale(.75f, 1.5f, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "2531f8d1e05d7b6dc22f3efcd2fb84e4",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preScale"
},
    "SkMatrix_preScale_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preScale(.75f, 1.5f);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "3edbdea8e43d06086abf33ec4a9b415b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preScale_2"
},
    "SkMatrix_preSkew": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preSkew(.5f, 0, source.width() / 2, source.height() / 2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "199a18ad61d702664ce6df1d7037aa48",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preSkew"
},
    "SkMatrix_preSkew_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix.preSkew(.5f, 0);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "e100c543869fe8fd516ba69de79444ba",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preSkew_2"
},
    "SkMatrix_preTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    for (int i = 0; i < 2; ++i ) {\n        SkMatrix matrix;\n        i == 0 ? matrix.reset(): matrix.setRotate(25, rect.centerX(), 320);\n        { \n            SkAutoCanvasRestore acr(canvas, true);\n            canvas->concat(matrix);\n            paint.setColor(SK_ColorGRAY);\n            canvas->drawRect(rect, paint);\n        }\n        paint.setColor(SK_ColorRED);\n        for (int j = 0; j < 2; ++j ) {\n            SkAutoCanvasRestore acr(canvas, true);\n            matrix.preTranslate(40, 40);\n            canvas->concat(matrix);\n            canvas->drawCircle(0, 0, 3, paint);\n        }\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "08f6749933f4ce541073077ab506fd9b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preTranslate"
},
    "SkMatrix_preservesRightAngles": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    SkMatrix m;\n    int pos = 0;\n    for (SkScalar sx : { 1, 2 } ) {\n        for (SkScalar kx : { 0, 1 } ) {\n            m.setAll(sx, kx, 16,    0, 1, 32,   0, 0, 1);\n            bool isSimilarity = m.isSimilarity();\n            bool preservesRightAngles = m.preservesRightAngles();\n            SkString str;\n            str.printf(\"sx: %g kx: %g %s %s\", sx, kx, isSimilarity ? \"sim\" : \"\",\n                        preservesRightAngles ? \"right\" : \"\");\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            canvas->concat(m);\n            canvas->drawString(str, 0, pos, p);    \n            pos += 20;\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "a3d5bfebc1c3423fb983d30aaf4ac5f4",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::preservesRightAngles"
},
    "SkMatrix_set9": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix m;\n    SkScalar buffer[9] = {4, 0, 3,    0, 5, 4,     0, 0, 1};\n    m.set9(buffer);\n    canvas->concat(m);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "ec5de0d23e5fe28ba7628625d1402e85",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::set9"
},
    "SkMatrix_setAll": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(64);\n    SkMatrix m;\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            m.setAll(sx, 1, 128,    0, sy, 64,   0, 0, 1);\n            canvas->concat(m);\n            canvas->drawString(\"K\", 0, 0, p);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "95ccfc2a89ce593e6b7a9f992a844bc0",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setAll"
},
    "SkMatrix_setConcat": {
    "code": "void draw(SkCanvas* canvas) {\n    SkMatrix matrix, matrix2;\n    SkPoint bitmapBounds[4], perspect[4] = {{50, 10}, {180, 40}, {236, 176}, {10, 206}};\n    SkRect::Make(source.bounds()).toQuad(bitmapBounds);\n    matrix.setPolyToPoly(bitmapBounds, perspect, 4);\n    matrix2.setPolyToPoly(perspect, bitmapBounds, 4);\n    matrix.setConcat(matrix, matrix2);\n    canvas->concat(matrix);\n    canvas->drawBitmap(source, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "0381a10ac69bdefdf9d15b47cbb9fefe",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setConcat"
},
    "SkMatrix_setPerspX": {
    "code": "void draw(SkCanvas* canvas) {\n    for (SkScalar perspX : { -.003f, 0.f, .003f, .012f } ) {\n        SkMatrix matrix;\n        matrix.setIdentity();\n        matrix.setPerspX(perspX);\n        canvas->save();\n        canvas->concat(matrix);\n        canvas->drawBitmap(source, 0, 0);\n        canvas->restore();\n        canvas->translate(64, 64);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "830a9e4e4bb93d25afd83b2fea63929e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setPerspX"
},
    "SkMatrix_setPerspY": {
    "code": "void draw(SkCanvas* canvas) {\n    for (SkScalar perspX : { -.003f, 0.f, .003f, .012f } ) {\n        SkMatrix matrix;\n        matrix.setIdentity();\n        matrix.setPerspY(perspX);\n        canvas->save();\n        canvas->concat(matrix);\n        canvas->drawBitmap(source, 0, 0);\n        canvas->restore();\n        canvas->translate(64, 64);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "aeb258b7922c1a11b698b00f562182ec",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setPerspY"
},
    "SkMatrix_setPolyToPoly": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkPoint src[] = { { 0, 0}, {30,   0}, {30, -30}, { 0, -30} };\n    const SkPoint dst[] = { {50, 0}, {80, -10}, {90, -30}, {60, -40} };\n    SkPaint blackPaint;\n    blackPaint.setAntiAlias(true);\n    blackPaint.setTextSize(42);\n    SkPaint redPaint = blackPaint;\n    redPaint.setColor(SK_ColorRED);\n    for (int count : { 1, 2, 3, 4 } ) {\n        canvas->translate(35, 55);\n        for (int index = 0; index < count; ++index) {\n            canvas->drawCircle(src[index], 3, blackPaint);\n            canvas->drawCircle(dst[index], 3, blackPaint);\n            if (index > 0) {\n                canvas->drawLine(src[index], src[index - 1], blackPaint);\n                canvas->drawLine(dst[index], dst[index - 1], blackPaint);\n            }\n        }\n        SkMatrix matrix;\n        matrix.setPolyToPoly(src, dst, count);\n        canvas->drawString(\"A\", src[0].fX, src[0].fY, redPaint);\n        SkAutoCanvasRestore acr(canvas, true);\n        canvas->concat(matrix);\n        canvas->drawString(\"A\", src[0].fX, src[0].fY, redPaint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "c851d1313e8909aaea4f0591699fdb7b",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setPolyToPoly"
},
    "SkMatrix_setRSXform": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    SkMatrix matrix;\n    matrix.setRSXform(SkRSXform::Make(.85f, .25f, rect.centerX(), rect.centerY()));\n    canvas->concat(matrix);\n    canvas->translate(-rect.centerX(), -rect.centerY());\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "c3f5faddca466f78278b32b88fd5f5eb",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setRSXform"
},
    "SkMatrix_setRotate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    SkMatrix matrix;\n    matrix.setRotate(25, rect.centerX(), rect.centerY());\n    canvas->concat(matrix);\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "8c28db3add9cd0177225088f6df6bbb5",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setRotate"
},
    "SkMatrix_setRotate_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    SkMatrix matrix;\n    matrix.setRotate(25);\n    canvas->translate(rect.centerX(), rect.centerY());\n    canvas->concat(matrix);\n    canvas->translate(-rect.centerX(), -rect.centerY());\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "93efb9d191bf1b9710c173513e014d6c",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setRotate_2"
},
    "SkMatrix_setScale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(64);\n    SkMatrix m;\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            m.setScale(sx, sy, 128, 64);\n            canvas->concat(m);\n            canvas->drawString(\"%\", 128, 64, p);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "4565a0792058178c88e0a129a87272d6",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setScale"
},
    "SkMatrix_setScaleX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 12, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setScaleX(3);\n    canvas->concat(matrix);\n    canvas->drawString(\"x scale\", 0, 48, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "a39dfed98c3c3c3a56be9ad59fe4e21e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setScaleX"
},
    "SkMatrix_setScaleY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 12, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setScaleY(3);\n    canvas->concat(matrix);\n    canvas->drawString(\"y scale\", 12, 48, paint);\n}",
    "width": 256,
    "height": 192,
    "hash": "f040c6dd85a02e94eaca00d5c2832604",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setScaleY"
},
    "SkMatrix_setScale_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(64);\n    SkMatrix m;\n    for (SkScalar sx : { -1, 1 } ) {\n        for (SkScalar sy : { -1, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            m.setScale(sx, sy);\n            m.postTranslate(128, 64);\n            canvas->concat(m);\n            canvas->drawString(\"@\", 0, 0, p);\n        }\n    }\n}",
    "width": 256,
    "height": 128,
    "hash": "1579d0cc109c26e69f66f73abd35fb0e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setScale_2"
},
    "SkMatrix_setSinCos": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    SkMatrix matrix;\n    matrix.setSinCos(.25f, .85f, rect.centerX(), rect.centerY());\n    canvas->concat(matrix);\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "187e1d9228e2e4341ef820bd77b6fda9",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSinCos"
},
    "SkMatrix_setSinCos_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorGRAY);\n    paint.setAntiAlias(true);\n    SkRect rect = {20, 20, 100, 100};\n    canvas->drawRect(rect, paint);\n    paint.setColor(SK_ColorRED);\n    SkMatrix matrix;\n    matrix.setSinCos(.25f, .85f);\n    matrix.postTranslate(rect.centerX(), rect.centerY());\n    canvas->concat(matrix);\n    canvas->translate(-rect.centerX(), -rect.centerY());\n    canvas->drawRect(rect, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "e37a94a53c959951b059fcd624639ef6",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSinCos_2"
},
    "SkMatrix_setSkew": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(48);\n    SkMatrix m;\n    for (SkScalar sx : { -1, 0, 1 } ) {\n        for (SkScalar sy : { -1, 0, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            m.setSkew(sx, sy, 96 + 64 * sx, 128 + 48 * sy);\n            canvas->concat(m);\n            canvas->drawString(\"K\", 96 + 64 * sx, 128 + 48 * sy, p);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "55e0431adc6c5b1987ebb8123cc10342",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSkew"
},
    "SkMatrix_setSkewX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 12, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setSkewX(-.7f);\n    canvas->concat(matrix);\n    canvas->drawString(\"x skew\", 36, 48, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "c7177a6fbc1545be95a5ebca87e0cd0d",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSkewX"
},
    "SkMatrix_setSkewY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 12, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setSkewY(.3f);\n    canvas->concat(matrix);\n    canvas->drawString(\"y skew\", 12, 48, paint);\n}",
    "width": 256,
    "height": 96,
    "hash": "b418d15df9829aefcc6aca93a37428bb",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSkewY"
},
    "SkMatrix_setSkew_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint p;\n    p.setAntiAlias(true);\n    p.setTextSize(48);\n    SkMatrix m;\n    for (SkScalar sx : { -1, 0, 1 } ) {\n        for (SkScalar sy : { -1, 0, 1 } ) {\n            SkAutoCanvasRestore autoRestore(canvas, true);\n            m.setSkew(sx, sy);\n            m.postTranslate(96 + 64 * sx, 128 + 48 * sy);\n            canvas->concat(m);\n            canvas->drawString(\"K\", 0, 0, p);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "05be7844e9afdd7b9bfc31c5423a70a2",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setSkew_2"
},
    "SkMatrix_setTranslate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 8, 24, paint);\n    SkMatrix matrix;\n    matrix.setTranslate(96, 24);\n    canvas->concat(matrix);\n    canvas->drawString(\"translate\", 8, 24, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "63ca62985741b1bccb5e8b9cf734874e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setTranslate"
},
    "SkMatrix_setTranslateX": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 8, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setTranslateX(96);\n    canvas->concat(matrix);\n    canvas->drawString(\"x translate\", 8, 24, paint);\n}",
    "width": 256,
    "height": 48,
    "hash": "a18bc2e3607ac3a8e438bcb61fb13130",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setTranslateX"
},
    "SkMatrix_setTranslateY": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 8, 24, paint);\n    SkMatrix matrix;\n    matrix.setIdentity();\n    matrix.setTranslateY(24);\n    canvas->concat(matrix);\n    canvas->drawString(\"y translate\", 8, 24, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "34e3c70a72b836abf7f4858d35eecc98",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setTranslateY"
},
    "SkMatrix_setTranslate_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(24);\n    canvas->drawString(\"normal\", 8, 24, paint);\n    SkMatrix matrix;\n    matrix.setTranslate({96, 24});\n    canvas->concat(matrix);\n    canvas->drawString(\"translate\", 8, 24, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "ccfc734aff2ddea0b097c83f5621de5e",
    "file": "SkMatrix_Reference",
    "name": "SkMatrix::setTranslate_2"
},
    "SkPaint_Join": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(10, 50);\n    path.quadTo(35, 110, 60, 210);\n    path.quadTo(105, 110, 130, 10);\n    SkPaint paint;  // set to default kMiter_Join\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(20);\n    canvas->drawPath(path, paint);\n    canvas->translate(150, 0);\n    paint.setStrokeJoin(SkPaint::kBevel_Join);\n    canvas->drawPath(path, paint);\n    canvas->translate(150, 0);\n    paint.setStrokeJoin(SkPaint::kRound_Join);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 462,
    "height": 256,
    "hash": "3b1aebacc21c1836a52876b9b0b3905e",
    "file": "SkPaint_Reference",
    "name": "SkPaint::Join"
},
    "SkPaint_breakText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(50);\n    const char str[] = \"Breakfast\";\n    const int count = sizeof(str) - 1;\n    canvas->drawText(str, count, 25, 50, paint);\n    SkScalar measuredWidth;\n    int partialBytes = paint.breakText(str, count, 100, &measuredWidth);\n    canvas->drawText(str, partialBytes, 25, 100, paint);\n    canvas->drawLine(25, 60, 25 + 100, 60, paint);\n    canvas->drawLine(25, 110, 25 + measuredWidth, 110, paint);\n}\n",
    "width": 280,
    "height": 128,
    "hash": "fd0033470ccbd5c7059670fdbf96cffc",
    "file": "SkPaint_Reference",
    "name": "SkPaint::breakText"
},
    "SkPaint_empty_constructor": {
    "code": "void draw(SkCanvas* canvas) {\n    #ifndef SkUserConfig_DEFINED\n    #define SkUserConfig_DEFINED\n    #define SkPaintDefaults_Flags      0x01   // always enable antialiasing\n    #define SkPaintDefaults_TextSize   24.f   // double default font size\n    #define SkPaintDefaults_Hinting    3      // use full hinting\n    #define SkPaintDefaults_MiterLimit 10.f   // use HTML Canvas miter limit setting\n    #endif\n}",
    "width": 256,
    "height": 1,
    "hash": "c4b2186d85c142a481298f7144295ffd",
    "file": "SkPaint_Reference",
    "name": "SkPaint::SkPaint()"
},
    "SkPaint_getFillPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint strokePaint;\n    strokePaint.setAntiAlias(true);\n    strokePaint.setStyle(SkPaint::kStroke_Style);\n    strokePaint.setStrokeWidth(.1f);\n    SkPath strokePath;\n    strokePath.moveTo(.08f, .08f);\n    strokePath.quadTo(.09f, .08f, .17f, .17f);\n    SkPath fillPath;\n    SkPaint outlinePaint(strokePaint);\n    outlinePaint.setStrokeWidth(2);\n    SkMatrix scale = SkMatrix::MakeScale(300, 300);\n    for (SkScalar precision : { 0.01f, .1f, 1.f, 10.f, 100.f } ) {\n        strokePaint.getFillPath(strokePath, &fillPath, nullptr, precision);\n        fillPath.transform(scale);\n        canvas->drawPath(fillPath, outlinePaint);\n        canvas->translate(60, 0);\n        if (1.f == precision) canvas->translate(-180, 100);\n    }\n    strokePath.transform(scale);\n    strokePaint.setStrokeWidth(30);\n    canvas->drawPath(strokePath, strokePaint);\n}\n",
    "width": 256,
    "height": 192,
    "hash": "cedd6233848198e1fca4d1e14816baaf",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFillPath"
},
    "SkPaint_getFillPath_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    SkPath strokePath;\n    strokePath.moveTo(20, 20);\n    strokePath.lineTo(100, 100);\n    canvas->drawPath(strokePath, paint);\n    SkPath fillPath;\n    paint.getFillPath(strokePath, &fillPath);\n    paint.setStrokeWidth(2);\n    canvas->translate(40, 0);\n    canvas->drawPath(fillPath, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "e6d8ca0cc17e0b475bd54dd995825468",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFillPath_2"
},
    "SkPaint_getFontMetrics": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    SkScalar lineHeight = paint.getFontMetrics(nullptr);\n    canvas->drawString(\"line 1\", 10, 40, paint);\n    canvas->drawString(\"line 2\", 10, 40 + lineHeight, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    lineHeight = paint.getFontMetrics(nullptr, 1.10f);  // account for stroke height\n    canvas->drawString(\"line 3\", 120, 40, paint);\n    canvas->drawString(\"line 4\", 120, 40 + lineHeight, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "b899d84caba6607340322d317992d070",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getFontMetrics"
},
    "SkPaint_getPosTextHIntercepts": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(120);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(4);\n    SkScalar textPosH[] = { 20, 80, 140 };\n    SkScalar y = 100;\n    SkScalar bounds[] = { 56, 78 };\n    const char str[] = \"\\\\-/\";\n    int len = sizeof(str) - 1;\n    int count = paint.getPosTextHIntercepts(str, len, textPosH, y, bounds, nullptr);\n    std::vector<SkScalar> intervals;\n    intervals.resize(count);\n    (void) paint.getPosTextHIntercepts(str, len, textPosH, y, bounds, &intervals.front());\n    canvas->drawPosTextH(str, len, textPosH, y, paint);\n    paint.setColor(0xFFFF7777);\n    paint.setStyle(SkPaint::kFill_Style);\n    SkScalar x = textPosH[0];\n    for (int i = 0; i < count; i+= 2) {\n        canvas->drawRect({x, bounds[0], intervals[i], bounds[1]}, paint);\n        x = intervals[i + 1];\n    }\n    canvas->drawRect({intervals[count - 1], bounds[0], 180, bounds[1]}, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "dc9851c43acc3716aca8c9a4d40d452d",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getPosTextHIntercepts"
},
    "SkPaint_getPosTextIntercepts": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(120);\n    paint.setVerticalText(true);\n    SkPoint textPos[] = {{ 60, 40 }, { 60, 140 }};\n    SkScalar bounds[] = { 56, 64 };\n    const char str[] = \"A-\";\n    int len = sizeof(str) - 1;\n    int count = paint.getPosTextIntercepts(str, len, textPos, bounds, nullptr);\n    std::vector<SkScalar> intervals;\n    intervals.resize(count);\n    (void) paint.getPosTextIntercepts(str, len, textPos, bounds, &intervals.front());\n    canvas->drawPosText(str, len, textPos, paint);\n    paint.setColor(SK_ColorRED);\n    SkScalar y = textPos[0].fY;\n    for (int i = 0; i < count; i+= 2) {\n        canvas->drawRect({bounds[0], y, bounds[1], intervals[i]}, paint);\n        y = intervals[i + 1];\n    }\n    canvas->drawRect({bounds[0], intervals[count - 1], bounds[1], 240}, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "98b2dfc552d0540a7c041fe7a2839bd7",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getPosTextIntercepts"
},
    "SkPaint_getPosTextPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(80);\n    SkPath path, path2;\n    SkPoint pos[] = {{20, 60}, {30, 70}, {40, 80}};\n    paint.getPosTextPath(\"ABC\", 3, pos, &path);\n    Simplify(path, &path);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 85,
    "hash": "7f27c93472aa99a7542fb3493076f072",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getPosTextPath"
},
    "SkPaint_getTextBlobIntercepts": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);\n    paint.setTextSize(120);\n    SkPoint textPos = { 20, 110 };\n    int len = 3;\n    SkTextBlobBuilder textBlobBuilder;\n    const SkTextBlobBuilder::RunBuffer& run = \n            textBlobBuilder.allocRun(paint, len, textPos.fX, textPos.fY);\n    run.glyphs[0] = 10;\n    run.glyphs[1] = 20;\n    run.glyphs[2] = 30;       \n    sk_sp<const SkTextBlob> blob = textBlobBuilder.make();\n    canvas->drawTextBlob(blob.get(), textPos.fX, textPos.fY, paint);\n    SkScalar bounds[] = { 116, 134 };\n    int count = paint.getTextBlobIntercepts(blob.get(), bounds, nullptr);\n    std::vector<SkScalar> intervals;\n    intervals.resize(count);\n    (void) paint.getTextBlobIntercepts(blob.get(), bounds, &intervals.front());\n    canvas->drawTextBlob(blob.get(), 0, 0, paint);\n    paint.setColor(0xFFFF7777);\n    SkScalar x = textPos.fX;\n    for (int i = 0; i < count; i+= 2) {\n        canvas->drawRect({x, bounds[0], intervals[i], bounds[1]}, paint);\n        x = intervals[i + 1];\n    }\n    canvas->drawRect({intervals[count - 1], bounds[0], 180, bounds[1]}, paint);\n}\n",
    "width": 256,
    "height": 143,
    "hash": "71959a66b2290d70003887c0de339266",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextBlobIntercepts"
},
    "SkPaint_getTextIntercepts": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(120);\n    SkPoint textOrigin = { 20, 100 };\n    SkScalar bounds[] = { 100, 108 };\n    int count = paint.getTextIntercepts(\"y\", 1, textOrigin.fX, textOrigin.fY, bounds, nullptr);\n    std::vector<SkScalar> intervals;\n    intervals.resize(count);\n    (void) paint.getTextIntercepts(\"y\", 1, textOrigin.fX, textOrigin.fY, bounds,\n            &intervals.front());\n    canvas->drawString(\"y\", textOrigin.fX, textOrigin.fY, paint);\n    paint.setColor(SK_ColorRED);\n    SkScalar x = textOrigin.fX;\n    for (int i = 0; i < count; i += 2) {\n        canvas->drawRect({x, bounds[0], intervals[i], bounds[1]}, paint);\n        x = intervals[i + 1];\n    }\n    canvas->drawRect({intervals[count - 1], bounds[0],\n        textOrigin.fX + paint.measureText(\"y\", 1), bounds[1]}, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "2a0b80ed20d193c688085b79deb5bdc9",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextIntercepts"
},
    "SkPaint_getTextPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(80);\n    SkPath path, path2;\n    paint.getTextPath(\"ABC\", 3, 20, 80, &path);\n    path.offset(20, 20, &path2);\n    Op(path, path2, SkPathOp::kDifference_SkPathOp, &path);\n    path.addPath(path2);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "7c9e6a399f898d68026c1f0865e6f73e",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextPath"
},
    "SkPaint_getTextWidths": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(50);\n    const char str[] = \"abc\";\n    const int bytes = sizeof(str) - 1;\n    int count = paint.getTextWidths(str, bytes, nullptr);\n    std::vector<SkScalar> widths;\n    std::vector<SkRect> bounds;\n    widths.resize(count);\n    bounds.resize(count);\n    for (int loop = 0; loop < 2; ++loop) {\n        (void) paint.getTextWidths(str, count, &widths.front(), &bounds.front());\n        SkPoint loc = { 25, 50 };\n        canvas->drawText(str, bytes, loc.fX, loc.fY, paint);\n        paint.setStyle(SkPaint::kStroke_Style);\n        paint.setStrokeWidth(0);\n        SkScalar advanceY = loc.fY + 10;\n        for (int index = 0; index < count; ++index) {\n            bounds[index].offset(loc.fX, loc.fY);\n            canvas->drawRect(bounds[index], paint);\n            canvas->drawLine(loc.fX, advanceY, loc.fX + widths[index], advanceY, paint);\n            loc.fX += widths[index];\n            advanceY += 5;\n        }\n        canvas->translate(0, 80);\n        paint.setStrokeWidth(3);\n    }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "6b9e101f49e9c2c28755c5bdcef64dfb",
    "file": "SkPaint_Reference",
    "name": "SkPaint::getTextWidths"
},
    "SkPaint_glyphsToUnichars": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    const char hello[] = \"Hello!\";\n    const int count = sizeof(hello) - 1;\n    SkGlyphID glyphs[count];\n    if (count != paint.textToGlyphs(hello, count, glyphs)) {\n        return;\n    }\n    SkUnichar unichars[count];\n    paint.glyphsToUnichars(glyphs, count, unichars);\n    paint.setTextEncoding(SkPaint::kUTF32_TextEncoding);\n    canvas->drawText(unichars, sizeof(unichars), 10, 30, paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "c12686b0b3e0a87d0a248bbfc57e9492",
    "file": "SkPaint_Reference",
    "name": "SkPaint::glyphsToUnichars"
},
    "SkPaint_isLinearText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const char testStr[] = \"xxxx xxxx\";\n    for (auto linearText : { false, true } ) {\n        paint.setLinearText(linearText);\n        paint.setTextSize(24);\n        canvas->drawString(paint.isLinearText() ? \"linear\" : \"hinted\", 128, 30, paint);\n        for (SkScalar textSize = 8; textSize < 30; textSize *= 1.22f) {\n            paint.setTextSize(textSize);\n            canvas->translate(0, textSize);\n            canvas->drawString(testStr, 10, 0, paint);\n        }\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "2890ad644f980637837e6fcb386fb462",
    "file": "SkPaint_Reference",
    "name": "SkPaint::isLinearText"
},
    "SkPaint_measureText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(50);\n    const char str[] = \"ay^jZ\";\n    const int count = sizeof(str) - 1;\n    canvas->drawText(str, count, 25, 50, paint);\n    SkRect bounds;\n    paint.measureText(str, count, &bounds);\n    canvas->translate(25, 50);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawRect(bounds, paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "06084f609184470135a9cd9ebc5af149",
    "file": "SkPaint_Reference",
    "name": "SkPaint::measureText"
},
    "SkPaint_setAutohinted": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const char testStr[] = \"xxxx xxxx\";\n        for (auto forceAutoHinting : { false, true} ) {\n        paint.setAutohinted(forceAutoHinting);\n        paint.setTextSize(24);\n        canvas->drawString(paint.isAutohinted() ? \"auto-hinted\" : \"default\", 108, 30, paint);\n        for (SkScalar textSize = 8; textSize < 30; textSize *= 1.22f) {\n            paint.setTextSize(textSize);\n            canvas->translate(0, textSize);\n            canvas->drawString(testStr, 10, 0, paint);\n        }\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "4e185306d7de9390fe8445eed0139309",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setAutohinted"
},
    "SkPaint_setColorFilter": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPaint paint;\n   paint.setColorFilter(SkColorFilter::MakeModeFilter(SK_ColorLTGRAY, SkBlendMode::kSrcIn));\n   canvas->drawRect(SkRect::MakeWH(50, 50), paint);\n   paint.setColorFilter(nullptr);\n   canvas->translate(70, 0);\n   canvas->drawRect(SkRect::MakeWH(50, 50), paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "c7b786dc9b3501cd0eaba47494b6fa31",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setColorFilter"
},
    "SkPaint_setDrawLooper": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setDrawLooper(SkBlurDrawLooper::Make(0x7FFF0000, 4, -5, -10));\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    paint.setAntiAlias(true);\n    paint.setColor(0x7f0000ff);\n    canvas->drawCircle(70, 70, 50, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "bf10f838b330f0a3a3266d42ea68a638",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setDrawLooper"
},
    "SkPaint_setImageFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkBitmap bitmap;\n    bitmap.allocN32Pixels(100, 100);\n    SkCanvas offscreen(bitmap);\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setColor(SK_ColorWHITE);\n    paint.setTextSize(96);\n    offscreen.clear(0);\n    offscreen.drawString(\"e\", 20, 70, paint);\n    paint.setImageFilter(\n           SkLightingImageFilter::MakePointLitDiffuse(SkPoint3::Make(80, 100, 10),\n           SK_ColorWHITE, 1, 2, nullptr, nullptr));\n    canvas->drawBitmap(bitmap, 0, 0, &paint);\n}\n",
    "width": 256,
    "height": 160,
    "hash": "6679d6e4ec632715ee03e68391bd7f9a",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setImageFilter"
},
    "SkPaint_setLinearText": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const char testStr[] = \"abcd efgh\";\n    for (int textSize : { 12, 24 } ) {\n        paint.setTextSize(textSize);\n        for (auto linearText : { false, true } ) {\n            paint.setLinearText(linearText);\n            SkString width;\n            width.appendScalar(paint.measureText(testStr, SK_ARRAY_COUNT(testStr), nullptr));\n            canvas->translate(0, textSize + 4);\n            canvas->drawString(testStr, 10, 0, paint);\n            canvas->drawString(width, 128, 0, paint);\n        }\n     }\n  }\n",
    "width": 256,
    "height": 128,
    "hash": "c93bb912f3bddfb4d96d3ad70ada552b",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setLinearText"
},
    "SkPaint_setMaskFilter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    paint.setMaskFilter(SkBlurMaskFilter::Make(kNormal_SkBlurStyle, 10));\n    canvas->drawRect(SkRect::MakeXYWH(40, 40, 175, 175), paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "62c5a826692f85c3de3bab65e9e97aa9",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setMaskFilter"
},
    "SkPaint_setPathEffect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setPathEffect(SkDiscretePathEffect::Make(3, 5));\n    canvas->drawRect(SkRect::MakeXYWH(40, 40, 175, 175), paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "52dd55074ca0b7d520d04e750ca2a0d7",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setPathEffect"
},
    "SkPaint_setShader": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setColor(SK_ColorBLUE);\n    paint.setShader(SkShader::MakeColorShader(SK_ColorRED));\n    canvas->drawRect(SkRect::MakeWH(40, 40), paint);\n    paint.setShader(nullptr);\n    canvas->translate(50, 0);\n    canvas->drawRect(SkRect::MakeWH(40, 40), paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "77e64d5bae9b1ba037fd99252bb4aa58",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setShader"
},
    "SkPaint_setStyle": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(5);\n    SkRegion region;\n    region.op(140, 10, 160, 30, SkRegion::kUnion_Op);\n    region.op(170, 40, 190, 60, SkRegion::kUnion_Op);\n    SkBitmap bitmap;\n    bitmap.setInfo(SkImageInfo::MakeA8(50, 50), 50);\n    uint8_t pixels[50][50];\n    for (int x = 0; x < 50; ++x) {\n        for (int y = 0; y < 50; ++y) {\n            pixels[y][x] = (x + y) % 5 ? 0xFF : 0x00;\n        }\n    }\n    bitmap.setPixels(pixels);\n    for (auto style : { SkPaint::kFill_Style,\n                        SkPaint::kStroke_Style,\n                        SkPaint::kStrokeAndFill_Style }) {\n        paint.setStyle(style);\n        canvas->drawLine(10, 10, 60, 60, paint);\n        canvas->drawRect({80, 10, 130, 60}, paint);\n        canvas->drawRegion(region, paint);\n        canvas->drawBitmap(bitmap, 200, 10, &paint);\n        canvas->translate(0, 80);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "c7bb6248e4735b8d1a32d02fba40d344",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setStyle"
},
    "SkPaint_setTextAlign": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(40);\n    canvas->drawString(\"Aa\", 100, 50, paint);\n    paint.setTextAlign(SkPaint::kCenter_Align);\n    canvas->drawString(\"Aa\", 100, 100, paint);\n    paint.setTextAlign((SkPaint::Align) SkPaint::kAlignCount);\n    canvas->drawString(\"Aa\", 100, 150, paint);\n}\n",
    "width": 256,
    "height": 160,
    "hash": "d37540afd918506ac2594665ca63979b",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setTextAlign"
},
    "SkPaint_setTypeface": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTypeface(SkTypeface::MakeFromName(\"monospace\", SkFontStyle()));\n    canvas->drawString(\"hamburgerfons\", 10, 30, paint);\n    paint.setTypeface(nullptr);\n    canvas->drawString(\"hamburgerfons\", 10, 50, paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "0e6fbb7773cd925b274552f4cd1abef2",
    "file": "SkPaint_Reference",
    "name": "SkPaint::setTypeface"
},
    "SkPaint_textToGlyphs": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    const uint8_t utf8[] = { 0x24, 0xC2, 0xA2, 0xE2, 0x82, 0xAC, 0xC2, 0xA5, 0xC2, 0xA3 };\n    std::vector<SkGlyphID> glyphs;\n    int count = paint.textToGlyphs(utf8, sizeof(utf8), nullptr);\n    glyphs.resize(count);\n    (void) paint.textToGlyphs(utf8, sizeof(utf8), &glyphs.front());\n    paint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);\n    paint.setTextSize(32);\n    canvas->drawText(&glyphs.front(), glyphs.size() * sizeof(SkGlyphID), 10, 40, paint);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "343e9471a7f7b5f09abdc3b44983433b",
    "file": "SkPaint_Reference",
    "name": "SkPaint::textToGlyphs"
},
    "SkPath_AddPathMode": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path, path2;\n    path.moveTo(20, 20);\n    path.lineTo(20, 40);\n    path.lineTo(40, 20);\n    path2.moveTo(60, 60);\n    path2.lineTo(80, 60);\n    path2.lineTo(80, 40);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 2; i++) {\n        for (auto addPathMode : { SkPath::kAppend_AddPathMode, SkPath::kExtend_AddPathMode } ) {\n            SkPath test(path);\n            test.addPath(path2, addPathMode);\n            canvas->drawPath(test, paint);\n            canvas->translate(100, 0);\n        }\n        canvas->translate(-200, 100);\n        path.close();\n    }\n}",
    "width": 256,
    "height": 180,
    "hash": "801b02e74c64aafdb734f2e5cf3e5ab0",
    "file": "SkPath_Reference",
    "name": "SkPath::AddPathMode"
},
    "SkPath_ArcSize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (auto sweep: { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        for (auto arcSize : { SkPath::kSmall_ArcSize, SkPath::kLarge_ArcSize } ) {\n            SkPath path;\n            path.moveTo({120, 50});\n            path.arcTo(70, 40, 30, arcSize, sweep, 156, 100);\n            if (SkPath::kCCW_Direction == sweep && SkPath::kLarge_ArcSize == arcSize) {\n                paint.setColor(SK_ColorBLUE);\n                paint.setStrokeWidth(3);\n            }\n            canvas->drawPath(path, paint);\n         }\n    }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "8e40c546eecd9cc213200717240898ba",
    "file": "SkPath_Reference",
    "name": "SkPath::ArcSize"
},
    "SkPath_ConvertConicToQuads": {
    "code": "void draw(SkCanvas* canvas) {\n      SkPaint conicPaint;\n      conicPaint.setAntiAlias(true);\n      conicPaint.setStyle(SkPaint::kStroke_Style);\n      SkPaint quadPaint(conicPaint);\n      quadPaint.setColor(SK_ColorRED);\n      SkPoint conic[] = { {20, 170}, {80, 170}, {80, 230} };\n      for (auto weight : { .25f, .5f, .707f, .85f, 1.f } ) {\n          SkPoint quads[5];\n          SkPath::ConvertConicToQuads(conic[0], conic[1], conic[2], weight, quads, 1);\n          SkPath path;\n          path.moveTo(conic[0]);\n          path.conicTo(conic[1], conic[2], weight);\n          canvas->drawPath(path, conicPaint);\n          path.rewind();\n          path.moveTo(quads[0]);\n          path.quadTo(quads[1], quads[2]);\n          path.quadTo(quads[3], quads[4]);\n          canvas->drawPath(path, quadPaint);\n          canvas->translate(50, -50);\n      }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "3ba94448a4ba48f926e643baeb5b1016",
    "file": "SkPath_Reference",
    "name": "SkPath::ConvertConicToQuads"
},
    "SkPath_Convexity": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPoint quad[] = {{70, 70}, {20, 20}, {120, 20}, {120, 120}}; \n    const char* labels[] = { \"unknown\", \"convex\", \"concave\" };\n    for (SkScalar x : { 40, 100 } ) {\n        SkPath path;\n        quad[0].fX = x;\n        path.addPoly(quad, SK_ARRAY_COUNT(quad), true);\n        canvas->drawPath(path, paint);\n        canvas->drawString(labels[(int) path.getConvexity()], 30, 100, paint);\n        canvas->translate(100, 100);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "b7d0c0732411db76fa37b05fc18712b3",
    "file": "SkPath_Reference",
    "name": "SkPath::Convexity"
},
    "SkPath_Direction": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkPoint arrow[] = { {40, -5}, {45, 0}, {40, 5} };\n    const SkRect rect = {10, 10, 90, 90};\n    SkPaint rectPaint;\n    rectPaint.setAntiAlias(true);\n    SkPaint textPaint(rectPaint);\n    textPaint.setTextAlign(SkPaint::kCenter_Align);\n    rectPaint.setStyle(SkPaint::kStroke_Style);\n    SkPaint arrowPaint(rectPaint);\n    SkPath arrowPath;\n    arrowPath.addPoly(arrow, SK_ARRAY_COUNT(arrow), true);\n    arrowPaint.setPathEffect(SkPath1DPathEffect::Make(arrowPath, 320, 0,\n                             SkPath1DPathEffect::kRotate_Style));\n    for (auto direction : { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        canvas->drawRect(rect, rectPaint);\n        for (unsigned start : { 0, 1, 2, 3 } ) {\n           SkPath path;\n           path.addRect(rect, direction, start);\n           canvas->drawPath(path, arrowPaint);\n       }\n       canvas->drawString(SkPath::kCW_Direction == direction ? \"CW\" : \"CCW\",  rect.centerX(),\n            rect.centerY(), textPaint);\n       canvas->translate(120, 0);\n    }\n}\n",
    "width": 256,
    "height": 100,
    "hash": "0de03d9c939b6238318b7366866e8722",
    "file": "SkPath_Reference",
    "name": "SkPath::Direction"
},
    "SkPath_FillType": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPath path;\n   path.addRect({10, 10, 30, 30}, SkPath::kCW_Direction);\n   path.addRect({20, 20, 40, 40}, SkPath::kCW_Direction);\n   path.addRect({10, 60, 30, 80}, SkPath::kCW_Direction);\n   path.addRect({20, 70, 40, 90}, SkPath::kCCW_Direction);\n   SkPaint strokePaint;\n   strokePaint.setStyle(SkPaint::kStroke_Style);\n   SkRect clipRect = {0, 0, 51, 100};\n   canvas->drawPath(path, strokePaint);\n   SkPaint fillPaint;\n   for (auto fillType : { SkPath::kWinding_FillType, SkPath::kEvenOdd_FillType, \n                      SkPath::kInverseWinding_FillType, SkPath::kInverseEvenOdd_FillType } ) {\n        canvas->translate(51, 0);\n        canvas->save();\n        canvas->clipRect(clipRect);\n        path.setFillType(fillType);\n        canvas->drawPath(path, fillPaint);\n        canvas->restore();\n    }\n}\n",
    "width": 256,
    "height": 100,
    "hash": "525ed591c31960de23068dba8ea11a75",
    "file": "SkPath_Reference",
    "name": "SkPath::FillType"
},
    "SkPath_FillType_a": {
    "code": "void draw(SkCanvas* canvas) {\n   SkPath path;\n   path.addRect({20, 10, 80, 70}, SkPath::kCW_Direction);\n   path.addRect({40, 30, 100, 90}, SkPath::kCW_Direction);\n   SkPaint strokePaint;\n   strokePaint.setStyle(SkPaint::kStroke_Style);\n   SkRect clipRect = {0, 0, 128, 128};\n   canvas->drawPath(path, strokePaint);\n   canvas->drawLine({0, 50}, {120, 50}, strokePaint);\n   SkPaint textPaint;\n   textPaint.setAntiAlias(true);\n   textPaint.setTextAlign(SkPaint::kCenter_Align);\n   SkScalar textHPos[] = { 10, 30, 60, 90, 110 };\n   canvas->drawPosTextH(\"01210\", 5, textHPos, 48, textPaint);\n   textPaint.setTextSize(18);\n   canvas->translate(0, 128);\n   canvas->scale(.5f, .5f);\n   canvas->drawString(\"inverse\", 384, 150, textPaint);\n   SkPaint fillPaint;\n   for (auto fillType : { SkPath::kWinding_FillType, SkPath::kEvenOdd_FillType, \n                      SkPath::kInverseWinding_FillType, SkPath::kInverseEvenOdd_FillType } ) {\n        canvas->save();\n        canvas->clipRect(clipRect);\n        path.setFillType(fillType);\n        canvas->drawPath(path, fillPaint);\n        canvas->restore();\n        canvas->drawString(fillType & 1 ? \"even-odd\" : \"winding\", 64, 170, textPaint);\n        canvas->translate(128, 0);\n    }\n}\n",
    "width": 256,
    "height": 230,
    "hash": "0ebf978b234a00e2c2573cfa7b04e776",
    "file": "SkPath_Reference",
    "name": "SkPath::FillType_2"
},
    "SkPath_Iter": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(256);\n    SkPath asterisk, path;\n    paint.getTextPath(\"*\", 1, 50, 192, &asterisk);\n    SkPath::Iter iter(asterisk, true); \n    SkPoint start[4], pts[4];\n    iter.next(start);  // skip moveTo\n    iter.next(start);  // first quadTo\n    path.moveTo((start[0] + start[1]) * 0.5f);\n    while (SkPath::kClose_Verb != iter.next(pts)) {\n        path.quadTo(pts[0], (pts[0] + pts[1]) * 0.5f);\n    }\n    path.quadTo(start[0], (start[0] + start[1]) * 0.5f);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "3ca8417e2a1466bf5b3ac97780a8070c",
    "file": "SkPath_Reference",
    "name": "SkPath::Iter"
},
    "SkPath_addArc": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    for (auto start : { 0, 90, 135, 180, 270 } ) {\n        for (auto sweep : { -450.f, -180.f, -90.f, 90.f, 180.f, 360.1f } ) {\n            SkPath path;\n            path.addArc({10, 10, 35, 45}, start, sweep);\n            canvas->drawPath(path, paint);\n            canvas->translate(252 / 6, 0);\n        }\n        canvas->translate(-252, 255 / 5);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "9cf5122475624e4cf39f06c698f80b1a",
    "file": "SkPath_Reference",
    "name": "SkPath::addArc"
},
    "SkPath_addCircle": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(10);\n    for (int size = 10; size < 300; size += 20) {\n        SkPath path;\n        path.addCircle(128, 128, size, SkPath::kCW_Direction);\n        canvas->drawPath(path, paint);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "bd5286cb9a5e5c32cd980f72b8f400fb",
    "file": "SkPath_Reference",
    "name": "SkPath::addCircle"
},
    "SkPath_addOval": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath oval;\n    oval.addOval({20, 20, 160, 80});\n    canvas->drawPath(oval, paint);\n}",
    "width": 256,
    "height": 120,
    "hash": "cac84cf68e63a453c2a8b64c91537704",
    "file": "SkPath_Reference",
    "name": "SkPath::addOval"
},
    "SkPath_addOval_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkPoint arrow[] = { {0, -5}, {10, 0}, {0, 5} };\n    const SkRect rect = {10, 10, 54, 54};\n    SkPaint ovalPaint;\n    ovalPaint.setAntiAlias(true);\n    SkPaint textPaint(ovalPaint);\n    textPaint.setTextAlign(SkPaint::kCenter_Align);\n    ovalPaint.setStyle(SkPaint::kStroke_Style);\n    SkPaint arrowPaint(ovalPaint);\n    SkPath arrowPath;\n    arrowPath.addPoly(arrow, SK_ARRAY_COUNT(arrow), true);\n    arrowPaint.setPathEffect(SkPath1DPathEffect::Make(arrowPath, 176, 0,\n                             SkPath1DPathEffect::kRotate_Style));\n    for (auto direction : { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        for (unsigned start : { 0, 1, 2, 3 } ) {\n           SkPath path;\n           path.addOval(rect, direction, start);\n           canvas->drawPath(path, ovalPaint);\n           canvas->drawPath(path, arrowPaint);\n           canvas->drawText(&\"0123\"[start], 1, rect.centerX(), rect.centerY() + 5, textPaint);\n           canvas->translate(64, 0);\n       }\n       canvas->translate(-256, 72);\n       canvas->drawString(SkPath::kCW_Direction == direction ? \"clockwise\" : \"counterclockwise\",\n                          128, 0, textPaint);\n    }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "ab9753174060e4a551727ef3af12924d",
    "file": "SkPath_Reference",
    "name": "SkPath::addOval_2"
},
    "SkPath_addPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    paint.setFakeBoldText(true);\n    SkPath dest, text;\n    paint.getTextPath(\"O\", 1, 50, 120, &text);\n    for (int i = 0; i < 3; i++) {\n        dest.addPath(text, i * 20, i * 20);\n    }\n    Simplify(dest, &dest);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(3);\n    canvas->drawPath(dest, paint);\n}",
    "width": 256,
    "height": 180,
    "hash": "c416bddfe286628974e1c7f0fd66f3f4",
    "file": "SkPath_Reference",
    "name": "SkPath::addPath"
},
    "SkPath_addPath_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath dest, path;\n    path.addOval({-80, 20, 0, 60}, SkPath::kCW_Direction, 1);\n    for (int i = 0; i < 2; i++) {\n        dest.addPath(path, SkPath::kExtend_AddPathMode);\n        dest.offset(100, 0);\n    }\n    canvas->drawPath(dest, paint);\n}",
    "width": 256,
    "height": 80,
    "hash": "84b2d1c0fc29f1b35e855b6fc6672f9e",
    "file": "SkPath_Reference",
    "name": "SkPath::addPath_2"
},
    "SkPath_addPath_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath dest, path;\n    path.addOval({20, 20, 200, 120}, SkPath::kCW_Direction, 1);\n    for (int i = 0; i < 6; i++) {\n        SkMatrix matrix;\n        matrix.reset();\n        matrix.setPerspX(i / 400.f);\n        dest.addPath(path, matrix);\n    }\n    canvas->drawPath(dest, paint);\n}",
    "width": 256,
    "height": 160,
    "hash": "3a90a91030f7289d5df0671d342dbbad",
    "file": "SkPath_Reference",
    "name": "SkPath::addPath_3"
},
    "SkPath_addPoly": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeCap(SkPaint::kRound_Cap);\n    const SkPoint points[] = {{20, 20}, {70, 20}, {40, 90}};\n    for (bool close : { false, true } ) {\n        SkPath path;\n        path.addPoly(points, SK_ARRAY_COUNT(points), close);\n        for (auto style : {SkPaint::kStroke_Style, SkPaint::kFill_Style,\n                SkPaint::kStrokeAndFill_Style} ) {\n            paint.setStyle(style);\n            canvas->drawPath(path, paint);\n            canvas->translate(85, 0);\n        }\n        canvas->translate(-255, 128);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "182b3999772f330f3b0b891b492634ae",
    "file": "SkPath_Reference",
    "name": "SkPath::addPoly"
},
    "SkPath_addRRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRRect rrect;\n    SkVector radii[] = {{50, 50}, {0, 0}, {0, 0}, {50, 50}};\n    rrect.setRectRadii({10, 10, 110, 110}, radii);\n    SkPath path;\n    SkMatrix rotate90;\n    rotate90.setRotate(90, 128, 128);\n    for (int i = 0; i < 4; ++i) {\n        path.addRRect(rrect);\n        path.transform(rotate90);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "d9ecd58081b5bc77a157636fcb345dc6",
    "file": "SkPath_Reference",
    "name": "SkPath::addRRect"
},
    "SkPath_addRRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkRRect rrect;\n    rrect.setRectXY({40, 40, 215, 215}, 50, 50);\n    SkPath path;\n    path.addRRect(rrect);\n    canvas->drawPath(path, paint);\n    for (int start = 0; start < 8; ++start) {\n        SkPath textPath;\n        textPath.addRRect(rrect, SkPath::kCW_Direction, start);\n        canvas->drawTextOnPathHV(&\"01234567\"[start], 1, textPath, 0, -5, paint);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "f18740ffcb10a499007488948c2cd60d",
    "file": "SkPath_Reference",
    "name": "SkPath::addRRect_2"
},
    "SkPath_addRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeCap(SkPaint::kSquare_Cap);\n    float intervals[] = { 5, 21.75f };\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 0));\n    SkPath path;\n    path.addRect({20, 20, 100, 100}, SkPath::kCW_Direction);\n    canvas->drawPath(path, paint);\n    path.rewind();\n    path.addRect({140, 20, 220, 100}, SkPath::kCCW_Direction);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "0f841e4eaebb613b5069800567917c2d",
    "file": "SkPath_Reference",
    "name": "SkPath::addRect"
},
    "SkPath_addRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    const SkPoint arrow[] = { {5, -5}, {15, -5}, {20, 0}, {15, 5}, {5, 5}, {10, 0} };\n    const SkRect rect = {10, 10, 54, 54};\n    SkPaint rectPaint;\n    rectPaint.setAntiAlias(true);\n    rectPaint.setStyle(SkPaint::kStroke_Style);\n    SkPaint arrowPaint(rectPaint);\n    SkPath arrowPath;\n    arrowPath.addPoly(arrow, SK_ARRAY_COUNT(arrow), true);\n    arrowPaint.setPathEffect(SkPath1DPathEffect::Make(arrowPath, 176, 0,\n                             SkPath1DPathEffect::kRotate_Style));\n    for (auto direction : { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        for (unsigned start : { 0, 1, 2, 3 } ) {\n           SkPath path;\n           path.addRect(rect, direction, start);\n           canvas->drawPath(path, rectPaint);\n           canvas->drawPath(path, arrowPaint);\n           canvas->translate(64, 0);\n       }\n       canvas->translate(-256, 64);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "9202430b3f4f5275af8eec5cc9d7baa8",
    "file": "SkPath_Reference",
    "name": "SkPath::addRect_2"
},
    "SkPath_addRect_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeCap(SkPaint::kSquare_Cap);\n    float intervals[] = { 5, 21.75f };\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 0));\n    for (auto direction : { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        SkPath path;\n        path.addRect(20, 20, 100, 100, direction);\n        canvas->drawPath(path, paint);\n        canvas->translate(128, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "3837827310e8b88b8c2e128ef9fbbd65",
    "file": "SkPath_Reference",
    "name": "SkPath::addRect_3"
},
    "SkPath_addRoundRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    for (auto xradius : { 0, 7, 13, 20 } ) {\n        for (auto yradius : { 0, 9, 18, 40 } ) {\n            SkPath path;\n            path.addRoundRect({10, 10, 36, 46}, xradius, yradius);\n            paint.setColor(path.isRect(nullptr) ? SK_ColorRED : path.isOval(nullptr) ?\n                           SK_ColorBLUE : path.isConvex() ? SK_ColorGRAY : SK_ColorGREEN);\n            canvas->drawPath(path, paint);\n            canvas->translate(64, 0);\n        }\n        canvas->translate(-256, 64);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "24736f685f265cf533f1700c042db353",
    "file": "SkPath_Reference",
    "name": "SkPath::addRoundRect"
},
    "SkPath_addRoundRect_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkScalar radii[] = { 80, 100, 0, 0, 40, 60, 0, 0 };\n    SkPath path;\n    SkMatrix rotate90;\n    rotate90.setRotate(90, 128, 128);\n    for (int i = 0; i < 4; ++i) {\n        path.addRoundRect({10, 10, 110, 110}, radii);\n        path.transform(rotate90);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "c43d70606b4ee464d2befbcf448c5e73",
    "file": "SkPath_Reference",
    "name": "SkPath::addRoundRect_2"
},
    "SkPath_arcTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath path;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(4);\n    path.moveTo(0, 0);\n    path.arcTo({20, 20, 120, 120}, -90, 90, false);\n    canvas->drawPath(path, paint);\n    path.rewind();\n    path.arcTo({120, 20, 220, 120}, -90, 90, false);\n    canvas->drawPath(path, paint);\n    path.rewind();\n    path.moveTo(0, 0);\n    path.arcTo({20, 120, 120, 220}, -90, 90, true);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 200,
    "hash": "5f02890edaa10cb5e1a4243a82b6a382",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo"
},
    "SkPath_arcTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint tangentPaint;\n    tangentPaint.setAntiAlias(true);\n    SkPaint textPaint(tangentPaint);\n    tangentPaint.setStyle(SkPaint::kStroke_Style);\n    tangentPaint.setColor(SK_ColorGRAY);\n    SkPaint arcPaint(tangentPaint);\n    arcPaint.setStrokeWidth(5);\n    arcPaint.setColor(SK_ColorBLUE);\n    SkPath path;\n    SkPoint pts[] = { {56, 20}, {200, 20}, {90, 190} };\n    SkScalar radius = 50;\n    path.moveTo(pts[0]);\n    path.arcTo(pts[1], pts[2], radius);\n    canvas->drawLine(pts[0], pts[1], tangentPaint);\n    canvas->drawLine(pts[1], pts[2], tangentPaint);\n    SkPoint lastPt;\n    (void) path.getLastPt(&lastPt);\n    SkVector radial = pts[2] - pts[1];\n    radial.setLength(radius);\n    SkPoint center = { lastPt.fX - radial.fY, lastPt.fY + radial.fX };\n    canvas->drawCircle(center, radius, tangentPaint);\n    canvas->drawLine(lastPt, center, tangentPaint);\n    radial = pts[1] - pts[0];\n    radial.setLength(radius);\n    SkPoint arcStart = { center.fX + radial.fY, center.fY - radial.fX };\n    canvas->drawLine(center, arcStart, tangentPaint);\n    canvas->drawPath(path, arcPaint);\n    textPaint.setTextAlign(SkPaint::kRight_Align);\n    canvas->drawString(\"(x0, y0)\", pts[0].fX - 5, pts[0].fY, textPaint);\n    textPaint.setTextAlign(SkPaint::kLeft_Align);\n    canvas->drawString(\"(x1, y1)\", pts[1].fX + 5, pts[1].fY, textPaint);\n    textPaint.setTextAlign(SkPaint::kCenter_Align);\n    canvas->drawString(\"(x2, y2)\", pts[2].fX, pts[2].fY + 15, textPaint);\n    textPaint.setTextAlign(SkPaint::kRight_Align);\n    canvas->drawString(\"radius\", center.fX + 15, center.fY + 25, textPaint);\n    canvas->drawString(\"radius\", center.fX - 3, center.fY - 16, textPaint);\n}\n",
    "width": 256,
    "height": 226,
    "hash": "d9c6435f26f37b3d63c664a99028f77f",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_2"
},
    "SkPath_arcTo_2_a": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint tangentPaint;\n    tangentPaint.setAntiAlias(true);\n    SkPaint textPaint(tangentPaint);\n    tangentPaint.setStyle(SkPaint::kStroke_Style);\n    tangentPaint.setColor(SK_ColorGRAY);\n    SkPaint arcPaint(tangentPaint);\n    arcPaint.setStrokeWidth(5);\n    arcPaint.setColor(SK_ColorBLUE);\n    SkPath path;\n    SkPoint pts[] = { {156, 20}, {200, 20}, {170, 50} };\n    SkScalar radius = 50;\n    path.moveTo(pts[0]);\n    path.arcTo(pts[1], pts[2], radius);\n    canvas->drawLine(pts[0], pts[1], tangentPaint);\n    canvas->drawLine(pts[1], pts[2], tangentPaint);\n    SkPoint lastPt;\n    (void) path.getLastPt(&lastPt);\n    SkVector radial = pts[2] - pts[1];\n    radial.setLength(radius);\n    SkPoint center = { lastPt.fX - radial.fY, lastPt.fY + radial.fX };\n    canvas->drawLine(lastPt, center, tangentPaint);\n    radial = pts[1] - pts[0];\n    radial.setLength(radius);\n    SkPoint arcStart = { center.fX + radial.fY, center.fY - radial.fX };\n    canvas->drawLine(center, arcStart, tangentPaint);\n    canvas->drawPath(path, arcPaint);\n    textPaint.setTextAlign(SkPaint::kCenter_Align);\n    canvas->drawString(\"(x0, y0)\", pts[0].fX, pts[0].fY - 7, textPaint);\n    textPaint.setTextAlign(SkPaint::kLeft_Align);\n    canvas->drawString(\"(x1, y1)\", pts[1].fX + 5, pts[1].fY, textPaint);\n    textPaint.setTextAlign(SkPaint::kCenter_Align);\n    canvas->drawString(\"(x2, y2)\", pts[2].fX, pts[2].fY + 15, textPaint);\n    textPaint.setTextAlign(SkPaint::kRight_Align);\n    canvas->drawString(\"radius\", center.fX + 15, center.fY + 25, textPaint);\n    canvas->drawString(\"radius\", center.fX - 5, center.fY - 20, textPaint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "01d2ddfd539ab86a86989e210640dffc",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_2_2"
},
    "SkPath_arcTo_4": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (auto sweep: { SkPath::kCW_Direction, SkPath::kCCW_Direction } ) {\n        for (auto arcSize : { SkPath::kSmall_ArcSize, SkPath::kLarge_ArcSize } ) {\n            SkPath path;\n            path.moveTo({120, 50});\n            path.arcTo(70, 40, 30, arcSize, sweep, 120.1, 50);\n            if (SkPath::kCCW_Direction == sweep && SkPath::kLarge_ArcSize == arcSize) {\n                paint.setColor(SK_ColorBLUE);\n                paint.setStrokeWidth(3);\n            }\n            canvas->drawPath(path, paint);\n         }\n    }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "6b6ea44f659b27918f3a6fa621bf6173",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_4"
},
    "SkPath_arcTo_5": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath path;\n    const SkPoint starts[] = {{20, 20}, {120, 20}, {70, 60}};\n    for (auto start : starts) {\n        path.moveTo(start.fX, start.fY);\n        path.rArcTo(20, 20, 0, SkPath::kSmall_ArcSize, SkPath::kCCW_Direction, 60, 0);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 108,
    "hash": "3f76a1007416181a4848c1a87fc81dbd",
    "file": "SkPath_Reference",
    "name": "SkPath::arcTo_5"
},
    "SkPath_close": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStrokeWidth(15);\n    paint.setStrokeCap(SkPaint::kRound_Cap);\n    SkPath path;\n    const SkPoint points[] = {{20, 20}, {70, 20}, {40, 90}};\n    path.addPoly(points, SK_ARRAY_COUNT(points), false);\n    for (int loop = 0; loop < 2; ++loop) {\n        for (auto style : {SkPaint::kStroke_Style, SkPaint::kFill_Style,\n                SkPaint::kStrokeAndFill_Style} ) {\n            paint.setStyle(style);\n            canvas->drawPath(path, paint);\n            canvas->translate(85, 0);\n        }\n        path.close();\n        canvas->translate(-255, 128);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "9235f6309271d6420fa5c45dc28664c5",
    "file": "SkPath_Reference",
    "name": "SkPath::close()"
},
    "SkPath_conicTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPoint conicPts[] = {{20, 150}, {120, 10}, {220, 150}};\n    canvas->drawLine(conicPts[0], conicPts[1], paint);\n    canvas->drawLine(conicPts[1], conicPts[2], paint);\n    SkColor colors[] = { 0xff88ff00, 0xff0088bb, 0xff6600cc, 0xffbb3377 };\n    paint.setStrokeWidth(3);\n    SkScalar weight = 0.5f;\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(colors); ++i) {\n        SkPath path;\n        path.moveTo(conicPts[0]);\n        path.conicTo(conicPts[1], conicPts[2], weight);\n        paint.setColor(colors[i]);\n        canvas->drawPath(path, paint);\n        weight += 0.25f;\n   }\n}\n",
    "width": 256,
    "height": 160,
    "hash": "358d9b6060b528b0923c007420f09c13",
    "file": "SkPath_Reference",
    "name": "SkPath::conicTo"
},
    "SkPath_conicTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkRect oval = {0, 20, 120, 140};\n    SkPath path;\n    for (int i = 0; i < 4; ++i) {\n        path.moveTo(oval.centerX(), oval.fTop);\n        path.arcTo(oval, -90, 90 - 20 * i, false);\n        oval.inset(15, 15);\n    }\n    path.offset(100, 0);\n    SkScalar conicWeights[] = { 0.707107f, 0.819152f, 0.906308f, 0.965926f };\n    SkPoint conicPts[][3] = { { {40, 20}, {100, 20}, {100, 80} },\n                              { {40, 35}, {71.509f, 35}, {82.286f, 64.6091f} },\n                              { {40, 50}, {53.9892f, 50}, {62.981f, 60.7164f} },\n                              { {40, 65}, {44.0192f, 65}, {47.5f, 67.0096f} } };\n    for (int i = 0; i < 4; ++i) {\n         path.moveTo(conicPts[i][0]);\n         path.conicTo(conicPts[i][1], conicPts[i][2], conicWeights[i]);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "22d25e03b19d5bae92118877e462361b",
    "file": "SkPath_Reference",
    "name": "SkPath::conicTo_2"
},
    "SkPath_conservativelyContainsRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.addRoundRect({10, 20, 54, 120}, 10, 20);\n    SkRect tests[] = {\n      { 10, 40, 54, 80 },\n      { 25, 20, 39, 120 },\n      { 15, 25, 49, 115 },\n      { 13, 27, 51, 113 },\n    };\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(tests); ++i) {\n      SkPaint paint;\n      paint.setColor(SK_ColorRED);\n      canvas->drawPath(path, paint);\n      bool rectInPath = path.conservativelyContainsRect(tests[i]);\n      paint.setColor(rectInPath ? SK_ColorBLUE : SK_ColorBLACK);\n      canvas->drawRect(tests[i], paint);\n      canvas->translate(64, 0);\n    }\n}\n",
    "width": 256,
    "height": 140,
    "hash": "41638d13e40fa449ece354dde5fb1941",
    "file": "SkPath_Reference",
    "name": "SkPath::conservativelyContainsRect"
},
    "SkPath_contains": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkPaint paint;\n    paint.setTextSize(256);\n    paint.getTextPath(\"&\", 1, 30, 220, &path);\n    for (int y = 2; y < 256; y += 9) {\n       for (int x = 2; x < 256; x += 9) {\n           int coverage = 0;\n           for (int iy = -4; iy <= 4; iy += 2) {\n               for (int ix = -4; ix <= 4; ix += 2) {\n                   coverage += path.contains(x + ix, y + iy);\n               }\n           }\n           paint.setColor(SkColorSetARGB(0x5f, 0xff * coverage / 25, 0, 0xff * (25 - coverage) / 25));\n           canvas->drawCircle(x, y, 8, paint);\n       }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "c0216b3f7ebd80b9589ae5728f08fc80",
    "file": "SkPath_Reference",
    "name": "SkPath::contains()"
},
    "SkPath_cubicTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(0, -10);\n    for (int i = 0; i < 128; i += 16) {\n        SkScalar c = i * 0.5f;\n        path.cubicTo( 10 + c, -10 - i,  10 + i, -10 - c,  10 + i,       0);\n        path.cubicTo( 14 + i,  14 + c,  14 + c,  14 + i,       0,  14 + i);\n        path.cubicTo(-18 - c,  18 + i, -18 - i,  18 + c, -18 - i,       0);\n        path.cubicTo(-22 - i, -22 - c, -22 - c, -22 - i,       0, -22 - i);\n    }\n    path.offset(128, 128);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "3e476378e3e0550ab134bbaf61112d98",
    "file": "SkPath_Reference",
    "name": "SkPath::cubicTo"
},
    "SkPath_cubicTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPoint pts[] = { {20, 20}, {300, 80}, {-140, 90}, {220, 10} };\n    SkPath path;\n    path.moveTo(pts[0]);\n    path.cubicTo(pts[1], pts[2], pts[3]);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 84,
    "hash": "d38aaf12c6ff5b8d901a2201bcee5476",
    "file": "SkPath_Reference",
    "name": "SkPath::cubicTo_2"
},
    "SkPath_incReserve": {
    "code": "void draw(SkCanvas* canvas) {\n    auto addPoly = [](int sides, SkScalar size, SkPath* path) -> void {\n        path->moveTo(size, 0);\n        for (int i = 1; i < sides; i++) {\n            SkScalar c, s = SkScalarSinCos(SK_ScalarPI * 2 * i / sides, &c);\n            path->lineTo(c * size, s * size);\n        }\n        path->close();\n    };\n    SkPath path;\n    path.incReserve(3 + 4 + 5 + 6 + 7 + 8 + 9);\n    for (int sides = 3; sides < 10; ++sides) {\n       addPoly(sides, sides, &path);\n    }\n    SkMatrix matrix;\n    matrix.setScale(10, 10, -10, -10);\n    path.transform(matrix);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 192,
    "hash": "f2260f2a170a54aef5bafe5b91c121b3",
    "file": "SkPath_Reference",
    "name": "SkPath::incReserve"
},
    "SkPath_interpolate": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path, path2;\n    path.moveTo(20, 20);\n    path.lineTo(40, 40);\n    path.lineTo(20, 40);\n    path.lineTo(40, 20);\n    path.close();\n    path2.addRect({20, 20, 40, 40});\n    for (SkScalar i = 0; i <= 1; i += 1.f / 6) {\n      SkPath interp;\n      path.interpolate(path2, i, &interp);\n      canvas->drawPath(interp, paint);\n      canvas->translate(30, 0);\n    }\n}\n",
    "width": 256,
    "height": 60,
    "hash": "404f11c5c9c9ca8a64822d484552a473",
    "file": "SkPath_Reference",
    "name": "SkPath::interpolate()"
},
    "SkPath_isConvex": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPoint quad[] = {{70, 70}, {20, 20}, {120, 20}, {120, 120}}; \n    for (SkScalar x : { 40, 100 } ) {\n        SkPath path;\n        quad[0].fX = x;\n        path.addPoly(quad, SK_ARRAY_COUNT(quad), true);\n        path.setConvexity(SkPath::kConvex_Convexity);\n        canvas->drawPath(path, paint);\n        canvas->drawString(path.isConvex() ? \"convex\" : \"not convex\", 30, 100, paint);\n        canvas->translate(100, 100);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "dfd2c40e1c2a7b539a94aec8d040d349",
    "file": "SkPath_Reference",
    "name": "SkPath::isConvex"
},
    "SkPath_isOval": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath path;\n    path.addOval({20, 20, 220, 220}, SkPath::kCW_Direction, 1);\n    SkRect bounds;\n    SkPath::Direction direction;\n    unsigned start;\n    path.isOval(&bounds, &direction, &start);\n    paint.setColor(0xFF9FBFFF);\n    canvas->drawRect(bounds, paint);\n    paint.setColor(0x3f000000);\n    canvas->drawPath(path, paint);\n    paint.setColor(SK_ColorBLACK);\n    canvas->rotate(start * 90, bounds.centerX(), bounds.centerY());\n    char startText = '0' + start;\n    paint.setTextSize(20);\n    canvas->drawText(&startText, 1, bounds.centerX(), bounds.fTop + 20, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(4);\n    path.reset();\n    path.addArc(bounds, -90, SkPath::kCW_Direction == direction ? 90 : -90);\n    path.rLineTo(20, -20); \n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "4fc7b86c9b772c5e85af480524267bde",
    "file": "SkPath_Reference",
    "name": "SkPath::isOval"
},
    "SkPath_isRRect": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath path;\n    path.addRRect(SkRRect::MakeRectXY({20, 20, 220, 220}, 30, 50), SkPath::kCCW_Direction, 3);\n    SkRRect rrect;\n    SkPath::Direction direction;\n    unsigned start;\n    path.isRRect(&rrect, &direction, &start);\n    const SkRect& bounds = rrect.rect();\n    paint.setColor(0xFF9FBFFF);\n    canvas->drawRect(bounds, paint);\n    paint.setColor(0x3f000000);\n    canvas->drawPath(path, paint);\n    paint.setColor(SK_ColorBLACK);\n    canvas->rotate(start * 90, bounds.centerX(), bounds.centerY());\n    char startText = '0' + start;\n    paint.setTextSize(20);\n    canvas->drawText(&startText, 1, bounds.centerX(), bounds.fTop + 20, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(4);\n    path.reset();\n    path.addArc(bounds, -90, SkPath::kCW_Direction == direction ? 90 : -90);\n    path.rLineTo(20, -20); \n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "f2b7e57a385e6604475c99ec8daa2697",
    "file": "SkPath_Reference",
    "name": "SkPath::isRRect"
},
    "SkPath_lineTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setTextSize(72);\n    canvas->drawString(\"#\", 120, 80, paint);\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setStrokeWidth(5);\n    SkPath path;\n    SkPoint hash[] = {{58, 28}, {43, 80}, {37, 45}, {85, 45}};\n    SkVector offsets[] = {{0, 0}, {17, 0}, {0, 0}, {-5, 17}};\n    unsigned o = 0;\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(hash); i += 2) {\n        for (unsigned j = 0; j < 2; o++, j++) {\n            path.moveTo(hash[i].fX + offsets[o].fX, hash[i].fY + offsets[o].fY);\n            path.lineTo(hash[i + 1].fX + offsets[o].fX, hash[i + 1].fY + offsets[o].fY);\n        }\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 100,
    "hash": "e311cdd451edacec33b50cc22a4dd5dc",
    "file": "SkPath_Reference",
    "name": "SkPath::lineTo"
},
    "SkPath_lineTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkVector oxo[] = {{25, 25}, {35, 35}, {25, 35}, {35, 25},\n                      {40, 20}, {40, 80}, {60, 20}, {60, 80},\n                      {20, 40}, {80, 40}, {20, 60}, {80, 60}};\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(oxo); i += 2) {\n        path.moveTo(oxo[i]);\n        path.lineTo(oxo[i + 1]);\n    }\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "41001546a7f7927d08e5a818bcc304f5",
    "file": "SkPath_Reference",
    "name": "SkPath::lineTo_2"
},
    "SkPath_moveTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkRect rect = { 20, 20, 120, 80 };\n    SkPath path;\n    path.addRect(rect);\n    path.moveTo(rect.fLeft, rect.fTop);\n    path.lineTo(rect.fRight, rect.fBottom);\n    path.moveTo(rect.fLeft, rect.fBottom);\n    path.lineTo(rect.fRight, rect.fTop);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 140,
    "height": 100,
    "hash": "84101d341e934a535a41ad6cf42218ce",
    "file": "SkPath_Reference",
    "name": "SkPath::moveTo"
},
    "SkPath_moveTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPoint data[][3] = {{{30,40},{60,60},{90,30}}, {{30,120},{60,100},{90,120}}, \n                         {{60,100},{60,40},{70,30}}, {{60,40},{50,20},{70,30}}};\n    SkPath path;\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(data); ++i) {\n        path.moveTo(data[i][0]);\n        path.lineTo(data[i][1]);\n        path.lineTo(data[i][2]);\n    }\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 128,
    "height": 128,
    "hash": "53b351d3fac667a4803418238e44a593",
    "file": "SkPath_Reference",
    "name": "SkPath::moveTo_2"
},
    "SkPath_offset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath pattern;\n    pattern.moveTo(20, 20);\n    pattern.lineTo(20, 40);\n    pattern.lineTo(40, 20);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 10; i++) {\n        SkPath path;\n        pattern.offset(20 * i, 0, &path);\n        canvas->drawPath(path, paint);\n    }\n}",
    "width": 256,
    "height": 60,
    "hash": "1d1892196ba5bda257df4f3351abd084",
    "file": "SkPath_Reference",
    "name": "SkPath::offset()"
},
    "SkPath_offset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(20, 20);\n    path.lineTo(20, 40);\n    path.lineTo(40, 20);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 10; i++) {\n        canvas->drawPath(path, paint);\n        path.offset(20, 0);\n    }\n}",
    "width": 256,
    "height": 60,
    "hash": "5188d77585715db30bef228f2dfbcccd",
    "file": "SkPath_Reference",
    "name": "SkPath::offset_2"
},
    "SkPath_quadTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(0, -10);\n    for (int i = 0; i < 128; i += 16) {\n        path.quadTo( 10 + i, -10 - i,  10 + i,       0);\n        path.quadTo( 14 + i,  14 + i,       0,  14 + i);\n        path.quadTo(-18 - i,  18 + i, -18 - i,       0);\n        path.quadTo(-22 - i, -22 - i,       0, -22 - i);\n    }\n    path.offset(128, 128);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "60ee3eb747474f5781b0f0dd3a17a866",
    "file": "SkPath_Reference",
    "name": "SkPath::quadTo"
},
    "SkPath_quadTo_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    paint.setAntiAlias(true);\n    SkPath path;\n    SkPoint pts[] = {{128, 10}, {10, 214}, {236, 214}};\n    path.moveTo(pts[1]);\n    for (int i = 0; i < 3; ++i) {\n        path.quadTo(pts[i % 3],  pts[(i + 2) % 3]);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "82621c4df8da1e589d9e627494067826",
    "file": "SkPath_Reference",
    "name": "SkPath::quadTo_2"
},
    "SkPath_rArcTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    SkPath path;\n    const SkPoint starts[] = {{20, 20}, {120, 20}, {70, 60}};\n    for (auto start : starts) {\n        path.moveTo(start.fX, start.fY);\n        path.rArcTo(20, 20, 0, SkPath::kSmall_ArcSize, SkPath::kCCW_Direction, 60, 0);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 108,
    "hash": "3f76a1007416181a4848c1a87fc81dbd",
    "file": "SkPath_Reference",
    "name": "SkPath::rArcTo"
},
    "SkPath_rConicTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(20, 80);\n    path.rConicTo( 60,   0,  60,  60, 0.707107f);\n    path.rConicTo(  0, -60,  60, -60, 0.707107f);\n    path.rConicTo(-60,   0, -60, -60, 0.707107f);\n    path.rConicTo(  0,  60, -60,  60, 0.707107f);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 140,
    "hash": "3d52763e7c0e20c0b1d484a0afa622d2",
    "file": "SkPath_Reference",
    "name": "SkPath::rConicTo"
},
    "SkPath_rCubicTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(24, 108);\n    for (int i = 0; i < 16; i++) {\n       SkScalar sx, sy;\n       sx = SkScalarSinCos(i * SK_ScalarPI / 8, &sy);\n       path.rCubicTo(40 * sx, 4 * sy, 4 * sx, 40 * sy, 40 * sx, 40 * sy);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "19f0cfc7eeba8937fe19446ec0b5f932",
    "file": "SkPath_Reference",
    "name": "SkPath::rCubicTo"
},
    "SkPath_rLineTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.moveTo(10, 98);\n    SkScalar x = 0, y = 0;\n    for (int i = 10; i < 100; i += 5) {\n        x += i * ((i & 2) - 1);\n        y += i * (((i + 1) & 2) - 1);\n        path.rLineTo(x, y);\n    }\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 128,
    "hash": "6e0be0766b8ca320da51640326e608b3",
    "file": "SkPath_Reference",
    "name": "SkPath::rLineTo"
},
    "SkPath_rMoveTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.addRect({20, 20, 80, 80}, SkPath::kCW_Direction, 2);\n    path.rMoveTo(25, 2);\n    SkVector arrow[] = {{0, -4}, {-20, 0}, {0, -3}, {-5, 5}, {5, 5}, {0, -3}, {20, 0}};\n    for (unsigned i = 0; i < SK_ARRAY_COUNT(arrow); ++i) {\n        path.rLineTo(arrow[i].fX, arrow[i].fY);\n    }\n    SkPaint paint;\n    canvas->drawPath(path, paint);\n    SkPoint lastPt;\n    path.getLastPt(&lastPt);\n    canvas->drawString(\"start\", lastPt.fX, lastPt.fY, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "63e32dec4b2d8440b427f368bf8313a4",
    "file": "SkPath_Reference",
    "name": "SkPath::rMoveTo"
},
    "SkPath_rQuadTo": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPath path;\n    path.moveTo(128, 20);\n    path.rQuadTo(-6, 10, -7, 10);\n    for (int i = 1; i < 32; i += 4) {\n       path.rQuadTo(10 + i, 10 + i, 10 + i * 4, 10);\n       path.rQuadTo(-10 - i, 10 + i, -10 - (i + 2) * 4, 10);\n    }\n    path.quadTo(92, 220, 128, 215);\n    canvas->drawPath(path, paint);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "1c1f4cdef1c572c9aa8fdf3e461191d0",
    "file": "SkPath_Reference",
    "name": "SkPath::rQuadTo"
},
    "SkPath_reverseAddPath": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(20, 20);\n    path.lineTo(20, 40);\n    path.lineTo(40, 20);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 2; i++) {\n        SkPath path2;\n        path2.moveTo(60, 60);\n        path2.lineTo(80, 60);\n        path2.lineTo(80, 40);\n        for (int j = 0; j < 2; j++) {\n            SkPath test(path);\n            test.reverseAddPath(path2);\n            canvas->drawPath(test, paint);\n            canvas->translate(100, 0);\n            path2.close();\n        }\n        canvas->translate(-200, 100);\n        path.close();\n    }\n}",
    "width": 256,
    "height": 200,
    "hash": "5e8513f073db09acde3ff616f6426e3d",
    "file": "SkPath_Reference",
    "name": "SkPath::reverseAddPath"
},
    "SkPath_setFillType": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.setFillType(SkPath::kInverseWinding_FillType);\n    SkPaint paint;\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 64,
    "hash": "b4a91cd7f50b2a0a0d1bec6d0ac823d2",
    "file": "SkPath_Reference",
    "name": "SkPath::setFillType"
},
    "SkPath_setIsVolatile": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    SkPath path;\n    path.setIsVolatile(true);\n    path.lineTo(40, 40);\n    canvas->drawPath(path, paint);\n    path.rewind();\n    path.moveTo(0, 40);\n    path.lineTo(40, 0);\n    canvas->drawPath(path, paint);\n}",
    "width": 50,
    "height": 50,
    "hash": "2049ff5141f0c80aac497618622b28af",
    "file": "SkPath_Reference",
    "name": "SkPath::setIsVolatile"
},
    "SkPath_setLastPt": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath path;\n    paint.getTextPath(\"@\", 1, 60, 100, &path);\n    path.setLastPt(20, 120);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "542c5afaea5f57baa11d0561dd402e18",
    "file": "SkPath_Reference",
    "name": "SkPath::setLastPt"
},
    "SkPath_setLastPt_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(128);\n    SkPath path, path2;\n    paint.getTextPath(\"A\", 1, 60, 100, &path);\n    paint.getTextPath(\"Z\", 1, 60, 100, &path2);\n    SkPoint pt, pt2;\n    path.getLastPt(&pt);\n    path2.getLastPt(&pt2);\n    path.setLastPt(pt2);\n    path2.setLastPt(pt);\n    canvas->drawPath(path, paint);\n    canvas->drawPath(path2, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "6fa5e8f9513b3225e106778592e27e94",
    "file": "SkPath_Reference",
    "name": "SkPath::setLastPt_2"
},
    "SkPath_toggleInverseFillType": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    SkPaint paint;\n    paint.setColor(SK_ColorRED);\n    paint.setTextSize(80);\n    paint.getTextPath(\"ABC\", 3, 20, 80, &path);\n    canvas->drawPath(path, paint);\n    path.toggleInverseFillType();\n    paint.setColor(SK_ColorGREEN);\n    canvas->drawPath(path, paint);\n}",
    "width": 256,
    "height": 100,
    "hash": "400facce23d417bc5043c5f58404afbd",
    "file": "SkPath_Reference",
    "name": "SkPath::toggleInverseFillType"
},
    "SkPath_transform": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath pattern;\n    pattern.moveTo(100, 100);\n    pattern.lineTo(100, 20);\n    pattern.lineTo(20, 100);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 10; i++) {\n        SkPath path;\n        SkMatrix matrix;\n        matrix.setRotate(36 * i, 100, 100);\n        pattern.transform(matrix, &path);\n        canvas->drawPath(path, paint);\n    }\n}",
    "width": 256,
    "height": 200,
    "hash": "99761add116ce3b0730557224c1b0105",
    "file": "SkPath_Reference",
    "name": "SkPath::transform()"
},
    "SkPath_transform_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPath path;\n    path.moveTo(100, 100);\n    path.quadTo(100, 20, 20, 100);\n    SkPaint paint;\n    paint.setStyle(SkPaint::kStroke_Style);\n    for (int i = 0; i < 10; i++) {\n        SkMatrix matrix;\n        matrix.setRotate(36, 100, 100);\n        path.transform(matrix);\n        canvas->drawPath(path, paint);\n    }\n}",
    "width": 256,
    "height": 200,
    "hash": "c40979a3b92a30cfb7bae36abcc1d805",
    "file": "SkPath_Reference",
    "name": "SkPath::transform_2"
},
    "SkPixmap_erase": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t storage[2];\n    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);\n    SkPixmap pixmap(info, storage, info.minRowBytes());\n    pixmap.erase(SK_ColorBLUE, {0, 0, 1, 1});\n    pixmap.erase(SK_ColorRED, {0, 1, 1, 2});\n    SkBitmap bitmap;\n    canvas->scale(20, 20);\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "a0cdbafed4786788cc90681e7b294234",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::erase()"
},
    "SkPixmap_erase_2": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t storage[2];\n    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);\n    SkPixmap pixmap(info, storage, info.minRowBytes());\n    pixmap.erase(SK_ColorBLUE);\n    SkBitmap bitmap;\n    canvas->scale(20, 20);\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "838202e0d49cad2eb3eeb495834f6d63",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::erase_2"
},
    "SkPixmap_erase_3": {
    "code": "void draw(SkCanvas* canvas) {\n    uint32_t storage[2];\n    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);\n    SkPixmap pixmap(info, storage, info.minRowBytes());\n    SkIRect topPixelBounds = {0, 0, 1, 1};\n    pixmap.erase({ 0.65f, 0.45f, 0.25f, 1 }, &topPixelBounds);\n    SkIRect bottomPixelBounds = {0, 1, 1, 2};\n    pixmap.erase({ 0.25f, 0.65f, 0.45f, 1 }, &bottomPixelBounds);\n    SkBitmap bitmap;\n    canvas->scale(20, 20);\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 50,
    "hash": "f884f3f46a565f052a5e252ae2f36e9b",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::erase_3"
},
    "SkPixmap_extractSubset": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    pixels.resize(image->height() * image->width() * 4);\n    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,\n            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n    image->readPixels(pixmap, 0, 0);\n    SkPixmap inset;\n    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {\n        SkBitmap bitmap;\n        bitmap.installPixels(inset);\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}\n",
    "width": 256,
    "height": 128,
    "hash": "febdbfac6cf4cde69837643be2e1f6dd",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::extractSubset"
},
    "SkPixmap_readPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height(),\n            canvas->imageInfo().colorSpace() ? SkColorSpace::MakeSRGB() : nullptr);\n    std::vector<int32_t> srcPixels;\n    srcPixels.resize(image->height() * image->width() * 4);\n    SkPixmap pixmap(info, (const void*) &srcPixels.front(), image->width() * 4);\n    image->readPixels(pixmap, 0, 0);\n    SkTransferFunctionBehavior behavior = canvas->imageInfo().colorSpace() ?\n            SkTransferFunctionBehavior::kRespect : SkTransferFunctionBehavior::kIgnore;\n    std::vector<int32_t> dstPixels;\n    dstPixels.resize(image->height() * image->width() * 4);\n    int offset = 0;\n    for (auto behavior : { SkTransferFunctionBehavior::kRespect,\n                           SkTransferFunctionBehavior::kIgnore} ) {\n        pixmap.readPixels(info, &dstPixels.front(), image->width() * 4, offset, 0, behavior);\n        offset += 128;\n    }\n    SkBitmap bitmap;\n    SkPixmap dstmap(info, &dstPixels.front(), image->width() * 4);\n    bitmap.installPixels(dstmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n}\n",
    "width": 256,
    "height": 256,
    "hash": "2b7f6cc59ea2d5ebceddccbc2f232bcf",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::readPixels"
},
    "SkPixmap_readPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    const int width = 256;\n    const int height = 64;\n    pixels.resize(height * width * 4);\n    SkImageInfo srcInfo = SkImageInfo::MakeN32Premul(width, height);\n    SkPixmap srcPixmap(srcInfo, (const void*) &pixels.front(), width * 4);\n    SkColor  gradColors[] = { 0xFFAA3300, 0x7F881122 };\n    SkPoint  gradPoints[] = { { 0, 0 }, { 256, 0 } };\n    SkPaint paint;\n    paint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,\n                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));\n    SkBitmap bitmap;\n    bitmap.installPixels(srcPixmap);\n    SkCanvas srcCanvas(bitmap);\n    srcCanvas.drawRect(SkRect::MakeWH(width, height), paint);\n    canvas->drawBitmap(bitmap, 0, 0);\n    std::vector<int32_t> dstPixels;\n    dstPixels.resize(height * width * 2);\n    SkImageInfo dstInfo = srcInfo.makeColorType(kARGB_4444_SkColorType);\n    srcPixmap.readPixels(dstInfo, &dstPixels.front(), width * 2);\n    SkPixmap dstPixmap(dstInfo, &dstPixels.front(), width * 2);\n    bitmap.installPixels(dstPixmap);\n    canvas->drawBitmap(bitmap, 0, 128);\n}",
    "width": 256,
    "height": 128,
    "hash": "df4e355c4845350daede833b4fd21ec1",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::readPixels_2"
},
    "SkPixmap_readPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());\n    std::vector<int32_t> srcPixels;\n    const int rowBytes = image->width() * 4;\n    srcPixels.resize(image->height() * rowBytes);\n    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);\n    image->readPixels(pixmap, 0, 0);\n    for (int offset : { 32, 64, 96 } ) {\n        std::vector<int32_t> dstPixels;\n        dstPixels.resize(image->height() * rowBytes);\n        pixmap.readPixels(info, &dstPixels.front(), rowBytes, offset, 0);\n        SkBitmap bitmap;\n        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);\n        bitmap.installPixels(dstmap);\n        canvas->translate(32, 32);\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "094ca0bd37588cc7be241bb387a3e17b",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::readPixels_3"
},
    "SkPixmap_readPixels_4": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());\n    std::vector<int32_t> srcPixels;\n    const int rowBytes = image->width() * 4;\n    srcPixels.resize(image->height() * rowBytes);\n    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);\n    image->readPixels(pixmap, 0, 0);\n    for (int offset : { 32, 64, 96 } ) {\n        std::vector<int32_t> dstPixels;\n        dstPixels.resize(image->height() * rowBytes);\n        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);\n        pixmap.readPixels(dstmap, offset, 0);\n        SkBitmap bitmap;\n        bitmap.installPixels(dstmap);\n        canvas->translate(32, 32);\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "6ec7f7b2cc163cd29f627eef6d4b061c",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::readPixels_4"
},
    "SkPixmap_readPixels_5": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());\n    std::vector<int32_t> srcPixels;\n    const int rowBytes = image->width() * 4;\n    srcPixels.resize(image->height() * rowBytes);\n    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);\n    image->readPixels(pixmap, 0, 0);\n    for (int index = 0; index < 3; ++index ) {\n        std::vector<int32_t> dstPixels;\n        dstPixels.resize(image->height() * rowBytes);\n        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);\n        pixmap.readPixels(dstmap);\n        SkBitmap bitmap;\n        bitmap.installPixels(dstmap);\n        canvas->translate(32, 32);\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "e18549b5ee1039cb61b0bb38c2104fc9",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::readPixels_5"
},
    "SkPixmap_reset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    pixels.resize(image->height() * image->width() * 4);\n    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,\n            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n    image->readPixels(pixmap, 0, 0);\n    int x = 0;\n    for (auto colorType : { kRGBA_8888_SkColorType, kBGRA_8888_SkColorType } ) {\n        pixmap.reset(SkImageInfo::Make(image->width(), image->height(), colorType, \n                image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n        SkBitmap bitmap;\n        bitmap.installPixels(pixmap);\n        canvas->drawBitmap(bitmap, x, 0);\n        x += 128;\n    }\n}\n",
    "width": 256,
    "height": 64,
    "hash": "a7c9bfe44f5d888ab5b9996f2b126788",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::reset_2"
},
    "SkPixmap_scalePixels": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());\n    std::vector<int32_t> srcPixels;\n    int rowBytes = image->width() * 4;\n    srcPixels.resize(image->height() * rowBytes);\n    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);\n    image->readPixels(pixmap, 0, 0);\n    for (int offset : { 32, 64, 96 } ) {\n        info = SkImageInfo::MakeN32Premul(image->width() + offset, image->height());\n        rowBytes = info.width() * 4;\n        std::vector<int32_t> dstPixels;\n        dstPixels.resize(image->height() * rowBytes);\n        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);\n        pixmap.scalePixels(dstmap, kMedium_SkFilterQuality);\n        SkBitmap bitmap;\n        bitmap.installPixels(dstmap);\n        canvas->translate(32, 32);\n        canvas->drawBitmap(bitmap, 0, 0);\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "8e3c8a9c1d0d2e9b8bf66e24d274f792",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::scalePixels"
},
    "SkPixmap_writable_addr16": {
    "code": "void draw(SkCanvas* canvas) {\n    uint16_t storage[][5] = {{ 0xCABF, 0xDABE, 0xCA9D, 0xC96C, 0xA39B },\n                             { 0xACEE, 0xA87C, 0x893A, 0x4779, 0x8708 },\n                             { 0x4B7C, 0x255B, 0x2559, 0x2557, 0x4656 },\n                             { 0x9099, 0x8128, 0x2557, 0x4124, 0x3323 },\n                             { 0x7547, 0x5505, 0x4434, 0x2012, 0x0000 }};\n    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kARGB_4444_SkColorType, kPremul_SkAlphaType);\n    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->scale(10, 10);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *pixmap.writable_addr16(2, 2) = 0x000F;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 10, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "6da54774f6432b46b47ea9013c15f280",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr16"
},
    "SkPixmap_writable_addr32": {
    "code": "void draw(SkCanvas* canvas) {\n    std::vector<int32_t> pixels;\n    pixels.resize(image->height() * image->width() * 4);\n    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,\n            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);\n    image->readPixels(pixmap, 0, 0);\n    for (int y = 0; y < pixmap.height() / 2; ++y) {\n        for (int x = 0; x < pixmap.width(); ++x) {\n            if ((x & 4) == (y & 4)) {\n                SkTSwap(*pixmap.writable_addr32(x, y), \n                        *pixmap.writable_addr32(pixmap.width() - x, pixmap.height() - y));\n            }\n        }\n    }\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 72,
    "hash": "f4fdce206b8c0a4e79f0a9f52b7f47a6",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr32"
},
    "SkPixmap_writable_addr64": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::Make(3, 3, kRGBA_F16_SkColorType, kPremul_SkAlphaType);\n    uint64_t storage[9];\n    SkPixmap pixmap(info, storage, 3 * sizeof(uint64_t));\n    SkColor4f c4 { 1, 0.45f, 0.25f, 0.65f };\n    pixmap.erase(c4);\n    SkBitmap bitmap;\n    canvas->scale(10, 10);\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *pixmap.writable_addr64(1, 1) |= 0x00ff000000000000LL;\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 10, 0);\n}",
    "width": 256,
    "height": 40,
    "hash": "de14d8d30e4a7b6462103d0e0dd96b0b",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr64"
},
    "SkPixmap_writable_addr8": {
    "code": "void draw(SkCanvas* canvas) {\n    uint8_t storage[][5] = {{ 0,   0,  64,   0,  0},\n                            { 0, 128, 255, 128,  0},\n                            {64, 255, 255, 255, 64},\n                            { 0, 128, 255, 128,  0},\n                            { 0,   0,  64,   0,  0}};\n    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kPremul_SkAlphaType);\n    SkPixmap pixmap(imageInfo, storage[0], 5);\n    SkBitmap bitmap;\n    bitmap.installPixels(pixmap);\n    canvas->scale(10, 10);\n    canvas->drawBitmap(bitmap, 0, 0);\n    *pixmap.writable_addr8(2, 2) = 0;\n//  bitmap.installPixels(pixmap);      // uncomment to fix on GPU\n    canvas->drawBitmap(bitmap, 10, 0);\n}\n",
    "width": 256,
    "height": 64,
    "hash": "809284db136748208b3efc31cd89de29",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addr8"
},
    "SkPixmap_writable_addrF16": {
    "code": "void draw(SkCanvas* canvas) {\n    SkImageInfo info = SkImageInfo::Make(1, 2, kRGBA_F16_SkColorType, kPremul_SkAlphaType);\n    uint16_t storage[2][4];\n    SkPixmap pixmap(info, storage[0], sizeof(uint64_t));\n    SkIRect topPixelBounds = {0, 0, 1, 1};\n    pixmap.erase({ 0.65f, 0.45f, 0.25f, 1 }, &topPixelBounds);\n    SkIRect bottomPixelBounds = {0, 1, 1, 2};\n    pixmap.erase({ 0.25f, 0.65f, 0.45f, 1 }, &bottomPixelBounds);\n    SkBitmap bitmap;\n    canvas->scale(20, 20);\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 0, 0);\n    uint16_t* pixel2 = pixmap.writable_addrF16(0, 1);\n    for (int i = 0; i < 4; ++i) {\n        pixel2[i] = storage[0][i];\n    }\n    bitmap.installPixels(pixmap);\n    canvas->drawBitmap(bitmap, 4, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "7822d78f5cacf5c04267cbbc6c6d0b80",
    "file": "SkPixmap_Reference",
    "name": "SkPixmap::writable_addrF16"
},
    "SkPoint_CrossProduct": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkVector vectors[][2] = {{{50, 2}, {-14, 20}}, {{0, 50}, {-50, 0}}, {{-20, 25}, {25, -20}},\n                             {{-20, -24}, {-24, -20}}};\n    SkPoint center[] = {{32, 32}, {160, 32}, {32, 160}, {160, 160}};\n    paint.setStrokeWidth(2);\n    for (size_t i = 0; i < 4; ++i) {\n        paint.setColor(SK_ColorRED);\n        canvas->drawLine(center[i], center[i] + vectors[i][0], paint);\n        paint.setColor(SK_ColorBLUE);\n        canvas->drawLine(center[i], center[i] + vectors[i][1], paint);\n        SkString str;\n        SkScalar cross = SkPoint::CrossProduct(vectors[i][1], vectors[i][0]);\n        str.printf(\"cross = %g\", cross);\n        paint.setColor(cross >= 0 ? SK_ColorRED : SK_ColorBLUE);\n        canvas->drawString(str, center[i].fX, center[i].fY, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "8b8a4cd8a29d22bb9c5e63b70357bd65",
    "file": "SkPoint_Reference",
    "name": "SkPoint::CrossProduct"
},
    "SkPoint_Distance": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint lines[][2] = {{{-10, -10}, {90, 30}}, {{0, 0}, {150, 30}}, {{10, 25}, {120, 150}}};\n    const SkPoint origin = {30, 160};\n    for (auto line : lines) {\n        SkPoint a = origin + line[0];\n        const SkPoint& b = line[1];\n        canvas->drawLine(a, b, paint);\n        SkAutoCanvasRestore acr(canvas, true);\n        SkScalar angle = SkScalarATan2((b.fY - a.fY), b.fX - a.fX);\n        canvas->rotate(angle * 180 / SK_ScalarPI, a.fX, a.fY);\n        SkString distance(\"distance = \");\n        distance.appendScalar(SkPoint::Distance(a, b));\n        canvas->drawString(distance, a.fX + 25, a.fY - 4, paint);\n    }\n}",
    "width": 256,
    "height": 192,
    "hash": "9e0a2de2eb94dba4521d733e73f2bda5",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Distance"
},
    "SkPoint_DotProduct": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkVector vectors[][2] = {{{50, 2}, {-14, 20}}, {{0, 50}, {-50, 0}}, {{-20, 25}, {25, -20}},\n                             {{-20, -24}, {-24, -20}}};\n    SkPoint center[] = {{32, 32}, {160, 32}, {32, 160}, {160, 160}};\n    paint.setStrokeWidth(2);\n    for (size_t i = 0; i < 4; ++i) {\n        canvas->drawLine(center[i], center[i] + vectors[i][0], paint);\n        canvas->drawLine(center[i], center[i] + vectors[i][1], paint);\n        SkString str;\n        str.printf(\"dot = %g\", SkPoint::DotProduct(vectors[i][0], vectors[i][1]));\n        canvas->drawString(str, center[i].fX, center[i].fY, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "496db0131a003162faba7d7f98b30340",
    "file": "SkPoint_Reference",
    "name": "SkPoint::DotProduct"
},
    "SkPoint_Length": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 90, 30 }, { 120, 150 }, { 150, 30 }, { 210, 90 } };\n    const SkPoint origin = {30, 140};\n    for (auto point : points) {\n        canvas->drawLine(origin, point, paint);\n        SkAutoCanvasRestore acr(canvas, true);\n        SkScalar angle = SkScalarATan2((point.fY - origin.fY), point.fX - origin.fX);\n        canvas->rotate(angle * 180 / SK_ScalarPI, origin.fX, origin.fY);\n        SkString length(\"length = \");\n        length.appendScalar(SkPoint::Length(point.fX, point.fY));\n        canvas->drawString(length, origin.fX + 25, origin.fY - 4, paint);\n    }\n}",
    "width": 256,
    "height": 192,
    "hash": "c98773d8b4509969d78cb8121e4b77f6",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Length"
},
    "SkPoint_Normalize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint lines[][2] = { {{  30, 110 }, { 190,  30 }},\n                                 {{  30, 220 }, { 120, 140 }}};\n    for (auto line : lines) {\n        canvas->drawLine(line[0], line[1], paint);\n        SkVector vector = line[1] - line[0];\n        SkScalar priorLength = SkPoint::Normalize(&vector);\n        SkVector rotate90 = { -vector.fY, vector.fX };\n        rotate90 *= 10.f;\n        canvas->drawLine(line[0] - rotate90, line[0] + rotate90, paint);\n        canvas->drawLine(line[1] - rotate90, line[1] + rotate90, paint);\n        SkString length(\"length = \");\n        length.appendScalar(priorLength);\n        canvas->drawString(length, line[0].fX + 25, line[0].fY - 4, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "60a08f3ce75374fc815384616d114df7",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Normalize"
},
    "SkPoint_Offset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    SkPoint::Offset(points, SK_ARRAY_COUNT(points), { 1, 9 } );\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "f0f24726df78a5d797bcf311e694a0a3",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Offset"
},
    "SkPoint_Offset_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    SkPoint::Offset(points, SK_ARRAY_COUNT(points), 1, 9);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "532849faa838de885b86d3ebffae3712",
    "file": "SkPoint_Reference",
    "name": "SkPoint::Offset_2"
},
    "SkPoint_add_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    SkVector mod = {1, 1};\n    for (auto& point : points) {\n        point = point + mod;\n        mod.fX *= 1.1f;\n        mod.fY += .2f;\n    }\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "911a84253dfec4dabf94dbe3c71766f0",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator+(const SkPoint& a, const SkVector& b)"
},
    "SkPoint_addto_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    points[1] += {1, 1};\n    points[2] += {-1, -1};\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "8b4e79109e2381345258cb744881b20c",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator+=(const SkVector& v)"
},
    "SkPoint_cross": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkVector vectors[][2] = {{{50, 2}, {-14, 20}}, {{0, 50}, {-50, 0}}, {{-20, 25}, {25, -20}},\n                             {{-20, -24}, {-24, -20}}};\n    SkPoint center[] = {{32, 32}, {160, 32}, {32, 160}, {160, 160}};\n    paint.setStrokeWidth(2);\n    for (size_t i = 0; i < 4; ++i) {\n        paint.setColor(SK_ColorRED);\n        canvas->drawLine(center[i], center[i] + vectors[i][0], paint);\n        paint.setColor(SK_ColorBLUE);\n        canvas->drawLine(center[i], center[i] + vectors[i][1], paint);\n        SkString str;\n        SkScalar cross = vectors[i][0].cross(vectors[i][1]);\n        str.printf(\"cross = %g\", cross);\n        paint.setColor(cross >= 0 ? SK_ColorRED : SK_ColorBLUE);\n        canvas->drawString(str, center[i].fX, center[i].fY, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "0bc7b3997357e499817278b78bdfbf1d",
    "file": "SkPoint_Reference",
    "name": "SkPoint::cross()"
},
    "SkPoint_distanceToOrigin": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 60, -110 }, { 90, 10 }, { 120, -110 }, { 180, -50 } };\n    const SkPoint origin = {0, 0};\n    canvas->translate(30, 140);\n    for (auto point : points) {\n        canvas->drawLine(origin, point, paint);\n        SkAutoCanvasRestore acr(canvas, true);\n        SkScalar angle = SkScalarATan2((point.fY - origin.fY), point.fX - origin.fX);\n        canvas->rotate(angle * 180 / SK_ScalarPI, origin.fX, origin.fY);\n        SkString distance(\"distance = \");\n        distance.appendScalar(point.distanceToOrigin());\n        canvas->drawString(distance, origin.fX + 25, origin.fY - 4, paint);\n    }\n}",
    "width": 256,
    "height": 192,
    "hash": "812cf26d91b1cdcd2c6b9438a8172518",
    "file": "SkPoint_Reference",
    "name": "SkPoint::distanceToOrigin"
},
    "SkPoint_dot": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkVector vectors[][2] = {{{50, 2}, {-14, 20}}, {{0, 50}, {-50, 0}}, {{-20, 25}, {25, -20}},\n                             {{-20, -24}, {-24, -20}}};\n    SkPoint center[] = {{32, 32}, {160, 32}, {32, 160}, {160, 160}};\n    paint.setStrokeWidth(2);\n    for (size_t i = 0; i < 4; ++i) {\n        canvas->drawLine(center[i], center[i] + vectors[i][0], paint);\n        canvas->drawLine(center[i], center[i] + vectors[i][1], paint);\n        SkString str;\n        str.printf(\"dot = %g\", vectors[i][0].dot(vectors[i][1]));\n        canvas->drawString(str, center[i].fX, center[i].fY, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "56d01ccfedd71d3c504b09afa2875d38",
    "file": "SkPoint_Reference",
    "name": "SkPoint::dot()"
},
    "SkPoint_length": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 90, 30 }, { 120, 150 }, { 150, 30 }, { 210, 90 } };\n    const SkPoint origin = {30, 140};\n    for (auto point : points) {\n        canvas->drawLine(origin, point, paint);\n        SkAutoCanvasRestore acr(canvas, true);\n        SkScalar angle = SkScalarATan2((point.fY - origin.fY), point.fX - origin.fX);\n        canvas->rotate(angle * 180 / SK_ScalarPI, origin.fX, origin.fY);\n        SkString length(\"length = \");\n        length.appendScalar(point.length());\n        canvas->drawString(length, origin.fX + 25, origin.fY - 4, paint);\n    }\n}",
    "width": 256,
    "height": 192,
    "hash": "8363ab179447ee4b827679e20d3d81eb",
    "file": "SkPoint_Reference",
    "name": "SkPoint::length()"
},
    "SkPoint_multiply_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(15, 10);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    for (auto& point : points) {\n        point = point * 1.5f;\n    }\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "35b3bc675779de043706ae4817ee950c",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator*(SkScalar scale)_const"
},
    "SkPoint_multiplyby_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(15, 10);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    for (auto& point : points) {\n        point *= 2;\n    }\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "3ce3db36235d80dbac4d39504cf756da",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator*=(SkScalar scale)"
},
    "SkPoint_normalize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint lines[][2] = { {{  30, 110 }, { 190,  30 }},\n                                 {{ 120, 140 }, {  30, 220 }}};\n    for (auto line : lines) {\n        canvas->drawLine(line[0], line[1], paint);\n        SkVector vector = line[1] - line[0];\n        if (vector.normalize()) {\n            SkVector rotate90 = { -vector.fY, vector.fX };\n            rotate90 *= 10.f;\n            canvas->drawLine(line[0] - rotate90, line[0] + rotate90, paint);\n            canvas->drawLine(line[1] - rotate90, line[1] + rotate90, paint);\n        }\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "d84fce292d86c7d9ef37ae2d179c03c7",
    "file": "SkPoint_Reference",
    "name": "SkPoint::normalize()"
},
    "SkPoint_offset": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    points[1].offset(1, 1);\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "02750ceaa874f956e6e6544ef6b858ee",
    "file": "SkPoint_Reference",
    "name": "SkPoint::offset()"
},
    "SkPoint_scale": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint point = {40, -15}, scaled;\n    SkPoint origin = {30, 110};\n    for (auto scale : {1, 2, 3, 5}) {\n        paint.setStrokeWidth(scale * 5);\n        paint.setARGB(0x7f, 0x9f, 0xbf, 0x33 * scale);\n        point.scale(scale, &scaled);\n        canvas->drawLine(origin, origin + scaled, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "972e4e230806281adb928e068bcd8551",
    "file": "SkPoint_Reference",
    "name": "SkPoint::scale()"
},
    "SkPoint_scale_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint point = {40, -15};\n    SkPoint origin = {30, 110};\n    for (auto scale : {1, 2, 3, 5}) {\n        paint.setStrokeWidth(scale * 5);\n        paint.setARGB(0x7f, 0x9f, 0xbf, 0x33 * scale);\n        point.scale(scale);\n        canvas->drawLine(origin, origin + point, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "1060a4f27d8ef29519e6ac006ce90f2b",
    "file": "SkPoint_Reference",
    "name": "SkPoint::scale_2"
},
    "SkPoint_setLength": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 60, -110 }, { 90, 10 }, { 120, -110 }, { 180, -50 } };\n    const SkPoint origin = {0, 0};\n    canvas->translate(30, 140);\n    for (auto point : points) {\n        paint.setStrokeWidth(1);\n        paint.setColor(SK_ColorBLACK);\n        canvas->drawLine(origin, point, paint);\n        SkVector normal = point;\n        normal.setLength(100);\n        paint.setStrokeWidth(10);\n        paint.setColor(0x3f45bf12);\n        canvas->drawLine(origin, normal, paint);\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "cbe7db206ece825aa3b9b7c3256aeaf0",
    "file": "SkPoint_Reference",
    "name": "SkPoint::setLength"
},
    "SkPoint_setLength_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 60, -110 }, { 90, 10 }, { 120, -110 }, { 180, -50 } };\n    const SkPoint origin = {0, 0};\n    canvas->translate(30, 140);\n    for (auto point : points) {\n        paint.setStrokeWidth(1);\n        paint.setColor(SK_ColorBLACK);\n        canvas->drawLine(origin, point, paint);\n        SkVector normal;\n        normal.setLength(point.fX, point.fY, 100);\n        paint.setStrokeWidth(10);\n        paint.setColor(0x3fbf4512);\n        canvas->drawLine(origin, normal, paint);\n    }\n}",
    "width": 256,
    "height": 160,
    "hash": "3cc0662b6fbbee1fe3442a0acfece22c",
    "file": "SkPoint_Reference",
    "name": "SkPoint::setLength_2"
},
    "SkPoint_setNormalize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    const SkPoint points[] = { { 60, -110 }, { 90, 10 }, { 120, -110 }, { 180, -50 } };\n    const SkPoint origin = {0, 0};\n    canvas->translate(30, 140);\n    for (auto point : points) {\n        paint.setStrokeWidth(1);\n        paint.setColor(SK_ColorBLACK);\n        canvas->drawLine(origin, point, paint);\n        SkVector normal;\n        normal.setNormalize(point.fX, point.fY);\n        normal *= 100;\n        paint.setStrokeWidth(10);\n        paint.setColor(0x3f4512bf);\n        canvas->drawLine(origin, normal, paint);\n    }\n}",
    "width": 256,
    "height": 256,
    "hash": "3e4f147d143a388802484bf0d26534c2",
    "file": "SkPoint_Reference",
    "name": "SkPoint::setNormalize"
},
    "SkPoint_subtract_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    points[1] += points[0] - points[2];\n    points[2] -= points[3] - points[5];\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "b6c4943ecd0b2dccf9d220b8944009e0",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator-(const SkPoint& a, const SkPoint& b)"
},
    "SkPoint_subtractfrom_operator": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setAntiAlias(true);\n    SkPoint points[] = { { 3, 1 }, { 4, 2 }, { 5, 1 }, { 7, 3 },\n                         { 6, 4 }, { 7, 5 }, { 5, 7 },\n                         { 4, 6 }, { 3, 7 }, { 1, 5 },\n                         { 2, 4 }, { 1, 3 }, { 3, 1 } };\n    canvas->scale(30, 15);\n    paint.setStyle(SkPaint::kStroke_Style);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n    points[1] -= {1, 1};\n    points[2] -= {-1, -1};\n    paint.setColor(SK_ColorRED);\n    canvas->drawPoints(SkCanvas::kPolygon_PointMode, SK_ARRAY_COUNT(points), points, paint);\n}",
    "width": 256,
    "height": 128,
    "hash": "86c0399704d8dff4091bf87b8d87d40b",
    "file": "SkPoint_Reference",
    "name": "SkPoint::operator-=(const SkVector& v)"
},
    "SkSurface_BackendHandleAccess": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    sk_sp<SkSurface> gpuSurface = SkSurface::MakeRenderTarget(\n            context, SkBudgeted::kYes, SkImageInfo::MakeN32Premul(10, 10));\n    int y = 20;\n    SkString str;\n    paint.setTextSize(16);\n    for (auto access : { SkSurface::kFlushRead_BackendHandleAccess, \n                         SkSurface::kFlushWrite_BackendHandleAccess,\n                         SkSurface::kDiscardWrite_BackendHandleAccess } ) {\n        sk_sp<SkImage> image(gpuSurface->makeImageSnapshot());\n        str.printf(\"uniqueID=%d\", image->uniqueID());\n        canvas->drawString(str, 20, y += 20, paint);\n        GrBackendObject backendObject = gpuSurface->getTextureHandle(access);\n        str.printf(\"backendObject %c= 0\", backendObject != 0 ? '!' : '=');\n        canvas->drawString(str, 20, y += 20, paint);\n    }\n    sk_sp<SkImage> image(gpuSurface->makeImageSnapshot());\n    str.printf(\"final image uniqueID=%d\", image->uniqueID());\n    canvas->drawString(str, 20, y += 20, paint);\n}",
    "width": 256,
    "height": 256,
    "hash": "260a5ba014b00eeb5a74b3c6b8d31be4",
    "file": "SkSurface_Reference",
    "name": "SkSurface::BackendHandleAccess"
},
    "SkSurface_MakeRenderTarget": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    SkImageInfo info = SkImageInfo::MakeN32(256, 64, kOpaque_SkAlphaType);\n    for (auto surfaceOrigin : { kTopLeft_GrSurfaceOrigin, kBottomLeft_GrSurfaceOrigin } ) {\n        auto gpuSurface(SkSurface::MakeRenderTarget(context, SkBudgeted::kNo, info, 0,\n               surfaceOrigin, nullptr));\n        auto surfaceCanvas = gpuSurface->getCanvas();\n        surfaceCanvas->clear(SK_ColorWHITE);\n        surfaceCanvas->drawString(\"GPU rocks!\", 20, 40, paint);\n        sk_sp<SkImage> image(gpuSurface->makeImageSnapshot());\n        canvas->drawImage(image, 0, 0);\n       canvas->translate(0, 128);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "67b6609471a3f1ed0f4b1657004cdecb",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRenderTarget"
},
    "SkSurface_MakeRenderTarget_2": {
    "code": "void draw(SkCanvas* canvas) {\n    auto test_draw = [](SkCanvas* surfaceCanvas) -> void {\n        SkPaint paint;\n        paint.setAntiAlias(true);\n        paint.setLCDRenderText(true);\n        paint.setColor(0xFFBBBBBB);\n        surfaceCanvas->drawRect(SkRect::MakeWH(128, 64), paint);\n        paint.setColor(SK_ColorWHITE);\n        paint.setTextSize(32);\n        surfaceCanvas->drawString(\"Pest\", 0, 25, paint);\n    };\n    GrContext* context = canvas->getGrContext();\n    SkImageInfo info = SkImageInfo::MakeN32(128, 64, kOpaque_SkAlphaType);\n    int y = 0;\n    for (auto geometry : { kRGB_H_SkPixelGeometry, kBGR_H_SkPixelGeometry,\n                           kRGB_V_SkPixelGeometry, kBGR_V_SkPixelGeometry } ) {\n        SkSurfaceProps props(0, geometry);\n        sk_sp<SkSurface> surface = context ? SkSurface::MakeRenderTarget(\n                context, SkBudgeted::kNo, info, 0, &props) : SkSurface::MakeRaster(info, &props);\n        test_draw(surface->getCanvas());\n        surface->draw(canvas, 0, y, nullptr);\n        sk_sp<SkImage> image(surface->makeImageSnapshot());\n        SkAutoCanvasRestore acr(canvas, true);\n        canvas->scale(8, 8);\n        canvas->drawImage(image, 12, y / 8);\n        y += 64;\n    }\n}\n",
    "width": 256,
    "height": 256,
    "hash": "640321e8ecfb3f9329f3bc6e1f02485f",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRenderTarget_2"
},
    "SkSurface_MakeRenderTarget_3": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    SkImageInfo info = SkImageInfo::MakeN32(256, 64, kOpaque_SkAlphaType);\n    auto gpuSurface(SkSurface::MakeRenderTarget(context, SkBudgeted::kNo, info));\n    auto surfaceCanvas = gpuSurface->getCanvas();\n    surfaceCanvas->clear(SK_ColorWHITE);\n    surfaceCanvas->drawString(\"GPU rocks!\", 20, 40, paint);\n    sk_sp<SkImage> image(gpuSurface->makeImageSnapshot());\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "5c7629c15e9ac93f098335e72560fa2e",
    "file": "SkSurface_Reference",
    "name": "SkSurface::MakeRenderTarget_3"
},
    "SkSurface_characterize": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    sk_sp<SkSurface> gpuSurface = SkSurface::MakeRenderTarget(\n            context, SkBudgeted::kYes, SkImageInfo::MakeN32Premul(64, 64));\n    SkSurfaceCharacterization characterization;\n    if (!gpuSurface->characterize(&characterization)) {\n         canvas->drawString(\"characterization unsupported\", 20, 40, paint);\n         return;\n    }\n    // start of threadable work \n    SkDeferredDisplayListRecorder recorder(characterization);\n    SkCanvas* subCanvas = recorder.getCanvas();\n    subCanvas->clear(SK_ColorGREEN);\n    std::unique_ptr<SkDeferredDisplayList> displayList = recorder.detach();\n    // end of threadable work\n    gpuSurface->draw(displayList.get());\n    sk_sp<SkImage> img = gpuSurface->makeImageSnapshot();\n    canvas->drawImage(std::move(img), 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "3df4e2fc63483a3fa19589b5388080bc",
    "file": "SkSurface_Reference",
    "name": "SkSurface::characterize()"
},
    "SkSurface_draw": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> big(SkSurface::MakeRasterN32Premul(64, 64));\n    sk_sp<SkSurface> lil(big->makeSurface(SkImageInfo::MakeN32(32, 32, kPremul_SkAlphaType)));\n    big->getCanvas()->clear(SK_ColorRED);\n    lil->getCanvas()->clear(SK_ColorBLACK);\n    lil->draw(big->getCanvas(), 16, 16, nullptr);\n    SkPixmap pixmap;\n    if (big->peekPixels(&pixmap)) {\n        SkBitmap bigBits;\n        bigBits.installPixels(pixmap);\n        canvas->drawBitmap(bigBits, 0, 0);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "0de693f4d8dd898a60be8cfba23952be",
    "file": "SkSurface_Reference",
    "name": "SkSurface::draw()"
},
    "SkSurface_draw_2": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(16);\n    sk_sp<SkSurface> gpuSurface = SkSurface::MakeRasterN32Premul(64, 64);\n    SkSurfaceCharacterization characterization;\n    if (!gpuSurface->characterize(&characterization)) {\n         canvas->drawString(\"characterization unsupported\", 20, 40, paint);\n         return;\n    }\n    // start of threadable work \n    SkDeferredDisplayListRecorder recorder(characterization);\n    SkCanvas* subCanvas = recorder.getCanvas();\n    subCanvas->clear(SK_ColorGREEN);\n    std::unique_ptr<SkDeferredDisplayList> displayList = recorder.detach();\n    // end of threadable work\n    gpuSurface->draw(displayList.get());\n    sk_sp<SkImage> img = gpuSurface->makeImageSnapshot();\n    canvas->drawImage(std::move(img), 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "3dfa7496268dfb2c7465cda5da39dfbd",
    "file": "SkSurface_Reference",
    "name": "SkSurface::draw_2"
},
    "SkSurface_getCanvas": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surface(SkSurface::MakeRasterN32Premul(64, 64));\n    SkCanvas* surfaceCanvas = surface->getCanvas();\n    surfaceCanvas->clear(SK_ColorBLUE);\n    SkPaint paint;\n    paint.setTextSize(40);\n    surfaceCanvas->drawString(\"\\xF0\\x9F\\x98\\x81\", 12, 45, paint);\n    surface->draw(canvas, 0, 0, nullptr);\n}",
    "width": 256,
    "height": 64,
    "hash": "33d0c5ad5a4810e533ae1010e29f8b75",
    "file": "SkSurface_Reference",
    "name": "SkSurface::getCanvas"
},
    "SkSurface_getRenderTargetHandle": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    sk_sp<SkSurface> gpuSurface = SkSurface::MakeRenderTarget(\n            context, SkBudgeted::kYes, SkImageInfo::MakeN32Premul(10, 10));\n    GrBackendObject backendObject;\n    if (gpuSurface->getRenderTargetHandle(&backendObject, \n            SkSurface::kFlushRead_BackendHandleAccess)) {\n        SkString str;\n        str.printf(\"backendObject=%d\", backendObject);\n        paint.setTextSize(16);\n        canvas->drawString(str, 20, 40, paint);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "16e848a4405ce08f8393bba13cc3b8bf",
    "file": "SkSurface_Reference",
    "name": "SkSurface::getRenderTargetHandle"
},
    "SkSurface_getTextureHandle": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    sk_sp<SkSurface> gpuSurface = SkSurface::MakeRenderTarget(\n            context, SkBudgeted::kYes, SkImageInfo::MakeN32Premul(10, 10));\n    GrBackendObject backendObject = gpuSurface->getTextureHandle(\n            SkSurface::kFlushRead_BackendHandleAccess);\n    if (backendObject) {\n        SkString str;\n        str.printf(\"backendObject=%08x\", backendObject);\n        paint.setTextSize(16);\n        canvas->drawString(str, 20, 40, paint);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "4b5720038daaf65ba1ba546e678ddd6e",
    "file": "SkSurface_Reference",
    "name": "SkSurface::getTextureHandle"
},
    "SkSurface_makeImageSnapshot": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> big(SkSurface::MakeRasterN32Premul(64, 64));\n    sk_sp<SkSurface> lil(big->makeSurface(SkImageInfo::MakeN32(32, 32, kPremul_SkAlphaType)));\n    big->getCanvas()->clear(SK_ColorRED);\n    lil->getCanvas()->clear(SK_ColorBLACK);\n    sk_sp<SkImage> early(big->makeImageSnapshot());\n    lil->draw(big->getCanvas(), 16, 16, nullptr);\n    sk_sp<SkImage> later(big->makeImageSnapshot());\n    canvas->drawImage(early, 0, 0);\n    canvas->drawImage(later, 128, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "46f1fa0d95e590a64bed0140407ce5f7",
    "file": "SkSurface_Reference",
    "name": "SkSurface::makeImageSnapshot"
},
    "SkSurface_makeSurface": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> big(SkSurface::MakeRasterN32Premul(64, 64));\n    sk_sp<SkSurface> lil(big->makeSurface(SkImageInfo::MakeN32(32, 32, kPremul_SkAlphaType)));\n    big->getCanvas()->clear(SK_ColorRED);\n    lil->getCanvas()->clear(SK_ColorBLACK);\n    SkPixmap pixmap;\n    if (big->peekPixels(&pixmap)) {\n        SkBitmap bigBits;\n        bigBits.installPixels(pixmap);\n        canvas->drawBitmap(bigBits, 0, 0);\n    }\n    if (lil->peekPixels(&pixmap)) {\n        SkBitmap lilBits;\n        lilBits.installPixels(pixmap);\n        canvas->drawBitmap(lilBits, 64, 64);\n    }\n}",
    "width": 256,
    "height": 96,
    "hash": "a9889b519a26896b900da0444e423c61",
    "file": "SkSurface_Reference",
    "name": "SkSurface::makeSurface"
},
    "SkSurface_peekPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    auto surfCanvas = surf->getCanvas();\n    surfCanvas->clear(SK_ColorRED);\n    SkPaint paint;\n    paint.setTextSize(40);\n    surfCanvas->drawString(\"&\", 16, 48, paint);\n    SkPixmap pixmap;\n    if (surf->peekPixels(&pixmap)) {\n        SkBitmap surfBits;\n        surfBits.installPixels(pixmap);\n        canvas->drawBitmap(surfBits, 0, 0);\n    }\n}",
    "width": 256,
    "height": 64,
    "hash": "8c6184f22cfe068f021704cf92a147a1",
    "file": "SkSurface_Reference",
    "name": "SkSurface::peekPixels"
},
    "SkSurface_readPixels": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    auto surfCanvas = surf->getCanvas();\n    surfCanvas->clear(SK_ColorRED);\n    SkPaint paint;\n    paint.setTextSize(40);\n    surfCanvas->drawString(\"&\", 0, 32, paint);\n    std::vector<SkPMColor> storage;\n    storage.resize(surf->width() * surf->height());\n    SkPixmap pixmap(SkImageInfo::MakeN32Premul(32, 32), &storage.front(),\n                    surf->width() * sizeof(storage[0]));\n    if (surf->readPixels(pixmap, 0, 0)) {\n        SkBitmap surfBits;\n        surfBits.installPixels(pixmap);\n        canvas->drawBitmap(surfBits, 0, 0);\n    }\n}",
    "width": 256,
    "height": 32,
    "hash": "9f454fb93bca6482598d198b4121f0a6",
    "file": "SkSurface_Reference",
    "name": "SkSurface::readPixels"
},
    "SkSurface_readPixels_2": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    auto surfCanvas = surf->getCanvas();\n    surfCanvas->clear(SK_ColorRED);\n    SkPaint paint;\n    surfCanvas->drawOval({4, 8, 58, 54}, paint);\n    SkImageInfo info = SkImageInfo::Make(64, 64, kBGRA_8888_SkColorType, kPremul_SkAlphaType);\n    sk_sp<SkData> data(SkData::MakeUninitialized(info.minRowBytes() * info.height()));\n    sk_bzero(data->writable_data(), info.minRowBytes() * info.height());\n    for (int x : { 32, -32 } ) {\n        for (int y : { 32, -32 } ) {\n            surf->readPixels(info, data->writable_data(), info.minRowBytes(), x, y);\n        } \n    }\n    sk_sp<SkImage> image = SkImage::MakeRasterData(info, data, info.minRowBytes());\n    canvas->drawImage(image, 0, 0);\n}",
    "width": 256,
    "height": 64,
    "hash": "d141d6c662d201d191fb1eea26d014fd",
    "file": "SkSurface_Reference",
    "name": "SkSurface::readPixels_2"
},
    "SkSurface_readPixels_3": {
    "code": "void draw(SkCanvas* canvas) {\n    sk_sp<SkSurface> surf(SkSurface::MakeRasterN32Premul(64, 64));\n    auto surfCanvas = surf->getCanvas();\n    surfCanvas->clear(SK_ColorGREEN);\n    SkPaint paint;\n    surfCanvas->drawOval({2, 10, 58, 54}, paint);\n    SkImageInfo info = SkImageInfo::Make(64, 64, kBGRA_8888_SkColorType, kPremul_SkAlphaType);\n    SkBitmap bitmap;\n    bitmap.setInfo(info);\n    bitmap.allocPixels();\n    for (int x : { 32, -32 } ) {\n        for (int y : { 32, -32 } ) {\n            surf->readPixels(bitmap, x, y);\n        } \n    }\n    canvas->drawBitmap(bitmap, 0, 0);\n}",
    "width": 256,
    "height": 256,
    "hash": "dcbd4af9151820f63de45a35f3a8d110",
    "file": "SkSurface_Reference",
    "name": "SkSurface::readPixels_3"
},
    "SkSurface_wait": {
    "code": "void draw(SkCanvas* canvas) {\n    SkPaint paint;\n    paint.setTextSize(32);\n    GrContext* context = canvas->getGrContext();\n    if (!context) {\n         canvas->drawString(\"GPU only!\", 20, 40, paint);\n         return;\n    }\n    GrBackendSemaphore semaphore;\n    sk_sp<SkSurface> surface = SkSurface::MakeRenderTarget(\n            context, SkBudgeted::kYes, SkImageInfo::MakeN32Premul(64, 64));\n    surface->flushAndSignalSemaphores(1, &semaphore);\n    sk_sp<SkImage> image = surface->makeImageSnapshot();\n    GrBackendObject backendImage = image->getTextureHandle(false); // unused\n    SkASSERT(backendImage);\n    const SkImageInfo childImageInfo = SkImageInfo::Make(64, 64,\n              kRGBA_8888_SkColorType, kPremul_SkAlphaType);\n    sk_sp<SkSurface> childSurface(SkSurface::MakeRenderTarget(context, SkBudgeted::kNo,\n              childImageInfo, 0, kTopLeft_GrSurfaceOrigin, nullptr));\n    GrBackendTexture backendTexture;\n    sk_sp<SkImage> childImage = SkImage::MakeFromTexture(context,\n              backendTexture,   // undefined\n              kTopLeft_GrSurfaceOrigin, kPremul_SkAlphaType, nullptr);\n    SkCanvas* childCanvas = childSurface->getCanvas();\n    childCanvas->clear(SK_ColorRED);\n    childSurface->wait(1, &semaphore);\n    childCanvas->drawImage(childImage, 32, 0);\n    childSurface->draw(canvas, 0, 0, nullptr);\n}",
    "width": 256,
    "height": 64,
    "hash": "c9033080af68efc0f270d748f1c0e011",
    "file": "SkSurface_Reference",
    "name": "SkSurface::wait()"
},
    "SkYUVColorSpace": {
    "code": "void draw(SkCanvas* canvas) {\n    // incomplete\n}",
    "width": 256,
    "height": 256,
    "hash": "882e8e0103048009a25cfc20400492f7",
    "file": "SkImageInfo_Reference",
    "name": "SkYUVColorSpace"
}
    }
    var canvas
var context
var getFromWeb = true
var mouseDown = false
var scale = .6
var outset = 15
var columnWidth = 256
var maxHeight = 256
var lastLink = null
var lastLinkStr = null
var labelback = {}
var loadedImages = 0
var images = {}
var imagesLength = 0;

function recContains(rec, value) {
    if (!value.length)
        return 0
    var lc = value.toLowerCase()
    if (rec.name.toLowerCase().indexOf(lc) >= 0)
        return 1
    if (rec.code.toLowerCase().indexOf(lc) >= 0)
        return 2
    return 3
}

function setLink(recstr) {
    var under
    var link = recstr
    if (!link.startsWith("Sk")) {
        under = link.indexOf('_')
        link = link.substring(under + 1)
    }
    under = link.lastIndexOf('_')
    var len = link.length
    if (under == len - 2) {
        var letter = link[len - 1]
        if ('a' <= letter && letter <= 'z') {
            link = link.substr(0, len - 2)
        } else if ('0' <= letter && letter <= '9') {
            link = link.substr(0, len - 2)
        }
    }
    lastLinkStr = link
}

function showLink() {
    var link = lastLink.file + '#' + lastLinkStr
    context.save()
    context.font = "normal 16px Arial";
    labelback.w = Math.max(labelback.w, context.measureText(link).width + 8)
    context.beginPath()
    context.rect(labelback.x, labelback.y, labelback.w, labelback.h)
    context.fillStyle = "rgba(232,180,220, 1)"
    context.fill()
    context.fillStyle = "rgba(64,32,48, 1)"
    context.fillText(link, labelback.x + 4, labelback.y + 16)
    context.restore()
}

function imageIterator(callout, state) {
    var row = outset + 30
    var column = outset
    for (var recstr in pngs) {
        var rec = pngs[recstr]
        var contains = recContains(rec, input.value)
        if (3 == contains)
            continue;
        var height = rec.height < maxHeight ? rec.height : maxHeight
        if (callout(state, column, row, height, contains, recstr))
            break;
        row += height + outset
        if (row >= canvas.height / scale) {
            row = 0
            column += columnWidth + outset
            if (column >= canvas.width / scale) {
                break
            }
        }
    }
}

function handleMouseOver(event) {
    var callout = function(state, column, row, height, contains, recstr) {
        if (state.x >= column && state.x <= column + columnWidth &&
                state.y >= row && state.y <= row + height) {
            document.body.style.cursor = "pointer"
            lastLink = pngs[recstr]
            setLink(recstr)
            showLink()
            return true
        }
        return false
    }
    var state = {
        x: (event.clientX - 5) / scale,
        y: (event.clientY - 7) / scale
    }
    document.body.style.cursor = ""
    lastLink = null
    imageIterator(callout, state)
}

function handleMouseClick() {
    if (null != lastLink) {
        var link = 'https://skia.org/user/api/' + lastLink.file + '#' + lastLinkStr
        window.location = link
    }
}

function doKeyPress(evt) {
    idiv.style.height = 20
    input.focus()
}

function drawImage(hash, x, y, w, h, contains) {
    context.save()
    context.transform(scale, 0, 0, scale, 0, 0)
    context.save()
    context.beginPath()
    context.rect(x, y, w, h)
    context.clip()
    context.drawImage(images[hash], x, y)
    context.restore()
    context.beginPath()
    context.rect(x, y, w, h)
    context.strokeStyle = 1 == contains ? "red" : "black"
    context.stroke()
    context.restore()
}

function draw() {
    var callout = function(state, column, row, height, contains, recstr) {
        drawImage(pngs[recstr].hash, column, row, columnWidth, height, contains)
        return false
    }
    imageIterator(callout, null)
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function redraw() {
    context.strokeStyle = "white"
    context.beginPath()
    context.fillStyle = "white"
    context.rect(0, 30, canvas.width, canvas.height)
    context.fill()
    context.rect((256 + outset) * scale, 0, canvas.width, 30)
    context.fill()
    for (var image in images) {
        image.drawn = false
    }
    do {
        draw();
        if (loadedImages >= imagesLength)
            break;
        console.debug(" loadedImages:" + loadedImages + " imagesLength:" + imagesLength)
        await sleep(1000);
    } while (true)
}

function resize() {
    setSize()
    redraw()
}

function setSize() {
    canvas.width = window.innerWidth - 20
    canvas.height = window.innerHeight - 20
    labelback.x = 0
    labelback.y = canvas.height - 20
    labelback.w = 0
    labelback.h = 20
}

function loadImages() {
    for (var recstr in pngs) {
        var rec = pngs[recstr]
        var image = new Image()
        images[rec.hash] = image
        if (getFromWeb)
            image.src = 'https://fiddle.skia.org/i/'
        image.src += rec.hash + '_raster.png'
        image.onload = function () {
            loadedImages += 1
        }
        imagesLength += 1;
    }
}

function start() {
    loadImages()
    window.addEventListener('keypress', doKeyPress, true);
    window.addEventListener('keydown', doKeyPress, true);
    canvas = document.getElementById('canvas')
    context = canvas.getContext('2d')
    resize()
}

</script>
</head>

<body onLoad="start()" onresize="resize()">
<div style="height:0" id="idiv">
<input type="text" id="input" onkeypress="redraw()" onkeydown="redraw()"/>
</div>
<canvas id="canvas" width="750" height="500"
onmousedown="mouseDown = true"
onmouseup="mouseDown = false"
onmousemove="handleMouseOver(event)"
onclick="handleMouseClick()"
></canvas >
</body>
</html>
    